{"version":3,"file":"index.js","mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC5lBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AClnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACtPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AClJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACzIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AClOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACpjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACnXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC9IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC5JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC5UA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC1OA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC5vBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC/HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACrQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACjLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AClJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACreA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACx7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC1qBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC1KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACpoDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AChpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACxPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACjHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC9LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC7KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC9HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACtOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACpXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACxDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC9MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACxgCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACxMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACjEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AClLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACxCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC3LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACrQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC9EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC/RA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC9hBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC5SA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACnIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACnLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACjOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC5LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC5qHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACrEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC9TA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACxYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC3IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC3JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACnEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC7IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACleA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AChJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC1QA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC3EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACnGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACpIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC59BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACxHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AChGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC1JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACpGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC/JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACz4BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACtFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC3UA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC1QA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACzRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC1FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACtEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC93CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AChFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACzEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACruCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AClWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACnEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AClQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACtMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACrKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACnHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC93CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACrgCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC1cA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACrEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACjLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACrMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC3UA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC9EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC1MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACxCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACtHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACjMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACncA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AClEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC1HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACrNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACrHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC3DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC12BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC1FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC3IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACzFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AClNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC5IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC3DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACt8GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACnEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC9eA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACnrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC5EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC9DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACxDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACxKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC3JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC9DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC9DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACxQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACjLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACnyBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvzEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AChEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC9EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACxDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC9DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC5FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACtDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACtDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AC/KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACrYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACrHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AC5MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACllCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACzEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AChLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC5QA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACjRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACtQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AC/GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACjKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC1vDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACtlIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AChMA;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACvQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AC5LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACvMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACnMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AChxCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AChCA;;;;;;;;AAAA;;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;;;;;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC7BA;AACA;;;;;;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["../webpack://effect-ts-github-action/./build/Git.js","../webpack://effect-ts-github-action/./build/Github.js","../webpack://effect-ts-github-action/./build/utils/config.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@actions+github@5.1.1/node_modules/@actions/github/lib/context.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@actions+github@5.1.1/node_modules/@actions/github/lib/github.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@actions+github@5.1.1/node_modules/@actions/github/lib/internal/utils.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@actions+github@5.1.1/node_modules/@actions/github/lib/utils.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@actions+http-client@2.0.1/node_modules/@actions/http-client/lib/index.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@actions+http-client@2.0.1/node_modules/@actions/http-client/lib/proxy.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+data@0.5.0/node_modules/@effect/data/Chunk.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+data@0.5.0/node_modules/@effect/data/Context.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+data@0.5.0/node_modules/@effect/data/Data.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+data@0.5.0/node_modules/@effect/data/Differ.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+data@0.5.0/node_modules/@effect/data/Differ/ChunkPatch.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+data@0.5.0/node_modules/@effect/data/Differ/ContextPatch.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+data@0.5.0/node_modules/@effect/data/Differ/HashMapPatch.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+data@0.5.0/node_modules/@effect/data/Differ/HashSetPatch.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+data@0.5.0/node_modules/@effect/data/Differ/OrPatch.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+data@0.5.0/node_modules/@effect/data/Duration.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+data@0.5.0/node_modules/@effect/data/Either.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+data@0.5.0/node_modules/@effect/data/Equal.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+data@0.5.0/node_modules/@effect/data/Function.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+data@0.5.0/node_modules/@effect/data/Gen.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+data@0.5.0/node_modules/@effect/data/Global.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+data@0.5.0/node_modules/@effect/data/Hash.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+data@0.5.0/node_modules/@effect/data/HashMap.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+data@0.5.0/node_modules/@effect/data/HashSet.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+data@0.5.0/node_modules/@effect/data/List.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+data@0.5.0/node_modules/@effect/data/MutableHashMap.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+data@0.5.0/node_modules/@effect/data/MutableList.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+data@0.5.0/node_modules/@effect/data/MutableQueue.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+data@0.5.0/node_modules/@effect/data/MutableRef.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+data@0.5.0/node_modules/@effect/data/Number.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+data@0.5.0/node_modules/@effect/data/Option.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+data@0.5.0/node_modules/@effect/data/Predicate.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+data@0.5.0/node_modules/@effect/data/Random.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+data@0.5.0/node_modules/@effect/data/ReadonlyArray.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+data@0.5.0/node_modules/@effect/data/ReadonlyRecord.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+data@0.5.0/node_modules/@effect/data/RedBlackTree.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+data@0.5.0/node_modules/@effect/data/SortedSet.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+data@0.5.0/node_modules/@effect/data/String.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+data@0.5.0/node_modules/@effect/data/internal/Context.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+data@0.5.0/node_modules/@effect/data/internal/Differ.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+data@0.5.0/node_modules/@effect/data/internal/Differ/ChunkPatch.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+data@0.5.0/node_modules/@effect/data/internal/Differ/ContextPatch.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+data@0.5.0/node_modules/@effect/data/internal/Differ/HashMapPatch.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+data@0.5.0/node_modules/@effect/data/internal/Differ/HashSetPatch.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+data@0.5.0/node_modules/@effect/data/internal/Differ/OrPatch.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+data@0.5.0/node_modules/@effect/data/internal/Either.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+data@0.5.0/node_modules/@effect/data/internal/HashMap.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+data@0.5.0/node_modules/@effect/data/internal/HashMap/array.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+data@0.5.0/node_modules/@effect/data/internal/HashMap/bitwise.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+data@0.5.0/node_modules/@effect/data/internal/HashMap/config.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+data@0.5.0/node_modules/@effect/data/internal/HashMap/keySet.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+data@0.5.0/node_modules/@effect/data/internal/HashMap/node.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+data@0.5.0/node_modules/@effect/data/internal/HashSet.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+data@0.5.0/node_modules/@effect/data/internal/Option.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+data@0.5.0/node_modules/@effect/data/internal/ReadonlyArray.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+data@0.5.0/node_modules/@effect/data/internal/RedBlackTree.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+data@0.5.0/node_modules/@effect/data/internal/RedBlackTree/iterator.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+data@0.5.0/node_modules/@effect/data/internal/RedBlackTree/node.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+data@0.5.0/node_modules/@effect/data/internal/Stack.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+data@0.5.0/node_modules/@effect/data/typeclass/Applicative.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+data@0.5.0/node_modules/@effect/data/typeclass/Bicovariant.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+data@0.5.0/node_modules/@effect/data/typeclass/Bounded.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+data@0.5.0/node_modules/@effect/data/typeclass/Chainable.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+data@0.5.0/node_modules/@effect/data/typeclass/Contravariant.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+data@0.5.0/node_modules/@effect/data/typeclass/Covariant.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+data@0.5.0/node_modules/@effect/data/typeclass/Equivalence.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+data@0.5.0/node_modules/@effect/data/typeclass/Filterable.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+data@0.5.0/node_modules/@effect/data/typeclass/FlatMap.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+data@0.5.0/node_modules/@effect/data/typeclass/Foldable.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+data@0.5.0/node_modules/@effect/data/typeclass/Invariant.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+data@0.5.0/node_modules/@effect/data/typeclass/Monoid.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+data@0.5.0/node_modules/@effect/data/typeclass/Of.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+data@0.5.0/node_modules/@effect/data/typeclass/Order.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+data@0.5.0/node_modules/@effect/data/typeclass/Product.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+data@0.5.0/node_modules/@effect/data/typeclass/SemiApplicative.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+data@0.5.0/node_modules/@effect/data/typeclass/SemiCoproduct.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+data@0.5.0/node_modules/@effect/data/typeclass/SemiProduct.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+data@0.5.0/node_modules/@effect/data/typeclass/Semigroup.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+data@0.5.0/node_modules/@effect/data/typeclass/Traversable.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+data@0.5.0/node_modules/@effect/data/typeclass/TraversableFilterable.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+io@0.10.0/node_modules/@effect/io/Cause.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+io@0.10.0/node_modules/@effect/io/Clock.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+io@0.10.0/node_modules/@effect/io/Config.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+io@0.10.0/node_modules/@effect/io/Config/Error.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+io@0.10.0/node_modules/@effect/io/Config/Provider.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+io@0.10.0/node_modules/@effect/io/Config/Secret.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+io@0.10.0/node_modules/@effect/io/Debug.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+io@0.10.0/node_modules/@effect/io/Deferred.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+io@0.10.0/node_modules/@effect/io/Effect.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+io@0.10.0/node_modules/@effect/io/ExecutionStrategy.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+io@0.10.0/node_modules/@effect/io/Exit.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+io@0.10.0/node_modules/@effect/io/Fiber.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+io@0.10.0/node_modules/@effect/io/Fiber/Id.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+io@0.10.0/node_modules/@effect/io/Fiber/Runtime/Flags/Patch.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+io@0.10.0/node_modules/@effect/io/Fiber/Status.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+io@0.10.0/node_modules/@effect/io/FiberRefs.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+io@0.10.0/node_modules/@effect/io/Hub.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+io@0.10.0/node_modules/@effect/io/Layer.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+io@0.10.0/node_modules/@effect/io/Logger/Level.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+io@0.10.0/node_modules/@effect/io/Logger/Span.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+io@0.10.0/node_modules/@effect/io/Queue.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+io@0.10.0/node_modules/@effect/io/Random.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+io@0.10.0/node_modules/@effect/io/Ref.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+io@0.10.0/node_modules/@effect/io/Runtime.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+io@0.10.0/node_modules/@effect/io/Schedule.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+io@0.10.0/node_modules/@effect/io/Schedule/Decision.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+io@0.10.0/node_modules/@effect/io/Schedule/Interval.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+io@0.10.0/node_modules/@effect/io/Schedule/Intervals.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+io@0.10.0/node_modules/@effect/io/Scheduler.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+io@0.10.0/node_modules/@effect/io/Scope.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+io@0.10.0/node_modules/@effect/io/internal_effect_untraced/cause-pretty.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+io@0.10.0/node_modules/@effect/io/internal_effect_untraced/cause.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+io@0.10.0/node_modules/@effect/io/internal_effect_untraced/clock.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+io@0.10.0/node_modules/@effect/io/internal_effect_untraced/config.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+io@0.10.0/node_modules/@effect/io/internal_effect_untraced/configError.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+io@0.10.0/node_modules/@effect/io/internal_effect_untraced/configProvider.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+io@0.10.0/node_modules/@effect/io/internal_effect_untraced/configProvider/pathPatch.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+io@0.10.0/node_modules/@effect/io/internal_effect_untraced/configSecret.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+io@0.10.0/node_modules/@effect/io/internal_effect_untraced/core.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+io@0.10.0/node_modules/@effect/io/internal_effect_untraced/debug.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+io@0.10.0/node_modules/@effect/io/internal_effect_untraced/defaultServices.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+io@0.10.0/node_modules/@effect/io/internal_effect_untraced/deferred.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+io@0.10.0/node_modules/@effect/io/internal_effect_untraced/effect.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+io@0.10.0/node_modules/@effect/io/internal_effect_untraced/effect/circular.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+io@0.10.0/node_modules/@effect/io/internal_effect_untraced/executionStrategy.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+io@0.10.0/node_modules/@effect/io/internal_effect_untraced/fiber.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+io@0.10.0/node_modules/@effect/io/internal_effect_untraced/fiberId.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+io@0.10.0/node_modules/@effect/io/internal_effect_untraced/fiberMessage.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+io@0.10.0/node_modules/@effect/io/internal_effect_untraced/fiberRefs.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+io@0.10.0/node_modules/@effect/io/internal_effect_untraced/fiberRefs/patch.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+io@0.10.0/node_modules/@effect/io/internal_effect_untraced/fiberRuntime.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+io@0.10.0/node_modules/@effect/io/internal_effect_untraced/fiberScope.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+io@0.10.0/node_modules/@effect/io/internal_effect_untraced/fiberStatus.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+io@0.10.0/node_modules/@effect/io/internal_effect_untraced/hub.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+io@0.10.0/node_modules/@effect/io/internal_effect_untraced/layer.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+io@0.10.0/node_modules/@effect/io/internal_effect_untraced/layer/circular.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+io@0.10.0/node_modules/@effect/io/internal_effect_untraced/logSpan.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+io@0.10.0/node_modules/@effect/io/internal_effect_untraced/logger.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+io@0.10.0/node_modules/@effect/io/internal_effect_untraced/metric.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+io@0.10.0/node_modules/@effect/io/internal_effect_untraced/metric/boundaries.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+io@0.10.0/node_modules/@effect/io/internal_effect_untraced/metric/hook.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+io@0.10.0/node_modules/@effect/io/internal_effect_untraced/metric/key.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+io@0.10.0/node_modules/@effect/io/internal_effect_untraced/metric/keyType.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+io@0.10.0/node_modules/@effect/io/internal_effect_untraced/metric/label.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+io@0.10.0/node_modules/@effect/io/internal_effect_untraced/metric/pair.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+io@0.10.0/node_modules/@effect/io/internal_effect_untraced/metric/registry.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+io@0.10.0/node_modules/@effect/io/internal_effect_untraced/metric/state.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+io@0.10.0/node_modules/@effect/io/internal_effect_untraced/opCodes/cause.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+io@0.10.0/node_modules/@effect/io/internal_effect_untraced/opCodes/config.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+io@0.10.0/node_modules/@effect/io/internal_effect_untraced/opCodes/configError.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+io@0.10.0/node_modules/@effect/io/internal_effect_untraced/opCodes/deferred.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+io@0.10.0/node_modules/@effect/io/internal_effect_untraced/opCodes/effect.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+io@0.10.0/node_modules/@effect/io/internal_effect_untraced/opCodes/layer.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+io@0.10.0/node_modules/@effect/io/internal_effect_untraced/queue.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+io@0.10.0/node_modules/@effect/io/internal_effect_untraced/random.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+io@0.10.0/node_modules/@effect/io/internal_effect_untraced/ref.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+io@0.10.0/node_modules/@effect/io/internal_effect_untraced/runtime.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+io@0.10.0/node_modules/@effect/io/internal_effect_untraced/runtimeFlags.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+io@0.10.0/node_modules/@effect/io/internal_effect_untraced/runtimeFlagsPatch.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+io@0.10.0/node_modules/@effect/io/internal_effect_untraced/schedule.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+io@0.10.0/node_modules/@effect/io/internal_effect_untraced/schedule/decision.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+io@0.10.0/node_modules/@effect/io/internal_effect_untraced/schedule/interval.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+io@0.10.0/node_modules/@effect/io/internal_effect_untraced/schedule/intervals.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+io@0.10.0/node_modules/@effect/io/internal_effect_untraced/singleShotGen.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+io@0.10.0/node_modules/@effect/io/internal_effect_untraced/string-utils.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+io@0.10.0/node_modules/@effect/io/internal_effect_untraced/supervisor.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+io@0.10.0/node_modules/@effect/io/internal_effect_untraced/supervisor/patch.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+io@0.10.0/node_modules/@effect/io/internal_effect_untraced/synchronizedRef.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+stream@0.12.1/node_modules/@effect/stream/Channel/MergeDecision.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+stream@0.12.1/node_modules/@effect/stream/Stream.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+stream@0.12.1/node_modules/@effect/stream/Stream/HaltStrategy.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+stream@0.12.1/node_modules/@effect/stream/internal/channel.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+stream@0.12.1/node_modules/@effect/stream/internal/channel/channelExecutor.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+stream@0.12.1/node_modules/@effect/stream/internal/channel/channelState.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+stream@0.12.1/node_modules/@effect/stream/internal/channel/childExecutorDecision.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+stream@0.12.1/node_modules/@effect/stream/internal/channel/continuation.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+stream@0.12.1/node_modules/@effect/stream/internal/channel/mergeDecision.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+stream@0.12.1/node_modules/@effect/stream/internal/channel/mergeState.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+stream@0.12.1/node_modules/@effect/stream/internal/channel/mergeStrategy.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+stream@0.12.1/node_modules/@effect/stream/internal/channel/singleProducerAsyncInput.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+stream@0.12.1/node_modules/@effect/stream/internal/channel/subexecutor.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+stream@0.12.1/node_modules/@effect/stream/internal/channel/upstreamPullRequest.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+stream@0.12.1/node_modules/@effect/stream/internal/channel/upstreamPullStrategy.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+stream@0.12.1/node_modules/@effect/stream/internal/core.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+stream@0.12.1/node_modules/@effect/stream/internal/groupBy.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+stream@0.12.1/node_modules/@effect/stream/internal/opCodes/channel.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+stream@0.12.1/node_modules/@effect/stream/internal/opCodes/channelState.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+stream@0.12.1/node_modules/@effect/stream/internal/opCodes/childExecutorDecision.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+stream@0.12.1/node_modules/@effect/stream/internal/opCodes/continuation.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+stream@0.12.1/node_modules/@effect/stream/internal/opCodes/haltStrategy.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+stream@0.12.1/node_modules/@effect/stream/internal/opCodes/mergeDecision.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+stream@0.12.1/node_modules/@effect/stream/internal/opCodes/mergeState.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+stream@0.12.1/node_modules/@effect/stream/internal/opCodes/mergeStrategy.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+stream@0.12.1/node_modules/@effect/stream/internal/opCodes/upstreamPullRequest.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+stream@0.12.1/node_modules/@effect/stream/internal/opCodes/upstreamPullStrategy.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+stream@0.12.1/node_modules/@effect/stream/internal/sink.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+stream@0.12.1/node_modules/@effect/stream/internal/stream.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+stream@0.12.1/node_modules/@effect/stream/internal/stream/debounceState.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+stream@0.12.1/node_modules/@effect/stream/internal/stream/emit.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+stream@0.12.1/node_modules/@effect/stream/internal/stream/haltStrategy.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+stream@0.12.1/node_modules/@effect/stream/internal/stream/handoff.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+stream@0.12.1/node_modules/@effect/stream/internal/stream/handoffSignal.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+stream@0.12.1/node_modules/@effect/stream/internal/stream/pull.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+stream@0.12.1/node_modules/@effect/stream/internal/stream/sinkEndReason.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+stream@0.12.1/node_modules/@effect/stream/internal/stream/zipAllState.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+stream@0.12.1/node_modules/@effect/stream/internal/stream/zipChunksState.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+stream@0.12.1/node_modules/@effect/stream/internal/support.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@effect+stream@0.12.1/node_modules/@effect/stream/internal/take.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@gist.githubusercontent.com+tim-smart+2249154d563b_oekcu5gxfvbtqdwlf4vpqi26fm/node_modules/@effect/node/Runtime.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@kwsites+file-exists@1.1.1/node_modules/@kwsites/file-exists/dist/index.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@kwsites+file-exists@1.1.1/node_modules/@kwsites/file-exists/dist/src/index.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@kwsites+promise-deferred@1.1.1/node_modules/@kwsites/promise-deferred/dist/index.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@octokit+auth-token@2.5.0/node_modules/@octokit/auth-token/dist-node/index.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@octokit+core@3.6.0/node_modules/@octokit/core/dist-node/index.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@octokit+endpoint@6.0.12/node_modules/@octokit/endpoint/dist-node/index.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@octokit+graphql@4.8.0/node_modules/@octokit/graphql/dist-node/index.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@octokit+plugin-paginate-rest@2.21.3_@octokit+core@3.6.0/node_modules/@octokit/plugin-paginate-rest/dist-node/index.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@octokit+plugin-rest-endpoint-methods@5.16.2_@octokit+core@3.6.0/node_modules/@octokit/plugin-rest-endpoint-methods/dist-node/index.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@octokit+request-error@2.1.0/node_modules/@octokit/request-error/dist-node/index.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@octokit+request@5.6.3/node_modules/@octokit/request/dist-node/index.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/before-after-hook@2.2.3/node_modules/before-after-hook/index.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/before-after-hook@2.2.3/node_modules/before-after-hook/lib/add.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/before-after-hook@2.2.3/node_modules/before-after-hook/lib/register.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/before-after-hook@2.2.3/node_modules/before-after-hook/lib/remove.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/browser.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/common.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/index.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/node.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/deprecation@2.3.1/node_modules/deprecation/dist-node/index.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/dotenv@16.0.3/node_modules/dotenv/lib/main.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/is-plain-object@5.0.0/node_modules/is-plain-object/dist/is-plain-object.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/ms@2.1.2/node_modules/ms/index.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/node-fetch@2.6.9/node_modules/node-fetch/lib/index.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/once@1.4.0/node_modules/once/once.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/simple-git@3.17.0/node_modules/simple-git/dist/cjs/index.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/tr46@0.0.3/node_modules/tr46/index.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/tunnel@0.0.6/node_modules/tunnel/index.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/tunnel@0.0.6/node_modules/tunnel/lib/tunnel.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/universal-user-agent@6.0.0/node_modules/universal-user-agent/dist-node/index.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/webidl-conversions@3.0.1/node_modules/webidl-conversions/lib/index.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/URL-impl.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/URL.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/public-api.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/url-state-machine.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/utils.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/wrappy@1.0.2/node_modules/wrappy/wrappy.js","../webpack://effect-ts-github-action/./node_modules/.pnpm/@vercel+ncc@0.36.1/node_modules/@vercel/ncc/dist/ncc/@@notfound.js","../webpack://effect-ts-github-action/external node-commonjs \"assert\"","../webpack://effect-ts-github-action/external node-commonjs \"child_process\"","../webpack://effect-ts-github-action/external node-commonjs \"events\"","../webpack://effect-ts-github-action/external node-commonjs \"fs\"","../webpack://effect-ts-github-action/external node-commonjs \"http\"","../webpack://effect-ts-github-action/external node-commonjs \"https\"","../webpack://effect-ts-github-action/external node-commonjs \"net\"","../webpack://effect-ts-github-action/external node-commonjs \"os\"","../webpack://effect-ts-github-action/external node-commonjs \"path\"","../webpack://effect-ts-github-action/external node-commonjs \"punycode\"","../webpack://effect-ts-github-action/external node-commonjs \"stream\"","../webpack://effect-ts-github-action/external node-commonjs \"tls\"","../webpack://effect-ts-github-action/external node-commonjs \"tty\"","../webpack://effect-ts-github-action/external node-commonjs \"url\"","../webpack://effect-ts-github-action/external node-commonjs \"util\"","../webpack://effect-ts-github-action/external node-commonjs \"zlib\"","../webpack://effect-ts-github-action/webpack/bootstrap","../webpack://effect-ts-github-action/webpack/runtime/compat","../webpack://effect-ts-github-action/./build/main.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.makeLayer = exports.Git = exports.GitRepo = exports.GitError = void 0;\nconst tsplus_module_1 = require(\"@effect/data/Context\");\nconst tsplus_module_2 = require(\"@effect/io/Effect\");\nconst tsplus_module_3 = require(\"@effect/io/Config\");\nconst SG = require(\"simple-git\");\n/**\n * A simple wrapper around simple-git.\n *\n * It exposes a `clone` method for working with git repositories.\n */\nclass GitError {\n    error;\n    _tag = \"GitError\";\n    constructor(error) {\n        this.error = error;\n    }\n}\nexports.GitError = GitError;\nexports.GitRepo = tsplus_module_1.Tag();\nconst make = ({ simpleGit: opts = {}, userName, userEmail }) => {\n    const clone = (url, dir) => tsplus_module_2.flatMap(tsplus_module_2.attemptCatchPromise(() => SG.simpleGit(opts).clone(url, dir), error => new GitError(error)), () => {\n        const git = SG.simpleGit(dir, opts);\n        const run = (f) => tsplus_module_2.attemptCatchPromise(() => f(git), error => new GitError(error));\n        return tsplus_module_2.map(run(_ => _.addConfig(\"user.name\", userName).addConfig(\"user.email\", userEmail)), () => ({ git, run, path: dir }));\n    });\n    return { clone };\n};\nexports.Git = tsplus_module_1.Tag();\nconst makeLayer = (_) => tsplus_module_2.toLayer(tsplus_module_2.map(tsplus_module_2.config(tsplus_module_3.unwrap(_)), make), exports.Git);\nexports.makeLayer = makeLayer;\n//# sourceMappingURL=Git.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.makeLayer = exports.Github = exports.GithubError = void 0;\nconst tsplus_module_1 = require(\"@effect/io/Config/Secret\");\nconst tsplus_module_2 = require(\"@effect/io/Effect\");\nconst tsplus_module_3 = require(\"@effect/data/Chunk\");\nconst tsplus_module_4 = require(\"@effect/stream/Stream\");\nconst tsplus_module_5 = require(\"@effect/data/Context\");\nconst tsplus_module_6 = require(\"@effect/io/Config\");\nconst tsplus_module_7 = require(\"@effect/data/Option\");\nconst github_1 = require(\"@actions/github\");\nclass GithubError {\n    reason;\n    _tag = \"GithubError\";\n    constructor(reason) {\n        this.reason = reason;\n    }\n}\nexports.GithubError = GithubError;\nconst make = ({ token }) => {\n    const api = (0, github_1.getOctokit)(tsplus_module_1.value(token));\n    const rest = api.rest;\n    const request = (f) => tsplus_module_2.attemptCatchPromise(() => f(rest), reason => new GithubError(reason));\n    const wrap = (f) => (...args) => tsplus_module_2.map(tsplus_module_2.attemptCatchPromise(() => f(rest)(...args), reason => new GithubError(reason)), _ => _.data);\n    const stream = (f) => tsplus_module_4.paginateChunkEffect(0, page => tsplus_module_2.map(tsplus_module_2.attemptCatchPromise(() => f(rest, page), reason => new GithubError(reason)), _ => [\n        tsplus_module_3.fromIterable(_.data),\n        maybeNextPage(page, _.headers.link),\n    ]));\n    return { api, token, request, wrap, stream };\n};\nexports.Github = tsplus_module_5.Tag();\nconst makeLayer = (_) => tsplus_module_2.toLayer(tsplus_module_2.map(tsplus_module_2.config(tsplus_module_6.unwrap(_)), make), exports.Github);\nexports.makeLayer = makeLayer;\nconst maybeNextPage = (page, linkHeader) => tsplus_module_7.as(page + 1)(tsplus_module_7.filter(_ => _.includes(`rel=\\\"next\\\"`))(tsplus_module_7.fromNullable(linkHeader)));\n//# sourceMappingURL=Github.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.inputSecret = exports.input = exports.nonEmptySecret = exports.nonEmptyString = void 0;\nconst tsplus_module_1 = require(\"@effect/data/Either\");\nconst tsplus_module_2 = require(\"@effect/data/Chunk\");\nconst tsplus_module_3 = require(\"@effect/io/Config\");\nconst tsplus_module_4 = require(\"@effect/io/Config/Secret\");\nconst Error_1 = require(\"@effect/io/Config/Error\");\nconst nonEmptyString = (name) => tsplus_module_3.mapOrFail(tsplus_module_3.string(name), _ => {\n    const trimmed = _.trim();\n    return trimmed !== \"\"\n        ? tsplus_module_1.right(trimmed)\n        : tsplus_module_1.left((0, Error_1.MissingData)(tsplus_module_2.empty(), \"must not be empty\"));\n});\nexports.nonEmptyString = nonEmptyString;\nconst nonEmptySecret = (name) => tsplus_module_3.mapOrFail(tsplus_module_3.secret(name), _ => {\n    const trimmed = tsplus_module_4.fromString(tsplus_module_4.value(_).trim());\n    return tsplus_module_4.value(trimmed) !== \"\"\n        ? tsplus_module_1.right(trimmed)\n        : tsplus_module_1.left((0, Error_1.MissingData)(tsplus_module_2.empty(), \"must not be empty\"));\n});\nexports.nonEmptySecret = nonEmptySecret;\nconst input = (name) => tsplus_module_3.nested((0, exports.nonEmptyString)(name), \"input\");\nexports.input = input;\nconst inputSecret = (name) => tsplus_module_3.nested((0, exports.nonEmptySecret)(name), \"input\");\nexports.inputSecret = inputSecret;\n//# sourceMappingURL=config.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Context = void 0;\nconst fs_1 = require(\"fs\");\nconst os_1 = require(\"os\");\nclass Context {\n    /**\n     * Hydrate the context from the environment\n     */\n    constructor() {\n        var _a, _b, _c;\n        this.payload = {};\n        if (process.env.GITHUB_EVENT_PATH) {\n            if (fs_1.existsSync(process.env.GITHUB_EVENT_PATH)) {\n                this.payload = JSON.parse(fs_1.readFileSync(process.env.GITHUB_EVENT_PATH, { encoding: 'utf8' }));\n            }\n            else {\n                const path = process.env.GITHUB_EVENT_PATH;\n                process.stdout.write(`GITHUB_EVENT_PATH ${path} does not exist${os_1.EOL}`);\n            }\n        }\n        this.eventName = process.env.GITHUB_EVENT_NAME;\n        this.sha = process.env.GITHUB_SHA;\n        this.ref = process.env.GITHUB_REF;\n        this.workflow = process.env.GITHUB_WORKFLOW;\n        this.action = process.env.GITHUB_ACTION;\n        this.actor = process.env.GITHUB_ACTOR;\n        this.job = process.env.GITHUB_JOB;\n        this.runNumber = parseInt(process.env.GITHUB_RUN_NUMBER, 10);\n        this.runId = parseInt(process.env.GITHUB_RUN_ID, 10);\n        this.apiUrl = (_a = process.env.GITHUB_API_URL) !== null && _a !== void 0 ? _a : `https://api.github.com`;\n        this.serverUrl = (_b = process.env.GITHUB_SERVER_URL) !== null && _b !== void 0 ? _b : `https://github.com`;\n        this.graphqlUrl = (_c = process.env.GITHUB_GRAPHQL_URL) !== null && _c !== void 0 ? _c : `https://api.github.com/graphql`;\n    }\n    get issue() {\n        const payload = this.payload;\n        return Object.assign(Object.assign({}, this.repo), { number: (payload.issue || payload.pull_request || payload).number });\n    }\n    get repo() {\n        if (process.env.GITHUB_REPOSITORY) {\n            const [owner, repo] = process.env.GITHUB_REPOSITORY.split('/');\n            return { owner, repo };\n        }\n        if (this.payload.repository) {\n            return {\n                owner: this.payload.repository.owner.login,\n                repo: this.payload.repository.name\n            };\n        }\n        throw new Error(\"context.repo requires a GITHUB_REPOSITORY environment variable like 'owner/repo'\");\n    }\n}\nexports.Context = Context;\n//# sourceMappingURL=context.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getOctokit = exports.context = void 0;\nconst Context = __importStar(require(\"./context\"));\nconst utils_1 = require(\"./utils\");\nexports.context = new Context.Context();\n/**\n * Returns a hydrated octokit ready to use for GitHub Actions\n *\n * @param     token    the repo PAT or GITHUB_TOKEN\n * @param     options  other options to set\n */\nfunction getOctokit(token, options, ...additionalPlugins) {\n    const GitHubWithPlugins = utils_1.GitHub.plugin(...additionalPlugins);\n    return new GitHubWithPlugins(utils_1.getOctokitOptions(token, options));\n}\nexports.getOctokit = getOctokit;\n//# sourceMappingURL=github.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getApiBaseUrl = exports.getProxyAgent = exports.getAuthString = void 0;\nconst httpClient = __importStar(require(\"@actions/http-client\"));\nfunction getAuthString(token, options) {\n    if (!token && !options.auth) {\n        throw new Error('Parameter token or opts.auth is required');\n    }\n    else if (token && options.auth) {\n        throw new Error('Parameters token and opts.auth may not both be specified');\n    }\n    return typeof options.auth === 'string' ? options.auth : `token ${token}`;\n}\nexports.getAuthString = getAuthString;\nfunction getProxyAgent(destinationUrl) {\n    const hc = new httpClient.HttpClient();\n    return hc.getAgent(destinationUrl);\n}\nexports.getProxyAgent = getProxyAgent;\nfunction getApiBaseUrl() {\n    return process.env['GITHUB_API_URL'] || 'https://api.github.com';\n}\nexports.getApiBaseUrl = getApiBaseUrl;\n//# sourceMappingURL=utils.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getOctokitOptions = exports.GitHub = exports.defaults = exports.context = void 0;\nconst Context = __importStar(require(\"./context\"));\nconst Utils = __importStar(require(\"./internal/utils\"));\n// octokit + plugins\nconst core_1 = require(\"@octokit/core\");\nconst plugin_rest_endpoint_methods_1 = require(\"@octokit/plugin-rest-endpoint-methods\");\nconst plugin_paginate_rest_1 = require(\"@octokit/plugin-paginate-rest\");\nexports.context = new Context.Context();\nconst baseUrl = Utils.getApiBaseUrl();\nexports.defaults = {\n    baseUrl,\n    request: {\n        agent: Utils.getProxyAgent(baseUrl)\n    }\n};\nexports.GitHub = core_1.Octokit.plugin(plugin_rest_endpoint_methods_1.restEndpointMethods, plugin_paginate_rest_1.paginateRest).defaults(exports.defaults);\n/**\n * Convience function to correctly format Octokit Options to pass into the constructor.\n *\n * @param     token    the repo PAT or GITHUB_TOKEN\n * @param     options  other options to set\n */\nfunction getOctokitOptions(token, options) {\n    const opts = Object.assign({}, options || {}); // Shallow clone - don't mutate the object provided by the caller\n    // Auth\n    const auth = Utils.getAuthString(token, opts);\n    if (auth) {\n        opts.auth = auth;\n    }\n    return opts;\n}\nexports.getOctokitOptions = getOctokitOptions;\n//# sourceMappingURL=utils.js.map","\"use strict\";\n/* eslint-disable @typescript-eslint/no-explicit-any */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.HttpClient = exports.isHttps = exports.HttpClientResponse = exports.HttpClientError = exports.getProxyUrl = exports.MediaTypes = exports.Headers = exports.HttpCodes = void 0;\nconst http = __importStar(require(\"http\"));\nconst https = __importStar(require(\"https\"));\nconst pm = __importStar(require(\"./proxy\"));\nconst tunnel = __importStar(require(\"tunnel\"));\nvar HttpCodes;\n(function (HttpCodes) {\n    HttpCodes[HttpCodes[\"OK\"] = 200] = \"OK\";\n    HttpCodes[HttpCodes[\"MultipleChoices\"] = 300] = \"MultipleChoices\";\n    HttpCodes[HttpCodes[\"MovedPermanently\"] = 301] = \"MovedPermanently\";\n    HttpCodes[HttpCodes[\"ResourceMoved\"] = 302] = \"ResourceMoved\";\n    HttpCodes[HttpCodes[\"SeeOther\"] = 303] = \"SeeOther\";\n    HttpCodes[HttpCodes[\"NotModified\"] = 304] = \"NotModified\";\n    HttpCodes[HttpCodes[\"UseProxy\"] = 305] = \"UseProxy\";\n    HttpCodes[HttpCodes[\"SwitchProxy\"] = 306] = \"SwitchProxy\";\n    HttpCodes[HttpCodes[\"TemporaryRedirect\"] = 307] = \"TemporaryRedirect\";\n    HttpCodes[HttpCodes[\"PermanentRedirect\"] = 308] = \"PermanentRedirect\";\n    HttpCodes[HttpCodes[\"BadRequest\"] = 400] = \"BadRequest\";\n    HttpCodes[HttpCodes[\"Unauthorized\"] = 401] = \"Unauthorized\";\n    HttpCodes[HttpCodes[\"PaymentRequired\"] = 402] = \"PaymentRequired\";\n    HttpCodes[HttpCodes[\"Forbidden\"] = 403] = \"Forbidden\";\n    HttpCodes[HttpCodes[\"NotFound\"] = 404] = \"NotFound\";\n    HttpCodes[HttpCodes[\"MethodNotAllowed\"] = 405] = \"MethodNotAllowed\";\n    HttpCodes[HttpCodes[\"NotAcceptable\"] = 406] = \"NotAcceptable\";\n    HttpCodes[HttpCodes[\"ProxyAuthenticationRequired\"] = 407] = \"ProxyAuthenticationRequired\";\n    HttpCodes[HttpCodes[\"RequestTimeout\"] = 408] = \"RequestTimeout\";\n    HttpCodes[HttpCodes[\"Conflict\"] = 409] = \"Conflict\";\n    HttpCodes[HttpCodes[\"Gone\"] = 410] = \"Gone\";\n    HttpCodes[HttpCodes[\"TooManyRequests\"] = 429] = \"TooManyRequests\";\n    HttpCodes[HttpCodes[\"InternalServerError\"] = 500] = \"InternalServerError\";\n    HttpCodes[HttpCodes[\"NotImplemented\"] = 501] = \"NotImplemented\";\n    HttpCodes[HttpCodes[\"BadGateway\"] = 502] = \"BadGateway\";\n    HttpCodes[HttpCodes[\"ServiceUnavailable\"] = 503] = \"ServiceUnavailable\";\n    HttpCodes[HttpCodes[\"GatewayTimeout\"] = 504] = \"GatewayTimeout\";\n})(HttpCodes = exports.HttpCodes || (exports.HttpCodes = {}));\nvar Headers;\n(function (Headers) {\n    Headers[\"Accept\"] = \"accept\";\n    Headers[\"ContentType\"] = \"content-type\";\n})(Headers = exports.Headers || (exports.Headers = {}));\nvar MediaTypes;\n(function (MediaTypes) {\n    MediaTypes[\"ApplicationJson\"] = \"application/json\";\n})(MediaTypes = exports.MediaTypes || (exports.MediaTypes = {}));\n/**\n * Returns the proxy URL, depending upon the supplied url and proxy environment variables.\n * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com\n */\nfunction getProxyUrl(serverUrl) {\n    const proxyUrl = pm.getProxyUrl(new URL(serverUrl));\n    return proxyUrl ? proxyUrl.href : '';\n}\nexports.getProxyUrl = getProxyUrl;\nconst HttpRedirectCodes = [\n    HttpCodes.MovedPermanently,\n    HttpCodes.ResourceMoved,\n    HttpCodes.SeeOther,\n    HttpCodes.TemporaryRedirect,\n    HttpCodes.PermanentRedirect\n];\nconst HttpResponseRetryCodes = [\n    HttpCodes.BadGateway,\n    HttpCodes.ServiceUnavailable,\n    HttpCodes.GatewayTimeout\n];\nconst RetryableHttpVerbs = ['OPTIONS', 'GET', 'DELETE', 'HEAD'];\nconst ExponentialBackoffCeiling = 10;\nconst ExponentialBackoffTimeSlice = 5;\nclass HttpClientError extends Error {\n    constructor(message, statusCode) {\n        super(message);\n        this.name = 'HttpClientError';\n        this.statusCode = statusCode;\n        Object.setPrototypeOf(this, HttpClientError.prototype);\n    }\n}\nexports.HttpClientError = HttpClientError;\nclass HttpClientResponse {\n    constructor(message) {\n        this.message = message;\n    }\n    readBody() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {\n                let output = Buffer.alloc(0);\n                this.message.on('data', (chunk) => {\n                    output = Buffer.concat([output, chunk]);\n                });\n                this.message.on('end', () => {\n                    resolve(output.toString());\n                });\n            }));\n        });\n    }\n}\nexports.HttpClientResponse = HttpClientResponse;\nfunction isHttps(requestUrl) {\n    const parsedUrl = new URL(requestUrl);\n    return parsedUrl.protocol === 'https:';\n}\nexports.isHttps = isHttps;\nclass HttpClient {\n    constructor(userAgent, handlers, requestOptions) {\n        this._ignoreSslError = false;\n        this._allowRedirects = true;\n        this._allowRedirectDowngrade = false;\n        this._maxRedirects = 50;\n        this._allowRetries = false;\n        this._maxRetries = 1;\n        this._keepAlive = false;\n        this._disposed = false;\n        this.userAgent = userAgent;\n        this.handlers = handlers || [];\n        this.requestOptions = requestOptions;\n        if (requestOptions) {\n            if (requestOptions.ignoreSslError != null) {\n                this._ignoreSslError = requestOptions.ignoreSslError;\n            }\n            this._socketTimeout = requestOptions.socketTimeout;\n            if (requestOptions.allowRedirects != null) {\n                this._allowRedirects = requestOptions.allowRedirects;\n            }\n            if (requestOptions.allowRedirectDowngrade != null) {\n                this._allowRedirectDowngrade = requestOptions.allowRedirectDowngrade;\n            }\n            if (requestOptions.maxRedirects != null) {\n                this._maxRedirects = Math.max(requestOptions.maxRedirects, 0);\n            }\n            if (requestOptions.keepAlive != null) {\n                this._keepAlive = requestOptions.keepAlive;\n            }\n            if (requestOptions.allowRetries != null) {\n                this._allowRetries = requestOptions.allowRetries;\n            }\n            if (requestOptions.maxRetries != null) {\n                this._maxRetries = requestOptions.maxRetries;\n            }\n        }\n    }\n    options(requestUrl, additionalHeaders) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.request('OPTIONS', requestUrl, null, additionalHeaders || {});\n        });\n    }\n    get(requestUrl, additionalHeaders) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.request('GET', requestUrl, null, additionalHeaders || {});\n        });\n    }\n    del(requestUrl, additionalHeaders) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.request('DELETE', requestUrl, null, additionalHeaders || {});\n        });\n    }\n    post(requestUrl, data, additionalHeaders) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.request('POST', requestUrl, data, additionalHeaders || {});\n        });\n    }\n    patch(requestUrl, data, additionalHeaders) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.request('PATCH', requestUrl, data, additionalHeaders || {});\n        });\n    }\n    put(requestUrl, data, additionalHeaders) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.request('PUT', requestUrl, data, additionalHeaders || {});\n        });\n    }\n    head(requestUrl, additionalHeaders) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.request('HEAD', requestUrl, null, additionalHeaders || {});\n        });\n    }\n    sendStream(verb, requestUrl, stream, additionalHeaders) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.request(verb, requestUrl, stream, additionalHeaders);\n        });\n    }\n    /**\n     * Gets a typed object from an endpoint\n     * Be aware that not found returns a null.  Other errors (4xx, 5xx) reject the promise\n     */\n    getJson(requestUrl, additionalHeaders = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);\n            const res = yield this.get(requestUrl, additionalHeaders);\n            return this._processResponse(res, this.requestOptions);\n        });\n    }\n    postJson(requestUrl, obj, additionalHeaders = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const data = JSON.stringify(obj, null, 2);\n            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);\n            additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);\n            const res = yield this.post(requestUrl, data, additionalHeaders);\n            return this._processResponse(res, this.requestOptions);\n        });\n    }\n    putJson(requestUrl, obj, additionalHeaders = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const data = JSON.stringify(obj, null, 2);\n            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);\n            additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);\n            const res = yield this.put(requestUrl, data, additionalHeaders);\n            return this._processResponse(res, this.requestOptions);\n        });\n    }\n    patchJson(requestUrl, obj, additionalHeaders = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const data = JSON.stringify(obj, null, 2);\n            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);\n            additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);\n            const res = yield this.patch(requestUrl, data, additionalHeaders);\n            return this._processResponse(res, this.requestOptions);\n        });\n    }\n    /**\n     * Makes a raw http request.\n     * All other methods such as get, post, patch, and request ultimately call this.\n     * Prefer get, del, post and patch\n     */\n    request(verb, requestUrl, data, headers) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._disposed) {\n                throw new Error('Client has already been disposed.');\n            }\n            const parsedUrl = new URL(requestUrl);\n            let info = this._prepareRequest(verb, parsedUrl, headers);\n            // Only perform retries on reads since writes may not be idempotent.\n            const maxTries = this._allowRetries && RetryableHttpVerbs.includes(verb)\n                ? this._maxRetries + 1\n                : 1;\n            let numTries = 0;\n            let response;\n            do {\n                response = yield this.requestRaw(info, data);\n                // Check if it's an authentication challenge\n                if (response &&\n                    response.message &&\n                    response.message.statusCode === HttpCodes.Unauthorized) {\n                    let authenticationHandler;\n                    for (const handler of this.handlers) {\n                        if (handler.canHandleAuthentication(response)) {\n                            authenticationHandler = handler;\n                            break;\n                        }\n                    }\n                    if (authenticationHandler) {\n                        return authenticationHandler.handleAuthentication(this, info, data);\n                    }\n                    else {\n                        // We have received an unauthorized response but have no handlers to handle it.\n                        // Let the response return to the caller.\n                        return response;\n                    }\n                }\n                let redirectsRemaining = this._maxRedirects;\n                while (response.message.statusCode &&\n                    HttpRedirectCodes.includes(response.message.statusCode) &&\n                    this._allowRedirects &&\n                    redirectsRemaining > 0) {\n                    const redirectUrl = response.message.headers['location'];\n                    if (!redirectUrl) {\n                        // if there's no location to redirect to, we won't\n                        break;\n                    }\n                    const parsedRedirectUrl = new URL(redirectUrl);\n                    if (parsedUrl.protocol === 'https:' &&\n                        parsedUrl.protocol !== parsedRedirectUrl.protocol &&\n                        !this._allowRedirectDowngrade) {\n                        throw new Error('Redirect from HTTPS to HTTP protocol. This downgrade is not allowed for security reasons. If you want to allow this behavior, set the allowRedirectDowngrade option to true.');\n                    }\n                    // we need to finish reading the response before reassigning response\n                    // which will leak the open socket.\n                    yield response.readBody();\n                    // strip authorization header if redirected to a different hostname\n                    if (parsedRedirectUrl.hostname !== parsedUrl.hostname) {\n                        for (const header in headers) {\n                            // header names are case insensitive\n                            if (header.toLowerCase() === 'authorization') {\n                                delete headers[header];\n                            }\n                        }\n                    }\n                    // let's make the request with the new redirectUrl\n                    info = this._prepareRequest(verb, parsedRedirectUrl, headers);\n                    response = yield this.requestRaw(info, data);\n                    redirectsRemaining--;\n                }\n                if (!response.message.statusCode ||\n                    !HttpResponseRetryCodes.includes(response.message.statusCode)) {\n                    // If not a retry code, return immediately instead of retrying\n                    return response;\n                }\n                numTries += 1;\n                if (numTries < maxTries) {\n                    yield response.readBody();\n                    yield this._performExponentialBackoff(numTries);\n                }\n            } while (numTries < maxTries);\n            return response;\n        });\n    }\n    /**\n     * Needs to be called if keepAlive is set to true in request options.\n     */\n    dispose() {\n        if (this._agent) {\n            this._agent.destroy();\n        }\n        this._disposed = true;\n    }\n    /**\n     * Raw request.\n     * @param info\n     * @param data\n     */\n    requestRaw(info, data) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve, reject) => {\n                function callbackForResult(err, res) {\n                    if (err) {\n                        reject(err);\n                    }\n                    else if (!res) {\n                        // If `err` is not passed, then `res` must be passed.\n                        reject(new Error('Unknown error'));\n                    }\n                    else {\n                        resolve(res);\n                    }\n                }\n                this.requestRawWithCallback(info, data, callbackForResult);\n            });\n        });\n    }\n    /**\n     * Raw request with callback.\n     * @param info\n     * @param data\n     * @param onResult\n     */\n    requestRawWithCallback(info, data, onResult) {\n        if (typeof data === 'string') {\n            if (!info.options.headers) {\n                info.options.headers = {};\n            }\n            info.options.headers['Content-Length'] = Buffer.byteLength(data, 'utf8');\n        }\n        let callbackCalled = false;\n        function handleResult(err, res) {\n            if (!callbackCalled) {\n                callbackCalled = true;\n                onResult(err, res);\n            }\n        }\n        const req = info.httpModule.request(info.options, (msg) => {\n            const res = new HttpClientResponse(msg);\n            handleResult(undefined, res);\n        });\n        let socket;\n        req.on('socket', sock => {\n            socket = sock;\n        });\n        // If we ever get disconnected, we want the socket to timeout eventually\n        req.setTimeout(this._socketTimeout || 3 * 60000, () => {\n            if (socket) {\n                socket.end();\n            }\n            handleResult(new Error(`Request timeout: ${info.options.path}`));\n        });\n        req.on('error', function (err) {\n            // err has statusCode property\n            // res should have headers\n            handleResult(err);\n        });\n        if (data && typeof data === 'string') {\n            req.write(data, 'utf8');\n        }\n        if (data && typeof data !== 'string') {\n            data.on('close', function () {\n                req.end();\n            });\n            data.pipe(req);\n        }\n        else {\n            req.end();\n        }\n    }\n    /**\n     * Gets an http agent. This function is useful when you need an http agent that handles\n     * routing through a proxy server - depending upon the url and proxy environment variables.\n     * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com\n     */\n    getAgent(serverUrl) {\n        const parsedUrl = new URL(serverUrl);\n        return this._getAgent(parsedUrl);\n    }\n    _prepareRequest(method, requestUrl, headers) {\n        const info = {};\n        info.parsedUrl = requestUrl;\n        const usingSsl = info.parsedUrl.protocol === 'https:';\n        info.httpModule = usingSsl ? https : http;\n        const defaultPort = usingSsl ? 443 : 80;\n        info.options = {};\n        info.options.host = info.parsedUrl.hostname;\n        info.options.port = info.parsedUrl.port\n            ? parseInt(info.parsedUrl.port)\n            : defaultPort;\n        info.options.path =\n            (info.parsedUrl.pathname || '') + (info.parsedUrl.search || '');\n        info.options.method = method;\n        info.options.headers = this._mergeHeaders(headers);\n        if (this.userAgent != null) {\n            info.options.headers['user-agent'] = this.userAgent;\n        }\n        info.options.agent = this._getAgent(info.parsedUrl);\n        // gives handlers an opportunity to participate\n        if (this.handlers) {\n            for (const handler of this.handlers) {\n                handler.prepareRequest(info.options);\n            }\n        }\n        return info;\n    }\n    _mergeHeaders(headers) {\n        if (this.requestOptions && this.requestOptions.headers) {\n            return Object.assign({}, lowercaseKeys(this.requestOptions.headers), lowercaseKeys(headers || {}));\n        }\n        return lowercaseKeys(headers || {});\n    }\n    _getExistingOrDefaultHeader(additionalHeaders, header, _default) {\n        let clientHeader;\n        if (this.requestOptions && this.requestOptions.headers) {\n            clientHeader = lowercaseKeys(this.requestOptions.headers)[header];\n        }\n        return additionalHeaders[header] || clientHeader || _default;\n    }\n    _getAgent(parsedUrl) {\n        let agent;\n        const proxyUrl = pm.getProxyUrl(parsedUrl);\n        const useProxy = proxyUrl && proxyUrl.hostname;\n        if (this._keepAlive && useProxy) {\n            agent = this._proxyAgent;\n        }\n        if (this._keepAlive && !useProxy) {\n            agent = this._agent;\n        }\n        // if agent is already assigned use that agent.\n        if (agent) {\n            return agent;\n        }\n        const usingSsl = parsedUrl.protocol === 'https:';\n        let maxSockets = 100;\n        if (this.requestOptions) {\n            maxSockets = this.requestOptions.maxSockets || http.globalAgent.maxSockets;\n        }\n        // This is `useProxy` again, but we need to check `proxyURl` directly for TypeScripts's flow analysis.\n        if (proxyUrl && proxyUrl.hostname) {\n            const agentOptions = {\n                maxSockets,\n                keepAlive: this._keepAlive,\n                proxy: Object.assign(Object.assign({}, ((proxyUrl.username || proxyUrl.password) && {\n                    proxyAuth: `${proxyUrl.username}:${proxyUrl.password}`\n                })), { host: proxyUrl.hostname, port: proxyUrl.port })\n            };\n            let tunnelAgent;\n            const overHttps = proxyUrl.protocol === 'https:';\n            if (usingSsl) {\n                tunnelAgent = overHttps ? tunnel.httpsOverHttps : tunnel.httpsOverHttp;\n            }\n            else {\n                tunnelAgent = overHttps ? tunnel.httpOverHttps : tunnel.httpOverHttp;\n            }\n            agent = tunnelAgent(agentOptions);\n            this._proxyAgent = agent;\n        }\n        // if reusing agent across request and tunneling agent isn't assigned create a new agent\n        if (this._keepAlive && !agent) {\n            const options = { keepAlive: this._keepAlive, maxSockets };\n            agent = usingSsl ? new https.Agent(options) : new http.Agent(options);\n            this._agent = agent;\n        }\n        // if not using private agent and tunnel agent isn't setup then use global agent\n        if (!agent) {\n            agent = usingSsl ? https.globalAgent : http.globalAgent;\n        }\n        if (usingSsl && this._ignoreSslError) {\n            // we don't want to set NODE_TLS_REJECT_UNAUTHORIZED=0 since that will affect request for entire process\n            // http.RequestOptions doesn't expose a way to modify RequestOptions.agent.options\n            // we have to cast it to any and change it directly\n            agent.options = Object.assign(agent.options || {}, {\n                rejectUnauthorized: false\n            });\n        }\n        return agent;\n    }\n    _performExponentialBackoff(retryNumber) {\n        return __awaiter(this, void 0, void 0, function* () {\n            retryNumber = Math.min(ExponentialBackoffCeiling, retryNumber);\n            const ms = ExponentialBackoffTimeSlice * Math.pow(2, retryNumber);\n            return new Promise(resolve => setTimeout(() => resolve(), ms));\n        });\n    }\n    _processResponse(res, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n                const statusCode = res.message.statusCode || 0;\n                const response = {\n                    statusCode,\n                    result: null,\n                    headers: {}\n                };\n                // not found leads to null obj returned\n                if (statusCode === HttpCodes.NotFound) {\n                    resolve(response);\n                }\n                // get the result from the body\n                function dateTimeDeserializer(key, value) {\n                    if (typeof value === 'string') {\n                        const a = new Date(value);\n                        if (!isNaN(a.valueOf())) {\n                            return a;\n                        }\n                    }\n                    return value;\n                }\n                let obj;\n                let contents;\n                try {\n                    contents = yield res.readBody();\n                    if (contents && contents.length > 0) {\n                        if (options && options.deserializeDates) {\n                            obj = JSON.parse(contents, dateTimeDeserializer);\n                        }\n                        else {\n                            obj = JSON.parse(contents);\n                        }\n                        response.result = obj;\n                    }\n                    response.headers = res.message.headers;\n                }\n                catch (err) {\n                    // Invalid resource (contents not json);  leaving result obj null\n                }\n                // note that 3xx redirects are handled by the http layer.\n                if (statusCode > 299) {\n                    let msg;\n                    // if exception/error in body, attempt to get better error\n                    if (obj && obj.message) {\n                        msg = obj.message;\n                    }\n                    else if (contents && contents.length > 0) {\n                        // it may be the case that the exception is in the body message as string\n                        msg = contents;\n                    }\n                    else {\n                        msg = `Failed request: (${statusCode})`;\n                    }\n                    const err = new HttpClientError(msg, statusCode);\n                    err.result = response.result;\n                    reject(err);\n                }\n                else {\n                    resolve(response);\n                }\n            }));\n        });\n    }\n}\nexports.HttpClient = HttpClient;\nconst lowercaseKeys = (obj) => Object.keys(obj).reduce((c, k) => ((c[k.toLowerCase()] = obj[k]), c), {});\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.checkBypass = exports.getProxyUrl = void 0;\nfunction getProxyUrl(reqUrl) {\n    const usingSsl = reqUrl.protocol === 'https:';\n    if (checkBypass(reqUrl)) {\n        return undefined;\n    }\n    const proxyVar = (() => {\n        if (usingSsl) {\n            return process.env['https_proxy'] || process.env['HTTPS_PROXY'];\n        }\n        else {\n            return process.env['http_proxy'] || process.env['HTTP_PROXY'];\n        }\n    })();\n    if (proxyVar) {\n        return new URL(proxyVar);\n    }\n    else {\n        return undefined;\n    }\n}\nexports.getProxyUrl = getProxyUrl;\nfunction checkBypass(reqUrl) {\n    if (!reqUrl.hostname) {\n        return false;\n    }\n    const noProxy = process.env['no_proxy'] || process.env['NO_PROXY'] || '';\n    if (!noProxy) {\n        return false;\n    }\n    // Determine the request port\n    let reqPort;\n    if (reqUrl.port) {\n        reqPort = Number(reqUrl.port);\n    }\n    else if (reqUrl.protocol === 'http:') {\n        reqPort = 80;\n    }\n    else if (reqUrl.protocol === 'https:') {\n        reqPort = 443;\n    }\n    // Format the request hostname and hostname with port\n    const upperReqHosts = [reqUrl.hostname.toUpperCase()];\n    if (typeof reqPort === 'number') {\n        upperReqHosts.push(`${upperReqHosts[0]}:${reqPort}`);\n    }\n    // Compare request host against noproxy\n    for (const upperNoProxyItem of noProxy\n        .split(',')\n        .map(x => x.trim().toUpperCase())\n        .filter(x => x)) {\n        if (upperReqHosts.some(x => x === upperNoProxyItem)) {\n            return true;\n        }\n    }\n    return false;\n}\nexports.checkBypass = checkBypass;\n//# sourceMappingURL=proxy.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.zipWithIndexOffset = exports.zipWithIndex = exports.zipWith = exports.zipAllWith = exports.zipAll = exports.zip = exports.unzip = exports.unsafeLast = exports.unsafeHead = exports.unsafeGet = exports.unsafeFromArray = exports.union = exports.unfold = exports.toReadonlyArray = exports.takeWhile = exports.takeRight = exports.take = exports.tailNonEmpty = exports.tail = exports.splitWhere = exports.splitAt = exports.split = exports.sort = exports.some = exports.size = exports.separate = exports.reverse = exports.replaceOption = exports.replace = exports.remove = exports.reduceWithIndex = exports.reduceRightWithIndex = exports.reduceRight = exports.reduce = exports.range = exports.prependAllNonEmpty = exports.prepend = exports.partitionWithIndex = exports.partitionMap = exports.partition = exports.of = exports.modifyOption = exports.modify = exports.mapWithIndex = exports.mapAccum = exports.map = exports.makeBy = exports.make = exports.last = exports.join = exports.isNonEmpty = exports.isEmpty = exports.isChunk = exports.intersection = exports.headNonEmpty = exports.head = exports.get = exports.fromIterable = exports.forEach = exports.flatten = exports.flatMap = exports.findLastIndex = exports.findLast = exports.findFirstIndex = exports.findFirst = exports.filterMapWithIndex = exports.filterMapWhile = exports.filterMap = exports.filter = exports.every = exports.empty = exports.elem = exports.dropWhile = exports.dropRight = exports.drop = exports.dedupeAdjacent = exports.dedupe = exports.crossWith = exports.cross = exports.correspondsTo = exports.concat = exports.compact = exports.chunksOf = exports.append = void 0;\nvar Equal = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Equal\"));\nvar Dual = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Function\"));\nvar Hash = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Hash\"));\nvar O = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Option\"));\nvar RA = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/ReadonlyArray\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\nconst TypeId = /*#__PURE__*/Symbol.for(\"@effect/data/Chunk\");\n/** @internal */\nconst emptyArray = [];\n/** @internal */\nfunction copy(src, srcPos, dest, destPos, len) {\n  for (let i = srcPos; i < Math.min(src.length, srcPos + len); i++) {\n    dest[destPos + i - srcPos] = src[i];\n  }\n  return dest;\n}\n/** @internal */\nclass ChunkImpl {\n  constructor(backing) {\n    this.backing = backing;\n    this._id = TypeId;\n    switch (backing._tag) {\n      case \"IEmpty\":\n        {\n          this.length = 0;\n          this.depth = 0;\n          this.left = this;\n          this.right = this;\n          break;\n        }\n      case \"IConcat\":\n        {\n          this.length = backing.left.length + backing.right.length;\n          this.depth = 1 + Math.max(backing.left.depth, backing.right.depth);\n          this.left = backing.left;\n          this.right = backing.right;\n          break;\n        }\n      case \"IArray\":\n        {\n          this.length = backing.array.length;\n          this.depth = 0;\n          this.left = _empty;\n          this.right = _empty;\n          break;\n        }\n      case \"ISingleton\":\n        {\n          this.length = 1;\n          this.depth = 0;\n          this.left = _empty;\n          this.right = _empty;\n          break;\n        }\n    }\n  }\n  toString() {\n    return `Chunk(${toReadonlyArray(this).map(String).join(\", \")})`;\n  }\n  toJSON() {\n    return {\n      _tag: \"Chunk\",\n      values: toReadonlyArray(this)\n    };\n  }\n  [Symbol.for(\"nodejs.util.inspect.custom\")]() {\n    return this.toJSON();\n  }\n  [Equal.symbol](that) {\n    if (isChunk(that) && this.length === that.length) {\n      return toReadonlyArray(this).every((value, i) => Equal.equals(value, unsafeGet(that, i)));\n    }\n    return false;\n  }\n  [Hash.symbol]() {\n    return Hash.array(toReadonlyArray(this));\n  }\n  [Symbol.iterator]() {\n    switch (this.backing._tag) {\n      case \"IArray\":\n        {\n          return this.backing.array[Symbol.iterator]();\n        }\n      case \"IEmpty\":\n        {\n          return emptyArray[Symbol.iterator]();\n        }\n      default:\n        {\n          return toReadonlyArray(this)[Symbol.iterator]();\n        }\n    }\n  }\n}\n/** @internal */\nconst copyToArray = (self, array, initial) => {\n  switch (self.backing._tag) {\n    case \"IArray\":\n      {\n        copy(self.backing.array, 0, array, initial, self.length);\n        break;\n      }\n    case \"IConcat\":\n      {\n        copyToArray(self.left, array, initial);\n        copyToArray(self.right, array, initial + self.left.length);\n        break;\n      }\n    case \"ISingleton\":\n      {\n        array[initial] = self.backing.a;\n        break;\n      }\n  }\n};\n/**\n * Checks if `u` is a `Chunk<unknown>`\n *\n * @since 1.0.0\n * @category constructors\n */\nconst isChunk = u => typeof u === \"object\" && u != null && \"_id\" in u && u[\"_id\"] === TypeId;\nexports.isChunk = isChunk;\nconst _empty = /*#__PURE__*/new ChunkImpl({\n  _tag: \"IEmpty\"\n});\n/**\n * @since 1.0.0\n * @category constructors\n */\nconst empty = () => _empty;\n/**\n * Converts from an `Iterable<A>`\n *\n * @since 1.0.0\n * @category conversions\n */\nexports.empty = empty;\nconst fromIterable = self => isChunk(self) ? self : new ChunkImpl({\n  _tag: \"IArray\",\n  array: Array.from(self)\n});\n/**\n * Converts to a `ReadonlyArray<A>`\n *\n * @since 1.0.0\n * @category conversions\n */\nexports.fromIterable = fromIterable;\nconst toReadonlyArray = self => {\n  switch (self.backing._tag) {\n    case \"IEmpty\":\n      {\n        return emptyArray;\n      }\n    case \"IArray\":\n      {\n        return self.backing.array;\n      }\n    default:\n      {\n        const arr = new Array(self.length);\n        copyToArray(self, arr, 0);\n        self.backing = {\n          _tag: \"IArray\",\n          array: arr\n        };\n        self.left = _empty;\n        self.right = _empty;\n        self.depth = 0;\n        return arr;\n      }\n  }\n};\n/**\n * This function provides a safe way to read a value at a particular index from a `Chunk`.\n *\n * @since 1.0.0\n * @category elements\n */\nexports.toReadonlyArray = toReadonlyArray;\nconst get = /*#__PURE__*/Dual.dual(2, (self, index) => index < 0 || index >= self.length ? O.none() : O.some(unsafeGet(self, index)));\n/**\n * Wraps an array into a chunk without copying, unsafe on mutable arrays\n *\n * @since 1.0.0\n * @category unsafe\n */\nexports.get = get;\nconst unsafeFromArray = self => new ChunkImpl({\n  _tag: \"IArray\",\n  array: self\n});\n/**\n * Gets an element unsafely, will throw on out of bounds\n *\n * @since 1.0.0\n * @category unsafe\n */\nexports.unsafeFromArray = unsafeFromArray;\nconst unsafeGet = /*#__PURE__*/Dual.dual(2, (self, index) => {\n  switch (self.backing._tag) {\n    case \"IEmpty\":\n      {\n        throw new Error(`Index out of bounds`);\n      }\n    case \"ISingleton\":\n      {\n        if (index !== 0) {\n          throw new Error(`Index out of bounds`);\n        }\n        return self.backing.a;\n      }\n    case \"IArray\":\n      {\n        if (index >= self.length || index < 0) {\n          throw new Error(`Index out of bounds`);\n        }\n        return self.backing.array[index];\n      }\n    case \"IConcat\":\n      {\n        return index < self.left.length ? unsafeGet(self.left, index) : unsafeGet(self.right, index - self.left.length);\n      }\n  }\n});\n/**\n * Appends the value to the chunk\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.unsafeGet = unsafeGet;\nconst append = /*#__PURE__*/Dual.dual(2, (self, a) => concat(self, of(a)));\n/**\n * Prepends the value to the chunk\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.append = append;\nconst prepend = /*#__PURE__*/Dual.dual(2, (self, a) => concat(of(a), self));\n/**\n * Takes the first up to `n` elements from the chunk\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.prepend = prepend;\nconst take = /*#__PURE__*/Dual.dual(2, (self, n) => {\n  if (n <= 0) {\n    return _empty;\n  } else if (n >= self.length) {\n    return self;\n  } else {\n    return unsafeFromArray(RA.take(n)(toReadonlyArray(self)));\n  }\n});\n/**\n * Drops the first up to `n` elements from the chunk\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.take = take;\nconst drop = /*#__PURE__*/Dual.dual(2, (self, n) => {\n  if (n <= 0) {\n    return self;\n  } else if (n >= self.length) {\n    return _empty;\n  } else {\n    return unsafeFromArray(RA.drop(n)(toReadonlyArray(self)));\n  }\n});\n/**\n * Drops the last `n` elements.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.drop = drop;\nconst dropRight = /*#__PURE__*/Dual.dual(2, (self, n) => take(self, Math.max(0, self.length - n)));\n/**\n * Drops all elements so long as the predicate returns true.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.dropRight = dropRight;\nconst dropWhile = /*#__PURE__*/Dual.dual(2, (self, f) => {\n  const arr = toReadonlyArray(self);\n  const len = arr.length;\n  let i = 0;\n  while (i < len && f(arr[i])) {\n    i++;\n  }\n  return drop(i)(self);\n});\n/**\n * @category mutations\n * @since 1.0.0\n */\nexports.dropWhile = dropWhile;\nconst prependAllNonEmpty = /*#__PURE__*/Dual.dual(2, (self, that) => concat(that, self));\n/**\n * Concatenates the two chunks\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.prependAllNonEmpty = prependAllNonEmpty;\nconst concat = /*#__PURE__*/Dual.dual(2, (self, that) => {\n  if (self.backing._tag === \"IEmpty\") {\n    return that;\n  }\n  if (that.backing._tag === \"IEmpty\") {\n    return self;\n  }\n  const diff = that.depth - self.depth;\n  if (Math.abs(diff) <= 1) {\n    return new ChunkImpl({\n      _tag: \"IConcat\",\n      left: self,\n      right: that\n    });\n  } else if (diff < -1) {\n    if (self.left.depth >= self.right.depth) {\n      const nr = concat(that)(self.right);\n      return new ChunkImpl({\n        _tag: \"IConcat\",\n        left: self.left,\n        right: nr\n      });\n    } else {\n      const nrr = concat(that)(self.right.right);\n      if (nrr.depth === self.depth - 3) {\n        const nr = new ChunkImpl({\n          _tag: \"IConcat\",\n          left: self.right.left,\n          right: nrr\n        });\n        return new ChunkImpl({\n          _tag: \"IConcat\",\n          left: self.left,\n          right: nr\n        });\n      } else {\n        const nl = new ChunkImpl({\n          _tag: \"IConcat\",\n          left: self.left,\n          right: self.right.left\n        });\n        return new ChunkImpl({\n          _tag: \"IConcat\",\n          left: nl,\n          right: nrr\n        });\n      }\n    }\n  } else {\n    if (that.right.depth >= that.left.depth) {\n      const nl = concat(that.left)(self);\n      return new ChunkImpl({\n        _tag: \"IConcat\",\n        left: nl,\n        right: that.right\n      });\n    } else {\n      const nll = concat(that.left.left)(self);\n      if (nll.depth === that.depth - 3) {\n        const nl = new ChunkImpl({\n          _tag: \"IConcat\",\n          left: nll,\n          right: that.left.right\n        });\n        return new ChunkImpl({\n          _tag: \"IConcat\",\n          left: nl,\n          right: that.right\n        });\n      } else {\n        const nr = new ChunkImpl({\n          _tag: \"IConcat\",\n          left: that.left.right,\n          right: that.right\n        });\n        return new ChunkImpl({\n          _tag: \"IConcat\",\n          left: nll,\n          right: nr\n        });\n      }\n    }\n  }\n});\n/**\n * Compares the two chunks of equal length using the specified function\n *\n * @since 1.0.0\n * @category elements\n */\nexports.concat = concat;\nconst correspondsTo = /*#__PURE__*/Dual.dual(3, (self, that, f) => {\n  if (self.length !== that.length) {\n    return false;\n  }\n  const selfArray = toReadonlyArray(self);\n  const thatArray = toReadonlyArray(that);\n  return selfArray.every((v, i) => f(v, thatArray[i]));\n});\n/**\n * Returns a filtered and mapped subset of the elements.\n *\n * @since 1.0.0\n * @category filtering\n */\nexports.correspondsTo = correspondsTo;\nconst filterMap = /*#__PURE__*/Dual.dual(2, (self, f) => unsafeFromArray(RA.filterMap(f)(self)));\n/**\n * Returns a filtered and mapped subset of the elements.\n *\n * @since 1.0.0\n * @category filtering\n */\nexports.filterMap = filterMap;\nconst filter = /*#__PURE__*/Dual.dual(2, (self, predicate) => unsafeFromArray(RA.filterMap(O.liftPredicate(predicate))(self)));\n/**\n * Returns a filtered and mapped subset of the elements.\n *\n * @since 1.0.0\n * @category filtering\n */\nexports.filter = filter;\nconst filterMapWithIndex = /*#__PURE__*/Dual.dual(2, (self, f) => unsafeFromArray(RA.filterMap(f)(self)));\n/**\n * Transforms all elements of the chunk for as long as the specified function returns some value\n *\n * @since 1.0.0\n * @category filtering\n */\nexports.filterMapWithIndex = filterMapWithIndex;\nconst filterMapWhile = /*#__PURE__*/Dual.dual(2, (self, f) => {\n  const res = [];\n  for (const a of self) {\n    const b = f(a);\n    if (O.isSome(b)) {\n      res.push(b.value);\n    } else {\n      break;\n    }\n  }\n  return unsafeFromArray(res);\n});\n/**\n * Tests whether a value is a member of a `Chunk<A>`.\n *\n * @since 1.0.0\n * @category elements\n */\nexports.filterMapWhile = filterMapWhile;\nconst elem = /*#__PURE__*/Dual.dual(2, (self, b) => RA.contains(Equal.equivalence())(b)(toReadonlyArray(self)));\n/**\n * Filter out optional values\n *\n * @since 1.0.0\n * @category filtering\n */\nexports.elem = elem;\nconst compact = self => filterMap(self, Dual.identity);\n/**\n * Deduplicates adjacent elements that are identical.\n *\n * @since 1.0.0\n * @category filtering\n */\nexports.compact = compact;\nconst dedupeAdjacent = self => {\n  const builder = [];\n  let lastA = O.none();\n  for (const a of self) {\n    if (O.isNone(lastA) || !Equal.equals(a, lastA.value)) {\n      builder.push(a);\n      lastA = O.some(a);\n    }\n  }\n  return unsafeFromArray(builder);\n};\n/**\n * Check if a predicate holds true for any `Chunk` member.\n *\n * @since 1.0.0\n * @category elements\n */\nexports.dedupeAdjacent = dedupeAdjacent;\nconst some = /*#__PURE__*/Dual.dual(2, (self, f) => toReadonlyArray(self).findIndex(v => f(v)) !== -1);\n/**\n * Check if a predicate holds true for every `Chunk` member.\n *\n * @since 1.0.0\n * @category elements\n */\nexports.some = some;\nconst every = /*#__PURE__*/Dual.dual(2, (self, f) => toReadonlyArray(self).every(v => f(v)));\n/**\n * Find the first element which satisfies a predicate (or a refinement) function.\n *\n * @since 1.0.0\n * @category elements\n */\nexports.every = every;\nconst findFirst = /*#__PURE__*/Dual.dual(2, (self, predicate) => RA.findFirst(predicate)(toReadonlyArray(self)));\n/**\n * Find the first index for which a predicate holds\n *\n * @since 1.0.0\n * @category elements\n */\nexports.findFirst = findFirst;\nconst findFirstIndex = /*#__PURE__*/Dual.dual(2, (self, f) => RA.findFirstIndex(f)(toReadonlyArray(self)));\n/**\n * Find the first index for which a predicate holds\n *\n * @since 1.0.0\n * @category elements\n */\nexports.findFirstIndex = findFirstIndex;\nconst findLastIndex = /*#__PURE__*/Dual.dual(2, (self, f) => RA.findLastIndex(f)(toReadonlyArray(self)));\n/**\n * Find the last element which satisfies a predicate function\n *\n * @since 1.0.0\n * @category elements\n */\nexports.findLastIndex = findLastIndex;\nconst findLast = /*#__PURE__*/Dual.dual(2, (self, f) => RA.findLast(f)(toReadonlyArray(self)));\n/**\n * Returns a chunk with the elements mapped by the specified function.\n *\n * @since 1.0.0\n * @category sequencing\n */\nexports.findLast = findLast;\nconst flatMap = /*#__PURE__*/Dual.dual(2, (self, f) => {\n  if (self.backing._tag === \"ISingleton\") {\n    return f(self.backing.a);\n  }\n  let r = _empty;\n  for (const k of self) {\n    r = concat(f(k))(r);\n  }\n  return r;\n});\n/**\n * Flattens a chunk of chunks into a single chunk by concatenating all chunks.\n *\n * @since 1.0.0\n * @category sequencing\n */\nexports.flatMap = flatMap;\nconst flatten = /*#__PURE__*/flatMap(Dual.identity);\n/**\n * Iterate over the chunk applying `f`.\n *\n * @since 1.0.0\n * @category elements\n */\nexports.flatten = flatten;\nconst forEach = /*#__PURE__*/Dual.dual(2, (self, f) => self.backing._tag === \"ISingleton\" ? f(self.backing.a) : toReadonlyArray(self).forEach(f));\n/**\n * Groups elements in chunks of up to `n` elements.\n *\n * @since 1.0.0\n * @category elements\n */\nexports.forEach = forEach;\nconst chunksOf = /*#__PURE__*/Dual.dual(2, (self, n) => {\n  const gr = [];\n  let current = [];\n  toReadonlyArray(self).forEach(a => {\n    current.push(a);\n    if (current.length >= n) {\n      gr.push(unsafeFromArray(current));\n      current = [];\n    }\n  });\n  if (current.length > 0) {\n    gr.push(unsafeFromArray(current));\n  }\n  return unsafeFromArray(gr);\n});\n/**\n * Returns the first element of this chunk if it exists.\n *\n * @since 1.0.0\n * @category elements\n */\nexports.chunksOf = chunksOf;\nconst head = /*#__PURE__*/get(0);\n/**\n * Creates a Chunk of unique values that are included in all given Chunks.\n *\n * The order and references of result values are determined by the Chunk.\n *\n * @since 1.0.0\n * @category elements\n */\nexports.head = head;\nconst intersection = /*#__PURE__*/Dual.dual(2, (self, that) => unsafeFromArray(RA.intersection(Equal.equivalence())(toReadonlyArray(that))(toReadonlyArray(self))));\n/**\n * Determines if the chunk is empty.\n *\n * @since 1.0.0\n * @category elements\n */\nexports.intersection = intersection;\nconst isEmpty = self => self.length === 0;\n/**\n * Determines if the chunk is not empty.\n *\n * @since 1.0.0\n * @category elements\n */\nexports.isEmpty = isEmpty;\nconst isNonEmpty = self => self.length > 0;\n/**\n * Folds over the elements in this chunk from the left.\n *\n * @since 1.0.0\n * @category folding\n */\nexports.isNonEmpty = isNonEmpty;\nconst reduce = /*#__PURE__*/Dual.dual(3, (self, b, f) => RA.reduce(b, f)(toReadonlyArray(self)));\n/**\n * Folds over the elements in this chunk from the left.\n *\n * @since 1.0.0\n * @category folding\n */\nexports.reduce = reduce;\nconst reduceWithIndex = /*#__PURE__*/Dual.dual(3, (self, b, f) => RA.reduce(b, f)(toReadonlyArray(self)));\n/**\n * Folds over the elements in this chunk from the right.\n *\n * @since 1.0.0\n * @category folding\n */\nexports.reduceWithIndex = reduceWithIndex;\nconst reduceRight = /*#__PURE__*/Dual.dual(3, (self, b, f) => RA.reduceRight(b, (b, a) => f(b, a))(toReadonlyArray(self)));\n/**\n * Folds over the elements in this chunk from the right.\n *\n * @since 1.0.0\n * @category folding\n */\nexports.reduceRight = reduceRight;\nconst reduceRightWithIndex = /*#__PURE__*/Dual.dual(3, (self, b, f) => RA.reduceRight(b, f)(toReadonlyArray(self)));\n/**\n * Joins the elements together with \"sep\" in the middle.\n *\n * @since 1.0.0\n * @category folding\n */\nexports.reduceRightWithIndex = reduceRightWithIndex;\nconst join = /*#__PURE__*/Dual.dual(2, (self, sep) => reduce(self, \"\", (s, a) => s.length > 0 ? `${s}${sep}${a}` : a));\n/**\n * Returns the last element of this chunk if it exists.\n *\n * @since 1.0.0\n * @category elements\n */\nexports.join = join;\nconst last = self => get(self, self.length - 1);\n/**\n * Builds a `NonEmptyChunk` from an non-empty collection of elements.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.last = last;\nconst make = (...as) => unsafeFromArray(as);\n/**\n * Builds a `NonEmptyChunk` from a single element.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.make = make;\nconst of = a => new ChunkImpl({\n  _tag: \"ISingleton\",\n  a\n});\n/**\n * Return a Chunk of length n with element i initialized with f(i).\n *\n * **Note**. `n` is normalized to an integer >= 1.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.of = of;\nconst makeBy = /*#__PURE__*/Dual.dual(2, (n, f) => make(...RA.makeBy(n, f)));\n/**\n * Returns an effect whose success is mapped by the specified f function.\n *\n * @since 1.0.0\n * @category mapping\n */\nexports.makeBy = makeBy;\nconst map = /*#__PURE__*/Dual.dual(2, (self, f) => self.backing._tag === \"ISingleton\" ? of(f(self.backing.a)) : unsafeFromArray(RA.map(f)(toReadonlyArray(self))));\n/**\n * Returns an effect whose success is mapped by the specified f function.\n *\n * @since 1.0.0\n * @category mapping\n */\nexports.map = map;\nconst mapWithIndex = /*#__PURE__*/Dual.dual(2, (self, f) => self.backing._tag === \"ISingleton\" ? of(f(self.backing.a, 0)) : unsafeFromArray(RA.map(f)(toReadonlyArray(self))));\n/**\n * Statefully maps over the chunk, producing new elements of type `B`.\n *\n * @since 1.0.0\n * @category folding\n */\nexports.mapWithIndex = mapWithIndex;\nconst mapAccum = /*#__PURE__*/Dual.dual(3, (self, s, f) => {\n  let s1 = s;\n  const res = [];\n  for (const a of toReadonlyArray(self)) {\n    const r = f(s1, a);\n    s1 = r[0];\n    res.push(r[1]);\n  }\n  return [s1, unsafeFromArray(res)];\n});\n/**\n * Separate elements based on a predicate that also exposes the index of the element.\n *\n * @category filtering\n * @since 1.0.0\n */\nexports.mapAccum = mapAccum;\nconst partitionWithIndex = /*#__PURE__*/Dual.dual(2, (self, f) => (([l, r]) => [unsafeFromArray(l), unsafeFromArray(r)])(RA.partition(f)(toReadonlyArray(self))));\n/**\n * Separate elements based on a predicate.\n *\n * @category filtering\n * @since 1.0.0\n */\nexports.partitionWithIndex = partitionWithIndex;\nconst partition = /*#__PURE__*/Dual.dual(2, (self, predicate) => (([l, r]) => [unsafeFromArray(l), unsafeFromArray(r)])(RA.partition(predicate)(toReadonlyArray(self))));\n/**\n * Partitions the elements of this chunk into two chunks using f.\n *\n * @category filtering\n * @since 1.0.0\n */\nexports.partition = partition;\nconst partitionMap = /*#__PURE__*/Dual.dual(2, (self, f) => (([l, r]) => [unsafeFromArray(l), unsafeFromArray(r)])(RA.partitionMap(f)(toReadonlyArray(self))));\n/**\n * Partitions the elements of this chunk into two chunks.\n *\n * @category filtering\n * @since 1.0.0\n */\nexports.partitionMap = partitionMap;\nconst separate = self => (([l, r]) => [unsafeFromArray(l), unsafeFromArray(r)])(RA.separate(toReadonlyArray(self)));\n/**\n * Create a non empty `Chunk` containing a range of integers, including both endpoints.\n *\n * @category constructors\n * @since 1.0.0\n */\nexports.separate = separate;\nconst range = (start, end) => start <= end ? makeBy(end - start + 1, i => start + i) : of(start);\n/**\n * Reverse a Chunk, creating a new Chunk.\n *\n * @since 1.0.0\n * @category elements\n */\nexports.range = range;\nconst reverse = self => unsafeFromArray(RA.reverse(toReadonlyArray(self)));\n/**\n * Retireves the size of the chunk\n *\n * @since 1.0.0\n * @category elements\n */\nexports.reverse = reverse;\nconst size = self => self.length;\n/**\n * Sort the elements of a Chunk in increasing order, creating a new Chunk.\n *\n * @since 1.0.0\n * @category elements\n */\nexports.size = size;\nconst sort = /*#__PURE__*/Dual.dual(2, (self, O) => unsafeFromArray(RA.sort(O)(toReadonlyArray(self))));\n/**\n *  Returns two splits of this chunk at the specified index.\n *\n * @since 1.0.0\n * @category elements\n */\nexports.sort = sort;\nconst splitAt = /*#__PURE__*/Dual.dual(2, (self, n) => [take(n)(self), drop(n)(self)]);\n/**\n * Splits this chunk into `n` equally sized chunks.\n *\n * @since 1.0.0\n * @category elements\n */\nexports.splitAt = splitAt;\nconst split = /*#__PURE__*/Dual.dual(2, (self, n) => {\n  const length = self.length;\n  const k = Math.floor(n);\n  const quotient = Math.floor(length / k);\n  const remainder = length % k;\n  const chunks = [];\n  let i = 0;\n  let chunk = [];\n  toReadonlyArray(self).forEach(a => {\n    chunk.push(a);\n    if (i <= remainder && chunk.length > quotient || i > remainder && chunk.length >= quotient) {\n      chunks.push(unsafeFromArray(chunk));\n      chunk = [];\n    }\n    i++;\n  });\n  if (chunk.length > 0) {\n    chunks.push(unsafeFromArray(chunk));\n  }\n  return unsafeFromArray(chunks);\n});\n/**\n * Splits this chunk on the first element that matches this predicate.\n *\n * @since 1.0.0\n * @category elements\n */\nexports.split = split;\nconst splitWhere = /*#__PURE__*/Dual.dual(2, (self, f) => {\n  let i = 0;\n  for (const a of toReadonlyArray(self)) {\n    if (f(a)) {\n      break;\n    } else {\n      i++;\n    }\n  }\n  return splitAt(i)(self);\n});\n/**\n * Returns every elements after the first.\n *\n * @since 1.0.0\n * @category elements\n */\nexports.splitWhere = splitWhere;\nconst tail = self => self.length > 0 ? O.some(drop(1)(self)) : O.none();\n/**\n * Takes the last `n` elements.\n *\n * @since 1.0.0\n * @category elements\n */\nexports.tail = tail;\nconst takeRight = /*#__PURE__*/Dual.dual(2, (self, n) => drop(self, self.length - n));\n/**\n * Takes all elements so long as the predicate returns true.\n *\n * @since 1.0.0\n * @category elements\n */\nexports.takeRight = takeRight;\nconst takeWhile = /*#__PURE__*/Dual.dual(2, (self, f) => {\n  const res = [];\n  for (const a of toReadonlyArray(self)) {\n    if (f(a)) {\n      res.push(a);\n    } else {\n      break;\n    }\n  }\n  return unsafeFromArray(res);\n});\n/**\n * Constructs a `Chunk` by repeatedly applying the function `f` as long as it * returns `Some`.\n *\n * @since 1.0.0\n * @category elements\n */\nexports.takeWhile = takeWhile;\nconst unfold = (s, f) => {\n  const builder = [];\n  let cont = true;\n  let s1 = s;\n  while (cont) {\n    const x = f(s1);\n    if (O.isSome(x)) {\n      s1 = x.value[1];\n      builder.push(x.value[0]);\n    } else {\n      cont = false;\n    }\n  }\n  return unsafeFromArray(builder);\n};\n/**\n * Creates a Chunks of unique values, in order, from all given Chunks.\n *\n * @since 1.0.0\n * @category elements\n */\nexports.unfold = unfold;\nconst union = /*#__PURE__*/Dual.dual(2, (self, that) => unsafeFromArray(RA.union(Equal.equivalence())(toReadonlyArray(that))(toReadonlyArray(self))));\n/**\n * Remove duplicates from an array, keeping the first occurrence of an element.\n *\n * @since 1.0.0\n * @category elements\n */\nexports.union = union;\nconst dedupe = self => unsafeFromArray(RA.uniq(Equal.equivalence())(toReadonlyArray(self)));\n/**\n * Returns the first element of this chunk.\n *\n * @since 1.0.0\n * @category unsafe\n */\nexports.dedupe = dedupe;\nconst unsafeHead = self => unsafeGet(0)(self);\n/**\n * Returns the last element of this chunk.\n *\n * @since 1.0.0\n * @category unsafe\n */\nexports.unsafeHead = unsafeHead;\nconst unsafeLast = self => unsafeGet(self.length - 1)(self);\n/**\n * Takes an array of pairs and return two corresponding arrays.\n *\n * Note: The function is reverse of `zip`.\n *\n * @since 1.0.0\n * @category elements\n */\nexports.unsafeLast = unsafeLast;\nconst unzip = as => {\n  const fa = [];\n  const fb = [];\n  toReadonlyArray(as).forEach(([a, b]) => {\n    fa.push(a);\n    fb.push(b);\n  });\n  return [unsafeFromArray(fa), unsafeFromArray(fb)];\n};\n/**\n * Zips this chunk pointwise with the specified chunk.\n *\n * @since 1.0.0\n * @category elements\n */\nexports.unzip = unzip;\nconst zip = /*#__PURE__*/Dual.dual(2, (self, that) => zipWith(self, that, (a, b) => [a, b]));\n/**\n * Zips this chunk pointwise with the specified chunk using the specified combiner.\n *\n * @since 1.0.0\n * @category elements\n */\nexports.zip = zip;\nconst zipWith = /*#__PURE__*/Dual.dual(3, (self, that, f) => {\n  const selfA = toReadonlyArray(self);\n  const thatA = toReadonlyArray(that);\n  return unsafeFromArray(RA.zipWith(thatA, f)(selfA));\n});\n/**\n * Zips this chunk pointwise with the specified chunk to produce a new chunk with\n * pairs of elements from each chunk, filling in missing values from the\n * shorter chunk with `None`. The returned chunk will have the length of the\n * longer chunk.\n *\n * @since 1.0.0\n * @category elements\n */\nexports.zipWith = zipWith;\nconst zipAll = /*#__PURE__*/Dual.dual(2, (self, that) => zipAllWith(self, that, (a, b) => [O.some(a), O.some(b)], a => [O.some(a), O.none()], b => [O.none(), O.some(b)]));\n/**\n * Zips with chunk with the specified chunk to produce a new chunk with\n * pairs of elements from each chunk combined using the specified function\n * `both`. If one chunk is shorter than the other uses the specified\n * function `left` or `right` to map the element that does exist to the\n * result type.\n *\n * @since 1.0.0\n * @category elements\n */\nexports.zipAll = zipAll;\nconst zipAllWith = /*#__PURE__*/Dual.dual(5, (self, that, f, left, right) => {\n  const length = Math.max(self.length, that.length);\n  if (length === 0) {\n    return _empty;\n  }\n  const leftarr = toReadonlyArray(self);\n  const rightArr = toReadonlyArray(that);\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  const leftLength = leftarr.length;\n  const rightLength = rightArr.length;\n  const builder = new Array(length);\n  while (i < length) {\n    if (j < leftLength && k < rightLength) {\n      builder[i] = f(leftarr[j], rightArr[k]);\n      i++;\n      j++;\n      k++;\n    } else if (j < leftLength) {\n      builder[i] = left(leftarr[j]);\n      i++;\n      j++;\n    } else if (k < rightLength) {\n      builder[i] = right(rightArr[k]);\n      i++;\n      k++;\n    }\n  }\n  return unsafeFromArray(builder);\n});\n/**\n * Zips this chunk crosswise with the specified chunk using the specified combiner.\n *\n * @since 1.0.0\n * @category elements\n */\nexports.zipAllWith = zipAllWith;\nconst crossWith = /*#__PURE__*/Dual.dual(3, (self, that, f) => flatMap(self, a => map(b => f(a, b))(that)));\n/**\n * Zips this chunk crosswise with the specified chunk.\n *\n * @since 1.0.0\n * @category elements\n */\nexports.crossWith = crossWith;\nconst cross = /*#__PURE__*/Dual.dual(2, (self, that) => crossWith(self, that, (a, b) => [a, b]));\n/**\n * Zips this chunk with the index of every element, starting from the initial\n * index value.\n *\n * @category elements\n * @since 1.0.0\n */\nexports.cross = cross;\nconst zipWithIndex = self => zipWithIndexOffset(0)(self);\n/**\n * Zips this chunk with the index of every element, starting from the initial\n * index value.\n *\n * @category elements\n * @since 1.0.0\n */\nexports.zipWithIndex = zipWithIndex;\nconst zipWithIndexOffset = /*#__PURE__*/Dual.dual(2, (self, offset) => {\n  const iterator = self[Symbol.iterator]();\n  let next;\n  let i = offset;\n  const builder = [];\n  while (!(next = iterator.next()).done) {\n    builder.push([next.value, i]);\n    i = i + 1;\n  }\n  return unsafeFromArray(builder);\n});\n/**\n * Delete the element at the specified index, creating a new `Chunk`,\n * or returning the input if the index is out of bounds.\n *\n * @category mutations\n * @since 1.0.0\n */\nexports.zipWithIndexOffset = zipWithIndexOffset;\nconst remove = /*#__PURE__*/Dual.dual(2, (self, i) => unsafeFromArray(RA.remove(i)(toReadonlyArray(self))));\n/**\n * Change the element at the specified index, creating a new `Chunk`,\n * or returning the input if the index is out of bounds.\n *\n * @category mutations\n * @since 1.0.0\n */\nexports.remove = remove;\nconst replace = /*#__PURE__*/Dual.dual(3, (self, i, b) => modify(self, i, () => b));\n/**\n * @category mutations\n * @since 1.0.0\n */\nexports.replace = replace;\nconst replaceOption = /*#__PURE__*/Dual.dual(3, (self, i, b) => modifyOption(self, i, () => b));\n/**\n * Apply a function to the element at the specified index, creating a new `Chunk`,\n * or returning the input if the index is out of bounds.\n *\n * @category mutations\n * @since 1.0.0\n */\nexports.replaceOption = replaceOption;\nconst modify = /*#__PURE__*/Dual.dual(3, (self, i, f) => O.getOrElse(() => self)(modifyOption(self, i, f)));\n/**\n * @category mutations\n * @since 1.0.0\n */\nexports.modify = modify;\nconst modifyOption = /*#__PURE__*/Dual.dual(3, (self, i, f) => O.map(unsafeFromArray)(RA.modifyOption(i, f)(toReadonlyArray(self))));\n/**\n * Returns the first element of this non empty chunk.\n *\n * @since 1.0.0\n * @category elements\n */\nexports.modifyOption = modifyOption;\nconst headNonEmpty = unsafeHead;\n/**\n * Returns every elements after the first.\n *\n * @since 1.0.0\n * @category elements\n */\nexports.headNonEmpty = headNonEmpty;\nconst tailNonEmpty = self => drop(self, 1);\nexports.tailNonEmpty = tailNonEmpty;\n//# sourceMappingURL=Chunk.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.unsafeGet = exports.pick = exports.merge = exports.make = exports.isTag = exports.isContext = exports.getOption = exports.get = exports.empty = exports.add = exports.Tag = void 0;\nvar C = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/internal/Context\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\nconst TagTypeId = C.TagTypeId;\n/**\n * Creates a new `Tag` instance with an optional key parameter.\n *\n * Specifying the `key` will make the `Tag` global, meaning two tags with the same\n * key will map to the same instance.\n *\n * Note: this is useful for cases where live reload can happen and it is\n * desireable to preserve the instance across reloads.\n *\n * @param key - An optional key that makes the `Tag` global.\n *\n * @example\n * import * as Context from \"@effect/data/Context\"\n *\n * assert.strictEqual(Context.Tag() === Context.Tag(), false)\n * assert.strictEqual(Context.Tag(\"PORT\") === Context.Tag(\"PORT\"), true)\n *\n * @since 1.0.0\n * @category constructors\n */\nconst Tag = key => new C.TagImpl(key);\nexports.Tag = Tag;\nconst TypeId = C.ContextTypeId;\n/**\n * Checks if the provided argument is a `Context`.\n *\n * @param input - The value to be checked if it is a `Context`.\n *\n * @example\n * import * as Context from \"@effect/data/Context\"\n *\n * assert.strictEqual(Context.isContext(Context.empty()), true)\n *\n * @since 1.0.0\n * @category guards\n */\nconst isContext = C.isContext;\n/**\n * Checks if the provided argument is a `Tag`.\n *\n * @param input - The value to be checked if it is a `Tag`.\n *\n * @example\n * import * as Context from \"@effect/data/Context\"\n *\n * assert.strictEqual(Context.isTag(Context.Tag()), true)\n *\n * @since 1.0.0\n * @category guards\n */\nexports.isContext = isContext;\nconst isTag = C.isTag;\n/**\n * Returns an empty `Context`.\n *\n * @example\n * import * as Context from \"@effect/data/Context\"\n *\n * assert.strictEqual(Context.isContext(Context.empty()), true)\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.isTag = isTag;\nconst empty = C.empty;\n/**\n * Creates a new `Context` with a single service associated to the tag.\n *\n * @example\n * import * as Context from \"@effect/data/Context\"\n *\n * const Port = Context.Tag<{ PORT: number }>()\n *\n * const Services = Context.make(Port, { PORT: 8080 })\n *\n * assert.deepStrictEqual(Context.get(Services, Port), { PORT: 8080 })\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.empty = empty;\nconst make = C.make;\n/**\n * Adds a service to a given `Context`.\n *\n * @example\n * import * as Context from \"@effect/data/Context\"\n * import { pipe } from \"@effect/data/Function\"\n *\n * const Port = Context.Tag<{ PORT: number }>()\n * const Timeout = Context.Tag<{ TIMEOUT: number }>()\n *\n * const someContext = Context.make(Port, { PORT: 8080 })\n *\n * const Services = pipe(\n *   someContext,\n *   Context.add(Timeout, { TIMEOUT: 5000 })\n * )\n *\n * assert.deepStrictEqual(Context.get(Services, Port), { PORT: 8080 })\n * assert.deepStrictEqual(Context.get(Services, Timeout), { TIMEOUT: 5000 })\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.make = make;\nconst add = C.add;\n/**\n * Get a service from the context that corresponds to the given tag.\n *\n * @param self - The `Context` to search for the service.\n * @param tag - The `Tag` of the service to retrieve.\n *\n * @example\n * import * as Context from \"@effect/data/Context\"\n * import { pipe } from \"@effect/data/Function\"\n *\n * const Port = Context.Tag<{ PORT: number }>()\n * const Timeout = Context.Tag<{ TIMEOUT: number }>()\n *\n * const Services = pipe(\n *   Context.make(Port, { PORT: 8080 }),\n *   Context.add(Timeout, { TIMEOUT: 5000 })\n * )\n *\n * assert.deepStrictEqual(Context.get(Services, Timeout), { TIMEOUT: 5000 })\n *\n * @since 1.0.0\n * @category getters\n */\nexports.add = add;\nconst get = C.get;\n/**\n * Get a service from the context that corresponds to the given tag.\n * This function is unsafe because if the tag is not present in the context, a runtime error will be thrown.\n *\n * For a safer version see {@link getOption}.\n *\n * @param self - The `Context` to search for the service.\n * @param tag - The `Tag` of the service to retrieve.\n *\n * @example\n * import * as Context from \"@effect/data/Context\"\n *\n * const Port = Context.Tag<{ PORT: number }>()\n * const Timeout = Context.Tag<{ TIMEOUT: number }>()\n *\n * const Services = Context.make(Port, { PORT: 8080 })\n *\n * assert.deepStrictEqual(Context.unsafeGet(Services, Port), { PORT: 8080 })\n * assert.throws(() => Context.unsafeGet(Services, Timeout))\n *\n * @since 1.0.0\n * @category unsafe\n */\nexports.get = get;\nconst unsafeGet = C.unsafeGet;\n/**\n * Get the value associated with the specified tag from the context wrapped in an `Option` object. If the tag is not\n * found, the `Option` object will be `None`.\n *\n * @param self - The `Context` to search for the service.\n * @param tag - The `Tag` of the service to retrieve.\n *\n * @example\n * import * as Context from \"@effect/data/Context\"\n * import * as O from \"@effect/data/Option\"\n *\n * const Port = Context.Tag<{ PORT: number }>()\n * const Timeout = Context.Tag<{ TIMEOUT: number }>()\n *\n * const Services = Context.make(Port, { PORT: 8080 })\n *\n * assert.deepStrictEqual(Context.getOption(Services, Port), O.some({ PORT: 8080 }))\n * assert.deepStrictEqual(Context.getOption(Services, Timeout), O.none())\n *\n * @since 1.0.0\n * @category getters\n */\nexports.unsafeGet = unsafeGet;\nconst getOption = C.getOption;\n/**\n * Merges two `Context`s, returning a new `Context` containing the services of both.\n *\n * @param self - The first `Context` to merge.\n * @param that - The second `Context` to merge.\n *\n * @example\n * import * as Context from \"@effect/data/Context\"\n *\n * const Port = Context.Tag<{ PORT: number }>()\n * const Timeout = Context.Tag<{ TIMEOUT: number }>()\n *\n * const firstContext = Context.make(Port, { PORT: 8080 })\n * const secondContext = Context.make(Timeout, { TIMEOUT: 5000 })\n *\n * const Services = Context.merge(firstContext, secondContext)\n *\n * assert.deepStrictEqual(Context.get(Services, Port), { PORT: 8080 })\n * assert.deepStrictEqual(Context.get(Services, Timeout), { TIMEOUT: 5000 })\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.getOption = getOption;\nconst merge = C.merge;\n/**\n * Returns a new `Context` that contains only the specified services.\n *\n * @param self - The `Context` to prune services from.\n * @param tags - The list of `Tag`s to be included in the new `Context`.\n *\n * @example\n * import * as Context from \"@effect/data/Context\"\n * import { pipe } from \"@effect/data/Function\"\n * import * as O from \"@effect/data/Option\"\n *\n * const Port = Context.Tag<{ PORT: number }>()\n * const Timeout = Context.Tag<{ TIMEOUT: number }>()\n *\n * const someContext = pipe(\n *   Context.make(Port, { PORT: 8080 }),\n *   Context.add(Timeout, { TIMEOUT: 5000 })\n * )\n *\n * const Services = pipe(someContext, Context.pick(Port))\n *\n * assert.deepStrictEqual(Context.getOption(Services, Port), O.some({ PORT: 8080 }))\n * assert.deepStrictEqual(Context.getOption(Services, Timeout), O.none())\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.merge = merge;\nconst pick = C.pick;\nexports.pick = pick;\n//# sourceMappingURL=Context.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.unsafeStruct = exports.unsafeArray = exports.tuple = exports.tagged = exports.struct = exports.case = exports.array = exports.TaggedClass = exports.Class = void 0;\nvar Equal = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Equal\"));\nvar Hash = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Hash\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/**\n * @since 1.0.0\n */\n\nconst protoArr = /*#__PURE__*/(() => {\n  const proto = {\n    [Hash.symbol]() {\n      return Hash.array(this);\n    },\n    [Equal.symbol](that) {\n      if (Array.isArray(that) && this.length === that.length) {\n        return this.every((v, i) => Equal.equals(v, that[i]));\n      } else {\n        return false;\n      }\n    }\n  };\n  return Object.setPrototypeOf(proto, Array.prototype);\n})();\nconst protoStruct = /*#__PURE__*/(() => {\n  const proto = {\n    [Hash.symbol]() {\n      return Hash.structure(this);\n    },\n    [Equal.symbol](that) {\n      const selfKeys = Object.keys(this);\n      const thatKeys = Object.keys(that);\n      if (selfKeys.length !== thatKeys.length) {\n        return false;\n      }\n      for (const key of selfKeys) {\n        if (!(key in that && Equal.equals(this[key], that[key]))) {\n          return false;\n        }\n      }\n      return true;\n    }\n  };\n  return Object.setPrototypeOf(proto, Object.prototype);\n})();\n/**\n * @category constructors\n * @since 1.0.0\n */\nconst struct = as => unsafeStruct(Object.assign({}, as));\n/**\n * @category constructors\n * @since 1.0.0\n */\nexports.struct = struct;\nconst unsafeStruct = as => Object.setPrototypeOf(as, protoStruct);\n/**\n * @category constructors\n * @since 1.0.0\n */\nexports.unsafeStruct = unsafeStruct;\nconst tuple = (...as) => unsafeArray(as);\n/**\n * @category constructors\n * @since 1.0.0\n */\nexports.tuple = tuple;\nconst array = as => unsafeArray(as.slice(0));\n/**\n * @category constructors\n * @since 1.0.0\n */\nexports.array = array;\nconst unsafeArray = as => Object.setPrototypeOf(as, protoArr);\nexports.unsafeArray = unsafeArray;\nconst _case = () => args => args === undefined ? struct({}) : struct(args);\nexports.case = _case;\n/**\n * Provides a tagged constructor for the specified `Case`.\n *\n * @since 1.0.0\n * @category constructors\n */\nconst tagged = tag =>\n// @ts-expect-error\nargs => args === undefined ? struct({\n  _tag: tag\n}) : struct({\n  ...args,\n  _tag: tag\n});\n/**\n * Provides a Tagged constructor for a Case Class.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.tagged = tagged;\nconst TaggedClass = tag => {\n  class Base extends Class {\n    constructor() {\n      super(...arguments);\n      this._tag = tag;\n    }\n  }\n  return Base;\n};\n/**\n * Provides a constructor for a Case Class.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.TaggedClass = TaggedClass;\nconst Class = /*#__PURE__*/(() => {\n  class Base {\n    constructor(args) {\n      if (args) {\n        Object.assign(this, args);\n      }\n    }\n    [Hash.symbol]() {\n      return Hash.structure(this);\n    }\n    [Equal.symbol](that) {\n      const selfKeys = Object.keys(this);\n      const thatKeys = Object.keys(that);\n      if (selfKeys.length !== thatKeys.length) {\n        return false;\n      }\n      for (const key of selfKeys) {\n        if (!(key in that && Equal.equals(this[key], that[key]))) {\n          return false;\n        }\n      }\n      return true;\n    }\n  }\n  return Base;\n})();\nexports.Class = Class;\n//# sourceMappingURL=Data.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.zip = exports.updateWith = exports.update = exports.transform = exports.patch = exports.orElseResult = exports.make = exports.hashSet = exports.hashMap = exports.environment = exports.empty = exports.diff = exports.combine = exports.chunk = void 0;\nvar Dual = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Function\"));\nvar D = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/internal/Differ\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\nconst TypeId = D.DifferTypeId;\n/**\n * An empty patch that describes no changes.\n *\n * @since 1.0.0\n * @category patch\n */\nconst empty = self => self.empty;\n/**\n * An empty patch that describes no changes.\n *\n * @since 1.0.0\n * @category patch\n */\nexports.empty = empty;\nconst diff = /*#__PURE__*/Dual.dual(3, (self, oldValue, newValue) => self.diff(oldValue, newValue));\n/**\n * Combines two patches to produce a new patch that describes the updates of\n * the first patch and then the updates of the second patch. The combine\n * operation should be associative. In addition, if the combine operation is\n * commutative then joining multiple fibers concurrently will result in\n * deterministic `FiberRef` values.\n *\n * @since 1.0.0\n * @category patch\n */\nexports.diff = diff;\nconst combine = /*#__PURE__*/Dual.dual(3, (self, first, second) => self.combine(first, second));\n/**\n * Applies a patch to an old value to produce a new value that is equal to the\n * old value with the updates described by the patch.\n *\n * @since 1.0.0\n * @category patch\n */\nexports.combine = combine;\nconst patch = /*#__PURE__*/Dual.dual(3, (self, patch, oldValue) => self.patch(patch, oldValue));\n/**\n * Constructs a new `Differ`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.patch = patch;\nconst make = D.make;\n/**\n * Constructs a differ that knows how to diff `Env` values.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.make = make;\nconst environment = D.environment;\n/**\n * Constructs a differ that knows how to diff a `Chunk` of values given a\n * differ that knows how to diff the values.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.environment = environment;\nconst chunk = D.chunk;\n/**\n * Constructs a differ that knows how to diff a `HashMap` of keys and values given\n * a differ that knows how to diff the values.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.chunk = chunk;\nconst hashMap = D.hashMap;\n/**\n * Constructs a differ that knows how to diff a `HashSet` of values.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.hashMap = hashMap;\nconst hashSet = D.hashSet;\n/**\n * Combines this differ and the specified differ to produce a differ that\n * knows how to diff the sum of their values.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.hashSet = hashSet;\nconst orElseResult = D.orElseResult;\n/**\n * Transforms the type of values that this differ knows how to differ using\n * the specified functions that map the new and old value types to each other.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.orElseResult = orElseResult;\nconst transform = D.transform;\n/**\n * Constructs a differ that just diffs two values by returning a function that\n * sets the value to the new value. This differ does not support combining\n * multiple updates to the value compositionally and should only be used when\n * there is no compositional way to update them.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.transform = transform;\nconst update = D.update;\n/**\n * A variant of `update` that allows specifying the function that will be used\n * to combine old values with new values.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.update = update;\nconst updateWith = D.updateWith;\n/**\n * Combines this differ and the specified differ to produce a new differ that\n * knows how to diff the product of their values.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.updateWith = updateWith;\nconst zip = D.zip;\nexports.zip = zip;\n//# sourceMappingURL=Differ.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.patch = exports.empty = exports.diff = exports.combine = void 0;\nvar CP = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/internal/Differ/ChunkPatch\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/**\n * @since 1.0.0\n */\n\nconst TypeId = CP.ChunkPatchTypeId;\n/**\n * Constructs an empty chunk patch.\n *\n * @since 1.0.0\n * @category constructors\n */\nconst empty = CP.empty;\n/**\n * Constructs a chunk patch from a new and old chunk of values and a differ\n * for the values.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.empty = empty;\nconst diff = CP.diff;\n/**\n * Combines two chunk patches to produce a new chunk patch that describes\n * applying their changes sequentially.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.diff = diff;\nconst combine = CP.combine;\n/**\n * Applies a chunk patch to a chunk of values to produce a new chunk of\n * values which represents the original chunk of values updated with the\n * changes described by this patch.\n *\n * @since 1.0.0\n * @category destructors\n */\nexports.combine = combine;\nconst patch = CP.patch;\nexports.patch = patch;\n//# sourceMappingURL=ChunkPatch.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.patch = exports.empty = exports.diff = exports.combine = void 0;\nvar CP = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/internal/Differ/ContextPatch\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/**\n * @since 1.0.0\n */\n\nconst TypeId = CP.ContextPatchTypeId;\n/**\n * An empty patch which returns the environment unchanged.\n *\n * @since 1.0.0\n * @category constructors\n */\nconst empty = CP.empty;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexports.empty = empty;\nconst diff = CP.diff;\n/**\n * Combines two patches to produce a new patch that describes applying the\n * updates from this patch and then the updates from the specified patch.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.diff = diff;\nconst combine = CP.combine;\n/**\n * Applies a `Patch` to the specified `Context` to produce a new patched\n * `Context`.\n *\n * @since 1.0.0\n * @category destructors\n */\nexports.combine = combine;\nconst patch = CP.patch;\nexports.patch = patch;\n//# sourceMappingURL=ContextPatch.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.patch = exports.empty = exports.diff = exports.combine = void 0;\nvar HMP = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/internal/Differ/HashMapPatch\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/**\n * @since 1.0.0\n */\n\nconst TypeId = HMP.HashMapPatchTypeId;\n/**\n * Constructs an empty map patch.\n *\n * @since 1.0.0\n * @category constructors\n */\nconst empty = HMP.empty;\n/**\n * Constructs a map patch from a new and old map of keys and values and a\n * differ for the values.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.empty = empty;\nconst diff = HMP.diff;\n/**\n * Combines two map patches to produce a new map patch that describes\n * applying their changes sequentially.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.diff = diff;\nconst combine = HMP.combine;\n/**\n * Applies a map patch to a map of keys and values to produce a new map of\n * keys and values values which represents the original map of keys and\n * values updated with the changes described by this patch.\n *\n * @since 1.0.0\n * @category destructors\n */\nexports.combine = combine;\nconst patch = HMP.patch;\nexports.patch = patch;\n//# sourceMappingURL=HashMapPatch.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.patch = exports.empty = exports.diff = exports.combine = void 0;\nvar HSP = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/internal/Differ/HashSetPatch\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/**\n * @since 1.0.0\n */\n\nconst TypeId = HSP.HashSetPatchTypeId;\n/**\n * Constructs an empty set patch.\n *\n * @since 1.0.0\n * @category constructors\n */\nconst empty = HSP.empty;\n/**\n * Constructs a set patch from a new set of values.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.empty = empty;\nconst diff = HSP.diff;\n/**\n * Combines two set patches to produce a new set patch that describes\n * applying their changes sequentially.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.diff = diff;\nconst combine = HSP.combine;\n/**\n * Applies a set patch to a set of values to produce a new set of values\n * which represents the original set of values updated with the changes\n * described by this patch.\n *\n * @since 1.0.0\n * @category destructors\n */\nexports.combine = combine;\nconst patch = HSP.patch;\nexports.patch = patch;\n//# sourceMappingURL=HashSetPatch.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.patch = exports.empty = exports.diff = exports.combine = void 0;\nvar OP = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/internal/Differ/OrPatch\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/**\n * @since 1.0.0\n */\n\nconst TypeId = OP.OrPatchTypeId;\n/**\n * Constructs an empty `OrPatch`.\n *\n * @since 1.0.0\n * @category constructors\n */\nconst empty = OP.empty;\n/**\n * Constructs an `OrPatch` from a new and old value and a differ for the\n * values.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.empty = empty;\nconst diff = OP.diff;\n/**\n * Combines two or patches to produce a new or patch that describes applying\n * their changes sequentially.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.diff = diff;\nconst combine = OP.combine;\n/**\n * Applies an `OrPatch` to a value to produce a new value which represents\n * the original value updated with the changes described by this patch.\n *\n * @since 1.0.0\n * @category destructors\n */\nexports.combine = combine;\nconst patch = OP.patch;\nexports.patch = patch;\n//# sourceMappingURL=OrPatch.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.zero = exports.weeks = exports.times = exports.sumAll = exports.sum = exports.subtract = exports.seconds = exports.minutes = exports.min = exports.millis = exports.max = exports.lessThanOrEqualTo = exports.lessThan = exports.isDuration = exports.infinity = exports.hours = exports.greaterThanOrEqualTo = exports.greaterThan = exports.equals = exports.days = exports.clamp = exports.between = exports.SemigroupSum = exports.SemigroupMin = exports.SemigroupMax = exports.Order = exports.MonoidSum = exports.MonoidMin = exports.MonoidMax = exports.Equivalence = exports.Bounded = void 0;\nvar Equal = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Equal\"));\nvar Dual = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Function\"));\nvar Hash = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Hash\"));\nvar monoid = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/typeclass/Monoid\"));\nvar order = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/typeclass/Order\"));\nvar semigroup = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/typeclass/Semigroup\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/**\n * @since 1.0.0\n */\n\nconst TypeId = /*#__PURE__*/Symbol.for(\"@effect/data/Duration\");\n/** @internal */\nclass DurationImpl {\n  constructor(millis) {\n    this.millis = millis;\n    this._id = TypeId;\n  }\n  [Hash.symbol]() {\n    return Hash.hash(this.millis);\n  }\n  [Equal.symbol](that) {\n    return isDuration(that) && this.millis === that.millis;\n  }\n}\n/**\n * @since 1.0.0\n * @category guards\n */\nconst isDuration = u => typeof u === \"object\" && u != null && \"_id\" in u && u[\"_id\"] === TypeId;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexports.isDuration = isDuration;\nconst zero = /*#__PURE__*/new DurationImpl(0);\n/**\n * @since 1.0.0\n * @category constructors\n */\nexports.zero = zero;\nconst infinity = /*#__PURE__*/new DurationImpl(Infinity);\n/**\n * @since 1.0.0\n * @category constructors\n */\nexports.infinity = infinity;\nconst millis = millis => new DurationImpl(millis);\n/**\n * @since 1.0.0\n * @category constructors\n */\nexports.millis = millis;\nconst seconds = seconds => new DurationImpl(seconds * 1000);\n/**\n * @since 1.0.0\n * @category constructors\n */\nexports.seconds = seconds;\nconst minutes = minutes => new DurationImpl(minutes * 60000);\n/**\n * @since 1.0.0\n * @category constructors\n */\nexports.minutes = minutes;\nconst hours = hours => new DurationImpl(hours * 3600000);\n/**\n * @since 1.0.0\n * @category constructors\n */\nexports.hours = hours;\nconst days = days => new DurationImpl(days * 86400000);\n/**\n * @since 1.0.0\n * @category constructors\n */\nexports.days = days;\nconst weeks = weeks => new DurationImpl(weeks * 604800000);\n/**\n * @category instances\n * @since 1.0.0\n */\nexports.weeks = weeks;\nconst Order = {\n  compare: (self, that) => self.millis < that.millis ? -1 : self.millis > that.millis ? 1 : 0\n};\n/**\n * @category instances\n * @since 1.0.0\n */\nexports.Order = Order;\nconst Bounded = {\n  compare: Order.compare,\n  maxBound: infinity,\n  minBound: zero\n};\n/**\n * Checks if a `Duration` is between a `minimum` and `maximum` value.\n *\n * @category predicates\n * @since 1.0.0\n */\nexports.Bounded = Bounded;\nconst between = /*#__PURE__*/order.between(Order);\n/**\n * @category instances\n * @since 1.0.0\n */\nexports.between = between;\nconst Equivalence = (self, that) => self.millis === that.millis;\n/**\n * @category utils\n * @since 1.0.0\n */\nexports.Equivalence = Equivalence;\nconst min = /*#__PURE__*/order.min(Order);\n/**\n * @category utils\n * @since 1.0.0\n */\nexports.min = min;\nconst max = /*#__PURE__*/order.max(Order);\n/**\n * @category utils\n * @since 1.0.0\n */\nexports.max = max;\nconst clamp = /*#__PURE__*/order.clamp(Order);\n/**\n * @since 1.0.0\n * @category math\n */\nexports.clamp = clamp;\nconst times = /*#__PURE__*/Dual.dual(2, (self, times) => new DurationImpl(self.millis * times));\n/**\n * @since 1.0.0\n * @category math\n */\nexports.times = times;\nconst sum = /*#__PURE__*/Dual.dual(2, (self, that) => new DurationImpl(self.millis + that.millis));\n/**\n * @category instances\n * @since 1.0.0\n */\nexports.sum = sum;\nconst SemigroupSum = /*#__PURE__*/semigroup.make(sum);\n/**\n * @category instances\n * @since 1.0.0\n */\nexports.SemigroupSum = SemigroupSum;\nconst MonoidSum = /*#__PURE__*/monoid.fromSemigroup(SemigroupSum, zero);\n/**\n * @category instances\n * @since 1.0.0\n */\nexports.MonoidSum = MonoidSum;\nconst SemigroupMax = /*#__PURE__*/semigroup.make(max);\n/**\n * @category instances\n * @since 1.0.0\n */\nexports.SemigroupMax = SemigroupMax;\nconst MonoidMax = /*#__PURE__*/monoid.fromSemigroup(SemigroupMax, zero);\n/**\n * @category instances\n * @since 1.0.0\n */\nexports.MonoidMax = MonoidMax;\nconst SemigroupMin = /*#__PURE__*/semigroup.make(min);\n/**\n * @category instances\n * @since 1.0.0\n */\nexports.SemigroupMin = SemigroupMin;\nconst MonoidMin = /*#__PURE__*/monoid.fromSemigroup(SemigroupMin, infinity);\n/**\n * @category math\n * @since 1.0.15\n */\nexports.MonoidMin = MonoidMin;\nconst sumAll = MonoidSum.combineAll;\n/**\n * @since 1.0.0\n * @category math\n */\nexports.sumAll = sumAll;\nconst subtract = /*#__PURE__*/Dual.dual(2, (self, that) => new DurationImpl(self.millis - that.millis));\n/**\n * @since 1.0.0\n * @category predicates\n */\nexports.subtract = subtract;\nconst lessThan = /*#__PURE__*/Dual.dual(2, (self, that) => self.millis < that.millis);\n/**\n * @since 1.0.0\n * @category predicates\n */\nexports.lessThan = lessThan;\nconst lessThanOrEqualTo = /*#__PURE__*/Dual.dual(2, (self, that) => self.millis <= that.millis);\n/**\n * @since 1.0.0\n * @category predicates\n */\nexports.lessThanOrEqualTo = lessThanOrEqualTo;\nconst greaterThan = /*#__PURE__*/Dual.dual(2, (self, that) => self.millis > that.millis);\n/**\n * @since 1.0.0\n * @category predicates\n */\nexports.greaterThan = greaterThan;\nconst greaterThanOrEqualTo = /*#__PURE__*/Dual.dual(2, (self, that) => self.millis >= that.millis);\n/**\n * @since 1.0.0\n * @category predicates\n */\nexports.greaterThanOrEqualTo = greaterThanOrEqualTo;\nconst equals = /*#__PURE__*/Dual.dual(2, (self, that) => self.millis === that.millis);\nexports.equals = equals;\n//# sourceMappingURL=Duration.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.zipWith = exports.unit = exports.tupled = exports.tuple = exports.traverseTap = exports.traverse = exports.toRefinement = exports.toOption = exports.toArray = exports.tapError = exports.tap = exports.sum = exports.subtract = exports.struct = exports.sequence = exports.rights = exports.right = exports.reverse = exports.orElseFail = exports.orElseEither = exports.orElse = exports.multiply = exports.merge = exports.match = exports.mapLeft = exports.map = exports.liftThrowable = exports.liftPredicate = exports.liftOption = exports.liftNullable = exports.lift2 = exports.let = exports.lefts = exports.left = exports.isRight = exports.isLeft = exports.isEither = exports.inspectRight = exports.inspectLeft = exports.getRight = exports.getOrUndefined = exports.getOrThrowWith = exports.getOrThrow = exports.getOrNull = exports.getOrElse = exports.getOptionalSemigroup = exports.getLeft = exports.getFirstRightSemigroup = exports.getFirstLeftSemigroup = exports.getFirstLeftMonoid = exports.getEquivalence = exports.gen = exports.fromOption = exports.fromNullable = exports.fromIterable = exports.flatten = exports.flatMapOption = exports.flatMapNullable = exports.flatMap = exports.flap = exports.firstRightOf = exports.filterMap = exports.filter = exports.exists = exports.divide = exports.contains = exports.composeK = exports.compact = exports.bindTo = exports.bind = exports.bimap = exports.asUnit = exports.as = exports.appendElement = exports.ap = exports.andThenDiscard = exports.andThenBind = exports.andThen = exports.all = exports.Traversable = exports.SemiProduct = exports.SemiCoproduct = exports.SemiApplicative = exports.SemiAlternative = exports.Product = exports.Pointed = exports.Monad = exports.Invariant = exports.Foldable = exports.FlatMap = exports.Do = exports.Covariant = exports.Chainable = exports.Bicovariant = exports.Applicative = void 0;\nvar Equal = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Equal\"));\nvar _Function = /*#__PURE__*/require(\"@effect/data/Function\");\nvar Gen = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Gen\"));\nvar either = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/internal/Either\"));\nvar option = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/internal/Option\"));\nvar N = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Number\"));\nvar applicative = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/typeclass/Applicative\"));\nvar bicovariant = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/typeclass/Bicovariant\"));\nvar chainable = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/typeclass/Chainable\"));\nvar covariant = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/typeclass/Covariant\"));\nvar equivalence = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/typeclass/Equivalence\"));\nvar flatMap_ = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/typeclass/FlatMap\"));\nvar foldable = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/typeclass/Foldable\"));\nvar invariant = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/typeclass/Invariant\"));\nvar of_ = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/typeclass/Of\"));\nvar product_ = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/typeclass/Product\"));\nvar semiApplicative = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/typeclass/SemiApplicative\"));\nvar semiCoproduct = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/typeclass/SemiCoproduct\"));\nvar semigroup = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/typeclass/Semigroup\"));\nvar semiProduct = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/typeclass/SemiProduct\"));\nvar traversable = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/typeclass/Traversable\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/**\n * @since 1.0.0\n */\n\n/**\n * Constructs a new `Either` holding a `Right` value. This usually represents a successful value due to the right bias\n * of this structure.\n *\n * @category constructors\n * @since 1.0.0\n */\nconst right = either.right;\n/**\n * Constructs a new `Either` holding a `Left` value. This usually represents a failure, due to the right-bias of this\n * structure.\n *\n * @category constructors\n * @since 1.0.0\n */\nexports.right = right;\nconst left = either.left;\n/**\n * Tests if a value is a `Either`.\n *\n * @param input - The value to test.\n *\n * @example\n * import { isEither, left, right } from '@effect/data/Either'\n *\n * assert.deepStrictEqual(isEither(right(1)), true)\n * assert.deepStrictEqual(isEither(left(\"error\")), true)\n * assert.deepStrictEqual(isEither({ right: 1 }), false)\n *\n * @category guards\n * @since 1.0.0\n */\nexports.left = left;\nconst isEither = input => typeof input === \"object\" && input != null && \"_tag\" in input && (input[\"_tag\"] === \"Left\" || input[\"_tag\"] === \"Right\") && Equal.isEqual(input);\n/**\n * Determine if a `Either` is a `Left`.\n *\n * @param self - The `Either` to check.\n *\n * @example\n * import { isLeft, left, right } from '@effect/data/Either'\n *\n * assert.deepStrictEqual(isLeft(right(1)), false)\n * assert.deepStrictEqual(isLeft(left(\"error\")), true)\n *\n * @category guards\n * @since 1.0.0\n */\nexports.isEither = isEither;\nconst isLeft = either.isLeft;\n/**\n * Determine if a `Either` is a `Right`.\n *\n * @param self - The `Either` to check.\n *\n * @example\n * import { isRight, left, right } from '@effect/data/Either'\n *\n * assert.deepStrictEqual(isRight(right(1)), true)\n * assert.deepStrictEqual(isRight(left(\"error\")), false)\n *\n * @category guards\n * @since 1.0.0\n */\nexports.isLeft = isLeft;\nconst isRight = either.isRight;\n/**\n * Returns a `Refinement` from a `Either` returning function.\n * This function ensures that a `Refinement` definition is type-safe.\n *\n * @category conversions\n * @since 1.0.0\n */\nexports.isRight = isRight;\nconst toRefinement = f => a => isRight(f(a));\n/**\n * @category conversions\n * @since 1.0.0\n */\nexports.toRefinement = toRefinement;\nconst fromIterable = /*#__PURE__*/(0, _Function.dual)(2, (collection, onEmpty) => {\n  for (const a of collection) {\n    return right(a);\n  }\n  return left(onEmpty());\n});\n/**\n * Converts a `Either` to an `Option` discarding the error.\n *\n * @param self - The `Either` to convert to an `Option`.\n *\n * @example\n * import * as O from '@effect/data/Option'\n * import * as E from '@effect/data/Either'\n *\n * assert.deepStrictEqual(E.toOption(E.right(1)), O.some(1))\n * assert.deepStrictEqual(E.toOption(E.left('a')), O.none())\n *\n * @category conversions\n * @since 1.0.0\n */\nexports.fromIterable = fromIterable;\nconst toOption = either.getRight;\n/**\n * Converts a `Either` to an `Option` discarding the error.\n *\n * Alias of {@link toOption}.\n *\n * @example\n * import * as O from '@effect/data/Option'\n * import * as E from '@effect/data/Either'\n *\n * assert.deepStrictEqual(E.getRight(E.right('ok')), O.some('ok'))\n * assert.deepStrictEqual(E.getRight(E.left('err')), O.none())\n *\n * @category conversions\n * @since 1.0.0\n */\nexports.toOption = toOption;\nconst getRight = toOption;\n/**\n * Converts a `Either` to an `Option` discarding the value.\n *\n * @example\n * import * as O from '@effect/data/Option'\n * import * as E from '@effect/data/Either'\n *\n * assert.deepStrictEqual(E.getLeft(E.right('ok')), O.none())\n * assert.deepStrictEqual(E.getLeft(E.left('err')), O.some('err'))\n *\n * @category conversions\n * @since 1.0.0\n */\nexports.getRight = getRight;\nconst getLeft = either.getLeft;\n/**\n * @example\n * import * as E from '@effect/data/Either'\n * import * as O from '@effect/data/Option'\n *\n * assert.deepStrictEqual(E.fromOption(O.some(1), () => 'error'), E.right(1))\n * assert.deepStrictEqual(E.fromOption(O.none(), () => 'error'), E.left('error'))\n *\n * @category conversions\n * @since 1.0.0\n */\nexports.getLeft = getLeft;\nconst fromOption = either.fromOption;\n/**\n * @category equivalence\n * @since 1.0.0\n */\nexports.fromOption = fromOption;\nconst getEquivalence = (EE, EA) => equivalence.make((x, y) => x === y || (isLeft(x) ? isLeft(y) && EE(x.left, y.left) : isRight(y) && EA(x.right, y.right)));\n/**\n * @category mapping\n * @since 1.0.0\n */\nexports.getEquivalence = getEquivalence;\nconst bimap = /*#__PURE__*/(0, _Function.dual)(3, (self, f, g) => isLeft(self) ? left(f(self.left)) : right(g(self.right)));\n/**\n * @category instances\n * @since 1.0.0\n */\nexports.bimap = bimap;\nconst Bicovariant = {\n  bimap\n};\n/**\n * Maps the `Left` side of an `Either` value to a new `Either` value.\n *\n * @param self - The input `Either` value to map.\n * @param f - A transformation function to apply to the `Left` value of the input `Either`.\n *\n * @category error handling\n * @since 1.0.0\n */\nexports.Bicovariant = Bicovariant;\nconst mapLeft = /*#__PURE__*/bicovariant.mapLeft(Bicovariant);\n/**\n * Maps the `Right` side of an `Either` value to a new `Either` value.\n *\n * @param self - An `Either` to map\n * @param f - The function to map over the value of the `Either`\n *\n * @category mapping\n * @since 1.0.0\n */\nexports.mapLeft = mapLeft;\nconst map = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => isRight(self) ? right(f(self.right)) : self);\nexports.map = map;\nconst imap = /*#__PURE__*/covariant.imap(map);\n/**\n * @category instances\n * @since 1.0.0\n */\nconst Covariant = {\n  imap,\n  map\n};\n/**\n * @category instances\n * @since 1.0.0\n */\nexports.Covariant = Covariant;\nconst Invariant = {\n  imap\n};\n/**\n * @category mapping\n * @since 1.0.0\n */\nexports.Invariant = Invariant;\nconst flap = /*#__PURE__*/covariant.flap(Covariant);\n/**\n * Maps the `Right` value of this `Either` to the specified constant value.\n *\n * @category mapping\n * @since 1.0.0\n */\nexports.flap = flap;\nconst as = /*#__PURE__*/covariant.as(Covariant);\n/**\n * Maps the `Right` value of this `Either` to the `void` constant value.\n *\n * @category mapping\n * @since 1.0.0\n */\nexports.as = as;\nconst asUnit = /*#__PURE__*/covariant.asUnit(Covariant);\nexports.asUnit = asUnit;\nconst of = right;\nconst Of = {\n  of\n};\n/**\n * @since 1.0.0\n */\nconst unit = /*#__PURE__*/of_.unit(Of);\n/**\n * @category instances\n * @since 1.0.0\n */\nexports.unit = unit;\nconst Pointed = {\n  of,\n  imap,\n  map\n};\n/**\n * @category combining\n * @since 1.0.0\n */\nexports.Pointed = Pointed;\nconst flatMap = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => isLeft(self) ? self : f(self.right));\n/**\n * @category instances\n * @since 1.0.0\n */\nexports.flatMap = flatMap;\nconst FlatMap = {\n  flatMap\n};\n/**\n * @since 1.0.0\n */\nexports.FlatMap = FlatMap;\nconst flatten = /*#__PURE__*/flatMap_.flatten(FlatMap);\n/**\n * @since 1.0.0\n */\nexports.flatten = flatten;\nconst andThen = /*#__PURE__*/flatMap_.andThen(FlatMap);\n/**\n * @since 1.0.0\n */\nexports.andThen = andThen;\nconst composeK = /*#__PURE__*/flatMap_.composeK(FlatMap);\n/**\n * @category instances\n * @since 1.0.0\n */\nexports.composeK = composeK;\nconst Chainable = {\n  imap,\n  map,\n  flatMap\n};\n/**\n * Sequences the specified effect after this effect, but ignores the value\n * produced by the effect.\n *\n * @category combining\n * @since 1.0.0\n */\nexports.Chainable = Chainable;\nconst andThenDiscard = /*#__PURE__*/chainable.andThenDiscard(Chainable);\n/**\n * @category instances\n * @since 1.0.0\n */\nexports.andThenDiscard = andThenDiscard;\nconst Monad = {\n  imap,\n  of,\n  map,\n  flatMap\n};\nexports.Monad = Monad;\nconst product = (self, that) => isRight(self) ? isRight(that) ? right([self.right, that.right]) : that : self;\nconst productMany = (self, collection) => {\n  if (isLeft(self)) {\n    return self;\n  }\n  const out = [self.right];\n  for (const e of collection) {\n    if (isLeft(e)) {\n      return e;\n    }\n    out.push(e.right);\n  }\n  return right(out);\n};\n/**\n * @category instances\n * @since 1.0.0\n */\nconst SemiProduct = {\n  imap,\n  product,\n  productMany\n};\n/**\n * Similar to `Promise.all` but operates on `Either`s.\n *\n * ```\n * Iterable<Either<E, A>> -> Either<E, A[]>\n * ```\n *\n * Flattens a collection of `Either`s into a single `Either` that contains a list of all the `Right` values.\n * If there is a `Left` value in the collection, it returns the first `Left` found as the result.\n *\n * @param collection - An iterable collection of `Either`s to flatten.\n *\n * @example\n * import * as E from \"@effect/data/Either\"\n *\n * assert.deepStrictEqual(E.all([E.right(1), E.right(2), E.right(3)]), E.right([1, 2, 3]))\n * assert.deepStrictEqual(E.all([E.right(1), E.left(\"error\"), E.right(3)]), E.left(\"error\"))\n *\n * @category combining\n * @since 1.0.0\n */\nexports.SemiProduct = SemiProduct;\nconst all = collection => {\n  const out = [];\n  for (const e of collection) {\n    if (isLeft(e)) {\n      return e;\n    }\n    out.push(e.right);\n  }\n  return right(out);\n};\n/**\n * @category instances\n * @since 1.0.0\n */\nexports.all = all;\nconst Product = {\n  of,\n  imap,\n  product,\n  productMany,\n  productAll: all\n};\n/**\n * Similar to `Promise.all` but operates on `Either`s.\n *\n * ```\n * [Either<E1, A>, Either<E1, B>, ...] -> Either<E1 \\| E2 \\| ..., [A, B, ...]>\n * ```\n *\n * @since 1.0.0\n */\nexports.Product = Product;\nconst tuple = /*#__PURE__*/product_.tuple(Product);\n/**\n * @since 1.0.0\n */\nexports.tuple = tuple;\nconst struct = /*#__PURE__*/product_.struct(Product);\n/**\n * @category instances\n * @since 1.0.0\n */\nexports.struct = struct;\nconst SemiApplicative = {\n  imap,\n  map,\n  product,\n  productMany\n};\n/**\n * Lifts a binary function into `Either`.\n *\n * @param f - The function to lift.\n *\n * @category lifting\n * @since 1.0.0\n */\nexports.SemiApplicative = SemiApplicative;\nconst lift2 = /*#__PURE__*/semiApplicative.lift2(SemiApplicative);\n/**\n * @category combining\n * @since 1.0.0\n */\nexports.lift2 = lift2;\nconst zipWith = /*#__PURE__*/semiApplicative.zipWith(SemiApplicative);\n/**\n * @since 1.0.0\n */\nexports.zipWith = zipWith;\nconst ap = /*#__PURE__*/semiApplicative.ap(SemiApplicative);\n/**\n * @category instances\n * @since 1.0.0\n */\nexports.ap = ap;\nconst Applicative = {\n  imap,\n  of,\n  map,\n  product,\n  productMany,\n  productAll: all\n};\n/**\n * `Semigroup` returning the left-most `Left` value. If both operands are `Right`s then the inner values\n * are combined using the provided `Semigroup`.\n *\n * ```\n * | self       | that       | combine(self, that)     |\n * | ---------- | ---------- | ----------------------- |\n * | left(e1)   | left(e2)   | left(e1)                |\n * | left(e1)   | right(a2)  | left(e1)                |\n * | right(a1)  | left(e2)   | left(e2)                |\n * | right(a1)  | right(a2)  | right(combine(a1, a2))  |\n * ```\n *\n * @category combining\n * @since 1.0.0\n */\nexports.Applicative = Applicative;\nconst getFirstLeftSemigroup = /*#__PURE__*/semiApplicative.getSemigroup(SemiApplicative);\n/**\n * `Monoid` returning the left-most `Left` value. If both operands are `Right`s then the inner values\n * are combined using the provided `Monoid`.\n *\n * - `combine` is provided by {@link getFirstLeftSemigroup}.\n * - `empty` is `right(M.empty)`\n *\n * @category combining\n * @since 1.0.0\n */\nexports.getFirstLeftSemigroup = getFirstLeftSemigroup;\nconst getFirstLeftMonoid = /*#__PURE__*/applicative.getMonoid(Applicative);\nexports.getFirstLeftMonoid = getFirstLeftMonoid;\nconst coproduct = (self, that) => isRight(self) ? self : that;\nconst coproductMany = (self, collection) => {\n  let out = self;\n  if (isRight(out)) {\n    return out;\n  }\n  for (out of collection) {\n    if (isRight(out)) {\n      return out;\n    }\n  }\n  return out;\n};\n/**\n * @category instances\n * @since 1.0.0\n */\nconst SemiCoproduct = {\n  imap,\n  coproduct,\n  coproductMany\n};\n/**\n * @category error handling\n * @since 1.0.0\n */\nexports.SemiCoproduct = SemiCoproduct;\nconst firstRightOf = /*#__PURE__*/(0, _Function.dual)(2, coproductMany);\n/**\n * Semigroup returning the left-most `Right` value.\n *\n * ```\n * | self       | that       | combine(self, that) |\n * | ---------- | ---------- | ------------------- |\n * | left(e1)   | left(e2)   | left(e2)            |\n * | left(e1)   | right(a2)  | right(a2)           |\n * | right(a1)  | left(e2)   | right(a1)           |\n * | right(a1)  | right(a2)  | right(a1)           |\n * ```\n *\n * @category combining\n * @since 1.0.0\n */\nexports.firstRightOf = firstRightOf;\nconst getFirstRightSemigroup = /*#__PURE__*/semiCoproduct.getSemigroup(SemiCoproduct);\n/**\n * Returns the wrapped value if it's a `Right` or a default value if is a `Left`.\n *\n * @example\n * import * as E from '@effect/data/Either'\n * import { pipe } from '@effect/data/Function'\n *\n * assert.deepStrictEqual(\n *   E.getOrElse(E.right(1), () => 0),\n *   1\n * )\n * assert.deepStrictEqual(\n *   E.getOrElse(E.left('error'), () => 0),\n *   0\n * )\n *\n * @category getters\n * @since 1.0.0\n */\nexports.getFirstRightSemigroup = getFirstRightSemigroup;\nconst getOrElse = /*#__PURE__*/(0, _Function.dual)(2, (self, onLeft) => isLeft(self) ? onLeft(self.left) : self.right);\n/**\n * Executes this effect and returns its value, if it succeeds, but otherwise\n * executes the specified effect.\n *\n * @category error handling\n * @since 1.0.0\n */\nexports.getOrElse = getOrElse;\nconst orElse = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => isLeft(self) ? that(self.left) : self);\n/**\n * Returns an effect that will produce the value of this effect, unless it\n * fails, in which case, it will produce the value of the specified effect.\n *\n * @category error handling\n * @since 1.0.0\n */\nexports.orElse = orElse;\nconst orElseEither = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => isLeft(self) ? map(that(self.left), right) : map(self, left));\n/**\n * Executes this effect and returns its value, if it succeeds, but otherwise\n * fails with the specified error.\n *\n * @category error handling\n * @since 1.0.0\n */\nexports.orElseEither = orElseEither;\nconst orElseFail = /*#__PURE__*/(0, _Function.dual)(2, (self, onLeft) => orElse(self, () => left(onLeft())));\n/**\n * @category instances\n * @since 1.0.0\n */\nexports.orElseFail = orElseFail;\nconst SemiAlternative = {\n  map,\n  imap,\n  coproduct,\n  coproductMany: firstRightOf\n};\n/**\n * @category instances\n * @since 1.0.0\n */\nexports.SemiAlternative = SemiAlternative;\nconst Foldable = {\n  reduce: /*#__PURE__*/(0, _Function.dual)(3, (self, b, f) => isLeft(self) ? b : f(b, self.right))\n};\n/**\n * Transforms an `Either` into an `Array`.\n * If the input is `Left`, an empty array is returned.\n * If the input is `Right`, the value is wrapped in an array.\n *\n * @param self - The `Either` to convert to an array.\n *\n * @example\n * import { right, left, toArray } from '@effect/data/Either'\n *\n * assert.deepStrictEqual(toArray(right(1)), [1])\n * assert.deepStrictEqual(toArray(left(\"error\")), [])\n *\n * @category conversions\n * @since 1.0.0\n */\nexports.Foldable = Foldable;\nconst toArray = /*#__PURE__*/foldable.toArray(Foldable);\n/**\n * Takes two functions and an `Either` value, if the value is a `Left` the inner value is applied to the first function,\n * if the value is a `Right` the inner value is applied to the second function.\n *\n * @example\n * import * as E from '@effect/data/Either'\n * import { pipe } from '@effect/data/Function'\n *\n * const onLeft  = (errors: ReadonlyArray<string>): string => `Errors: ${errors.join(', ')}`\n *\n * const onRight = (value: number): string => `Ok: ${value}`\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     E.right(1),\n *     E.match(onLeft , onRight)\n *   ),\n *   'Ok: 1'\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     E.left(['error 1', 'error 2']),\n *     E.match(onLeft , onRight)\n *   ),\n *   'Errors: error 1, error 2'\n * )\n *\n * @category pattern matching\n * @since 1.0.0\n */\nexports.toArray = toArray;\nconst match = /*#__PURE__*/(0, _Function.dual)(3, (self, onLeft, onRight) => isLeft(self) ? onLeft(self.left) : onRight(self.right));\n/**\n * Takes a lazy default and a nullable value, if the value is not nully, turn it into a `Right`, if the value is nully use\n * the provided default as a `Left`.\n *\n * @example\n * import * as E from '@effect/data/Either'\n *\n * const parse = E.fromNullable(() => 'nullable')\n *\n * assert.deepStrictEqual(parse(1), E.right(1))\n * assert.deepStrictEqual(parse(null), E.left('nullable'))\n *\n * @category interop\n * @since 1.0.0\n */\nexports.match = match;\nconst fromNullable = /*#__PURE__*/(0, _Function.dual)(2, (a, onNullable) => a == null ? left(onNullable(a)) : right(a));\n/**\n * @category interop\n * @since 1.0.0\n */\nexports.fromNullable = fromNullable;\nconst liftNullable = (f, onNullable) => (...a) => fromNullable(f(...a), () => onNullable(...a));\n/**\n * @category interop\n * @since 1.0.0\n */\nexports.liftNullable = liftNullable;\nconst merge = /*#__PURE__*/match(_Function.identity, _Function.identity);\n/**\n * @category combining\n * @since 1.0.0\n */\nexports.merge = merge;\nconst flatMapNullable = /*#__PURE__*/(0, _Function.dual)(3, (self, f, onNullable) => flatMap(self, liftNullable(f, onNullable)));\n/**\n * Extracts the value of an `Either` or throws if the `Either` is `Left`.\n *\n * If a default error is sufficient for your use case and you don't need to configure the thrown error, see {@link getOrThrow}.\n *\n * @param self - The `Either` to extract the value from.\n * @param onLeft - A function that will be called if the `Either` is `Left`. It returns the error to be thrown.\n *\n * @example\n * import * as E from \"@effect/data/Either\"\n *\n * assert.deepStrictEqual(\n *   E.getOrThrowWith(E.right(1), () => new Error('Unexpected Left')),\n *   1\n * )\n * assert.throws(() => E.getOrThrowWith(E.left(\"error\"), () => new Error('Unexpected Left')))\n *\n * @category interop\n * @since 1.0.0\n */\nexports.flatMapNullable = flatMapNullable;\nconst getOrThrowWith = /*#__PURE__*/(0, _Function.dual)(2, (self, onLeft) => {\n  if (isRight(self)) {\n    return self.right;\n  }\n  throw onLeft(self.left);\n});\n/**\n * Extracts the value of an `Either` or throws if the `Either` is `Left`.\n *\n * The thrown error is a default error. To configure the error thrown, see  {@link getOrThrowWith}.\n *\n * @param self - The `Either` to extract the value from.\n * @throws `Error(\"getOrThrow called on a Left\")`\n *\n * @example\n * import * as E from \"@effect/data/Either\"\n *\n * assert.deepStrictEqual(E.getOrThrow(E.right(1)), 1)\n * assert.throws(() => E.getOrThrow(E.left(\"error\")))\n *\n * @category interop\n * @since 1.0.0\n */\nexports.getOrThrowWith = getOrThrowWith;\nconst getOrThrow = /*#__PURE__*/getOrThrowWith(() => new Error(\"getOrThrow called on a Left\"));\n/**\n * Lifts a function that may throw to one returning a `Either`.\n *\n * @category interop\n * @since 1.0.0\n */\nexports.getOrThrow = getOrThrow;\nconst liftThrowable = (f, onThrow) => (...a) => {\n  try {\n    return right(f(...a));\n  } catch (e) {\n    return left(onThrow(e));\n  }\n};\n/**\n * @since 1.0.0\n */\nexports.liftThrowable = liftThrowable;\nconst reverse = self => isLeft(self) ? right(self.left) : left(self.right);\n/**\n * @category filtering\n * @since 1.0.0\n */\nexports.reverse = reverse;\nconst filter = /*#__PURE__*/(0, _Function.dual)(3, (self, predicate, onFalse) => isLeft(self) ? self : predicate(self.right) ? self : left(onFalse()));\n/**\n * @category filtering\n * @since 1.0.0\n */\nexports.filter = filter;\nconst filterMap = /*#__PURE__*/(0, _Function.dual)(3, (self, f, onNone) => flatMap(self, a => {\n  const ob = f(a);\n  return option.isNone(ob) ? left(onNone()) : right(ob.value);\n}));\n/**\n * @category filtering\n * @since 1.0.0\n */\nexports.filterMap = filterMap;\nconst compact = /*#__PURE__*/(0, _Function.dual)(2, (self, onNone) => filterMap(self, _Function.identity, onNone));\n/**\n * @category traversing\n * @since 1.0.0\n */\nexports.compact = compact;\nconst traverse = F => (0, _Function.dual)(2, (self, f) => isLeft(self) ? F.of(self) : F.map(f(self.right), right));\n/**\n * @category instances\n * @since 1.0.0\n */\nexports.traverse = traverse;\nconst Traversable = {\n  traverse\n};\n/**\n * @category traversing\n * @since 1.0.0\n */\nexports.Traversable = Traversable;\nconst sequence = /*#__PURE__*/traversable.sequence(Traversable);\n/**\n * @category traversing\n * @since 1.0.0\n */\nexports.sequence = sequence;\nconst traverseTap = /*#__PURE__*/traversable.traverseTap(Traversable);\n/**\n * Returns an effect that effectfully \"peeks\" at the success of this effect.\n *\n * @category combinators\n * @since 1.0.0\n */\nexports.traverseTap = traverseTap;\nconst tap = /*#__PURE__*/chainable.tap(Chainable);\n/**\n * @category debugging\n * @since 1.0.0\n */\nexports.tap = tap;\nconst inspectRight = /*#__PURE__*/(0, _Function.dual)(2, (self, onRight) => {\n  if (isRight(self)) {\n    onRight(self.right);\n  }\n  return self;\n});\n/**\n * @category debugging\n * @since 1.0.0\n */\nexports.inspectRight = inspectRight;\nconst inspectLeft = /*#__PURE__*/(0, _Function.dual)(2, (self, onLeft) => {\n  if (isLeft(self)) {\n    onLeft(self.left);\n  }\n  return self;\n});\n/**\n * Returns an effect that effectfully \"peeks\" at the failure of this effect.\n *\n * @category error handling\n * @since 1.0.0\n */\nexports.inspectLeft = inspectLeft;\nconst tapError = /*#__PURE__*/(0, _Function.dual)(2, (self, onLeft) => {\n  if (isRight(self)) {\n    return self;\n  }\n  const out = onLeft(self.left);\n  return isLeft(out) ? out : self;\n});\n/**\n * @category getters\n * @since 1.0.0\n */\nexports.tapError = tapError;\nconst getOrNull = /*#__PURE__*/getOrElse(_Function.constNull);\n/**\n * @category getters\n * @since 1.0.0\n */\nexports.getOrNull = getOrNull;\nconst getOrUndefined = /*#__PURE__*/getOrElse(_Function.constUndefined);\n/**\n * @example\n * import { liftPredicate, left, right } from '@effect/data/Either'\n * import { pipe } from '@effect/data/Function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     1,\n *     liftPredicate((n) => n > 0, () => 'error')\n *   ),\n *   right(1)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     -1,\n *     liftPredicate((n) => n > 0, () => 'error')\n *   ),\n *   left('error')\n * )\n *\n * @category lifting\n * @since 1.0.0\n */\nexports.getOrUndefined = getOrUndefined;\nconst liftPredicate = (predicate, onFalse) => b => predicate(b) ? right(b) : left(onFalse(b));\n/**\n * @category lifting\n * @since 1.0.0\n */\nexports.liftPredicate = liftPredicate;\nconst liftOption = (f, onNone) => (...a) => fromOption(() => onNone(...a))(f(...a));\n/**\n * @category combining\n * @since 1.0.0\n */\nexports.liftOption = liftOption;\nconst flatMapOption = /*#__PURE__*/(0, _Function.dual)(3, (self, f, onNone) => flatMap(self, liftOption(f, onNone)));\n/**\n * Returns a function that checks if an `Either` contains a given value using a provided `equivalence` function.\n *\n * @since 1.0.0\n */\nexports.flatMapOption = flatMapOption;\nconst contains = isEquivalent => (0, _Function.dual)(2, (self, a) => isLeft(self) ? false : isEquivalent(self.right, a));\n/**\n * Returns `false` if `Left` or returns the Either of the application of the given predicate to the `Right` value.\n *\n * @example\n * import * as E from '@effect/data/Either'\n *\n * const f = E.exists((n: number) => n > 2)\n *\n * assert.deepStrictEqual(f(E.left('a')), false)\n * assert.deepStrictEqual(f(E.right(1)), false)\n * assert.deepStrictEqual(f(E.right(3)), true)\n *\n * @since 1.0.0\n */\nexports.contains = contains;\nconst exists = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => isLeft(self) ? false : predicate(self.right));\n/**\n * Semigroup that models the combination of values that may be absent, elements that are `Left` are ignored\n * while elements that are `Right` are combined using the provided `Semigroup`.\n *\n * @category instances\n * @since 1.0.0\n */\nexports.exists = exists;\nconst getOptionalSemigroup = S => semigroup.make((x, y) => isLeft(y) ? x : isLeft(x) ? y : right(S.combine(x.right, y.right)));\n/**\n * @category math\n * @since 1.0.0\n */\nexports.getOptionalSemigroup = getOptionalSemigroup;\nconst sum = /*#__PURE__*/lift2(N.sum);\n/**\n * @category math\n * @since 1.0.0\n */\nexports.sum = sum;\nconst multiply = /*#__PURE__*/lift2(N.multiply);\n/**\n * @category math\n * @since 1.0.0\n */\nexports.multiply = multiply;\nconst subtract = /*#__PURE__*/lift2(N.subtract);\n/**\n * @category math\n * @since 1.0.0\n */\nexports.subtract = subtract;\nconst divide = /*#__PURE__*/lift2(N.divide);\n/**\n * Return all the `Right` elements from an `Interable` of `Either`s.\n *\n * @category getters\n * @since 1.0.0\n */\nexports.divide = divide;\nconst rights = self => {\n  const out = [];\n  for (const a of self) {\n    if (isRight(a)) {\n      out.push(a.right);\n    }\n  }\n  return out;\n};\n/**\n * Return all the `Left` elements from an `Interable` of `Either`s.\n *\n * @category getters\n * @since 1.0.0\n */\nexports.rights = rights;\nconst lefts = self => {\n  const out = [];\n  for (const a of self) {\n    if (isLeft(a)) {\n      out.push(a.left);\n    }\n  }\n  return out;\n};\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * @category do notation\n * @since 1.0.0\n */\nexports.lefts = lefts;\nconst tupled = /*#__PURE__*/invariant.tupled(Invariant);\n/**\n * Appends an element to the end of a tuple.\n *\n * @category do notation\n * @since 1.0.0\n */\nexports.tupled = tupled;\nconst appendElement = /*#__PURE__*/semiProduct.appendElement(SemiProduct);\n/**\n * @category do notation\n * @since 1.0.0\n */\nexports.appendElement = appendElement;\nconst bindTo = /*#__PURE__*/invariant.bindTo(Invariant);\nexports.bindTo = bindTo;\nconst let_ = /*#__PURE__*/covariant.let(Covariant);\nexports.let = let_;\n/**\n * @category do notation\n * @since 1.0.0\n */\nconst Do = /*#__PURE__*/of_.Do(Of);\n/**\n * @category do notation\n * @since 1.0.0\n */\nexports.Do = Do;\nconst bind = /*#__PURE__*/chainable.bind(Chainable);\n/**\n * Extends the `Either` value with the value of another `Either` type.\n *\n * If both `Either` instances are `Left`, then the result will be the first `Left`.\n *\n * @param self - The original `Either` value.\n * @param name - The name of the property that will be added to the original `Either` type.\n * @param that - The `Either` value that will be added to the original `Either` type.\n *\n * @example\n * import * as E from '@effect/data/Either'\n * import { pipe } from '@effect/data/Function'\n *\n * const result = pipe(\n *   E.Do,\n *   E.bind(\"a\", () => E.left(\"e1\")),\n *   E.andThenBind(\"b\", E.left(\"e2\"))\n * )\n *\n * assert.deepStrictEqual(result, E.left(\"e1\"))\n *\n * @category do notation\n * @since 1.0.0\n */\nexports.bind = bind;\nconst andThenBind = /*#__PURE__*/semiProduct.andThenBind(SemiProduct);\n/**\n * The `gen` API is a helper function that provides a generator interface for the `Either` monad instance.\n * It can be used to easily create complex `Either` computations in a readable and concise manner.\n *\n * @example\n * import * as E from \"@effect/data/Either\"\n *\n * assert.deepStrictEqual(\n *   E.gen(function*($) {\n *     const a = yield* $(E.right(1))\n *     const b = yield* $(E.right(2))\n *     return a + b\n *   }),\n *   E.right(3)\n * )\n *\n * @since 1.0.0\n * @category generators\n */\nexports.andThenBind = andThenBind;\nconst gen = /*#__PURE__*/Gen.singleShot(Monad)( /*#__PURE__*/Gen.adapter());\nexports.gen = gen;\n//# sourceMappingURL=Either.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.equals = equals;\nexports.symbol = exports.isEqual = exports.equivalence = void 0;\nvar Hash = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Hash\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/**\n * @since 1.0.0\n */\n\n/**\n * @since 1.0.0\n * @category symbols\n */\nconst symbol = /*#__PURE__*/Symbol.for(\"@effect/data/Equal\");\nexports.symbol = symbol;\nfunction equals() {\n  if (arguments.length === 1) {\n    return self => compareBoth(self, arguments[0]);\n  }\n  return compareBoth(arguments[0], arguments[1]);\n}\nfunction compareBoth(self, that) {\n  if (self === that) {\n    return true;\n  }\n  const selfType = typeof self;\n  if (selfType !== typeof that) {\n    return false;\n  }\n  if ((selfType === \"object\" || selfType === \"function\") && self !== null && that !== null) {\n    if (isEqual(self) && isEqual(that)) {\n      return Hash.hash(self) === Hash.hash(that) && self[symbol](that);\n    }\n  }\n  return false;\n}\n/**\n * @since 1.0.0\n * @category guards\n */\nconst isEqual = u => typeof u === \"object\" && u !== null && symbol in u;\n/**\n * @since 1.0.0\n * @category instances\n */\nexports.isEqual = isEqual;\nconst equivalence = () => (self, that) => Hash.hash(self) === Hash.hash(that) && equals(self, that);\nexports.equivalence = equivalence;\n//# sourceMappingURL=Equal.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.flip = exports.dual = exports.constant = exports.constVoid = exports.constUndefined = exports.constTrue = exports.constNull = exports.constFalse = exports.compose = exports.apply = exports.absurd = exports.SK = void 0;\nexports.flow = flow;\nexports.isFunction = exports.identity = exports.hole = void 0;\nexports.pipe = pipe;\nexports.untupled = exports.unsafeCoerce = exports.tupled = void 0;\n/**\n * Tests if a value is a `function`.\n *\n * @param input - The value to test.\n *\n * @example\n * import { isFunction } from '@effect/data/Predicate'\n *\n * assert.deepStrictEqual(isFunction(isFunction), true)\n * assert.deepStrictEqual(isFunction(\"function\"), false)\n *\n * @category guards\n * @since 1.0.0\n */\nconst isFunction = input => typeof input === \"function\";\n/**\n * Creates a function that can be used in a data-last (aka `pipe`able) or\n * data-first style.\n *\n * The first parameter to `dual` is either the arity of the uncurried function\n * or a predicate that determines if the function is being used in a data-first\n * or data-last style.\n *\n * Using the arity is the most common use case, but there are some cases where\n * you may want to use a predicate. For example, if you have a function that\n * takes an optional argument, you can use a predicate to determine if the\n * function is being used in a data-first or data-last style.\n *\n * @param arity - Either the arity of the uncurried function or a predicate\n *                which determines if the function is being used in a data-first\n *                or data-last style.\n * @param body - The definition of the uncurried function.\n *\n * @example\n * import { dual, pipe } from \"@effect/data/Function\"\n *\n * // Exampe using arity to determine data-first or data-last style\n * export const sum: {\n *   (that: number): (self: number) => number\n *   (self: number, that: number): number\n * } = dual(2, (self: number, that: number): number => self + that)\n *\n * assert.deepStrictEqual(sum(2, 3), 5)\n * assert.deepStrictEqual(pipe(2, sum(3)), 5)\n *\n * // Example using a predicate to determine data-first or data-last style\n * export const sum2: {\n *   (that: number): (self: number) => number\n *   (self: number, that: number): number\n * } = dual((args) => args.length === 1, (self: number, that: number): number => self + that)\n *\n * assert.deepStrictEqual(sum(2, 3), 5)\n * assert.deepStrictEqual(pipe(2, sum(3)), 5)\n *\n * @since 1.0.0\n */\nexports.isFunction = isFunction;\nconst dual = (arity, body) => {\n  const isDataFirst = typeof arity === \"number\" ? args => args.length >= arity : arity;\n  return function () {\n    if (isDataFirst(arguments)) {\n      // @ts-expect-error\n      return body.apply(this, arguments);\n    }\n    return self => body(self, ...arguments);\n  };\n};\n/**\n * Apply a function to a given value.\n *\n * @param a - The value that the function will be applied to.\n * @param self - The function to be applied to a value.\n *\n * @example\n * import { pipe, apply } from \"@effect/data/Function\"\n * import { length } from '@effect/data/String'\n *\n * assert.deepStrictEqual(pipe(length, apply(\"hello\")), 5)\n *\n * @since 1.0.0\n */\nexports.dual = dual;\nconst apply = a => self => self(a);\n/**\n * The identity function, i.e. A function that returns its input argument.\n *\n * @param a - The input argument.\n *\n * @example\n * import { identity } from \"@effect/data/Function\"\n *\n * assert.deepStrictEqual(identity(5), 5)\n *\n * @since 1.0.0\n */\nexports.apply = apply;\nconst identity = a => a;\n/**\n * Casts the result to the specified type.\n *\n * @param a - The value to be casted to the target type.\n *\n * @example\n * import { unsafeCoerce, identity } from \"@effect/data/Function\"\n *\n * assert.deepStrictEqual(unsafeCoerce, identity)\n *\n * @since 1.0.0\n */\nexports.identity = identity;\nconst unsafeCoerce = identity;\n/**\n * Creates a constant value that never changes.\n *\n * This is useful when you want to pass a value to a higher-order function (a function that takes another function as its argument)\n * and want that inner function to always use the same value, no matter how many times it is called.\n *\n * @param value - The constant value to be returned.\n *\n * @example\n * import { constant } from \"@effect/data/Function\"\n *\n * const constNull = constant(null)\n *\n * assert.deepStrictEqual(constNull(), null)\n * assert.deepStrictEqual(constNull(), null)\n *\n * @since 1.0.0\n */\nexports.unsafeCoerce = unsafeCoerce;\nconst constant = value => () => value;\n/**\n * A thunk that returns always `true`.\n *\n * @example\n * import { constTrue } from \"@effect/data/Function\"\n *\n * assert.deepStrictEqual(constTrue(), true)\n *\n * @since 1.0.0\n */\nexports.constant = constant;\nconst constTrue = /*#__PURE__*/constant(true);\n/**\n * A thunk that returns always `false`.\n *\n * @example\n * import { constFalse } from \"@effect/data/Function\"\n *\n * assert.deepStrictEqual(constFalse(), false)\n *\n * @since 1.0.0\n */\nexports.constTrue = constTrue;\nconst constFalse = /*#__PURE__*/constant(false);\n/**\n * A thunk that returns always `null`.\n *\n * @example\n * import { constNull } from \"@effect/data/Function\"\n *\n * assert.deepStrictEqual(constNull(), null)\n *\n * @since 1.0.0\n */\nexports.constFalse = constFalse;\nconst constNull = /*#__PURE__*/constant(null);\n/**\n * A thunk that returns always `undefined`.\n *\n * @example\n * import { constUndefined } from \"@effect/data/Function\"\n *\n * assert.deepStrictEqual(constUndefined(), undefined)\n *\n * @since 1.0.0\n */\nexports.constNull = constNull;\nconst constUndefined = /*#__PURE__*/constant(undefined);\n/**\n * A thunk that returns always `void`.\n *\n * @example\n * import { constVoid } from \"@effect/data/Function\"\n *\n * assert.deepStrictEqual(constVoid(), undefined)\n *\n * @since 1.0.0\n */\nexports.constUndefined = constUndefined;\nconst constVoid = constUndefined;\n/**\n * Reverses the order of arguments for a curried function.\n *\n * @param f - A curried function that takes multiple arguments.\n *\n * @example\n * import { flip } from \"@effect/data/Function\"\n *\n * const f = (a: number) => (b: string) => a - b.length\n *\n * assert.deepStrictEqual(flip(f)('aaa')(2), -1)\n *\n * @since 1.0.0\n */\nexports.constVoid = constVoid;\nconst flip = f => (...b) => (...a) => f(...a)(...b);\nexports.flip = flip;\nfunction flow(ab, bc, cd, de, ef, fg, gh, hi, ij) {\n  switch (arguments.length) {\n    case 1:\n      return ab;\n    case 2:\n      return function () {\n        return bc(ab.apply(this, arguments));\n      };\n    case 3:\n      return function () {\n        return cd(bc(ab.apply(this, arguments)));\n      };\n    case 4:\n      return function () {\n        return de(cd(bc(ab.apply(this, arguments))));\n      };\n    case 5:\n      return function () {\n        return ef(de(cd(bc(ab.apply(this, arguments)))));\n      };\n    case 6:\n      return function () {\n        return fg(ef(de(cd(bc(ab.apply(this, arguments))))));\n      };\n    case 7:\n      return function () {\n        return gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))));\n      };\n    case 8:\n      return function () {\n        return hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments))))))));\n      };\n    case 9:\n      return function () {\n        return ij(hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))))));\n      };\n  }\n  return;\n}\n/**\n * Composes two functions, `ab` and `bc` into a single function that takes in an argument `a` of type `A` and returns a result of type `C`.\n * The result is obtained by first applying the `ab` function to `a` and then applying the `bc` function to the result of `ab`.\n *\n * @param ab - A function that maps from `A` to `B`.\n * @param bc - A function that maps from `B` to `C`.\n *\n * @example\n * import { compose } from \"@effect/data/Function\"\n *\n * const increment = (n: number) => n + 1;\n * const square = (n: number) => n * n;\n *\n * assert.strictEqual(compose(increment, square)(2), 9);\n *\n * @since 1.0.0\n */\nconst compose = /*#__PURE__*/dual(2, (ab, bc) => flow(ab, bc));\n/**\n * The `absurd` function is a stub for cases where a value of type `never` is encountered in your code,\n * meaning that it should be impossible for this code to be executed.\n *\n * This function is particularly when it's necessary to specify that certain cases are impossible.\n *\n * @since 1.0.0\n */\nexports.compose = compose;\nconst absurd = _ => {\n  throw new Error(\"Called `absurd` function which should be uncallable\");\n};\n/**\n * Creates a tupled version of this function: instead of `n` arguments, it accepts a single tuple argument.\n *\n * @example\n * import { tupled } from \"@effect/data/Function\"\n *\n * const sumTupled = tupled((x: number, y: number): number => x + y)\n *\n * assert.deepStrictEqual(sumTupled([1, 2]), 3)\n *\n * @since 1.0.0\n */\nexports.absurd = absurd;\nconst tupled = f => a => f(...a);\n/**\n * Inverse function of `tupled`\n *\n * @example\n * import { untupled } from \"@effect/data/Function\"\n *\n * const getFirst = untupled(<A, B>(tuple: [A, B]): A => tuple[0])\n *\n * assert.deepStrictEqual(getFirst(1, 2), 1)\n *\n * @since 1.0.0\n */\nexports.tupled = tupled;\nconst untupled = f => (...a) => f(a);\nexports.untupled = untupled;\nfunction pipe(a, ab, bc, cd, de, ef, fg, gh, hi) {\n  switch (arguments.length) {\n    case 1:\n      return a;\n    case 2:\n      return ab(a);\n    case 3:\n      return bc(ab(a));\n    case 4:\n      return cd(bc(ab(a)));\n    case 5:\n      return de(cd(bc(ab(a))));\n    case 6:\n      return ef(de(cd(bc(ab(a)))));\n    case 7:\n      return fg(ef(de(cd(bc(ab(a))))));\n    case 8:\n      return gh(fg(ef(de(cd(bc(ab(a)))))));\n    case 9:\n      return hi(gh(fg(ef(de(cd(bc(ab(a))))))));\n    default:\n      {\n        let ret = arguments[0];\n        for (let i = 1; i < arguments.length; i++) {\n          ret = arguments[i](ret);\n        }\n        return ret;\n      }\n  }\n}\n/**\n * Type hole simulation.\n *\n * @since 1.0.0\n */\nconst hole = /*#__PURE__*/unsafeCoerce(absurd);\n/**\n * The SK combinator, also known as the \"S-K combinator\" or \"S-combinator\", is a fundamental combinator in the\n * lambda calculus and the SKI combinator calculus.\n *\n * This function is useful for discarding the first argument passed to it and returning the second argument.\n *\n * @param _ - The first argument to be discarded.\n * @param b - The second argument to be returned.\n *\n * @example\n * import { SK } from \"@effect/data/Function\";\n *\n * assert.deepStrictEqual(SK(0, \"hello\"), \"hello\")\n *\n * @since 1.0.0\n */\nexports.hole = hole;\nconst SK = (_, b) => b;\nexports.SK = SK;\n//# sourceMappingURL=Function.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.singleShot = exports.makeGenKind = exports.adapter = exports.SingleShotGen = exports.GenKindTypeId = exports.GenKindImpl = void 0;\nvar _Function = /*#__PURE__*/require(\"@effect/data/Function\");\nvar _a;\n/**\n * @since 1.0.0\n */\n\n/**\n * @category symbols\n * @since 1.0.0\n */\nconst GenKindTypeId = /*#__PURE__*/Symbol.for(\"@effect/data/Gen/GenKind\");\n/**\n * @category constructors\n * @since 1.0.0\n */\nexports.GenKindTypeId = GenKindTypeId;\nclass GenKindImpl {\n  constructor(\n  /**\n   * @since 1.0.0\n   */\n  value) {\n    this.value = value;\n    /**\n     * @since 1.0.0\n     */\n    this[_a] = GenKindTypeId;\n  }\n  /**\n   * @since 1.0.0\n   */\n  get _F() {\n    return _Function.identity;\n  }\n  /**\n   * @since 1.0.0\n   */\n  get _R() {\n    return _ => _;\n  }\n  /**\n   * @since 1.0.0\n   */\n  get _O() {\n    return _ => _;\n  }\n  /**\n   * @since 1.0.0\n   */\n  get _E() {\n    return _ => _;\n  }\n  /**\n   * @since 1.0.0\n   */\n  [(_a = GenKindTypeId, Symbol.iterator)]() {\n    return new SingleShotGen(this);\n  }\n}\n/**\n * @category constructors\n * @since 1.0.0\n */\nexports.GenKindImpl = GenKindImpl;\nclass SingleShotGen {\n  constructor(self) {\n    this.self = self;\n    this.called = false;\n  }\n  /**\n   * @since 1.0.0\n   */\n  next(a) {\n    return this.called ? {\n      value: a,\n      done: true\n    } : (this.called = true, {\n      value: this.self,\n      done: false\n    });\n  }\n  /**\n   * @since 1.0.0\n   */\n  return(a) {\n    return {\n      value: a,\n      done: true\n    };\n  }\n  /**\n   * @since 1.0.0\n   */\n  throw(e) {\n    throw e;\n  }\n  /**\n   * @since 1.0.0\n   */\n  [Symbol.iterator]() {\n    return new SingleShotGen(this.self);\n  }\n}\n/**\n * @category constructors\n * @since 1.0.0\n */\nexports.SingleShotGen = SingleShotGen;\nconst makeGenKind = kind => new GenKindImpl(kind);\n/**\n * @category adapters\n * @since 1.0.0\n */\nexports.makeGenKind = makeGenKind;\nconst adapter = () => kind => new GenKindImpl(kind);\nexports.adapter = adapter;\nfunction runGen(F, state, iterator) {\n  if (state.done) {\n    return F.of(state.value);\n  }\n  return F.flatMap(val => {\n    const next = iterator.next(val);\n    return runGen(F, next, iterator);\n  })(state.value.value);\n}\n/**\n * @category constructors\n * @since 1.0.0\n */\nconst singleShot = F => adapter => body => F.flatMap(() => {\n  const iterator = body(adapter);\n  const state = iterator.next();\n  // @ts-expect-error\n  return runGen(F, state, iterator);\n})(F.of(void 0));\nexports.singleShot = singleShot;\n//# sourceMappingURL=Gen.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.globalValue = void 0;\n/**\n * @since 1.0.0\n */\nconst globalStoreId = /*#__PURE__*/Symbol.for(\"@effect/data/Global/globalStoreId\");\nif (!(globalStoreId in globalThis)) {\n  globalThis[globalStoreId] = /*#__PURE__*/new Map();\n}\nconst globalStore = globalThis[globalStoreId];\n/**\n * @since 1.0.0\n */\nconst globalValue = (id, compute) => {\n  if (!globalStore.has(id)) {\n    globalStore.set(id, compute());\n  }\n  return globalStore.get(id);\n};\nexports.globalValue = globalValue;\n//# sourceMappingURL=Global.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.symbol = exports.structure = exports.string = exports.random = exports.optimize = exports.number = exports.isHash = exports.hash = exports.combine = exports.array = void 0;\nvar _Global = /*#__PURE__*/require(\"@effect/data/Global\");\nvar _Random = /*#__PURE__*/require(\"@effect/data/Random\");\n/**\n * @since 1.0.0\n */\n\n/** @internal */\nconst randomHashCache = /*#__PURE__*/(0, _Global.globalValue)( /*#__PURE__*/Symbol.for(\"@effect/data/Hash/randomHashCache\"), () => new WeakMap());\n/** @internal */\nconst pcgr = /*#__PURE__*/(0, _Global.globalValue)( /*#__PURE__*/Symbol.for(\"@effect/data/Hash/pcgr\"), () => new _Random.PCGRandom());\n/**\n * @since 1.0.0\n * @category symbols\n */\nconst symbol = /*#__PURE__*/Symbol.for(\"@effect/data/Hash\");\n/**\n * @since 1.0.0\n * @category hashing\n */\nexports.symbol = symbol;\nconst hash = self => {\n  switch (typeof self) {\n    case \"number\":\n      {\n        return number(self);\n      }\n    case \"bigint\":\n      {\n        return string(self.toString(10));\n      }\n    case \"boolean\":\n      {\n        return string(String(self));\n      }\n    case \"symbol\":\n      {\n        return string(String(self));\n      }\n    case \"string\":\n      {\n        return string(self);\n      }\n    case \"undefined\":\n      {\n        return string(\"undefined\");\n      }\n    case \"function\":\n    case \"object\":\n      {\n        if (self === null) {\n          return string(\"null\");\n        }\n        if (isHash(self)) {\n          return self[symbol]();\n        } else {\n          return random(self);\n        }\n      }\n    default:\n      {\n        throw new Error(\"Bug in Equal.hashGeneric\");\n      }\n  }\n};\n/**\n * @since 1.0.0\n * @category hashing\n */\nexports.hash = hash;\nconst random = self => {\n  if (!randomHashCache.has(self)) {\n    randomHashCache.set(self, number(pcgr.integer(Number.MAX_SAFE_INTEGER)));\n  }\n  return randomHashCache.get(self);\n};\n/**\n * @since 1.0.0\n * @category hashing\n */\nexports.random = random;\nconst combine = b => self => self * 53 ^ b;\n/**\n * @since 1.0.0\n * @category hashing\n */\nexports.combine = combine;\nconst optimize = n => n & 0xbfffffff | n >>> 1 & 0x40000000;\n/**\n * @since 1.0.0\n * @category guards\n */\nexports.optimize = optimize;\nconst isHash = u => typeof u === \"object\" && u !== null && symbol in u;\n/**\n * @since 1.0.0\n * @category hashing\n */\nexports.isHash = isHash;\nconst number = n => {\n  if (n !== n || n === Infinity) {\n    return 0;\n  }\n  let h = n | 0;\n  if (h !== n) {\n    h ^= n * 0xffffffff;\n  }\n  while (n > 0xffffffff) {\n    h ^= n /= 0xffffffff;\n  }\n  return optimize(n);\n};\n/**\n * @since 1.0.0\n * @category hashing\n */\nexports.number = number;\nconst string = str => {\n  let h = 5381,\n    i = str.length;\n  while (i) {\n    h = h * 33 ^ str.charCodeAt(--i);\n  }\n  return optimize(h);\n};\n/**\n * @since 1.0.0\n * @category hashing\n */\nexports.string = string;\nconst structure = o => {\n  const keys = Object.keys(o);\n  let h = 12289;\n  for (let i = 0; i < keys.length; i++) {\n    h ^= combine(hash(o[keys[i]]))(string(keys[i]));\n  }\n  return optimize(h);\n};\n/**\n * @since 1.0.0\n * @category hashing\n */\nexports.structure = structure;\nconst array = arr => {\n  let h = 6151;\n  for (let i = 0; i < arr.length; i++) {\n    h = combine(hash(arr[i]))(h);\n  }\n  return optimize(h);\n};\nexports.array = array;\n//# sourceMappingURL=Hash.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.values = exports.unsafeGet = exports.union = exports.size = exports.set = exports.removeMany = exports.remove = exports.reduceWithIndex = exports.reduce = exports.mutate = exports.modifyHash = exports.modifyAt = exports.modify = exports.mapWithIndex = exports.map = exports.make = exports.keys = exports.keySet = exports.isHashMap = exports.isEmpty = exports.hasHash = exports.has = exports.getHash = exports.get = exports.fromIterable = exports.forEachWithIndex = exports.forEach = exports.flatMapWithIndex = exports.flatMap = exports.filterWithIndex = exports.filterMapWithIndex = exports.filterMap = exports.filter = exports.endMutation = exports.empty = exports.compact = exports.beginMutation = void 0;\nvar HM = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/internal/HashMap\"));\nvar _keySet = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/internal/HashMap/keySet\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/**\n * @since 1.0.0\n */\n\nconst TypeId = HM.HashMapTypeId;\n/**\n * @since 1.0.0\n * @category refinements\n */\nconst isHashMap = HM.isHashMap;\n/**\n * Creates a new `HashMap`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.isHashMap = isHashMap;\nconst empty = HM.empty;\n/**\n * Constructs a new `HashMap` from an array of key/value pairs.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.empty = empty;\nconst make = HM.make;\n/**\n * Constructs a new `HashMap` from an iterable of key/value pairs.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.make = make;\nconst fromIterable = HM.fromIterable;\n/**\n * Checks if the `HashMap` contains any entries.\n *\n * @since 1.0.0\n * @category elements\n */\nexports.fromIterable = fromIterable;\nconst isEmpty = HM.isEmpty;\n/**\n * Safely lookup the value for the specified key in the `HashMap` using the\n * internal hashing function.\n *\n * @since 1.0.0\n * @category elements\n */\nexports.isEmpty = isEmpty;\nconst get = HM.get;\n/**\n * Lookup the value for the specified key in the `HashMap` using a custom hash.\n *\n * @since 1.0.0\n * @category elements\n */\nexports.get = get;\nconst getHash = HM.getHash;\n/**\n * Unsafely lookup the value for the specified key in the `HashMap` using the\n * internal hashing function.\n *\n * @since 1.0.0\n * @category unsafe\n */\nexports.getHash = getHash;\nconst unsafeGet = HM.unsafeGet;\n/**\n * Checks if the specified key has an entry in the `HashMap`.\n *\n * @since 1.0.0\n * @category elements\n */\nexports.unsafeGet = unsafeGet;\nconst has = HM.has;\n/**\n * Checks if the specified key has an entry in the `HashMap` using a custom\n * hash.\n *\n * @since 1.0.0\n * @category elements\n */\nexports.has = has;\nconst hasHash = HM.hasHash;\n/**\n * Sets the specified key to the specified value using the internal hashing\n * function.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.hasHash = hasHash;\nconst set = HM.set;\n/**\n * Returns an `IterableIterator` of the keys within the `HashMap`.\n *\n * @since 1.0.0\n * @category getters\n */\nexports.set = set;\nconst keys = HM.keys;\n/**\n * Returns a `HashSet` of keys within the `HashMap`.\n *\n * @since 1.0.0\n * @category getter\n */\nexports.keys = keys;\nconst keySet = _keySet.keySet;\n/**\n * Returns an `IterableIterator` of the values within the `HashMap`.\n *\n * @since 1.0.0\n * @category getters\n */\nexports.keySet = keySet;\nconst values = HM.values;\n/**\n * Returns the number of entries within the `HashMap`.\n *\n * @since 1.0.0\n * @category getters\n */\nexports.values = values;\nconst size = HM.size;\n/**\n * Marks the `HashMap` as mutable.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.size = size;\nconst beginMutation = HM.beginMutation;\n/**\n * Marks the `HashMap` as immutable.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.beginMutation = beginMutation;\nconst endMutation = HM.endMutation;\n/**\n * Mutates the `HashMap` within the context of the provided function.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.endMutation = endMutation;\nconst mutate = HM.mutate;\n/**\n * Set or remove the specified key in the `HashMap` using the specified\n * update function. The value of the specified key will be computed using the\n * provided hash.\n *\n * The update function will be invoked with the current value of the key if it\n * exists, or `None` if no such value exists.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.mutate = mutate;\nconst modifyAt = HM.modifyAt;\n/**\n * Alter the value of the specified key in the `HashMap` using the specified\n * update function. The value of the specified key will be computed using the\n * provided hash.\n *\n * The update function will be invoked with the current value of the key if it\n * exists, or `None` if no such value exists.\n *\n * This function will always either update or insert a value into the `HashMap`.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.modifyAt = modifyAt;\nconst modifyHash = HM.modifyHash;\n/**\n * Updates the value of the specified key within the `HashMap` if it exists.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.modifyHash = modifyHash;\nconst modify = HM.modify;\n/**\n * Performs a union of this `HashMap` and that `HashMap`.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.modify = modify;\nconst union = HM.union;\n/**\n * Remove the entry for the specified key in the `HashMap` using the internal\n * hashing function.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.union = union;\nconst remove = HM.remove;\n/**\n * Removes all entries in the `HashMap` which have the specified keys.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.remove = remove;\nconst removeMany = HM.removeMany;\n/**\n * Maps over the values of the `HashMap` using the specified function.\n *\n * @since 1.0.0\n * @category mapping\n */\nexports.removeMany = removeMany;\nconst map = HM.map;\n/**\n * Maps over the entries of the `HashMap` using the specified function.\n *\n * @since 1.0.0\n * @category mapping\n */\nexports.map = map;\nconst mapWithIndex = HM.mapWithIndex;\n/**\n * Chains over the values of the `HashMap` using the specified function.\n *\n * **NOTE**: the hash and equal of both maps have to be the same.\n *\n * @since 1.0.0\n * @category sequencing\n */\nexports.mapWithIndex = mapWithIndex;\nconst flatMap = HM.flatMap;\n/**\n * Chains over the entries of the `HashMap` using the specified function.\n *\n * **NOTE**: the hash and equal of both maps have to be the same.\n *\n * @since 1.0.0\n * @category sequencing\n */\nexports.flatMap = flatMap;\nconst flatMapWithIndex = HM.flatMapWithIndex;\n/**\n * Applies the specified function to the values of the `HashMap`.\n *\n * @since 1.0.0\n * @category traversing\n */\nexports.flatMapWithIndex = flatMapWithIndex;\nconst forEach = HM.forEach;\n/**\n * Applies the specified function to the entries of the `HashMap`.\n *\n * @since 1.0.0\n * @category traversing\n */\nexports.forEach = forEach;\nconst forEachWithIndex = HM.forEachWithIndex;\n/**\n * Reduces the specified state over the values of the `HashMap`.\n *\n * @since 1.0.0\n * @category folding\n */\nexports.forEachWithIndex = forEachWithIndex;\nconst reduce = HM.reduce;\n/**\n * Reduces the specified state over the entries of the `HashMap`.\n *\n * @since 1.0.0\n * @category folding\n */\nexports.reduce = reduce;\nconst reduceWithIndex = HM.reduceWithIndex;\n/**\n * Filters entries out of a `HashMap` using the specified predicate.\n *\n * @since 1.0.0\n * @category filtering\n */\nexports.reduceWithIndex = reduceWithIndex;\nconst filter = HM.filter;\n/**\n * Filters entries out of a `HashMap` using the specified predicate.\n *\n * @since 1.0.0\n * @category filtering\n */\nexports.filter = filter;\nconst filterWithIndex = HM.filterWithIndex;\n/**\n * Filters out `None` values from a `HashMap` of `Options`s.\n *\n * @since 1.0.0\n * @category filtering\n */\nexports.filterWithIndex = filterWithIndex;\nconst compact = HM.compact;\n/**\n * Maps over the values of the `HashMap` using the specified partial function\n * and filters out `None` values.\n *\n * @since 1.0.0\n * @category filtering\n */\nexports.compact = compact;\nconst filterMap = HM.filterMap;\n/**\n * Maps over the entries of the `HashMap` using the specified partial function\n * and filters out `None` values.\n *\n * @since 1.0.0\n * @category filtering\n */\nexports.filterMap = filterMap;\nconst filterMapWithIndex = HM.filterMapWithIndex;\nexports.filterMapWithIndex = filterMapWithIndex;\n//# sourceMappingURL=HashMap.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.values = exports.union = exports.toggle = exports.some = exports.size = exports.remove = exports.reduce = exports.partition = exports.mutate = exports.map = exports.make = exports.isSubset = exports.isHashSet = exports.intersection = exports.has = exports.fromIterable = exports.forEach = exports.flatMap = exports.filter = exports.every = exports.endMutation = exports.empty = exports.difference = exports.beginMutation = exports.add = void 0;\nvar HS = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/internal/HashSet\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/**\n * @since 1.0.0\n */\n\nconst TypeId = HS.HashSetTypeId;\n/**\n * @since 1.0.0\n * @category refinements\n */\nconst isHashSet = HS.isHashSet;\n/**\n * Creates an empty `HashSet`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.isHashSet = isHashSet;\nconst empty = HS.empty;\n/**\n * Construct a new `HashSet` from a `Collection` of values\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.empty = empty;\nconst fromIterable = HS.fromIterable;\n/**\n * Construct a new `HashSet` from a variable number of values.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.fromIterable = fromIterable;\nconst make = HS.make;\n/**\n * Checks if the specified value exists in the `HashSet`.\n *\n * @since 1.0.0\n * @category elements\n */\nexports.make = make;\nconst has = HS.has;\n/**\n * Returns `true` if any value in the `HashSet` matches the specified predicate.\n *\n * @since 1.0.0\n * @category elements\n */\nexports.has = has;\nconst some = HS.some;\n/**\n * Returns `true` only if all values in the `HashSet` match the specified\n * predicate.\n *\n * @since 1.0.0\n * @category elements\n */\nexports.some = some;\nconst every = HS.every;\n/**\n * Returns `true` if and only if every element in the this `HashSet` is an\n * element of the second set,\n *\n * **NOTE**: the hash and equal of both sets must be the same.\n *\n * @since 1.0.0\n * @category elements\n */\nexports.every = every;\nconst isSubset = HS.isSubset;\n/**\n * Returns an `IterableIterator` of the values in the `HashSet`.\n *\n * @since 1.0.0\n * @category getters\n */\nexports.isSubset = isSubset;\nconst values = HS.values;\n/**\n * Calculates the number of values in the `HashSet`.\n *\n * @since 1.0.0\n * @category getters\n */\nexports.values = values;\nconst size = HS.size;\n/**\n * Marks the `HashSet` as mutable.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.size = size;\nconst beginMutation = HS.beginMutation;\n/**\n * Marks the `HashSet` as immutable.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.beginMutation = beginMutation;\nconst endMutation = HS.endMutation;\n/**\n * Mutates the `HashSet` within the context of the provided function.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.endMutation = endMutation;\nconst mutate = HS.mutate;\n/**\n * Adds a value to the `HashSet`.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.mutate = mutate;\nconst add = HS.add;\n/**\n * Removes a value from the `HashSet`.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.add = add;\nconst remove = HS.remove;\n/**\n * Computes the set difference between this `HashSet` and the specified\n * `Iterable<A>`.\n *\n * **NOTE**: the hash and equal of the values in both the set and the iterable\n * must be the same.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.remove = remove;\nconst difference = HS.difference;\n/**\n * Returns a `HashSet` of values which are present in both this set and that\n * `Iterable<A>`.\n *\n * **NOTE**: the hash and equal of the values in both the set and the iterable\n * must be the same.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.difference = difference;\nconst intersection = HS.intersection;\n/**\n * Computes the set union `(`self` + `that`)` between this `HashSet` and the\n * specified `Iterable<A>`.\n *\n * **NOTE**: the hash and equal of the values in both the set and the iterable\n * must be the same.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.intersection = intersection;\nconst union = HS.union;\n/**\n * Checks if a value is present in the `HashSet`. If it is present, the value\n * will be removed from the `HashSet`, otherwise the value will be added to the\n * `HashSet`.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.union = union;\nconst toggle = HS.toggle;\n/**\n * Maps over the values of the `HashSet` using the specified function.\n *\n * @since 1.0.0\n * @category mapping\n */\nexports.toggle = toggle;\nconst map = HS.map;\n/**\n * Chains over the values of the `HashSet` using the specified function.\n *\n * @since 1.0.0\n * @category sequencing\n */\nexports.map = map;\nconst flatMap = HS.flatMap;\n/**\n * Applies the specified function to the values of the `HashSet`.\n *\n * @since 1.0.0\n * @category traversing\n */\nexports.flatMap = flatMap;\nconst forEach = HS.forEach;\n/**\n * Reduces the specified state over the values of the `HashSet`.\n *\n * @since 1.0.0\n * @category folding\n */\nexports.forEach = forEach;\nconst reduce = HS.reduce;\n/**\n * Filters values out of a `HashSet` using the specified predicate.\n *\n * @since 1.0.0\n * @category filtering\n */\nexports.reduce = reduce;\nconst filter = HS.filter;\n/**\n * Partition the values of a `HashSet` using the specified predicate.\n *\n * If a value matches the predicate, it will be placed into the `HashSet` on the\n * right side of the resulting `Tuple`, otherwise the value will be placed into\n * the left side.\n *\n * @since 1.0.0\n * @category partitioning\n */\nexports.filter = filter;\nconst partition = HS.partition;\nexports.partition = partition;\n//# sourceMappingURL=HashSet.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.unsafeTail = exports.unsafeLast = exports.unsafeHead = exports.toReadonlyArray = exports.toChunk = exports.take = exports.tail = exports.splitAt = exports.some = exports.reverse = exports.reduceRight = exports.reduce = exports.prependAllReversed = exports.prependAll = exports.prepend = exports.partitionMap = exports.partition = exports.of = exports.nil = exports.map = exports.make = exports.length = exports.last = exports.isNil = exports.isList = exports.isCons = exports.head = exports.fromIterable = exports.forEach = exports.flatMap = exports.findFirst = exports.filterMap = exports.filter = exports.every = exports.equalsWith = exports.empty = exports.drop = exports.cons = exports.concat = exports.compact = exports.ListTypeId = void 0;\nvar Chunk = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Chunk\"));\nvar Either = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Either\"));\nvar Equal = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Equal\"));\nvar Dual = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Function\"));\nvar Hash = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Hash\"));\nvar Option = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Option\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/**\n * @since 1.0.0\n */\nvar _a, _b;\n/**\n * This file is ported from\n *\n * Scala (https://www.scala-lang.org)\n *\n * Copyright EPFL and Lightbend, Inc.\n *\n * Licensed under Apache License 2.0\n * (http://www.apache.org/licenses/LICENSE-2.0).\n */\n\nconst ListSymbolKey = \"@effect/data/List\";\n/**\n * @since 1.0.0\n * @category symbol\n */\nconst ListTypeId = /*#__PURE__*/Symbol.for(ListSymbolKey);\nexports.ListTypeId = ListTypeId;\nconst listVariance = {\n  _A: _ => _\n};\nclass ConsImpl {\n  constructor(head, tail) {\n    this.head = head;\n    this.tail = tail;\n    this._tag = \"Cons\";\n    this[_a] = listVariance;\n  }\n  toString() {\n    return `List.Cons(${toReadonlyArray(this).map(String).join(\", \")})`;\n  }\n  toJSON() {\n    return {\n      _tag: \"List.Cons\",\n      values: toReadonlyArray(this)\n    };\n  }\n  [(_a = ListTypeId, Symbol.for(\"nodejs.util.inspect.custom\"))]() {\n    return this.toJSON();\n  }\n  [Equal.symbol](that) {\n    return isList(that) && this._tag === that._tag && equalsWith(this, that, Equal.equals);\n  }\n  [Hash.symbol]() {\n    return Hash.string(ListSymbolKey);\n  }\n  [Symbol.iterator]() {\n    let done = false;\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    let self = this;\n    return {\n      next() {\n        if (done) {\n          return this.return();\n        }\n        if (self._tag === \"Nil\") {\n          done = true;\n          return this.return();\n        }\n        const value = self.head;\n        self = self.tail;\n        return {\n          done,\n          value\n        };\n      },\n      return(value) {\n        if (!done) {\n          done = true;\n        }\n        return {\n          done: true,\n          value\n        };\n      }\n    };\n  }\n}\nclass NilImpl {\n  constructor() {\n    this._tag = \"Nil\";\n    this[_b] = listVariance;\n  }\n  toString() {\n    return `List.Nil`;\n  }\n  toJSON() {\n    return {\n      _tag: \"List.Nil\"\n    };\n  }\n  [(_b = ListTypeId, Symbol.for(\"nodejs.util.inspect.custom\"))]() {\n    return this.toJSON();\n  }\n  [Hash.symbol]() {\n    return Hash.array(Array.from(this));\n  }\n  [Equal.symbol](that) {\n    return isList(that) && this._tag === that._tag;\n  }\n  [Symbol.iterator]() {\n    return {\n      next() {\n        return {\n          done: true,\n          value: undefined\n        };\n      }\n    };\n  }\n}\n/**\n * Returns `true` if the specified value is a `List`, `false` otherwise.\n *\n * @since 1.0.0\n * @category refinements\n */\nconst isList = u => typeof u === \"object\" && u != null && ListTypeId in u;\n/**\n * Returns `true` if the specified value is a `List.Nil<A>`, `false` otherwise.\n *\n * @since 1.0.0\n * @category refinements\n */\nexports.isList = isList;\nconst isNil = self => self._tag === \"Nil\";\n/**\n * Returns `true` if the specified value is a `List.Cons<A>`, `false` otherwise.\n *\n * @since 1.0.0\n * @category refinements\n */\nexports.isNil = isNil;\nconst isCons = self => self._tag === \"Cons\";\n/**\n * Returns the number of elements contained in the specified `List`\n *\n * @since 1.0.0\n * @category getters\n */\nexports.isCons = isCons;\nconst length = self => {\n  let these = self;\n  let len = 0;\n  while (!isNil(these)) {\n    len += 1;\n    these = these.tail;\n  }\n  return len;\n};\n/**\n * Returns `true` if the two lists are equal according to the provided function,\n * `false` otherwise.\n *\n * @since 1.0.0\n * @category combinators\n */\nexports.length = length;\nconst equalsWith = /*#__PURE__*/Dual.dual(3, (self, that, f) => {\n  if (self === that) {\n    return true;\n  }\n  if (length(self) !== length(that)) {\n    return false;\n  }\n  const selfIterator = self[Symbol.iterator]();\n  const thatIterator = that[Symbol.iterator]();\n  let nextSelf;\n  let nextThat;\n  while (!(nextSelf = selfIterator.next()).done && !(nextThat = thatIterator.next()).done) {\n    if (!f(nextSelf.value, nextThat.value)) {\n      return false;\n    }\n  }\n  return true;\n});\nexports.equalsWith = equalsWith;\nconst _Nil = /*#__PURE__*/new NilImpl();\n/**\n * Constructs a new `List.Nil<A>`.\n *\n * @since 1.0.0\n * @category constructors\n */\nconst nil = () => _Nil;\n/**\n * Constructs a new `List.Cons<A>` from the specified `head` and `tail` values.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.nil = nil;\nconst cons = (head, tail) => new ConsImpl(head, tail);\n/**\n * Constructs a new empty `List<A>`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.cons = cons;\nconst empty = () => _Nil;\n/**\n * Constructs a new `List<A>` from the specified value.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.empty = empty;\nconst of = value => new ConsImpl(value, _Nil);\n/**\n * Constructs a new `List<A>` from the specified `Iterable<A>`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.of = of;\nconst fromIterable = prefix => {\n  const iterator = prefix[Symbol.iterator]();\n  let next;\n  if ((next = iterator.next()) && !next.done) {\n    const result = new ConsImpl(next.value, _Nil);\n    let curr = result;\n    while ((next = iterator.next()) && !next.done) {\n      const temp = new ConsImpl(next.value, _Nil);\n      curr.tail = temp;\n      curr = temp;\n    }\n    return result;\n  } else {\n    return _Nil;\n  }\n};\n/**\n * Constructs a new `List<A>` from the specified values.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.fromIterable = fromIterable;\nconst make = (...elements) => fromIterable(elements);\n/**\n * Removes all `None` values from the specified list.\n *\n * @since 1.0.0\n * @category combinators\n */\nexports.make = make;\nconst compact = self => filterMap(self, Dual.identity);\n/**\n * Concatentates the specified lists together.\n *\n * @since 1.0.0\n * @category combinators\n */\nexports.compact = compact;\nconst concat = /*#__PURE__*/Dual.dual(2, (self, that) => prependAll(that, self));\n/**\n * Drops the first `n` elements from the specified list.\n *\n * @since 1.0.0\n * @category combinators\n */\nexports.concat = concat;\nconst drop = /*#__PURE__*/Dual.dual(2, (self, n) => {\n  if (n <= 0) {\n    return self;\n  }\n  if (n >= length(self)) {\n    return _Nil;\n  }\n  let these = self;\n  let i = 0;\n  while (!isNil(these) && i < n) {\n    these = these.tail;\n    i += 1;\n  }\n  return these;\n});\n/**\n * Returns `true` if all elements of the specified list satisfy the specified\n * predicate, `false` otherwise.\n *\n * @since 1.0.0\n * @category combinators\n */\nexports.drop = drop;\nconst every = /*#__PURE__*/Dual.dual(2, (self, predicate) => {\n  for (const a of self) {\n    if (!predicate(a)) {\n      return false;\n    }\n  }\n  return true;\n});\n/**\n * Filters a list using the specified predicate.\n *\n * @since 1.0.0\n * @category combinators\n */\nexports.every = every;\nconst filter = /*#__PURE__*/Dual.dual(2, (self, predicate) => noneIn(self, predicate, false));\n/**\n * Filters and maps a list using the specified partial function. The resulting\n * list may be smaller than the input list due to the possibility of the partial\n * function not being defined for some elements.\n *\n * @since 1.0.0\n * @category combinators\n */\nexports.filter = filter;\nconst filterMap = /*#__PURE__*/Dual.dual(2, (self, pf) => {\n  const bs = [];\n  for (const a of self) {\n    const oa = pf(a);\n    if (Option.isSome(oa)) {\n      bs.push(oa.value);\n    }\n  }\n  return fromIterable(bs);\n});\n/**\n * Returns the first element of the specified list that satisfies the specified\n * predicate, or `None` if no such element exists.\n *\n * @since 1.0.0\n * @category combinators\n */\nexports.filterMap = filterMap;\nconst findFirst = /*#__PURE__*/Dual.dual(2, (self, predicate) => {\n  let these = self;\n  while (!isNil(these)) {\n    if (predicate(these.head)) {\n      return Option.some(these.head);\n    }\n    these = these.tail;\n  }\n  return Option.none();\n});\n/**\n * Flat maps a list using the specified function.\n *\n * @since 1.0.0\n * @category combinators\n */\nexports.findFirst = findFirst;\nconst flatMap = /*#__PURE__*/Dual.dual(2, (self, f) => {\n  let rest = self;\n  let head = undefined;\n  let tail = undefined;\n  while (!isNil(rest)) {\n    let bs = f(rest.head);\n    while (!isNil(bs)) {\n      const next = new ConsImpl(bs.head, _Nil);\n      if (tail === undefined) {\n        head = next;\n      } else {\n        tail.tail = next;\n      }\n      tail = next;\n      bs = bs.tail;\n    }\n    rest = rest.tail;\n  }\n  if (head === undefined) {\n    return _Nil;\n  }\n  return head;\n});\n/**\n * Applies the specified function to each element of the list.\n *\n * @since 1.0.0\n * @category combinators\n */\nexports.flatMap = flatMap;\nconst forEach = /*#__PURE__*/Dual.dual(2, (self, f) => {\n  let these = self;\n  while (!isNil(these)) {\n    f(these.head);\n    these = these.tail;\n  }\n});\n/**\n * Returns the first element of the specified list, or `None` if the list is\n * empty.\n *\n * @since 1.0.0\n * @category getters\n */\nexports.forEach = forEach;\nconst head = self => isNil(self) ? Option.none() : Option.some(self.head);\n/**\n * Returns the last element of the specified list, or `None` if the list is\n * empty.\n *\n * @since 1.0.0\n * @category getters\n */\nexports.head = head;\nconst last = self => isNil(self) ? Option.none() : Option.some(unsafeLast(self));\n/**\n * Applies the specified mapping function to each element of the list.\n *\n * @since 1.0.0\n * @category combinators\n */\nexports.last = last;\nconst map = /*#__PURE__*/Dual.dual(2, (self, f) => {\n  if (isNil(self)) {\n    return self;\n  } else {\n    const head = new ConsImpl(f(self.head), _Nil);\n    let nextHead = head;\n    let rest = self.tail;\n    while (!isNil(rest)) {\n      const next = new ConsImpl(f(rest.head), _Nil);\n      nextHead.tail = next;\n      nextHead = next;\n      rest = rest.tail;\n    }\n    return head;\n  }\n});\n/**\n * Partition a list into two lists, where the first list contains all elements\n * that did not satisfy the specified predicate, and the second list contains\n * all elements that did satisfy the specified predicate.\n *\n * @since 1.0.0\n * @category combinators\n */\nexports.map = map;\nconst partition = /*#__PURE__*/Dual.dual(2, (self, predicate) => {\n  const left = [];\n  const right = [];\n  for (const a of self) {\n    if (predicate(a)) {\n      right.push(a);\n    } else {\n      left.push(a);\n    }\n  }\n  return [fromIterable(left), fromIterable(right)];\n});\n/**\n * Partition a list into two lists, where the first list contains all elements\n * for which the specified function returned a `Left`, and the second list\n * contains all elements for which the specified function returned a `Right`.\n *\n * @since 1.0.0\n * @category combinators\n */\nexports.partition = partition;\nconst partitionMap = /*#__PURE__*/Dual.dual(2, (self, f) => {\n  const left = [];\n  const right = [];\n  for (const a of self) {\n    const e = f(a);\n    if (Either.isLeft(e)) {\n      left.push(e.left);\n    } else {\n      right.push(e.right);\n    }\n  }\n  return [fromIterable(left), fromIterable(right)];\n});\n/**\n * Prepends the specified element to the beginning of the list.\n *\n * @since 1.0.0\n * @category combinators\n */\nexports.partitionMap = partitionMap;\nconst prepend = /*#__PURE__*/Dual.dual(2, (self, element) => cons(element, self));\n/**\n * Prepends the specified prefix list to the beginning of the specified list.\n *\n * @since 1.0.0\n * @category combinators\n */\nexports.prepend = prepend;\nconst prependAll = /*#__PURE__*/Dual.dual(2, (self, prefix) => {\n  if (isNil(self)) {\n    return prefix;\n  } else if (isNil(prefix)) {\n    return self;\n  } else {\n    const result = new ConsImpl(prefix.head, self);\n    let curr = result;\n    let that = prefix.tail;\n    while (!isNil(that)) {\n      const temp = new ConsImpl(that.head, self);\n      curr.tail = temp;\n      curr = temp;\n      that = that.tail;\n    }\n    return result;\n  }\n});\n/**\n * Prepends the specified prefix list (in reverse order) to the beginning of the\n * specified list.\n *\n * @since 1.0.0\n * @category combinators\n */\nexports.prependAll = prependAll;\nconst prependAllReversed = /*#__PURE__*/Dual.dual(2, (self, prefix) => {\n  let these = self;\n  let pres = prefix;\n  while (isCons(pres)) {\n    these = new ConsImpl(pres.head, these);\n    pres = pres.tail;\n  }\n  return these;\n});\n/**\n * Folds over the elements of the list using the specified function, using the\n * specified initial value.\n *\n * @since 1.0.0\n * @category combinators\n */\nexports.prependAllReversed = prependAllReversed;\nconst reduce = /*#__PURE__*/Dual.dual(3, (self, zero, f) => {\n  let acc = zero;\n  let these = self;\n  while (!isNil(these)) {\n    acc = f(acc, these.head);\n    these = these.tail;\n  }\n  return acc;\n});\n/**\n * Folds over the elements of the list using the specified function, beginning\n * with the last element of the list, using the specified initial value.\n *\n * @since 1.0.0\n * @category combinators\n */\nexports.reduce = reduce;\nconst reduceRight = /*#__PURE__*/Dual.dual(3, (self, zero, f) => {\n  let acc = zero;\n  let these = reverse(self);\n  while (!isNil(these)) {\n    acc = f(acc, these.head);\n    these = these.tail;\n  }\n  return acc;\n});\n/**\n * Returns a new list with the elements of the specified list in reverse order.\n *\n * @since 1.0.0\n * @category combinators\n */\nexports.reduceRight = reduceRight;\nconst reverse = self => {\n  let result = empty();\n  let these = self;\n  while (!isNil(these)) {\n    result = prepend(result, these.head);\n    these = these.tail;\n  }\n  return result;\n};\n/**\n * Returns `true` if any element of the specified list satisfies the specified\n * predicate, `false` otherwise.\n *\n * @since 1.0.0\n * @category combinators\n */\nexports.reverse = reverse;\nconst some = /*#__PURE__*/Dual.dual(2, (self, predicate) => {\n  let these = self;\n  while (!isNil(these)) {\n    if (predicate(these.head)) {\n      return true;\n    }\n    these = these.tail;\n  }\n  return false;\n});\n/**\n * Splits the specified list into two lists at the specified index.\n *\n * @since 1.0.0\n * @category combinators\n */\nexports.some = some;\nconst splitAt = /*#__PURE__*/Dual.dual(2, (self, n) => [take(self, n), drop(self, n)]);\n/**\n * Returns the tail of the specified list, or `None` if the list is empty.\n *\n * @since 1.0.0\n * @category getters\n */\nexports.splitAt = splitAt;\nconst tail = self => isNil(self) ? Option.none() : Option.some(self.tail);\n/**\n * Takes the specified number of elements from the beginning of the specified\n * list.\n *\n * @since 1.0.0\n * @category combinators\n */\nexports.tail = tail;\nconst take = /*#__PURE__*/Dual.dual(2, (self, n) => {\n  if (n <= 0) {\n    return _Nil;\n  }\n  if (n >= length(self)) {\n    return self;\n  }\n  let these = make(unsafeHead(self));\n  let current = unsafeTail(self);\n  for (let i = 1; i < n; i++) {\n    these = new ConsImpl(unsafeHead(current), these);\n    current = unsafeTail(current);\n  }\n  return reverse(these);\n});\n/**\n * Converts the specified list to a `Chunk`.\n *\n * @since 1.0.0\n * @category conversions\n */\nexports.take = take;\nconst toChunk = self => Chunk.fromIterable(self);\n/**\n * Converts the specified list to a `ReadonlyArray`.\n *\n * @since 1.0.0\n * @category conversions\n */\nexports.toChunk = toChunk;\nconst toReadonlyArray = self => Array.from(self);\n/**\n * Unsafely returns the first element of the specified `List`.\n *\n * @since 1.0.0\n * @category unsafe\n */\nexports.toReadonlyArray = toReadonlyArray;\nconst unsafeHead = self => {\n  if (isNil(self)) {\n    throw new Error(\"Error: Expected List to be non-empty\");\n  }\n  return self.head;\n};\n/**\n * Unsafely returns the last element of the specified `List`.\n *\n * @since 1.0.0\n * @category unsafe\n */\nexports.unsafeHead = unsafeHead;\nconst unsafeLast = self => {\n  if (isNil(self)) {\n    throw new Error(\"Error: Expected List to be non-empty\");\n  }\n  let these = self;\n  let scout = self.tail;\n  while (!isNil(scout)) {\n    these = scout;\n    scout = scout.tail;\n  }\n  return these.head;\n};\n/**\n * Unsafely returns the tail of the specified `List`.\n *\n * @since 1.0.0\n * @category unsafe\n */\nexports.unsafeLast = unsafeLast;\nconst unsafeTail = self => {\n  if (isNil(self)) {\n    throw new Error(\"Error: Expected List to be non-empty\");\n  }\n  return self.tail;\n};\nexports.unsafeTail = unsafeTail;\nconst noneIn = (self, predicate, isFlipped) => {\n  /* eslint-disable no-constant-condition */\n  while (true) {\n    if (isNil(self)) {\n      return _Nil;\n    } else {\n      if (predicate(self.head) !== isFlipped) {\n        return allIn(self, self.tail, predicate, isFlipped);\n      } else {\n        self = self.tail;\n      }\n    }\n  }\n};\nconst allIn = (self, remaining, predicate, isFlipped) => {\n  /* eslint-disable no-constant-condition */\n  while (true) {\n    if (isNil(remaining)) {\n      return self;\n    } else {\n      if (predicate(remaining.head) !== isFlipped) {\n        remaining = remaining.tail;\n      } else {\n        return partialFill(self, remaining, predicate, isFlipped);\n      }\n    }\n  }\n};\nconst partialFill = (self, firstMiss, predicate, isFlipped) => {\n  const newHead = new ConsImpl(unsafeHead(self), _Nil);\n  let toProcess = unsafeTail(self);\n  let currentLast = newHead;\n  while (!(toProcess === firstMiss)) {\n    const newElem = new ConsImpl(unsafeHead(toProcess), _Nil);\n    currentLast.tail = newElem;\n    currentLast = (0, Dual.unsafeCoerce)(newElem);\n    toProcess = (0, Dual.unsafeCoerce)(toProcess.tail);\n  }\n  let next = firstMiss.tail;\n  let nextToCopy = (0, Dual.unsafeCoerce)(next);\n  while (!isNil(next)) {\n    const head = unsafeHead(next);\n    if (predicate(head) !== isFlipped) {\n      next = next.tail;\n    } else {\n      while (!(nextToCopy === next)) {\n        const newElem = new ConsImpl(unsafeHead(nextToCopy), _Nil);\n        currentLast.tail = newElem;\n        currentLast = newElem;\n        nextToCopy = (0, Dual.unsafeCoerce)(nextToCopy.tail);\n      }\n      nextToCopy = (0, Dual.unsafeCoerce)(next.tail);\n      next = next.tail;\n    }\n  }\n  if (!isNil(nextToCopy)) {\n    currentLast.tail = nextToCopy;\n  }\n  return newHead;\n};\n//# sourceMappingURL=List.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.size = exports.set = exports.remove = exports.modifyAt = exports.modify = exports.make = exports.has = exports.get = exports.fromIterable = exports.empty = void 0;\nvar Dual = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Function\"));\nvar HashMap = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/HashMap\"));\nvar MutableRef = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/MutableRef\"));\nvar Option = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Option\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/**\n * @since 1.0.0\n */\n\nconst TypeId = /*#__PURE__*/Symbol.for(\"@effect/data/MutableHashMap\");\n/** @internal */\nclass MutableHashMapImpl {\n  constructor() {\n    this._id = TypeId;\n    this.backingMap = MutableRef.make(HashMap.empty());\n  }\n  [Symbol.iterator]() {\n    return this.backingMap.current[Symbol.iterator]();\n  }\n  toString() {\n    return `MutableHashMap(${Array.from(this).map(([k, v]) => `[${String(k)}, ${String(v)}]`).join(\", \")})`;\n  }\n  toJSON() {\n    return {\n      _tag: \"MutableHashMap\",\n      values: Array.from(this)\n    };\n  }\n  [Symbol.for(\"nodejs.util.inspect.custom\")]() {\n    return this.toJSON();\n  }\n}\n/**\n * @since 1.0.0\n * @category constructors\n */\nconst empty = () => new MutableHashMapImpl();\n/**\n * @since 1.0.0\n * @category constructors\n */\nexports.empty = empty;\nconst make = (...entries) => fromIterable(entries);\n/**\n * @since 1.0.0\n * @category conversions\n */\nexports.make = make;\nconst fromIterable = entries => {\n  const map = empty();\n  for (const entry of entries) {\n    set(map, entry[0], entry[1]);\n  }\n  return map;\n};\n/**\n * @since 1.0.0\n * @category elements\n */\nexports.fromIterable = fromIterable;\nconst get = /*#__PURE__*/Dual.dual(2, (self, key) => HashMap.get(self.backingMap.current, key));\n/**\n * @since 1.0.0\n * @category elements\n */\nexports.get = get;\nconst has = /*#__PURE__*/Dual.dual(2, (self, key) => Option.isSome(get(self, key)));\n/**\n * Updates the value of the specified key within the `MutableHashMap` if it exists.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.has = has;\nconst modify = /*#__PURE__*/Dual.dual(3, (self, key, f) => {\n  MutableRef.update(self.backingMap, HashMap.modify(key, f));\n  return self;\n});\n/**\n * Set or remove the specified key in the `MutableHashMap` using the specified\n * update function.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.modify = modify;\nconst modifyAt = /*#__PURE__*/Dual.dual(3, (self, key, f) => {\n  const result = f(get(self, key));\n  if (Option.isSome(result)) {\n    set(self, key, result.value);\n  } else {\n    remove(self, key);\n  }\n  return self;\n});\n/**\n * @since 1.0.0\n * @category mutations\n */\nexports.modifyAt = modifyAt;\nconst remove = /*#__PURE__*/Dual.dual(2, (self, key) => {\n  MutableRef.update(self.backingMap, HashMap.remove(key));\n  return self;\n});\n/**\n * @since 1.0.0\n * @category mutations\n */\nexports.remove = remove;\nconst set = /*#__PURE__*/Dual.dual(3, (self, key, value) => {\n  MutableRef.update(self.backingMap, HashMap.set(key, value));\n  return self;\n});\n/**\n * @since 1.0.0\n * @category elements\n */\nexports.set = set;\nconst size = self => HashMap.size(MutableRef.get(self.backingMap));\nexports.size = size;\n//# sourceMappingURL=MutableHashMap.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.tail = exports.shift = exports.reset = exports.prepend = exports.pop = exports.make = exports.length = exports.isEmpty = exports.head = exports.from = exports.forEach = exports.empty = exports.append = void 0;\nvar Dual = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Function\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/**\n * @since 1.0.0\n */\n\nconst TypeId = /*#__PURE__*/Symbol.for(\"@effect/data/MutableList\");\n/** @internal */\nclass MutableListImpl {\n  constructor() {\n    this._id = TypeId;\n    this.head = undefined;\n    this.tail = undefined;\n    this._length = 0;\n  }\n  [Symbol.iterator]() {\n    let done = false;\n    let head = this.head;\n    return {\n      next() {\n        if (done) {\n          return this.return();\n        }\n        if (head == null) {\n          done = true;\n          return this.return();\n        }\n        const value = head.value;\n        head = head.next;\n        return {\n          done,\n          value\n        };\n      },\n      return(value) {\n        if (!done) {\n          done = true;\n        }\n        return {\n          done: true,\n          value\n        };\n      }\n    };\n  }\n  toString() {\n    return `MutableList(${Array.from(this).map(String).join(\", \")})`;\n  }\n  toJSON() {\n    return {\n      _tag: \"MutableList\",\n      values: Array.from(this)\n    };\n  }\n  [Symbol.for(\"nodejs.util.inspect.custom\")]() {\n    return this.toJSON();\n  }\n}\n/** @internal */\nclass LinkedListNode {\n  constructor(value) {\n    this.value = value;\n    this.removed = false;\n    this.prev = undefined;\n    this.next = undefined;\n  }\n}\n/**\n * Creates an empty `MutableList`.\n *\n * @since 1.0.0\n * @category constructors\n */\nconst empty = () => new MutableListImpl();\n/**\n * Creates a new `MutableList` from an `Iterable`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.empty = empty;\nconst from = iterable => {\n  const list = new MutableListImpl();\n  for (const element of iterable) {\n    append(list, element);\n  }\n  return list;\n};\n/**\n * Creates a new `MutableList` from the specified elements.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.from = from;\nconst make = (...elements) => from(elements);\n/**\n * Returns `true` if the list contains zero elements, `false`, otherwise.\n *\n * @since 1.0.0\n * @category getters\n */\nexports.make = make;\nconst isEmpty = self => length(self) === 0;\n/**\n * Returns the length of the list.\n *\n * @since 1.0.0\n * @category getters\n */\nexports.isEmpty = isEmpty;\nconst length = self => self._length;\n/**\n * Returns the last element of the list, if it exists.\n *\n * @since 1.0.0\n * @category getters\n */\nexports.length = length;\nconst tail = self => self.tail === undefined ? undefined : self.tail.value;\n/**\n * Returns the first element of the list, if it exists.\n *\n * @since 1.0.0\n * @category getters\n */\nexports.tail = tail;\nconst head = self => self.head === undefined ? undefined : self.head.value;\n/**\n * Executes the specified function `f` for each element in the list.\n *\n * @since 1.0.0\n * @category traversing\n */\nexports.head = head;\nconst forEach = /*#__PURE__*/Dual.dual(2, (self, f) => {\n  let current = self.head;\n  while (current !== undefined) {\n    f(current.value);\n    current = current.next;\n  }\n});\n/**\n * Removes all elements from the doubly-linked list.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.forEach = forEach;\nconst reset = self => {\n  ;\n  self._length = 0;\n  self.head = undefined;\n  self.tail = undefined;\n  return self;\n};\n/**\n * Appends the specified value to the end of the list.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.reset = reset;\nconst append = /*#__PURE__*/Dual.dual(2, (self, value) => {\n  const node = new LinkedListNode(value);\n  if (self.head === undefined) {\n    self.head = node;\n  }\n  if (self.tail === undefined) {\n    self.tail = node;\n  } else {\n    self.tail.next = node;\n    node.prev = self.tail;\n    self.tail = node;\n  }\n  ;\n  self._length += 1;\n  return self;\n});\n/**\n * Removes the first value from the list and returns it, if it exists.\n *\n * @since 0.0.1\n * @category mutations\n */\nexports.append = append;\nconst shift = self => {\n  const head = self.head;\n  if (head !== undefined) {\n    remove(self, head);\n    return head.value;\n  }\n  return undefined;\n};\n/**\n * Removes the last value from the list and returns it, if it exists.\n *\n * @since 0.0.1\n * @category mutations\n */\nexports.shift = shift;\nconst pop = self => {\n  const tail = self.tail;\n  if (tail !== undefined) {\n    remove(self, tail);\n    return tail.value;\n  }\n  return undefined;\n};\n/**\n * Prepends the specified value to the beginning of the list.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.pop = pop;\nconst prepend = /*#__PURE__*/Dual.dual(2, (self, value) => {\n  const node = new LinkedListNode(value);\n  node.next = self.head;\n  if (self.head !== undefined) {\n    self.head.prev = node;\n  }\n  self.head = node;\n  if (self.tail === undefined) {\n    self.tail = node;\n  }\n  ;\n  self._length += 1;\n  return self;\n});\nexports.prepend = prepend;\nconst remove = (self, node) => {\n  if (node.removed) {\n    return;\n  }\n  node.removed = true;\n  if (node.prev !== undefined && node.next !== undefined) {\n    node.prev.next = node.next;\n    node.next.prev = node.prev;\n  } else if (node.prev !== undefined) {\n    self.tail = node.prev;\n    node.prev.next = undefined;\n  } else if (node.next !== undefined) {\n    self.head = node.next;\n    node.next.prev = undefined;\n  } else {\n    self.tail = undefined;\n    self.head = undefined;\n  }\n  if (self._length > 0) {\n    ;\n    self._length -= 1;\n  }\n};\n//# sourceMappingURL=MutableList.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.unbounded = exports.pollUpTo = exports.poll = exports.offerAll = exports.offer = exports.length = exports.isFull = exports.isEmpty = exports.capacity = exports.bounded = exports.EmptyMutableQueue = void 0;\nvar Chunk = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Chunk\"));\nvar Dual = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Function\"));\nvar MutableList = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/MutableList\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/**\n * @since 1.0.0\n */\n\nconst TypeId = /*#__PURE__*/Symbol.for(\"@effect/data/MutableQueue\");\n/**\n * @since 1.0.0\n * @category symbol\n */\nconst EmptyMutableQueue = /*#__PURE__*/Symbol.for(\"@effect/data/mutable/MutableQueue/Empty\");\n/** @internal */\nexports.EmptyMutableQueue = EmptyMutableQueue;\nclass MutableQueueImpl {\n  constructor(capacity = undefined) {\n    this.capacity = capacity;\n    this._tag = \"Bounded\";\n    this._id = TypeId;\n    this.queue = MutableList.empty();\n  }\n  [Symbol.iterator]() {\n    return Array.from(this.queue)[Symbol.iterator]();\n  }\n  toString() {\n    return `MutableQueue(${Array.from(this).map(String).join(\", \")})`;\n  }\n  toJSON() {\n    return {\n      _tag: \"MutableQueue\",\n      values: Array.from(this)\n    };\n  }\n  [Symbol.for(\"nodejs.util.inspect.custom\")]() {\n    return this.toJSON();\n  }\n}\n/**\n * Creates a new bounded `MutableQueue`.\n *\n * @since 1.0.0\n * @category constructors\n */\nconst bounded = capacity => new MutableQueueImpl(capacity);\n/**\n * Creates a new unbounded `MutableQueue`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.bounded = bounded;\nconst unbounded = () => new MutableQueueImpl();\n/**\n * Returns the current number of elements in the queue.\n *\n * @since 1.0.0\n * @category getters\n */\nexports.unbounded = unbounded;\nconst length = self => MutableList.length(self.queue);\n/**\n * Returns `true` if the queue is empty, `false` otherwise.\n *\n * @since 1.0.0\n * @category getters\n */\nexports.length = length;\nconst isEmpty = self => MutableList.isEmpty(self.queue);\n/**\n * Returns `true` if the queue is full, `false` otherwise.\n *\n * @since 1.0.0\n * @category getters\n */\nexports.isEmpty = isEmpty;\nconst isFull = self => self.capacity === undefined ? false : MutableList.length(self.queue) === self.capacity;\n/**\n * The **maximum** number of elements that a queue can hold.\n *\n * **Note**: unbounded queues can still implement this interface with\n * `capacity = Infinity`.\n *\n * @since 1.0.0\n * @category getters\n */\nexports.isFull = isFull;\nconst capacity = self => self.capacity === undefined ? Infinity : self.capacity;\n/**\n * Offers an element to the queue.\n *\n * Returns whether the enqueue was successful or not.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.capacity = capacity;\nconst offer = /*#__PURE__*/Dual.dual(2, (self, value) => {\n  const queueLength = MutableList.length(self.queue);\n  if (self.capacity !== undefined && queueLength === self.capacity) {\n    return false;\n  }\n  MutableList.append(value)(self.queue);\n  return true;\n});\n/**\n * Enqueues a collection of values into the queue.\n *\n * Returns a `List` of the values that were **not** able to be enqueued.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.offer = offer;\nconst offerAll = /*#__PURE__*/Dual.dual(2, (self, values) => {\n  const iterator = values[Symbol.iterator]();\n  let next;\n  let remainder = Chunk.empty();\n  let offering = true;\n  while (offering && (next = iterator.next()) && !next.done) {\n    offering = offer(next.value)(self);\n  }\n  while (next != null && !next.done) {\n    remainder = Chunk.prepend(next.value)(remainder);\n    next = iterator.next();\n  }\n  return Chunk.reverse(remainder);\n});\n/**\n * Dequeues an element from the queue.\n *\n * Returns either an element from the queue, or the `def` param.\n *\n * **Note**: if there is no meaningful default for your type, you can always\n * use `poll(MutableQueue.EmptyMutableQueue)`.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.offerAll = offerAll;\nconst poll = /*#__PURE__*/Dual.dual(2, (self, def) => {\n  if (MutableList.isEmpty(self.queue)) {\n    return def;\n  }\n  return MutableList.shift(self.queue);\n});\n/**\n * Dequeues up to `n` elements from the queue.\n *\n * Returns a `List` of up to `n` elements.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.poll = poll;\nconst pollUpTo = /*#__PURE__*/Dual.dual(2, (self, n) => {\n  let result = Chunk.empty();\n  let count = 0;\n  while (count < n) {\n    const element = poll(EmptyMutableQueue)(self);\n    if (element === EmptyMutableQueue) {\n      break;\n    }\n    result = Chunk.prepend(element)(result);\n    count += 1;\n  }\n  return Chunk.reverse(result);\n});\nexports.pollUpTo = pollUpTo;\n//# sourceMappingURL=MutableQueue.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.updateAndGet = exports.update = exports.toggle = exports.setAndGet = exports.set = exports.make = exports.incrementAndGet = exports.increment = exports.getAndUpdate = exports.getAndSet = exports.getAndIncrement = exports.getAndDecrement = exports.get = exports.decrementAndGet = exports.decrement = exports.compareAndSet = void 0;\nvar Equal = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Equal\"));\nvar Dual = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Function\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/**\n * @since 1.0.0\n */\n\nconst TypeId = /*#__PURE__*/Symbol.for(\"@effect/data/MutableRef\");\nclass MutableRefImpl {\n  constructor(current) {\n    this.current = current;\n    this._T = _ => _;\n    this._id = TypeId;\n  }\n  toString() {\n    return `MutableRef(${String(this.current)})`;\n  }\n  toJSON() {\n    return {\n      _tag: \"MutableRef\",\n      current: this.current\n    };\n  }\n  [Symbol.for(\"nodejs.util.inspect.custom\")]() {\n    return this.toJSON();\n  }\n}\n/**\n * @since 1.0.0\n * @category constructors\n */\nconst make = value => new MutableRefImpl(value);\n/**\n * @since 1.0.0\n * @category general\n */\nexports.make = make;\nconst compareAndSet = /*#__PURE__*/Dual.dual(3, (self, oldValue, newValue) => {\n  if (Equal.equals(oldValue, self.current)) {\n    self.current = newValue;\n    return true;\n  }\n  return false;\n});\n/**\n * @since 1.0.0\n * @category numeric\n */\nexports.compareAndSet = compareAndSet;\nconst decrement = self => update(self, n => n - 1);\n/**\n * @since 1.0.0\n * @category numeric\n */\nexports.decrement = decrement;\nconst decrementAndGet = self => updateAndGet(self, n => n - 1);\n/**\n * @since 1.0.0\n * @category general\n */\nexports.decrementAndGet = decrementAndGet;\nconst get = self => self.current;\n/**\n * @since 1.0.0\n * @category numeric\n */\nexports.get = get;\nconst getAndDecrement = self => getAndUpdate(self, n => n - 1);\n/**\n * @since 1.0.0\n * @category numeric\n */\nexports.getAndDecrement = getAndDecrement;\nconst getAndIncrement = self => getAndUpdate(self, n => n + 1);\n/**\n * @since 1.0.0\n * @category general\n */\nexports.getAndIncrement = getAndIncrement;\nconst getAndSet = /*#__PURE__*/Dual.dual(2, (self, value) => {\n  const ret = self.current;\n  self.current = value;\n  return ret;\n});\n/**\n * @since 1.0.0\n * @category general\n */\nexports.getAndSet = getAndSet;\nconst getAndUpdate = /*#__PURE__*/Dual.dual(2, (self, f) => getAndSet(self, f(get(self))));\n/**\n * @since 1.0.0\n * @category numeric\n */\nexports.getAndUpdate = getAndUpdate;\nconst increment = self => update(self, n => n + 1);\n/**\n * @since 1.0.0\n * @category numeric\n */\nexports.increment = increment;\nconst incrementAndGet = self => updateAndGet(self, n => n + 1);\n/**\n * @since 1.0.0\n * @category general\n */\nexports.incrementAndGet = incrementAndGet;\nconst set = /*#__PURE__*/Dual.dual(2, (self, value) => {\n  self.current = value;\n  return self;\n});\n/**\n * @since 1.0.0\n * @category general\n */\nexports.set = set;\nconst setAndGet = /*#__PURE__*/Dual.dual(2, (self, value) => {\n  self.current = value;\n  return self.current;\n});\n/**\n * @since 1.0.0\n * @category general\n */\nexports.setAndGet = setAndGet;\nconst update = /*#__PURE__*/Dual.dual(2, (self, f) => set(self, f(get(self))));\n/**\n * @since 1.0.0\n * @category general\n */\nexports.update = update;\nconst updateAndGet = /*#__PURE__*/Dual.dual(2, (self, f) => setAndGet(self, f(get(self))));\n/**\n * @since 1.0.0\n * @category boolean\n */\nexports.updateAndGet = updateAndGet;\nconst toggle = self => update(self, _ => !_);\nexports.toggle = toggle;\n//# sourceMappingURL=MutableRef.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.sumAll = exports.sum = exports.subtract = exports.sign = exports.remainder = exports.multiplyAll = exports.multiply = exports.min = exports.max = exports.lessThanOrEqualTo = exports.lessThan = exports.isNumber = exports.increment = exports.greaterThanOrEqualTo = exports.greaterThan = exports.divide = exports.decrement = exports.clamp = exports.between = exports.SemigroupSum = exports.SemigroupMultiply = exports.SemigroupMin = exports.SemigroupMax = exports.Order = exports.MonoidSum = exports.MonoidMultiply = exports.MonoidMin = exports.MonoidMax = exports.Equivalence = exports.Bounded = void 0;\nvar _Function = /*#__PURE__*/require(\"@effect/data/Function\");\nvar predicate = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Predicate\"));\nvar bounded = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/typeclass/Bounded\"));\nvar equivalence = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/typeclass/Equivalence\"));\nvar monoid = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/typeclass/Monoid\"));\nvar order = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/typeclass/Order\"));\nvar semigroup = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/typeclass/Semigroup\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/**\n * This module provides utility functions and type class instances for working with the `number` type in TypeScript.\n * It includes functions for basic arithmetic operations, as well as type class instances for\n * `Equivalence`, `Order`, `Semigroup`, and `Monoid`.\n *\n * @since 1.0.0\n */\n\n/**\n * Tests if a value is a `number`.\n *\n * @param input - The value to test.\n *\n * @example\n * import { isNumber } from '@effect/data/Number'\n *\n * assert.deepStrictEqual(isNumber(2), true)\n * assert.deepStrictEqual(isNumber(\"2\"), false)\n *\n * @category guards\n * @since 1.0.0\n */\nconst isNumber = predicate.isNumber;\n/**\n * Provides an addition operation on `number`s.\n *\n * @param self - The first operand.\n * @param that - The second operand.\n *\n * @example\n * import { sum } from '@effect/data/Number'\n *\n * assert.deepStrictEqual(sum(2, 3), 5)\n *\n * @category math\n * @since 1.0.0\n */\nexports.isNumber = isNumber;\nconst sum = /*#__PURE__*/(0, _Function.dual)(2, semigroup.numberSum.combine);\n/**\n * Provides a multiplication operation on `number`s.\n *\n * @param self - The first operand.\n * @param that - The second operand.\n *\n * @example\n * import { multiply } from '@effect/data/Number'\n *\n * assert.deepStrictEqual(multiply(2, 3), 6)\n *\n * @category math\n * @since 1.0.0\n */\nexports.sum = sum;\nconst multiply = /*#__PURE__*/(0, _Function.dual)(2, semigroup.numberMultiply.combine);\n/**\n * Provides a subtraction operation on `number`s.\n *\n * @param self - The first operand.\n * @param that - The second operand.\n *\n * @example\n * import { subtract } from '@effect/data/Number'\n *\n * assert.deepStrictEqual(subtract(2, 3), -1)\n *\n * @category math\n * @since 1.0.0\n */\nexports.multiply = multiply;\nconst subtract = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => self - that);\n/**\n * Provides a division operation on `number`s.\n *\n * @param self - The dividend operand.\n * @param that - The divisor operand.\n *\n * @example\n * import { divide } from '@effect/data/Number'\n *\n * assert.deepStrictEqual(divide(6, 3), 2)\n *\n * @category math\n * @since 1.0.0\n */\nexports.subtract = subtract;\nconst divide = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => self / that);\n/**\n * Returns the result of adding `1` to a given number.\n *\n * @param n - A `number` to be incremented.\n *\n * @example\n * import { increment } from '@effect/data/Number'\n *\n * assert.deepStrictEqual(increment(2), 3)\n *\n * @category math\n * @since 1.0.0\n */\nexports.divide = divide;\nconst increment = n => n + 1;\n/**\n * Decrements a number by `1`.\n *\n * @param n - A `number` to be decremented.\n *\n * @example\n * import { decrement } from '@effect/data/Number'\n *\n * assert.deepStrictEqual(decrement(3), 2)\n *\n * @category math\n * @since 1.0.0\n */\nexports.increment = increment;\nconst decrement = n => n - 1;\n/**\n * @category instances\n * @since 1.0.0\n */\nexports.decrement = decrement;\nconst Equivalence = equivalence.number;\n/**\n * @category instances\n * @since 1.0.0\n */\nexports.Equivalence = Equivalence;\nconst Order = order.number;\n/**\n * Returns `true` if the first argument is less than the second, otherwise `false`.\n *\n * @param self - The first argument.\n * @param that - The second argument.\n *\n * @example\n * import { lessThan } from '@effect/data/Number'\n *\n * assert.deepStrictEqual(lessThan(2, 3), true)\n * assert.deepStrictEqual(lessThan(3, 3), false)\n * assert.deepStrictEqual(lessThan(4, 3), false)\n *\n * @category predicates\n * @since 1.0.0\n */\nexports.Order = Order;\nconst lessThan = /*#__PURE__*/order.lessThan(Order);\n/**\n * Returns a function that checks if a given `number` is less than or equal to the provided one.\n *\n * @param self - The first `number` to compare with.\n * @param that - The second `number` to compare with.\n *\n * @example\n * import { lessThanOrEqualTo } from '@effect/data/Number'\n *\n * assert.deepStrictEqual(lessThanOrEqualTo(2, 3), true)\n * assert.deepStrictEqual(lessThanOrEqualTo(3, 3), true)\n * assert.deepStrictEqual(lessThanOrEqualTo(4, 3), false)\n *\n * @category predicates\n * @since 1.0.0\n */\nexports.lessThan = lessThan;\nconst lessThanOrEqualTo = /*#__PURE__*/order.lessThanOrEqualTo(Order);\n/**\n * Returns `true` if the first argument is greater than the second, otherwise `false`.\n *\n * @param self - The first argument.\n * @param that - The second argument.\n *\n * @example\n * import { greaterThan } from '@effect/data/Number'\n *\n * assert.deepStrictEqual(greaterThan(2, 3), false)\n * assert.deepStrictEqual(greaterThan(3, 3), false)\n * assert.deepStrictEqual(greaterThan(4, 3), true)\n *\n * @category predicates\n * @since 1.0.0\n */\nexports.lessThanOrEqualTo = lessThanOrEqualTo;\nconst greaterThan = /*#__PURE__*/order.greaterThan(Order);\n/**\n * Returns a function that checks if a given `number` is greater than or equal to the provided one.\n *\n * @param self - The first `number` to compare with.\n * @param that - The second `number` to compare with.\n *\n * @example\n * import { greaterThanOrEqualTo } from '@effect/data/Number'\n *\n * assert.deepStrictEqual(greaterThanOrEqualTo(2, 3), false)\n * assert.deepStrictEqual(greaterThanOrEqualTo(3, 3), true)\n * assert.deepStrictEqual(greaterThanOrEqualTo(4, 3), true)\n *\n * @category predicates\n * @since 1.0.0\n */\nexports.greaterThan = greaterThan;\nconst greaterThanOrEqualTo = /*#__PURE__*/order.greaterThanOrEqualTo(Order);\n/**\n * Checks if a `number` is between a `minimum` and `maximum` value (inclusive).\n *\n * @param self - The `number` to check.\n * @param minimum - The `minimum` value to check.\n * @param maximum - The `maximum` value to check.\n *\n * @example\n * import { between } from '@effect/data/Number'\n *\n * assert.deepStrictEqual(between(0, 5)(3), true)\n * assert.deepStrictEqual(between(0, 5)(-1), false)\n * assert.deepStrictEqual(between(0, 5)(6), false)\n *\n * @category predicates\n * @since 1.0.0\n */\nexports.greaterThanOrEqualTo = greaterThanOrEqualTo;\nconst between = /*#__PURE__*/order.between(Order);\n/**\n * Restricts the given `number` to be within the range specified by the `minimum` and `maximum` values.\n *\n * - If the `number` is less than the `minimum` value, the function returns the `minimum` value.\n * - If the `number` is greater than the `maximum` value, the function returns the `maximum` value.\n * - Otherwise, it returns the original `number`.\n *\n * @param self - The `number` to be clamped.\n * @param minimum - The lower end of the range.\n * @param maximum - The upper end of the range.\n *\n * @example\n * import { clamp } from '@effect/data/Number'\n *\n * assert.deepStrictEqual(clamp(0, 5)(3), 3)\n * assert.deepStrictEqual(clamp(0, 5)(-1), 0)\n * assert.deepStrictEqual(clamp(0, 5)(6), 5)\n *\n * @since 1.0.0\n */\nexports.between = between;\nconst clamp = /*#__PURE__*/order.clamp(Order);\n/**\n * Returns the minimum between two `number`s.\n *\n * @param self - The first `number`.\n * @param that - The second `number`.\n *\n * @example\n * import { min } from '@effect/data/Number'\n *\n * assert.deepStrictEqual(min(2, 3), 2)\n *\n * @since 1.0.0\n */\nexports.clamp = clamp;\nconst min = /*#__PURE__*/order.min(Order);\n/**\n * Returns the maximum between two `number`s.\n *\n * @param self - The first `number`.\n * @param that - The second `number`.\n *\n * @example\n * import { max } from '@effect/data/Number'\n *\n * assert.deepStrictEqual(max(2, 3), 3)\n *\n * @since 1.0.0\n */\nexports.min = min;\nconst max = /*#__PURE__*/order.max(Order);\n/**\n * @category instances\n * @since 1.0.0\n */\nexports.max = max;\nconst Bounded = bounded.number;\n/**\n * `number` semigroup under addition.\n *\n * @example\n * import { SemigroupSum } from '@effect/data/Number'\n *\n * assert.deepStrictEqual(SemigroupSum.combine(2, 3), 5)\n *\n * @category instances\n * @since 1.0.0\n */\nexports.Bounded = Bounded;\nconst SemigroupSum = semigroup.numberSum;\n/**\n * `number` semigroup under multiplication.\n *\n * @example\n * import { SemigroupMultiply } from '@effect/data/Number'\n *\n * assert.deepStrictEqual(SemigroupMultiply.combine(2, 3), 6)\n *\n * @category instances\n * @since 1.0.0\n */\nexports.SemigroupSum = SemigroupSum;\nconst SemigroupMultiply = semigroup.numberMultiply;\n/**\n * A `Semigroup` that uses the minimum between two values.\n *\n * @example\n * import { SemigroupMin } from '@effect/data/Number'\n *\n * assert.deepStrictEqual(SemigroupMin.combine(2, 3), 2)\n *\n * @category instances\n * @since 1.0.0\n */\nexports.SemigroupMultiply = SemigroupMultiply;\nconst SemigroupMin = /*#__PURE__*/semigroup.min(Order);\n/**\n * A `Semigroup` that uses the maximum between two values.\n *\n * @example\n * import { SemigroupMax } from '@effect/data/Number'\n *\n * assert.deepStrictEqual(SemigroupMax.combine(2, 3), 3)\n *\n * @category instances\n * @since 1.0.0\n */\nexports.SemigroupMin = SemigroupMin;\nconst SemigroupMax = /*#__PURE__*/semigroup.max(Order);\n/**\n * `number` monoid under addition.\n *\n * The `empty` value is `0`.\n *\n * @example\n * import { MonoidSum } from '@effect/data/Number'\n *\n * assert.deepStrictEqual(MonoidSum.combine(2, 3), 5)\n * assert.deepStrictEqual(MonoidSum.combine(2, MonoidSum.empty), 2)\n *\n * @category instances\n * @since 1.0.0\n */\nexports.SemigroupMax = SemigroupMax;\nconst MonoidSum = monoid.numberSum;\n/**\n * `number` monoid under multiplication.\n *\n * The `empty` value is `1`.\n *\n * @example\n * import { MonoidMultiply } from '@effect/data/Number'\n *\n * assert.deepStrictEqual(MonoidMultiply.combine(2, 3), 6)\n * assert.deepStrictEqual(MonoidMultiply.combine(2, MonoidMultiply.empty), 2)\n *\n * @category instances\n * @since 1.0.0\n */\nexports.MonoidSum = MonoidSum;\nconst MonoidMultiply = monoid.numberMultiply;\n/**\n * A `Monoid` that uses the minimum between two values.\n *\n * The `empty` value is `-Infinity`.\n *\n * @example\n * import { MonoidMin } from '@effect/data/Number'\n *\n * assert.deepStrictEqual(MonoidMin.combine(2, 3), 2)\n * assert.deepStrictEqual(MonoidMin.combine(2, MonoidMin.empty), 2)\n *\n * @category instances\n * @since 1.0.0\n */\nexports.MonoidMultiply = MonoidMultiply;\nconst MonoidMin = /*#__PURE__*/bounded.min(Bounded);\n/**\n * A `Monoid` that uses the maximum between two values.\n *\n * The `empty` value is `Infinity`.\n *\n * @example\n * import { MonoidMax } from '@effect/data/Number'\n *\n * assert.deepStrictEqual(MonoidMax.combine(2, 3), 3)\n * assert.deepStrictEqual(MonoidMax.combine(2, MonoidMax.empty), 2)\n *\n * @category instances\n * @since 1.0.0\n */\nexports.MonoidMin = MonoidMin;\nconst MonoidMax = /*#__PURE__*/bounded.max(Bounded);\n/**\n * Determines the sign of a given `number`.\n *\n * @param n - The `number` to determine the sign of.\n *\n * @example\n * import { sign } from '@effect/data/Number'\n *\n * assert.deepStrictEqual(sign(-5), -1)\n * assert.deepStrictEqual(sign(0), 0)\n * assert.deepStrictEqual(sign(5), 1)\n *\n * @category math\n * @since 1.0.0\n */\nexports.MonoidMax = MonoidMax;\nconst sign = n => Order.compare(n, 0);\n/**\n * Takes an `Iterable` of `number`s and returns their sum as a single `number`.\n *\n * @param collection - The collection of `number`s to sum.\n *\n * @example\n * import { sumAll } from '@effect/data/Number'\n *\n * assert.deepStrictEqual(sumAll([2, 3, 4]), 9)\n *\n * @category math\n * @since 1.0.0\n */\nexports.sign = sign;\nconst sumAll = MonoidSum.combineAll;\n/**\n * Takes an `Iterable` of `number`s and returns their multiplication as a single `number`.\n *\n * @param collection - The collection of `number`s to multiply.\n *\n * @example\n * import { multiplyAll } from '@effect/data/Number'\n *\n * assert.deepStrictEqual(multiplyAll([2, 3, 4]), 24)\n *\n * @category math\n * @since 1.0.0\n */\nexports.sumAll = sumAll;\nconst multiplyAll = MonoidMultiply.combineAll;\n/**\n * Returns the remainder left over when one operand is divided by a second operand.\n *\n * It always takes the sign of the dividend.\n *\n * @param self - The dividend.\n * @param divisor - The divisor.\n *\n * @example\n * import { remainder } from \"@effect/data/Number\"\n *\n * assert.deepStrictEqual(remainder(2, 2), 0)\n * assert.deepStrictEqual(remainder(3, 2), 1)\n * assert.deepStrictEqual(remainder(-4, 2), -0)\n *\n * @category math\n * @since 1.0.0\n */\nexports.multiplyAll = multiplyAll;\nconst remainder = /*#__PURE__*/(0, _Function.dual)(2, (self, divisor) => {\n  // https://stackoverflow.com/questions/3966484/why-does-modulus-operator-return-fractional-number-in-javascript/31711034#31711034\n  const selfDecCount = (self.toString().split(\".\")[1] || \"\").length;\n  const divisorDecCount = (divisor.toString().split(\".\")[1] || \"\").length;\n  const decCount = selfDecCount > divisorDecCount ? selfDecCount : divisorDecCount;\n  const selfInt = parseInt(self.toFixed(decCount).replace(\".\", \"\"));\n  const divisorInt = parseInt(divisor.toFixed(decCount).replace(\".\", \"\"));\n  return selfInt % divisorInt / Math.pow(10, decCount);\n});\nexports.remainder = remainder;\n//# sourceMappingURL=Number.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.zipWith = exports.unit = exports.tupled = exports.tuple = exports.traverseTap = exports.traverse = exports.toRefinement = exports.toEither = exports.toArray = exports.tap = exports.sumCompact = exports.sum = exports.subtract = exports.struct = exports.some = exports.sequence = exports.reduceCompact = exports.partitionMap = exports.orElseEither = exports.orElse = exports.none = exports.multiplyCompact = exports.multiply = exports.match = exports.map = exports.liftThrowable = exports.liftPredicate = exports.liftNullable = exports.liftEither = exports.lift2 = exports.let = exports.isSome = exports.isOption = exports.isNone = exports.inspectSome = exports.inspectNone = exports.getRight = exports.getOrder = exports.getOrUndefined = exports.getOrThrowWith = exports.getOrThrow = exports.getOrNull = exports.getOrElse = exports.getOptionalMonoid = exports.getLeft = exports.getFirstSomeSemigroup = exports.getFailureSemigroup = exports.getFailureMonoid = exports.getEquivalence = exports.gen = exports.fromNullable = exports.fromIterable = exports.fromEither = exports.flatten = exports.flatMapNullable = exports.flatMapEither = exports.flatMap = exports.flap = exports.firstSomeOf = exports.filterMap = exports.filter = exports.exists = exports.divide = exports.contains = exports.composeK = exports.bindTo = exports.bind = exports.asUnit = exports.as = exports.appendElement = exports.ap = exports.andThenDiscard = exports.andThenBind = exports.andThen = exports.all = exports.Traversable = exports.SemiProduct = exports.SemiCoproduct = exports.SemiApplicative = exports.SemiAlternative = exports.Product = exports.Pointed = exports.Monad = exports.Invariant = exports.Foldable = exports.FlatMap = exports.Filterable = exports.Do = exports.Covariant = exports.Coproduct = exports.Chainable = exports.Applicative = exports.Alternative = void 0;\nvar Equal = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Equal\"));\nvar _Function = /*#__PURE__*/require(\"@effect/data/Function\");\nvar Gen = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Gen\"));\nvar either = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/internal/Either\"));\nvar option = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/internal/Option\"));\nvar N = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Number\"));\nvar applicative = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/typeclass/Applicative\"));\nvar chainable = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/typeclass/Chainable\"));\nvar covariant = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/typeclass/Covariant\"));\nvar equivalence = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/typeclass/Equivalence\"));\nvar filterable = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/typeclass/Filterable\"));\nvar flatMap_ = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/typeclass/FlatMap\"));\nvar foldable = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/typeclass/Foldable\"));\nvar invariant = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/typeclass/Invariant\"));\nvar monoid = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/typeclass/Monoid\"));\nvar of_ = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/typeclass/Of\"));\nvar order = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/typeclass/Order\"));\nvar product_ = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/typeclass/Product\"));\nvar semiApplicative = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/typeclass/SemiApplicative\"));\nvar semiCoproduct = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/typeclass/SemiCoproduct\"));\nvar semigroup = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/typeclass/Semigroup\"));\nvar semiProduct = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/typeclass/SemiProduct\"));\nvar traversable = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/typeclass/Traversable\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/**\n * Creates a new `Option` that represents the absence of a value.\n *\n * @category constructors\n * @since 1.0.0\n */\nconst none = () => option.none;\n/**\n * Creates a new `Option` that wraps the given value.\n *\n * @param value - The value to wrap.\n *\n * @category constructors\n * @since 1.0.0\n */\nexports.none = none;\nconst some = option.some;\n/**\n * Tests if a value is a `Option`.\n *\n * @param input - The value to check.\n *\n * @example\n * import { some, none, isOption } from '@effect/data/Option'\n *\n * assert.deepStrictEqual(isOption(some(1)), true)\n * assert.deepStrictEqual(isOption(none()), true)\n * assert.deepStrictEqual(isOption({}), false)\n *\n * @category guards\n * @since 1.0.0\n */\nexports.some = some;\nconst isOption = input => typeof input === \"object\" && input != null && \"_tag\" in input && (input[\"_tag\"] === \"None\" || input[\"_tag\"] === \"Some\") && Equal.isEqual(input);\n/**\n * Determine if a `Option` is a `None`.\n *\n * @param self - The `Option` to check.\n *\n * @example\n * import { some, none, isNone } from '@effect/data/Option'\n *\n * assert.deepStrictEqual(isNone(some(1)), false)\n * assert.deepStrictEqual(isNone(none()), true)\n *\n * @category guards\n * @since 1.0.0\n */\nexports.isOption = isOption;\nconst isNone = option.isNone;\n/**\n * Determine if a `Option` is a `Some`.\n *\n * @param self - The `Option` to check.\n *\n * @example\n * import { some, none, isSome } from '@effect/data/Option'\n *\n * assert.deepStrictEqual(isSome(some(1)), true)\n * assert.deepStrictEqual(isSome(none()), false)\n *\n * @category guards\n * @since 1.0.0\n */\nexports.isNone = isNone;\nconst isSome = option.isSome;\n/**\n * Matches the given `Option` and returns either the provided `onNone` value or the result of the provided `onSome`\n * function when passed the `Option`'s value.\n *\n * @param self - The `Option` to match\n * @param onNone - The value to be returned if the `Option` is `None`\n * @param onSome - The function to be called if the `Option` is `Some`, it will be passed the `Option`'s value and its result will be returned\n *\n * @example\n * import { some, none, match } from '@effect/data/Option'\n * import { pipe } from \"@effect/data/Function\"\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     some(1),\n *     match(() => 'a none', a => `a some containing ${a}`)\n *   ),\n *   'a some containing 1'\n * )\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     none(),\n *     match(() => 'a none', a => `a some containing ${a}`)\n *   ),\n *   'a none'\n * )\n *\n * @category pattern matching\n * @since 1.0.0\n */\nexports.isSome = isSome;\nconst match = /*#__PURE__*/(0, _Function.dual)(3, (self, onNone, onSome) => isNone(self) ? onNone() : onSome(self.value));\n/**\n * Returns a type guard from a `Option` returning function.\n * This function ensures that a type guard definition is type-safe.\n *\n * @example\n * import * as O from \"@effect/data/Option\"\n *\n * const parsePositive = (n: number): O.Option<number> =>\n *   n > 0 ? O.some(n) : O.none()\n *\n * const isPositive = O.toRefinement(parsePositive)\n *\n * assert.deepStrictEqual(isPositive(1), true)\n * assert.deepStrictEqual(isPositive(-1), false)\n *\n * @category conversions\n * @since 1.0.0\n */\nexports.match = match;\nconst toRefinement = f => a => isSome(f(a));\n/**\n * Converts an `Iterable` of values into an `Option`. Returns the first value of the `Iterable` wrapped in a `Some`\n * if the `Iterable` is not empty, otherwise returns `None`.\n *\n * @param collection - The `Iterable` to be converted to an `Option`.\n *\n * @example\n * import { fromIterable, some, none } from '@effect/data/Option'\n *\n * assert.deepStrictEqual(fromIterable([1, 2, 3]), some(1))\n * assert.deepStrictEqual(fromIterable([]), none())\n *\n * @category conversions\n * @since 1.0.0\n */\nexports.toRefinement = toRefinement;\nconst fromIterable = collection => {\n  for (const a of collection) {\n    return some(a);\n  }\n  return none();\n};\n/**\n * Converts a `Either` to an `Option` discarding the error.\n *\n * @param self - The `Either` to convert to an `Option`.\n *\n * @example\n * import * as O from \"@effect/data/Option\"\n * import * as E from \"@effect/data/Either\"\n *\n * assert.deepStrictEqual(O.fromEither(E.right(1)), O.some(1))\n * assert.deepStrictEqual(O.fromEither(E.left('error message')), O.none())\n *\n * @category conversions\n * @since 1.0.0\n */\nexports.fromIterable = fromIterable;\nconst fromEither = either.getRight;\n/**\n * Converts a `Either` to an `Option` discarding the error.\n *\n * Alias of {@link fromEither}.\n *\n * @example\n * import * as O from \"@effect/data/Option\"\n * import * as E from \"@effect/data/Either\"\n *\n * assert.deepStrictEqual(O.getRight(E.right('ok')), O.some('ok'))\n * assert.deepStrictEqual(O.getRight(E.left('err')), O.none())\n *\n * @category conversions\n * @since 1.0.0\n */\nexports.fromEither = fromEither;\nconst getRight = fromEither;\n/**\n * Converts a `Either` to an `Option` discarding the value.\n *\n * @example\n * import * as O from \"@effect/data/Option\"\n * import * as E from \"@effect/data/Either\"\n *\n * assert.deepStrictEqual(O.getLeft(E.right(\"ok\")), O.none())\n * assert.deepStrictEqual(O.getLeft(E.left(\"error\")), O.some(\"error\"))\n *\n * @category conversions\n * @since 1.0.0\n */\nexports.getRight = getRight;\nconst getLeft = either.getLeft;\n/**\n * Converts an `Option` to an `Either`, allowing you to provide a value to be used in the case of a `None`.\n *\n * @param self - the `Option` to convert.\n * @param onNone - a function that produces an error value when the `Option` is `None`.\n *\n * @example\n * import { pipe } from \"@effect/data/Function\"\n * import * as O from \"@effect/data/Option\"\n * import * as E from \"@effect/data/Either\"\n *\n * const onNone = () => 'error'\n * assert.deepStrictEqual(pipe(O.some(1), O.toEither(onNone)), E.right(1))\n * assert.deepStrictEqual(pipe(O.none(), O.toEither(onNone)), E.left('error'))\n *\n * @category conversions\n * @since 1.0.0\n */\nexports.getLeft = getLeft;\nconst toEither = either.fromOption;\n/**\n * Returns the value of the `Option` if it is `Some`, otherwise returns `onNone`\n *\n * @param self - The `Option` to get the value of.\n * @param onNone - Function that returns the default value to return if the `Option` is `None`.\n *\n * @example\n * import { some, none, getOrElse } from '@effect/data/Option'\n * import { pipe } from \"@effect/data/Function\"\n *\n * assert.deepStrictEqual(pipe(some(1), getOrElse(() => 0)), 1)\n * assert.deepStrictEqual(pipe(none(), getOrElse(() => 0)), 0)\n *\n * @category getters\n * @since 1.0.0\n */\nexports.toEither = toEither;\nconst getOrElse = /*#__PURE__*/(0, _Function.dual)(2, (self, onNone) => isNone(self) ? onNone() : self.value);\n/**\n * Returns the provided `Option` `that` if `self` is `None`, otherwise returns `self`.\n *\n * @param self - The first `Option` to be checked.\n * @param that - The `Option` to return if `self` is `None`.\n *\n * @example\n * import * as O from \"@effect/data/Option\"\n * import { pipe } from \"@effect/data/Function\"\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     O.none(),\n *     O.orElse(() => O.none())\n *   ),\n *   O.none()\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     O.some('a'),\n *     O.orElse(() => O.none())\n *   ),\n *   O.some('a')\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     O.none(),\n *     O.orElse(() => O.some('b'))\n *   ),\n *   O.some('b')\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     O.some('a'),\n *     O.orElse(() => O.some('b'))\n *   ),\n *   O.some('a')\n * )\n *\n * @category error handling\n * @since 1.0.0\n */\nexports.getOrElse = getOrElse;\nconst orElse = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => isNone(self) ? that() : self);\n/**\n * Similar to `orElse`, but instead of returning a simple union, it returns an `Either` object,\n * which contains information about which of the two `Option`s has been chosen.\n *\n * This is useful when it's important to know whether the value was retrieved from the first `Option` or the second option.\n *\n * @param self - The first `Option` to be checked.\n * @param that - The second `Option` to be considered if the first `Option` is `None`.\n *\n * @category error handling\n * @since 1.0.0\n */\nexports.orElse = orElse;\nconst orElseEither = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => isNone(self) ? map(that(), either.right) : map(self, either.left));\n/**\n * Given an `Iterable` collection of `Option`s, returns the first `Some` found in the collection.\n *\n * @param collection - An iterable collection of `Option` to be searched.\n *\n * @example\n * import * as O from \"@effect/data/Option\"\n *\n * assert.deepStrictEqual(O.firstSomeOf([O.none(), O.some(1), O.some(2)]), O.some(1))\n *\n * @category error handling\n * @since 1.0.0\n */\nexports.orElseEither = orElseEither;\nconst firstSomeOf = collection => {\n  let out = none();\n  for (out of collection) {\n    if (isSome(out)) {\n      return out;\n    }\n  }\n  return out;\n};\n/**\n * Similar to `Promise.all` but operates on `Option`s.\n *\n * ```\n * Iterable<Option<A>> -> Option<A[]>\n * ```\n *\n * Flattens a collection of `Option`s into a single `Option` that contains a list of all the `Some` values.\n * If there is a `None` value in the collection, it returns `None` as the result.\n *\n * @param collection - An iterable collection of `Option`s to flatten.\n *\n * @example\n * import * as O from \"@effect/data/Option\"\n *\n * assert.deepStrictEqual(O.all([O.some(1), O.some(2), O.some(3)]), O.some([1, 2, 3]))\n * assert.deepStrictEqual(O.all([O.some(1), O.none(), O.some(3)]), O.none())\n *\n * @category combining\n * @since 1.0.0\n */\nexports.firstSomeOf = firstSomeOf;\nconst all = collection => {\n  const out = [];\n  for (const o of collection) {\n    if (isNone(o)) {\n      return none();\n    }\n    out.push(o.value);\n  }\n  return some(out);\n};\n/**\n * Constructs a new `Option` from a nullable type. If the value is `null` or `undefined`, returns `None`, otherwise\n * returns the value wrapped in a `Some`.\n *\n * @param nullableValue - The nullable value to be converted to an `Option`.\n *\n * @example\n * import * as O from \"@effect/data/Option\"\n *\n * assert.deepStrictEqual(O.fromNullable(undefined), O.none())\n * assert.deepStrictEqual(O.fromNullable(null), O.none())\n * assert.deepStrictEqual(O.fromNullable(1), O.some(1))\n *\n * @category conversions\n * @since 1.0.0\n */\nexports.all = all;\nconst fromNullable = nullableValue => nullableValue == null ? none() : some(nullableValue);\n/**\n * This API is useful for lifting a function that returns `null` or `undefined` into the `Option` context.\n *\n * @example\n * import * as O from \"@effect/data/Option\"\n *\n * const parse = (s: string): number | undefined => {\n *   const n = parseFloat(s)\n *   return isNaN(n) ? undefined : n\n * }\n *\n * const parseOption = O.liftNullable(parse)\n *\n * assert.deepStrictEqual(parseOption('1'), O.some(1))\n * assert.deepStrictEqual(parseOption('not a number'), O.none())\n *\n * @category conversions\n * @since 1.0.0\n */\nexports.fromNullable = fromNullable;\nconst liftNullable = f => (...a) => fromNullable(f(...a));\n/**\n * Returns the value of the `Option` if it is a `Some`, otherwise returns `null`.\n *\n * @param self - The `Option` to extract the value from.\n *\n * @example\n * import * as O from \"@effect/data/Option\"\n *\n * assert.deepStrictEqual(O.getOrNull(O.some(1)), 1)\n * assert.deepStrictEqual(O.getOrNull(O.none()), null)\n *\n * @category getters\n * @since 1.0.0\n */\nexports.liftNullable = liftNullable;\nconst getOrNull = /*#__PURE__*/getOrElse(_Function.constNull);\n/**\n * Returns the value of the `Option` if it is a `Some`, otherwise returns `undefined`.\n *\n * @param self - The `Option` to extract the value from.\n *\n * @example\n * import * as O from \"@effect/data/Option\"\n *\n * assert.deepStrictEqual(O.getOrUndefined(O.some(1)), 1)\n * assert.deepStrictEqual(O.getOrUndefined(O.none()), undefined)\n *\n * @category getters\n * @since 1.0.0\n */\nexports.getOrNull = getOrNull;\nconst getOrUndefined = /*#__PURE__*/getOrElse(_Function.constUndefined);\n/**\n * A utility function that lifts a function that throws exceptions into a function that returns an `Option`.\n *\n * This function is useful for any function that might throw an exception, allowing the developer to handle\n * the exception in a more functional way.\n *\n * @param f - the function that can throw exceptions.\n *\n * @example\n * import * as O from \"@effect/data/Option\"\n *\n * const parse = O.liftThrowable(JSON.parse)\n *\n * assert.deepStrictEqual(parse(\"1\"), O.some(1))\n * assert.deepStrictEqual(parse(\"\"), O.none())\n *\n * @category conversions\n * @since 1.0.0\n */\nexports.getOrUndefined = getOrUndefined;\nconst liftThrowable = f => (...a) => {\n  try {\n    return some(f(...a));\n  } catch (e) {\n    return none();\n  }\n};\n/**\n * Extracts the value of an `Option` or throws if the `Option` is `None`.\n *\n * If a default error is sufficient for your use case and you don't need to configure the thrown error, see {@link getOrThrow}.\n *\n * @param self - The `Option` to extract the value from.\n * @param onNone - A function that will be called if the `Option` is `None`. It returns the error to be thrown.\n *\n * @example\n * import * as O from \"@effect/data/Option\"\n *\n * assert.deepStrictEqual(\n *   O.getOrThrowWith(O.some(1), () => new Error('Unexpected None')),\n *   1\n * )\n * assert.throws(() => O.getOrThrowWith(O.none(), () => new Error('Unexpected None')))\n *\n * @category conversions\n * @since 1.0.0\n */\nexports.liftThrowable = liftThrowable;\nconst getOrThrowWith = /*#__PURE__*/(0, _Function.dual)(2, (self, onNone) => {\n  if (isSome(self)) {\n    return self.value;\n  }\n  throw onNone();\n});\n/**\n * Extracts the value of an `Option` or throws if the `Option` is `None`.\n *\n * The thrown error is a default error. To configure the error thrown, see  {@link getOrThrowWith}.\n *\n * @param self - The `Option` to extract the value from.\n * @throws `Error(\"getOrThrow called on a None\")`\n *\n * @example\n * import * as O from \"@effect/data/Option\"\n *\n * assert.deepStrictEqual(O.getOrThrow(O.some(1)), 1)\n * assert.throws(() => O.getOrThrow(O.none()))\n *\n * @category conversions\n * @since 1.0.0\n */\nexports.getOrThrowWith = getOrThrowWith;\nconst getOrThrow = /*#__PURE__*/getOrThrowWith(() => new Error(\"getOrThrow called on a None\"));\n/**\n * Maps the `Some` side of an `Option` value to a new `Option` value.\n *\n * @param self - An `Option` to map\n * @param f - The function to map over the value of the `Option`\n *\n * @category transforming\n * @since 1.0.0\n */\nexports.getOrThrow = getOrThrow;\nconst map = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => isNone(self) ? none() : some(f(self.value)));\nexports.map = map;\nconst imap = /*#__PURE__*/covariant.imap(map);\n/**\n * @since 1.0.0\n */\nconst Covariant = {\n  imap,\n  map\n};\n/**\n * @since 1.0.0\n */\nexports.Covariant = Covariant;\nconst Invariant = {\n  imap\n};\n/**\n * @category transforming\n * @since 1.0.0\n */\nexports.Invariant = Invariant;\nconst flap = /*#__PURE__*/covariant.flap(Covariant);\n/**\n * Maps the `Some` value of this `Option` to the specified constant value.\n *\n * @category transforming\n * @since 1.0.0\n */\nexports.flap = flap;\nconst as = /*#__PURE__*/covariant.as(Covariant);\n/**\n * Maps the `Some` value of this `Option` to the `void` constant value.\n *\n * This is useful when the value of the `Option` is not needed, but the presence or absence of the value is important.\n *\n * @category transforming\n * @since 1.0.0\n */\nexports.as = as;\nconst asUnit = /*#__PURE__*/covariant.asUnit(Covariant);\nexports.asUnit = asUnit;\nconst of = some;\nconst Of = {\n  of\n};\n/**\n * @since 1.0.0\n */\nconst unit = /*#__PURE__*/of_.unit(Of);\n/**\n * @since 1.0.0\n */\nexports.unit = unit;\nconst Pointed = {\n  of,\n  imap,\n  map\n};\n/**\n * Applies a function to the value of an `Option` and flattens the result, if the input is `Some`.\n *\n * @category transforming\n * @since 1.0.0\n */\nexports.Pointed = Pointed;\nconst flatMap = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => isNone(self) ? none() : f(self.value));\n/**\n * Applies a provided function that returns an `Either` to the contents of an `Option`, flattening the result into another `Option`.\n *\n * @param self - The `Option` to apply the function to.\n * @param f - The function to be applied to the contents of the `Option`.\n *\n * @example\n * import * as O from \"@effect/data/Option\"\n * import * as E from \"@effect/data/Either\"\n * import { pipe } from \"@effect/data/Function\"\n *\n * const f = (n: number) => (n > 2 ? E.left('Too big') : E.right(n + 1))\n *\n * assert.deepStrictEqual(pipe(O.some(1), O.flatMapEither(f)), O.some(2))\n * assert.deepStrictEqual(pipe(O.some(3), O.flatMapEither(f)), O.none())\n *\n * @category transforming\n * @since 1.0.0\n */\nexports.flatMap = flatMap;\nconst flatMapEither = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => flatMap(self, liftEither(f)));\n/**\n * This is `flatMap` + `fromNullable`, useful when working with optional values.\n *\n * @example\n * import { some, none, flatMapNullable } from '@effect/data/Option'\n * import { pipe } from \"@effect/data/Function\"\n *\n * interface Employee {\n *   company?: {\n *     address?: {\n *       street?: {\n *         name?: string\n *       }\n *     }\n *   }\n * }\n *\n * const employee1: Employee = { company: { address: { street: { name: 'high street' } } } }\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     some(employee1),\n *     flatMapNullable(employee => employee.company?.address?.street?.name),\n *   ),\n *   some('high street')\n * )\n *\n * const employee2: Employee = { company: { address: { street: {} } } }\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     some(employee2),\n *     flatMapNullable(employee => employee.company?.address?.street?.name),\n *   ),\n *   none()\n * )\n *\n * @category transforming\n * @since 1.0.0\n */\nexports.flatMapEither = flatMapEither;\nconst flatMapNullable = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => isNone(self) ? none() : fromNullable(f(self.value)));\n/**\n * @since 1.0.0\n */\nexports.flatMapNullable = flatMapNullable;\nconst FlatMap = {\n  flatMap\n};\n/**\n * @category transforming\n * @since 1.0.0\n */\nexports.FlatMap = FlatMap;\nconst flatten = /*#__PURE__*/flatMap_.flatten(FlatMap);\n/**\n * @category transforming\n * @since 1.0.0\n */\nexports.flatten = flatten;\nconst andThen = /*#__PURE__*/flatMap_.andThen(FlatMap);\n/**\n * @category transforming\n * @since 1.0.0\n */\nexports.andThen = andThen;\nconst composeK = /*#__PURE__*/flatMap_.composeK(FlatMap);\n/**\n * @since 1.0.0\n */\nexports.composeK = composeK;\nconst Chainable = {\n  imap,\n  map,\n  flatMap\n};\n/**\n * Sequences the specified `that` `Option` but ignores its value.\n *\n * It is useful when we want to chain multiple operations, but only care about the result of `self`.\n *\n * @param that - The `Option` that will be ignored in the chain and discarded\n * @param self - The `Option` we care about\n *\n * @category transforming\n * @since 1.0.0\n */\nexports.Chainable = Chainable;\nconst andThenDiscard = /*#__PURE__*/chainable.andThenDiscard(Chainable);\n/**\n * Applies the provided function `f` to the value of the `Option` if it is `Some` and returns the original `Option`\n * unless `f` returns `None`, in which case it returns `None`.\n *\n * This function is useful for performing additional computations on the value of the input `Option` without affecting its value.\n *\n * @param f - Function to apply to the value of the `Option` if it is `Some`\n * @param self - The `Option` to apply the function to\n *\n * @example\n * import * as O from \"@effect/data/Option\"\n *\n * const getInteger = (n: number) => Number.isInteger(n) ? O.some(n) : O.none()\n *\n * assert.deepStrictEqual(O.tap(O.none(), getInteger), O.none())\n * assert.deepStrictEqual(O.tap(O.some(1), getInteger), O.some(1))\n * assert.deepStrictEqual(O.tap(O.some(1.14), getInteger), O.none())\n *\n * @category transforming\n * @since 1.0.0\n */\nexports.andThenDiscard = andThenDiscard;\nconst tap = /*#__PURE__*/chainable.tap(Chainable);\n/**\n * Useful for debugging purposes, the `onSome` callback is called with the value of `self` if it is a `Some`.\n *\n * @param self - the `Option` to inspect\n * @param onSome - callback function that is called with the value of `self` if it is a `Some`\n *\n * @category debugging\n * @since 1.0.0\n */\nexports.tap = tap;\nconst inspectSome = /*#__PURE__*/(0, _Function.dual)(2, (self, onSome) => {\n  if (isSome(self)) {\n    onSome(self.value);\n  }\n  return self;\n});\n/**\n * Useful for debugging purposes, the `onNone` callback is is called if `self` is a `None`.\n *\n * @param self - the `Option` to inspect\n * @param onNone - callback function that is is called if `self` is a `None`\n *\n * @category debugging\n * @since 1.0.0\n */\nexports.inspectSome = inspectSome;\nconst inspectNone = /*#__PURE__*/(0, _Function.dual)(2, (self, onNone) => {\n  if (isNone(self)) {\n    onNone();\n  }\n  return self;\n});\n/**\n * @since 1.0.0\n */\nexports.inspectNone = inspectNone;\nconst Monad = {\n  imap,\n  of,\n  map,\n  flatMap\n};\nexports.Monad = Monad;\nconst product = (self, that) => isSome(self) && isSome(that) ? some([self.value, that.value]) : none();\nconst productMany = (self, collection) => {\n  if (isNone(self)) {\n    return none();\n  }\n  const out = [self.value];\n  for (const o of collection) {\n    if (isNone(o)) {\n      return none();\n    }\n    out.push(o.value);\n  }\n  return some(out);\n};\n/**\n * @since 1.0.0\n */\nconst SemiProduct = {\n  imap,\n  product,\n  productMany\n};\n/**\n * @since 1.0.0\n */\nexports.SemiProduct = SemiProduct;\nconst Product = {\n  of,\n  imap,\n  product,\n  productMany,\n  productAll: all\n};\n/**\n * Similar to `Promise.all` but operates on `Option`s.\n *\n * ```\n * [Option<A>, Option<B>, ...] -> Option<[A, B, ...]>\n * ```\n *\n * Takes a tuple of `Option`s and returns an `Option` of a tuple of values.\n *\n * @param elements - the tuple of `Option`s to be sequenced.\n *\n * @example\n * import * as O from \"@effect/data/Option\"\n *\n * assert.deepStrictEqual(O.tuple(O.some(1), O.some(\"hello\")), O.some([1, \"hello\"]))\n * assert.deepStrictEqual(O.tuple(O.some(1), O.none()), O.none())\n *\n * @category combining\n * @since 1.0.0\n */\nexports.Product = Product;\nconst tuple = /*#__PURE__*/product_.tuple(Product);\n/**\n * Takes a struct of `Option`s and returns an `Option` of a struct of values.\n *\n * @param fields - the struct of `Option`s to be sequenced.\n *\n * @example\n * import * as O from \"@effect/data/Option\"\n *\n * assert.deepStrictEqual(O.struct({ a: O.some(1), b: O.some(\"hello\") }), O.some({ a: 1, b: \"hello\" }))\n * assert.deepStrictEqual(O.struct({ a: O.some(1), b: O.none() }), O.none())\n *\n * @category combining\n * @since 1.0.0\n */\nexports.tuple = tuple;\nconst struct = /*#__PURE__*/product_.struct(Product);\n/**\n * @since 1.0.0\n */\nexports.struct = struct;\nconst SemiApplicative = {\n  imap,\n  map,\n  product,\n  productMany\n};\n/**\n * Monoid that models the combination of values that may be absent, elements that are `None` are ignored\n * while elements that are `Some` are combined using the provided `Semigroup`.\n *\n * The `empty` value is `none()`.\n *\n * @param Semigroup - The `Semigroup` used to combine two values of type `A`.\n *\n * @example\n * import * as O from \"@effect/data/Option\"\n * import * as N from '@effect/data/Number'\n * import { pipe } from \"@effect/data/Function\"\n *\n * const M = O.getOptionalMonoid(N.SemigroupSum)\n *\n * assert.deepStrictEqual(M.combine(O.none(), O.none()), O.none())\n * assert.deepStrictEqual(M.combine(O.some(1), O.none()), O.some(1))\n * assert.deepStrictEqual(M.combine(O.none(), O.some(1)), O.some(1))\n * assert.deepStrictEqual(M.combine(O.some(1), O.some(2)), O.some(3))\n *\n * @since 1.0.0\n */\nexports.SemiApplicative = SemiApplicative;\nconst getOptionalMonoid = Semigroup => monoid.fromSemigroup(semigroup.make((self, that) => isNone(self) ? that : isNone(that) ? self : some(Semigroup.combine(self.value, that.value))), none());\n/**\n * Zips two `Option` values together using a provided function, returning a new `Option` of the result.\n *\n * @param self - The left-hand side of the zip operation\n * @param that - The right-hand side of the zip operation\n * @param f - The function used to combine the values of the two `Option`s\n *\n * @example\n * import * as O from \"@effect/data/Option\"\n *\n * type Complex = [number, number]\n *\n * const complex = (real: number, imaginary: number): Complex => [real, imaginary]\n *\n * assert.deepStrictEqual(O.zipWith(O.none(), O.none(), complex), O.none())\n * assert.deepStrictEqual(O.zipWith(O.some(1), O.none(), complex), O.none())\n * assert.deepStrictEqual(O.zipWith(O.none(), O.some(1), complex), O.none())\n * assert.deepStrictEqual(O.zipWith(O.some(1), O.some(2), complex), O.some([1, 2]))\n *\n * assert.deepStrictEqual(O.zipWith(O.some(1), complex)(O.some(2)), O.some([2, 1]))\n *\n * @category combining\n * @since 1.0.0\n */\nexports.getOptionalMonoid = getOptionalMonoid;\nconst zipWith = /*#__PURE__*/semiApplicative.zipWith(SemiApplicative);\n/**\n * @category combining\n * @since 1.0.0\n */\nexports.zipWith = zipWith;\nconst ap = /*#__PURE__*/semiApplicative.ap(SemiApplicative);\n/**\n * Semigroup that models the combination of computations that can fail, if at least one element is `None`\n * then the resulting combination is `None`, otherwise if all elements are `Some` then the resulting combination\n * is the combination of the wrapped elements using the provided `Semigroup`.\n *\n * See also `getFailureMonoid` if you need a `Monoid` instead of a `Semigroup`.\n *\n * @category combining\n * @since 1.0.0\n */\nexports.ap = ap;\nconst getFailureSemigroup = /*#__PURE__*/semiApplicative.getSemigroup(SemiApplicative);\n/**\n * @since 1.0.0\n */\nexports.getFailureSemigroup = getFailureSemigroup;\nconst Applicative = {\n  imap,\n  of,\n  map,\n  product,\n  productMany,\n  productAll: all\n};\n/**\n * Monoid that models the combination of computations that can fail, if at least one element is `None`\n * then the resulting combination is `None`, otherwise if all elements are `Some` then the resulting combination\n * is the combination of the wrapped elements using the provided `Monoid`.\n *\n * The `empty` value is `some(M.empty)`.\n *\n * See also `getFailureSemigroup` if you need a `Semigroup` instead of a `Monoid`.\n *\n * @category combining\n * @since 1.0.0\n */\nexports.Applicative = Applicative;\nconst getFailureMonoid = /*#__PURE__*/applicative.getMonoid(Applicative);\nexports.getFailureMonoid = getFailureMonoid;\nconst coproduct = (self, that) => isSome(self) ? self : that;\nconst coproductMany = (self, collection) => isSome(self) ? self : firstSomeOf(collection);\n/**\n * @since 1.0.0\n */\nconst SemiCoproduct = {\n  imap,\n  coproduct,\n  coproductMany\n};\n/**\n * Semigroup returning the first `Some` value encountered.\n *\n * @category combining\n * @since 1.0.0\n */\nexports.SemiCoproduct = SemiCoproduct;\nconst getFirstSomeSemigroup = /*#__PURE__*/semiCoproduct.getSemigroup(SemiCoproduct);\n/**\n * @since 1.0.0\n */\nexports.getFirstSomeSemigroup = getFirstSomeSemigroup;\nconst Coproduct = {\n  imap,\n  coproduct,\n  coproductMany,\n  zero: none,\n  coproductAll: firstSomeOf\n};\n/**\n * @since 1.0.0\n */\nexports.Coproduct = Coproduct;\nconst SemiAlternative = {\n  map,\n  imap,\n  coproduct,\n  coproductMany\n};\n/**\n * @since 1.0.0\n */\nexports.SemiAlternative = SemiAlternative;\nconst Alternative = {\n  map,\n  imap,\n  coproduct,\n  coproductMany,\n  coproductAll: firstSomeOf,\n  zero: none\n};\n/**\n * Reduces an `Iterable` of `Option<A>` to a single value of type `B`, elements that are `None` are ignored.\n *\n * @param self - The Iterable of `Option<A>` to be reduced.\n * @param b - The initial value of the accumulator.\n * @param f - The reducing function that takes the current accumulator value and the unwrapped value of an `Option<A>`.\n *\n * @example\n * import { some, none, reduceCompact } from '@effect/data/Option'\n * import { pipe } from \"@effect/data/Function\"\n *\n * const iterable = [some(1), none(), some(2), none()]\n * assert.deepStrictEqual(pipe(iterable, reduceCompact(0, (b, a) => b + a)), 3)\n *\n * @category folding\n * @since 1.0.0\n */\nexports.Alternative = Alternative;\nconst reduceCompact = /*#__PURE__*/(0, _Function.dual)(3, (self, b, f) => {\n  let out = b;\n  for (const oa of self) {\n    if (isSome(oa)) {\n      out = f(out, oa.value);\n    }\n  }\n  return out;\n});\n/**\n * @since 1.0.0\n */\nexports.reduceCompact = reduceCompact;\nconst Foldable = {\n  reduce: /*#__PURE__*/(0, _Function.dual)(3, (self, b, f) => isNone(self) ? b : f(b, self.value))\n};\n/**\n * Transforms an `Option` into an `Array`.\n * If the input is `None`, an empty array is returned.\n * If the input is `Some`, the value is wrapped in an array.\n *\n * @param self - The `Option` to convert to an array.\n *\n * @example\n * import * as O from \"@effect/data/Option\"\n *\n * assert.deepStrictEqual(O.toArray(O.some(1)), [1])\n * assert.deepStrictEqual(O.toArray(O.none()), [])\n *\n * @category conversions\n * @since 1.0.0\n */\nexports.Foldable = Foldable;\nconst toArray = /*#__PURE__*/foldable.toArray(Foldable);\n/**\n * @category filtering\n * @since 1.0.0\n */\nexports.toArray = toArray;\nconst partitionMap = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => {\n  if (isNone(self)) {\n    return [none(), none()];\n  }\n  const e = f(self.value);\n  return either.isLeft(e) ? [some(e.left), none()] : [none(), some(e.right)];\n});\n/**\n * Maps over the value of an `Option` and filters out `None`s.\n *\n * Useful when in addition to filtering you also want to change the type of the `Option`.\n *\n * @param self - The `Option` to map over.\n * @param f - A function to apply to the value of the `Option`.\n *\n * @example\n * import * as O from \"@effect/data/Option\"\n *\n * const evenNumber = (n: number) => n % 2 === 0 ? O.some(n) : O.none()\n *\n * assert.deepStrictEqual(O.filterMap(O.none(), evenNumber), O.none())\n * assert.deepStrictEqual(O.filterMap(O.some(3), evenNumber), O.none())\n * assert.deepStrictEqual(O.filterMap(O.some(2), evenNumber), O.some(2))\n *\n * @category filtering\n * @since 1.0.0\n */\nexports.partitionMap = partitionMap;\nconst filterMap = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => isNone(self) ? none() : f(self.value));\n/**\n * @since 1.0.0\n */\nexports.filterMap = filterMap;\nconst Filterable = {\n  partitionMap,\n  filterMap\n};\n/**\n * Filters an `Option` using a predicate. If the predicate is not satisfied or the `Option` is `None` returns `None`.\n *\n * If you need to change the type of the `Option` in addition to filtering, see `filterMap`.\n *\n * @param predicate - A predicate function to apply to the `Option` value.\n * @param fb - The `Option` to filter.\n *\n * @example\n * import * as O from \"@effect/data/Option\"\n *\n * // predicate\n * const isEven = (n: number) => n % 2 === 0\n *\n * assert.deepStrictEqual(O.filter(O.none(), isEven), O.none())\n * assert.deepStrictEqual(O.filter(O.some(3), isEven), O.none())\n * assert.deepStrictEqual(O.filter(O.some(2), isEven), O.some(2))\n *\n * // refinement\n * const isNumber = (v: unknown): v is number => typeof v === \"number\"\n *\n * assert.deepStrictEqual(O.filter(O.none(), isNumber), O.none())\n * assert.deepStrictEqual(O.filter(O.some('hello'), isNumber), O.none())\n * assert.deepStrictEqual(O.filter(O.some(2), isNumber), O.some(2))\n *\n * @category filtering\n * @since 1.0.0\n */\nexports.Filterable = Filterable;\nconst filter = /*#__PURE__*/filterable.filter(Filterable);\n/**\n * Applies an `Option` value to an effectful function that returns an `F` value.\n *\n * @param F - {@link applicative.Applicative} instance\n * @param self - The `Option` value.\n * @param f - An effectful function that returns an `F` value.\n *\n * @example\n * import * as O from \"@effect/data/Option\"\n * import * as E from \"@effect/data/Either\"\n *\n * const traverse = O.traverse(E.Applicative)\n * const f = (n: number) => n >= 0 ? E.right(1) : E.left(\"negative\")\n *\n * assert.deepStrictEqual(traverse(O.some(1), f), E.right(O.some(1)))\n * assert.deepStrictEqual(traverse(O.some(-1), f), E.left(\"negative\"))\n * assert.deepStrictEqual(traverse(O.none(), f), E.right(O.none()))\n *\n * @category combining\n * @since 1.0.0\n */\nexports.filter = filter;\nconst traverse = F => (0, _Function.dual)(2, (self, f) => isNone(self) ? F.of(none()) : F.map(f(self.value), some));\n/**\n * @since 1.0.0\n */\nexports.traverse = traverse;\nconst Traversable = {\n  traverse\n};\n/**\n * Combines an `Option` of an `F`-structure to an `F`-structure of an `Option` with the same inner type.\n *\n * @param F - {@link applicative.Applicative} instance\n * @param self - `Option` of Kind `F`\n *\n * @example\n * import * as O from \"@effect/data/Option\"\n * import * as E from \"@effect/data/Either\"\n *\n * const sequence = O.sequence(E.Applicative)\n *\n * assert.deepStrictEqual(sequence(O.some(E.right(1))), E.right(O.some(1)))\n * assert.deepStrictEqual(sequence(O.some(E.left(\"error\"))), E.left(\"error\"))\n * assert.deepStrictEqual(sequence(O.none()), E.right(O.none()))\n *\n * @category combining\n * @since 1.0.0\n */\nexports.Traversable = Traversable;\nconst sequence = /*#__PURE__*/traversable.sequence(Traversable);\n/**\n * @category combining\n * @since 1.0.0\n */\nexports.sequence = sequence;\nconst traverseTap = /*#__PURE__*/traversable.traverseTap(Traversable);\n/**\n * @example\n * import { none, some, getEquivalence } from '@effect/data/Option'\n * import * as N from '@effect/data/Number'\n *\n * const isEquivalent = getEquivalence(N.Equivalence)\n * assert.deepStrictEqual(isEquivalent(none(), none()), true)\n * assert.deepStrictEqual(isEquivalent(none(), some(1)), false)\n * assert.deepStrictEqual(isEquivalent(some(1), none()), false)\n * assert.deepStrictEqual(isEquivalent(some(1), some(2)), false)\n * assert.deepStrictEqual(isEquivalent(some(1), some(1)), true)\n *\n * @category equivalence\n * @since 1.0.0\n */\nexports.traverseTap = traverseTap;\nconst getEquivalence = E => equivalence.make((x, y) => x === y || (isNone(x) ? isNone(y) : isNone(y) ? false : E(x.value, y.value)));\n/**\n * The `Order` instance allows `Option` values to be compared with\n * `compare`, whenever there is an `Order` instance for\n * the type the `Option` contains.\n *\n * `None` is considered to be less than any `Some` value.\n *\n * @example\n * import { none, some, getOrder } from '@effect/data/Option'\n * import * as N from '@effect/data/Number'\n * import { pipe } from \"@effect/data/Function\"\n *\n * const O = getOrder(N.Order)\n * assert.deepStrictEqual(O.compare(none(), none()), 0)\n * assert.deepStrictEqual(O.compare(none(), some(1)), -1)\n * assert.deepStrictEqual(O.compare(some(1), none()), 1)\n * assert.deepStrictEqual(O.compare(some(1), some(2)), -1)\n * assert.deepStrictEqual(O.compare(some(1), some(1)), 0)\n *\n * @category sorting\n * @since 1.0.0\n */\nexports.getEquivalence = getEquivalence;\nconst getOrder = O => order.make((self, that) => isSome(self) ? isSome(that) ? O.compare(self.value, that.value) : 1 : -1);\n/**\n * Lifts a binary function into `Option`.\n *\n * @param f - The function to lift.\n *\n * @category lifting\n * @since 1.0.0\n */\nexports.getOrder = getOrder;\nconst lift2 = /*#__PURE__*/semiApplicative.lift2(SemiApplicative);\n/**\n * Transforms a `Predicate` function into a `Some` of the input value if the predicate returns `true` or `None`\n * if the predicate returns `false`.\n *\n * @param predicate - A `Predicate` function that takes in a value of type `A` and returns a boolean.\n *\n * @example\n * import * as O from \"@effect/data/Option\"\n *\n * const getOption = O.liftPredicate((n: number) => n >= 0)\n *\n * assert.deepStrictEqual(getOption(-1), O.none())\n * assert.deepStrictEqual(getOption(1), O.some(1))\n *\n * @category lifting\n * @since 1.0.0\n */\nexports.lift2 = lift2;\nconst liftPredicate = predicate => b => predicate(b) ? some(b) : none();\n/**\n * Lifts an `Either` function to an `Option` function.\n *\n * @param f - Any variadic function that returns an `Either`.\n *\n * @example\n * import * as O from \"@effect/data/Option\"\n * import * as E from \"@effect/data/Either\"\n *\n * const parse = (s: string) =>\n *   isNaN(+s) ? E.left(`Error: ${s} is not a number`) : E.right(+s)\n *\n * const parseNumber = O.liftEither(parse)\n *\n * assert.deepEqual(parseNumber('12'), O.some(12))\n * assert.deepEqual(parseNumber('not a number'), O.none())\n *\n * @category lifting\n * @since 1.0.0\n */\nexports.liftPredicate = liftPredicate;\nconst liftEither = f => (...a) => fromEither(f(...a));\n/**\n * Returns a function that checks if an `Option` contains a given value using a provided `Equivalence` instance.\n *\n * @param equivalent - An `Equivalence` instance to compare values of the `Option`.\n * @param self - The `Option` to apply the comparison to.\n * @param a - The value to compare against the `Option`.\n *\n * @example\n * import { some, none, contains } from '@effect/data/Option'\n * import { Equivalence } from '@effect/data/Number'\n * import { pipe } from \"@effect/data/Function\"\n *\n * assert.deepStrictEqual(pipe(some(2), contains(Equivalence)(2)), true)\n * assert.deepStrictEqual(pipe(some(1), contains(Equivalence)(2)), false)\n * assert.deepStrictEqual(pipe(none(), contains(Equivalence)(2)), false)\n *\n * @since 1.0.0\n */\nexports.liftEither = liftEither;\nconst contains = isEquivalent => (0, _Function.dual)(2, (self, a) => isNone(self) ? false : isEquivalent(self.value, a));\n/**\n * Check if a value in an `Option` type meets a certain predicate.\n *\n * @param self - The `Option` to check.\n * @param predicate - The condition to check.\n *\n * @example\n * import { some, none, exists } from '@effect/data/Option'\n * import { pipe } from \"@effect/data/Function\"\n *\n * const isEven = (n: number) => n % 2 === 0\n *\n * assert.deepStrictEqual(pipe(some(2), exists(isEven)), true)\n * assert.deepStrictEqual(pipe(some(1), exists(isEven)), false)\n * assert.deepStrictEqual(pipe(none(), exists(isEven)), false)\n *\n * @since 1.0.0\n */\nexports.contains = contains;\nconst exists = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => isNone(self) ? false : predicate(self.value));\n// -------------------------------------------------------------------------------------\n// math\n// -------------------------------------------------------------------------------------\n/**\n * @category math\n * @since 1.0.0\n */\nexports.exists = exists;\nconst sum = /*#__PURE__*/lift2(N.sum);\n/**\n * @category math\n * @since 1.0.0\n */\nexports.sum = sum;\nconst multiply = /*#__PURE__*/lift2(N.multiply);\n/**\n * @category math\n * @since 1.0.0\n */\nexports.multiply = multiply;\nconst subtract = /*#__PURE__*/lift2(N.subtract);\n/**\n * @category math\n * @since 1.0.0\n */\nexports.subtract = subtract;\nconst divide = /*#__PURE__*/lift2(N.divide);\n/**\n * Sum all numbers in an iterable of `Option<number>` ignoring the `None` values.\n *\n * @param self - The iterable of `Option<number>` to be summed.\n *\n * @example\n * import { sumCompact, some, none } from '@effect/data/Option'\n *\n * const iterable = [some(2), none(), some(3), none()]\n * assert.deepStrictEqual(sumCompact(iterable), 5)\n *\n * @category math\n * @since 1.0.0\n */\nexports.divide = divide;\nconst sumCompact = self => {\n  let out = 0;\n  for (const oa of self) {\n    if (isSome(oa)) {\n      out += oa.value;\n    }\n  }\n  return out;\n};\n/**\n * Multiply all numbers in an iterable of `Option<number>` ignoring the `None` values.\n *\n * @param self - The iterable of `Option<number>` to be multiplied.\n *\n * @example\n * import { multiplyCompact, some, none } from '@effect/data/Option'\n *\n * const iterable = [some(2), none(), some(3), none()]\n * assert.deepStrictEqual(multiplyCompact(iterable), 6)\n *\n * @category math\n * @since 1.0.0\n */\nexports.sumCompact = sumCompact;\nconst multiplyCompact = self => {\n  let out = 1;\n  for (const oa of self) {\n    if (isSome(oa)) {\n      const a = oa.value;\n      if (a === 0) {\n        return 0;\n      }\n      out *= a;\n    }\n  }\n  return out;\n};\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * @category do notation\n * @since 1.0.0\n */\nexports.multiplyCompact = multiplyCompact;\nconst tupled = /*#__PURE__*/invariant.tupled(Invariant);\n/**\n * Appends an element to the end of a tuple wrapped in an `Option` type.\n *\n * @param self - The option of a tuple to which an element needs to be added.\n * @param that - The element which needs to be added to the tuple.\n *\n * @example\n * import * as O from \"@effect/data/Option\"\n *\n * assert.deepStrictEqual(O.appendElement(O.some([1, 2]), O.some(3)), O.some([1, 2, 3]))\n * assert.deepStrictEqual(O.appendElement(O.some([1, 2]), O.none()), O.none())\n *\n * @category do notation\n * @since 1.0.0\n */\nexports.tupled = tupled;\nconst appendElement = /*#__PURE__*/semiProduct.appendElement(SemiProduct);\n/**\n * @category do notation\n * @since 1.0.0\n */\nexports.appendElement = appendElement;\nconst bindTo = /*#__PURE__*/invariant.bindTo(Invariant);\nexports.bindTo = bindTo;\nconst let_ = /*#__PURE__*/covariant.let(Covariant);\nexports.let = let_;\n/**\n * @category do notation\n * @since 1.0.0\n */\nconst bind = /*#__PURE__*/chainable.bind(Chainable);\n/**\n * @category do notation\n * @since 1.0.0\n */\nexports.bind = bind;\nconst Do = /*#__PURE__*/of_.Do(Of);\n/**\n * A variant of `bind` that sequentially ignores the scope.\n *\n * @category do notation\n * @since 1.0.0\n */\nexports.Do = Do;\nconst andThenBind = /*#__PURE__*/semiProduct.andThenBind(SemiProduct);\n/**\n * The `gen` API is a helper function that provides a generator interface for the `Option` monad instance.\n * It can be used to easily create complex `Option` computations in a readable and concise manner.\n *\n * @example\n * import * as O from \"@effect/data/Option\"\n *\n * assert.deepStrictEqual(\n *   O.gen(function*($) {\n *     const a = yield* $(O.some(1))\n *     const b = yield* $(O.some(2))\n *     return a + b\n *   }),\n *   O.some(3)\n * )\n *\n * @since 1.0.0\n * @category generators\n */\nexports.andThenBind = andThenBind;\nconst gen = /*#__PURE__*/Gen.singleShot(Monad)( /*#__PURE__*/Gen.adapter());\nexports.gen = gen;\n//# sourceMappingURL=Option.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.xor = exports.tupled = exports.tuple = exports.struct = exports.some = exports.or = exports.not = exports.nor = exports.nand = exports.isUnknown = exports.isUndefined = exports.isSymbol = exports.isString = exports.isRecord = exports.isReadonlyRecord = exports.isObject = exports.isNumber = exports.isNullable = exports.isNull = exports.isNotUndefined = exports.isNotNullable = exports.isNotNull = exports.isNever = exports.isFunction = exports.isError = exports.isDate = exports.isBoolean = exports.isBigint = exports.implies = exports.getSemigroupXor = exports.getSemigroupSome = exports.getSemigroupEvery = exports.getSemigroupEqv = exports.getMonoidXor = exports.getMonoidSome = exports.getMonoidEvery = exports.getMonoidEqv = exports.every = exports.eqv = exports.contramap = exports.compose = exports.bindTo = exports.appendElement = exports.andThenBind = exports.and = exports.SemiProduct = exports.Product = exports.Invariant = exports.Do = exports.Contravariant = void 0;\nvar _Function = /*#__PURE__*/require(\"@effect/data/Function\");\nvar readonlyArray = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/internal/ReadonlyArray\"));\nvar contravariant = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/typeclass/Contravariant\"));\nvar invariant = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/typeclass/Invariant\"));\nvar monoid = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/typeclass/Monoid\"));\nvar of_ = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/typeclass/Of\"));\nvar product_ = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/typeclass/Product\"));\nvar semigroup = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/typeclass/Semigroup\"));\nvar semiProduct = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/typeclass/SemiProduct\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/**\n * @since 1.0.0\n */\n\n/**\n * Given a `Predicate<A>` returns a `Predicate<B>`\n *\n * @param self - the `Predicate<A>` to be transformed to `Predicate<B>`.\n * @param f - a function to transform `B` to `A`.\n *\n * @example\n * import * as P from \"@effect/data/Predicate\"\n * import * as N from \"@effect/data/Number\"\n *\n * const minLength3 = P.contramap(N.greaterThan(2), (s: string) => s.length)\n *\n * assert.deepStrictEqual(minLength3(\"a\"), false)\n * assert.deepStrictEqual(minLength3(\"aa\"), false)\n * assert.deepStrictEqual(minLength3(\"aaa\"), true)\n * assert.deepStrictEqual(minLength3(\"aaaa\"), true)\n *\n * @category constructors\n * @since 1.0.0\n */\nconst contramap = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => b => self(f(b)));\n/**\n * Tests if a value is a `string`.\n *\n * @param input - The value to test.\n *\n * @example\n * import { isString } from \"@effect/data/Predicate\"\n *\n * assert.deepStrictEqual(isString(\"a\"), true)\n *\n * assert.deepStrictEqual(isString(1), false)\n *\n * @category guards\n * @since 1.0.0\n */\nexports.contramap = contramap;\nconst isString = input => typeof input === \"string\";\n/**\n * Tests if a value is a `number`.\n *\n * @param input - The value to test.\n *\n * @example\n * import { isNumber } from \"@effect/data/Predicate\"\n *\n * assert.deepStrictEqual(isNumber(2), true)\n *\n * assert.deepStrictEqual(isNumber(\"2\"), false)\n *\n * @category guards\n * @since 1.0.0\n */\nexports.isString = isString;\nconst isNumber = input => typeof input === \"number\";\n/**\n * Tests if a value is a `boolean`.\n *\n * @param input - The value to test.\n *\n * @example\n * import { isBoolean } from \"@effect/data/Predicate\"\n *\n * assert.deepStrictEqual(isBoolean(true), true)\n *\n * assert.deepStrictEqual(isBoolean(\"true\"), false)\n *\n * @category guards\n * @since 1.0.0\n */\nexports.isNumber = isNumber;\nconst isBoolean = input => typeof input === \"boolean\";\n/**\n * Tests if a value is a `bigint`.\n *\n * @param input - The value to test.\n *\n * @example\n * import { isBigint } from \"@effect/data/Predicate\"\n *\n * assert.deepStrictEqual(isBigint(1n), true)\n *\n * assert.deepStrictEqual(isBigint(1), false)\n *\n * @category guards\n * @since 1.0.0\n */\nexports.isBoolean = isBoolean;\nconst isBigint = input => typeof input === \"bigint\";\n/**\n * Tests if a value is a `symbol`.\n *\n * @param input - The value to test.\n *\n * @example\n * import { isSymbol } from \"@effect/data/Predicate\"\n *\n * assert.deepStrictEqual(isSymbol(Symbol.for(\"a\")), true)\n *\n * assert.deepStrictEqual(isSymbol(\"a\"), false)\n *\n * @category guards\n * @since 1.0.0\n */\nexports.isBigint = isBigint;\nconst isSymbol = input => typeof input === \"symbol\";\n/**\n * Tests if a value is a `function`.\n *\n * @param input - The value to test.\n *\n * @example\n * import { isFunction } from \"@effect/data/Predicate\"\n *\n * assert.deepStrictEqual(isFunction(isFunction), true)\n *\n * assert.deepStrictEqual(isFunction(\"function\"), false)\n *\n * @category guards\n * @since 1.0.0\n */\nexports.isSymbol = isSymbol;\nconst isFunction = _Function.isFunction;\n/**\n * Tests if a value is `undefined`.\n *\n * @param input - The value to test.\n *\n * @example\n * import { isUndefined } from \"@effect/data/Predicate\"\n *\n * assert.deepStrictEqual(isUndefined(undefined), true)\n *\n * assert.deepStrictEqual(isUndefined(null), false)\n * assert.deepStrictEqual(isUndefined(\"undefined\"), false)\n *\n * @category guards\n * @since 1.0.0\n */\nexports.isFunction = isFunction;\nconst isUndefined = input => input === undefined;\n/**\n * Tests if a value is not `undefined`.\n *\n * @param input - The value to test.\n *\n * @example\n * import { isNotUndefined } from \"@effect/data/Predicate\"\n *\n * assert.deepStrictEqual(isNotUndefined(null), true)\n * assert.deepStrictEqual(isNotUndefined(\"undefined\"), true)\n *\n * assert.deepStrictEqual(isNotUndefined(undefined), false)\n *\n * @category guards\n * @since 1.0.0\n */\nexports.isUndefined = isUndefined;\nconst isNotUndefined = input => input !== undefined;\n/**\n * Tests if a value is `undefined`.\n *\n * @param input - The value to test.\n *\n * @example\n * import { isNull } from \"@effect/data/Predicate\"\n *\n * assert.deepStrictEqual(isNull(null), true)\n *\n * assert.deepStrictEqual(isNull(undefined), false)\n * assert.deepStrictEqual(isNull(\"null\"), false)\n *\n * @category guards\n * @since 1.0.0\n */\nexports.isNotUndefined = isNotUndefined;\nconst isNull = input => input === null;\n/**\n * Tests if a value is not `undefined`.\n *\n * @param input - The value to test.\n *\n * @example\n * import { isNotNull } from \"@effect/data/Predicate\"\n *\n * assert.deepStrictEqual(isNotNull(undefined), true)\n * assert.deepStrictEqual(isNotNull(\"null\"), true)\n *\n * assert.deepStrictEqual(isNotNull(null), false)\n *\n * @category guards\n * @since 1.0.0\n */\nexports.isNull = isNull;\nconst isNotNull = input => input !== null;\n/**\n * A guard that always fails.\n *\n * @param _ - The value to test.\n *\n * @example\n * import { isNever } from \"@effect/data/Predicate\"\n *\n * assert.deepStrictEqual(isNever(null), false)\n * assert.deepStrictEqual(isNever(undefined), false)\n * assert.deepStrictEqual(isNever({}), false)\n * assert.deepStrictEqual(isNever([]), false)\n *\n * @category guards\n * @since 1.0.0\n */\nexports.isNotNull = isNotNull;\nconst isNever = _ => false;\n/**\n * A guard that always succeeds.\n *\n * @param _ - The value to test.\n *\n * @example\n * import { isUnknown } from \"@effect/data/Predicate\"\n *\n * assert.deepStrictEqual(isUnknown(null), true)\n * assert.deepStrictEqual(isUnknown(undefined), true)\n *\n * assert.deepStrictEqual(isUnknown({}), true)\n * assert.deepStrictEqual(isUnknown([]), true)\n *\n * @category guards\n * @since 1.0.0\n */\nexports.isNever = isNever;\nconst isUnknown = _ => true;\n/**\n * Tests if a value is an `object`.\n *\n * @param input - The value to test.\n *\n * @example\n * import { isObject } from \"@effect/data/Predicate\"\n *\n * assert.deepStrictEqual(isObject({}), true)\n * assert.deepStrictEqual(isObject([]), true)\n *\n * assert.deepStrictEqual(isObject(null), false)\n * assert.deepStrictEqual(isObject(undefined), false)\n *\n * @category guards\n * @since 1.0.0\n */\nexports.isUnknown = isUnknown;\nconst isObject = input => typeof input === \"object\" && input != null;\n/**\n * A guard that succeeds when the input is `null` or `undefined`.\n *\n * @param input - The value to test.\n *\n * @example\n * import { isNullable } from \"@effect/data/Predicate\"\n *\n * assert.deepStrictEqual(isNullable(null), true)\n * assert.deepStrictEqual(isNullable(undefined), true)\n *\n * assert.deepStrictEqual(isNullable({}), false)\n * assert.deepStrictEqual(isNullable([]), false)\n *\n * @category guards\n * @since 1.0.0\n */\nexports.isObject = isObject;\nconst isNullable = input => input === null || input === undefined;\n/**\n * A guard that succeeds when the input is not `null` or `undefined`.\n *\n * @param input - The value to test.\n *\n * @example\n * import { isNotNullable } from \"@effect/data/Predicate\"\n *\n * assert.deepStrictEqual(isNotNullable({}), true)\n * assert.deepStrictEqual(isNotNullable([]), true)\n *\n * assert.deepStrictEqual(isNotNullable(null), false)\n * assert.deepStrictEqual(isNotNullable(undefined), false)\n *\n * @category guards\n * @since 1.0.0\n */\nexports.isNullable = isNullable;\nconst isNotNullable = input => input !== null && input !== undefined;\n/**\n * A guard that succeeds when the input is an `Error`.\n *\n * @param input - The value to test.\n *\n * @example\n * import { isError } from \"@effect/data/Predicate\"\n *\n * assert.deepStrictEqual(isError(new Error()), true)\n *\n * assert.deepStrictEqual(isError(null), false)\n * assert.deepStrictEqual(isError({}), false)\n *\n * @category guards\n * @since 1.0.0\n */\nexports.isNotNullable = isNotNullable;\nconst isError = input => input instanceof Error;\n/**\n * A guard that succeeds when the input is a `Date`.\n *\n * @param input - The value to test.\n *\n * @example\n * import { isDate } from \"@effect/data/Predicate\"\n *\n * assert.deepStrictEqual(isDate(new Date()), true)\n *\n * assert.deepStrictEqual(isDate(null), false)\n * assert.deepStrictEqual(isDate({}), false)\n *\n * @category guards\n * @since 1.0.0\n */\nexports.isError = isError;\nconst isDate = input => input instanceof Date;\n/**\n * A guard that succeeds when the input is a record.\n *\n * @param input - The value to test.\n *\n * @example\n * import { isRecord } from \"@effect/data/Predicate\"\n *\n * assert.deepStrictEqual(isRecord({}), true)\n * assert.deepStrictEqual(isRecord({ a: 1 }), true)\n *\n * assert.deepStrictEqual(isRecord([]), false)\n * assert.deepStrictEqual(isRecord([1, 2, 3]), false)\n * assert.deepStrictEqual(isRecord(null), false)\n * assert.deepStrictEqual(isRecord(undefined), false)\n *\n * @category guards\n * @since 1.0.0\n */\nexports.isDate = isDate;\nconst isRecord = input => isObject(input) && !Array.isArray(input);\n/**\n * A guard that succeeds when the input is a readonly record.\n *\n * @param input - The value to test.\n *\n * @example\n * import { isReadonlyRecord } from \"@effect/data/Predicate\"\n *\n * assert.deepStrictEqual(isReadonlyRecord({}), true)\n * assert.deepStrictEqual(isReadonlyRecord({ a: 1 }), true)\n *\n * assert.deepStrictEqual(isReadonlyRecord([]), false)\n * assert.deepStrictEqual(isReadonlyRecord([1, 2, 3]), false)\n * assert.deepStrictEqual(isReadonlyRecord(null), false)\n * assert.deepStrictEqual(isReadonlyRecord(undefined), false)\n *\n * @category guards\n * @since 1.0.0\n */\nexports.isRecord = isRecord;\nconst isReadonlyRecord = isRecord;\n/**\n * @since 1.0.0\n */\nexports.isReadonlyRecord = isReadonlyRecord;\nconst compose = /*#__PURE__*/(0, _Function.dual)(2, (ab, bc) => a => ab(a) && bc(a));\nexports.compose = compose;\nconst imap = /*#__PURE__*/contravariant.imap(contramap);\n/**\n * @category instances\n * @since 1.0.0\n */\nconst Contravariant = {\n  imap,\n  contramap\n};\n/**\n * @category instances\n * @since 1.0.0\n */\nexports.Contravariant = Contravariant;\nconst Invariant = {\n  imap\n};\n/**\n * @since 1.0.0\n */\nexports.Invariant = Invariant;\nconst tupled = /*#__PURE__*/invariant.tupled(Invariant);\nexports.tupled = tupled;\nconst of = _ => isUnknown;\nconst Of = {\n  of\n};\nconst product = (self, that) => ([a, b]) => self(a) && that(b);\nconst productAll = collection => {\n  const predicates = readonlyArray.fromIterable(collection);\n  return as => {\n    const len = Math.min(as.length, predicates.length);\n    for (let i = 0; i < len; i++) {\n      if (predicates[i](as[i]) === false) {\n        return false;\n      }\n    }\n    return true;\n  };\n};\nconst productMany = (self, collection) => {\n  const rest = productAll(collection);\n  return ([head, ...tail]) => self(head) === false ? false : rest(tail);\n};\n/**\n * @category instances\n * @since 1.0.0\n */\nconst SemiProduct = {\n  imap,\n  product,\n  productMany\n};\n/**\n * @category instances\n * @since 1.0.0\n */\nexports.SemiProduct = SemiProduct;\nconst Product = {\n  of,\n  imap,\n  product,\n  productMany,\n  productAll\n};\n/**\n * This function appends a predicate to a tuple-like predicate, allowing you to create a new predicate that includes\n * the original elements and the new one.\n *\n * @param self - The tuple-like predicate to append to.\n * @param that - The predicate to append.\n *\n * @since 1.0.0\n */\nexports.Product = Product;\nconst appendElement = /*#__PURE__*/semiProduct.appendElement(SemiProduct);\n/**\n * Similar to `Promise.all` but operates on `Predicate`s.\n *\n * ```\n * [Predicate<A>, Predicate<B>, ...] -> Predicate<[A, B, ...]>\n * ```\n *\n * @since 1.0.0\n */\nexports.appendElement = appendElement;\nconst tuple = /*#__PURE__*/product_.tuple(Product);\n/**\n * @since 1.0.0\n */\nexports.tuple = tuple;\nconst struct = /*#__PURE__*/product_.struct(Product);\n/**\n * Negates the result of a given predicate.\n *\n * @param self - A predicate.\n *\n * @example\n * import * as P from \"@effect/data/Predicate\"\n * import * as N from \"@effect/data/Number\"\n *\n * const isPositive = P.not(N.lessThan(0))\n *\n * assert.deepStrictEqual(isPositive(-1), false)\n * assert.deepStrictEqual(isPositive(0), true)\n * assert.deepStrictEqual(isPositive(1), true)\n *\n * @category combinators\n * @since 1.0.0\n */\nexports.struct = struct;\nconst not = self => a => !self(a);\n/**\n * Combines two predicates into a new predicate that returns `true` if at least one of the predicates returns `true`.\n *\n * @param self - A predicate.\n * @param that - A predicate.\n *\n * @example\n * import * as P from \"@effect/data/Predicate\"\n * import * as N from \"@effect/data/Number\"\n *\n * const nonZero = P.or(N.lessThan(0), N.greaterThan(0))\n *\n * assert.deepStrictEqual(nonZero(-1), true)\n * assert.deepStrictEqual(nonZero(0), false)\n * assert.deepStrictEqual(nonZero(1), true)\n *\n * @category combinators\n * @since 1.0.0\n */\nexports.not = not;\nconst or = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => a => self(a) || that(a));\n/**\n * Combines two predicates into a new predicate that returns `true` if both of the predicates returns `true`.\n *\n * @param self - A predicate.\n * @param that - A predicate.\n *\n * @example\n * import * as P from \"@effect/data/Predicate\"\n *\n * const minLength = (n: number) => (s: string) => s.length >= n\n * const maxLength = (n: number) => (s: string) => s.length <= n\n *\n * const length = (n: number) => P.and(minLength(n), maxLength(n))\n *\n * assert.deepStrictEqual(length(2)(\"aa\"), true)\n * assert.deepStrictEqual(length(2)(\"a\"), false)\n * assert.deepStrictEqual(length(2)(\"aaa\"), false)\n *\n * @category combinators\n * @since 1.0.0\n */\nexports.or = or;\nconst and = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => a => self(a) && that(a));\n/**\n * @category combinators\n * @since 1.0.0\n */\nexports.and = and;\nconst xor = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => a => self(a) !== that(a));\n/**\n * @category combinators\n * @since 1.0.0\n */\nexports.xor = xor;\nconst eqv = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => a => self(a) === that(a));\n/**\n * @category combinators\n * @since 1.0.0\n */\nexports.eqv = eqv;\nconst implies = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => a => self(a) ? that(a) : true);\n/**\n * @category combinators\n * @since 1.0.0\n */\nexports.implies = implies;\nconst nor = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => a => !(self(a) || that(a)));\n/**\n * @category combinators\n * @since 1.0.0\n */\nexports.nor = nor;\nconst nand = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => a => !(self(a) && that(a)));\n/**\n * @category instances\n * @since 1.0.0\n */\nexports.nand = nand;\nconst getSemigroupEqv = () => semigroup.make(eqv);\n/**\n * @category instances\n * @since 1.0.0\n */\nexports.getSemigroupEqv = getSemigroupEqv;\nconst getMonoidEqv = () => monoid.fromSemigroup(getSemigroupEqv(), _Function.constTrue);\n/**\n * @category instances\n * @since 1.0.0\n */\nexports.getMonoidEqv = getMonoidEqv;\nconst getSemigroupXor = () => semigroup.make(xor);\n/**\n * @category instances\n * @since 1.0.0\n */\nexports.getSemigroupXor = getSemigroupXor;\nconst getMonoidXor = () => monoid.fromSemigroup(getSemigroupXor(), _Function.constFalse);\n/**\n * @category instances\n * @since 1.0.0\n */\nexports.getMonoidXor = getMonoidXor;\nconst getSemigroupSome = () => semigroup.make(or, (self, collection) => a => {\n  if (self(a)) {\n    return true;\n  }\n  for (const p of collection) {\n    if (p(a)) {\n      return true;\n    }\n  }\n  return false;\n});\n/**\n * @category instances\n * @since 1.0.0\n */\nexports.getSemigroupSome = getSemigroupSome;\nconst getMonoidSome = () => monoid.fromSemigroup(getSemigroupSome(), _Function.constFalse);\n/**\n * @category instances\n * @since 1.0.0\n */\nexports.getMonoidSome = getMonoidSome;\nconst getSemigroupEvery = () => semigroup.make(and, (self, collection) => a => {\n  if (!self(a)) {\n    return false;\n  }\n  for (const p of collection) {\n    if (!p(a)) {\n      return false;\n    }\n  }\n  return true;\n});\n/**\n * @category instances\n * @since 1.0.0\n */\nexports.getSemigroupEvery = getSemigroupEvery;\nconst getMonoidEvery = () => monoid.fromSemigroup(getSemigroupEvery(), _Function.constTrue);\n/**\n * @since 1.0.0\n */\nexports.getMonoidEvery = getMonoidEvery;\nconst every = collection => getMonoidEvery().combineAll(collection);\n/**\n * @since 1.0.0\n */\nexports.every = every;\nconst some = collection => getMonoidSome().combineAll(collection);\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * @category do notation\n * @since 1.0.0\n */\nexports.some = some;\nconst bindTo = /*#__PURE__*/invariant.bindTo(Invariant);\n/**\n * @category do notation\n * @since 1.0.0\n */\nexports.bindTo = bindTo;\nconst Do = /*#__PURE__*/of_.Do(Of);\n/**\n * A variant of `bind` that sequentially ignores the scope.\n *\n * @category do notation\n * @since 1.0.0\n */\nexports.Do = Do;\nconst andThenBind = /*#__PURE__*/semiProduct.andThenBind(SemiProduct);\nexports.andThenBind = andThenBind;\n//# sourceMappingURL=Predicate.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PCGRandom = void 0;\nexports.isNothing = isNothing;\n/*\n * Copyright 2014 Thom Chiovoloni, released under the MIT license.\n *\n * A random number generator based on the basic implementation of the PCG algorithm,\n * as described here: http://www.pcg-random.org/\n *\n * Adapted for TypeScript from Thom's original code at https://github.com/thomcc/pcg-random\n *\n * forked from https://github.com/frptools\n *\n * @since 1.0.0\n */\n/** @internal */\nfunction isNothing(value) {\n  return value === void 0 || value === null;\n}\nconst defaultIncHi = 0x14057b7e;\nconst defaultIncLo = 0xf767814f;\nconst MUL_HI = 0x5851f42d >>> 0;\nconst MUL_LO = 0x4c957f2d >>> 0;\nconst BIT_53 = 9007199254740992.0;\nconst BIT_27 = 134217728.0;\n/**\n * PCG is a family of simple fast space-efficient statistically good algorithms\n * for random number generation. Unlike many general-purpose RNGs, they are also\n * hard to predict.\n *\n * @category model\n * @since 1.0.0\n */\nclass PCGRandom {\n  constructor(seedHi, seedLo, incHi, incLo) {\n    if (isNothing(seedLo) && isNothing(seedHi)) {\n      seedLo = Math.random() * 0xffffffff >>> 0;\n      seedHi = 0;\n    } else if (isNothing(seedLo)) {\n      seedLo = seedHi;\n      seedHi = 0;\n    }\n    if (isNothing(incLo) && isNothing(incHi)) {\n      // @ts-expect-error\n      incLo = this._state ? this._state[3] : defaultIncLo;\n      // @ts-expect-error\n      incHi = this._state ? this._state[2] : defaultIncHi;\n    } else if (isNothing(incLo)) {\n      incLo = incHi;\n      incHi = 0;\n    }\n    this._state = new Int32Array([0, 0, incHi >>> 0, ((incLo || 0) | 1) >>> 0]);\n    this._next();\n    add64(this._state, this._state[0], this._state[1], seedHi >>> 0, seedLo >>> 0);\n    this._next();\n    return this;\n  }\n  /**\n   * Returns a copy of the internal state of this random number generator as a\n   * JavaScript Array.\n   *\n   * @category getters\n   * @since 1.0.0\n   */\n  getState() {\n    return [this._state[0], this._state[1], this._state[2], this._state[3]];\n  }\n  /**\n   * Restore state previously retrieved using `getState()`.\n   *\n   * @category mutations\n   * @since 1.0.0\n   */\n  setState(state) {\n    this._state[0] = state[0];\n    this._state[1] = state[1];\n    this._state[2] = state[2];\n    this._state[3] = state[3] | 1;\n  }\n  /**\n   * Get a uniformly distributed 32 bit integer between [0, max).\n   *\n   * @category getter\n   * @since 1.0.0\n   */\n  integer(max) {\n    if (!max) {\n      return this._next();\n    }\n    max = max >>> 0;\n    if ((max & max - 1) === 0) {\n      return this._next() & max - 1; // fast path for power of 2\n    }\n\n    let num = 0;\n    const skew = (-max >>> 0) % max >>> 0;\n    for (num = this._next(); num < skew; num = this._next()) {\n      // this loop will rarely execute more than twice,\n      // and is intentionally empty\n    }\n    return num % max;\n  }\n  /**\n   * Get a uniformly distributed IEEE-754 double between 0.0 and 1.0, with\n   * 53 bits of precision (every bit of the mantissa is randomized).\n   *\n   * @category getters\n   * @since 1.0.0\n   */\n  number() {\n    const hi = (this._next() & 0x03ffffff) * 1.0;\n    const lo = (this._next() & 0x07ffffff) * 1.0;\n    return (hi * BIT_27 + lo) / BIT_53;\n  }\n  /** @internal */\n  _next() {\n    // save current state (what we'll use for this number)\n    const oldHi = this._state[0] >>> 0;\n    const oldLo = this._state[1] >>> 0;\n    // churn LCG.\n    mul64(this._state, oldHi, oldLo, MUL_HI, MUL_LO);\n    add64(this._state, this._state[0], this._state[1], this._state[2], this._state[3]);\n    // get least sig. 32 bits of ((oldstate >> 18) ^ oldstate) >> 27\n    let xsHi = oldHi >>> 18;\n    let xsLo = (oldLo >>> 18 | oldHi << 14) >>> 0;\n    xsHi = (xsHi ^ oldHi) >>> 0;\n    xsLo = (xsLo ^ oldLo) >>> 0;\n    const xorshifted = (xsLo >>> 27 | xsHi << 5) >>> 0;\n    // rotate xorshifted right a random amount, based on the most sig. 5 bits\n    // bits of the old state.\n    const rot = oldHi >>> 27;\n    const rot2 = (-rot >>> 0 & 31) >>> 0;\n    return (xorshifted >>> rot | xorshifted << rot2) >>> 0;\n  }\n}\nexports.PCGRandom = PCGRandom;\nfunction mul64(out, aHi, aLo, bHi, bLo) {\n  let c1 = (aLo >>> 16) * (bLo & 0xffff) >>> 0;\n  let c0 = (aLo & 0xffff) * (bLo >>> 16) >>> 0;\n  let lo = (aLo & 0xffff) * (bLo & 0xffff) >>> 0;\n  let hi = (aLo >>> 16) * (bLo >>> 16) + ((c0 >>> 16) + (c1 >>> 16)) >>> 0;\n  c0 = c0 << 16 >>> 0;\n  lo = lo + c0 >>> 0;\n  if (lo >>> 0 < c0 >>> 0) {\n    hi = hi + 1 >>> 0;\n  }\n  c1 = c1 << 16 >>> 0;\n  lo = lo + c1 >>> 0;\n  if (lo >>> 0 < c1 >>> 0) {\n    hi = hi + 1 >>> 0;\n  }\n  hi = hi + Math.imul(aLo, bHi) >>> 0;\n  hi = hi + Math.imul(aHi, bLo) >>> 0;\n  out[0] = hi;\n  out[1] = lo;\n}\n// add two 64 bit numbers (given in parts), and store the result in `out`.\nfunction add64(out, aHi, aLo, bHi, bLo) {\n  let hi = aHi + bHi >>> 0;\n  const lo = aLo + bLo >>> 0;\n  if (lo >>> 0 < aLo >>> 0) {\n    hi = hi + 1 | 0;\n  }\n  out[0] = hi;\n  out[1] = lo;\n}\n//# sourceMappingURL=Random.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.empty = exports.dropWhile = exports.dropRight = exports.drop = exports.difference = exports.copy = exports.coproductMapKind = exports.contains = exports.composeK = exports.compact = exports.combineMapNonEmpty = exports.combineMap = exports.chunksOfNonEmpty = exports.chunksOf = exports.chopNonEmpty = exports.chop = exports.bindTo = exports.bind = exports.appendAllNonEmpty = exports.appendAll = exports.append = exports.ap = exports.andThenBind = exports.TraversableFilterable = exports.Traversable = exports.SemiProduct = exports.SemiApplicative = exports.Product = exports.Pointed = exports.Monad = exports.Invariant = exports.Foldable = exports.FlatMap = exports.Filterable = exports.Do = exports.Covariant = exports.Chainable = exports.Applicative = void 0;\nexports.every = every;\nexports.max = exports.matchRight = exports.matchLeft = exports.match = exports.mapNonEmpty = exports.map = exports.makeBy = exports.make = exports.liftPredicate = exports.liftOption = exports.liftNullable = exports.liftMonoid = exports.liftEither = exports.lift2 = exports.let = exports.length = exports.lefts = exports.lastNonEmpty = exports.last = exports.join = exports.isNonEmptyReadonlyArray = exports.isNonEmptyArray = exports.isEmptyReadonlyArray = exports.isEmptyArray = exports.intersperseNonEmpty = exports.intersperse = exports.intersection = exports.intercalateNonEmpty = exports.intercalate = exports.insertAt = exports.initNonEmpty = exports.init = exports.headNonEmpty = exports.head = exports.groupBy = exports.group = exports.getUnionSemigroup = exports.getUnionMonoid = exports.getSemigroup = exports.getOrder = exports.getMonoid = exports.getIntersectionSemigroup = exports.get = exports.fromRecord = exports.fromOption = exports.fromNullable = exports.fromIterable = exports.fromEither = exports.flattenNonEmpty = exports.flatten = exports.flatMapNullable = exports.flatMapNonEmpty = exports.flatMap = exports.flap = exports.findLastIndex = exports.findLast = exports.findFirstIndex = exports.findFirst = exports.filterMap = exports.filter = exports.extend = void 0;\nexports.zipWith = exports.zipNonEmptyWith = exports.zipNonEmpty = exports.zip = exports.unzipNonEmpty = exports.unzip = exports.unsafeGet = exports.unprepend = exports.uniqNonEmpty = exports.uniq = exports.unionNonEmpty = exports.union = exports.unfold = exports.unappend = exports.tupled = exports.traverseTap = exports.traversePartitionMap = exports.traversePartition = exports.traverseNonEmpty = exports.traverseFilterMap = exports.traverseFilter = exports.traverse = exports.takeWhile = exports.takeRight = exports.take = exports.tailNonEmpty = exports.tail = exports.splitNonEmptyAt = exports.splitAt = exports.span = exports.sortNonEmpty = exports.sortByNonEmpty = exports.sortBy = exports.sort = exports.some = exports.setNonEmptyLast = exports.setNonEmptyHead = exports.sequenceNonEmpty = exports.sequence = exports.separate = exports.scanRight = exports.scan = exports.rotateNonEmpty = exports.rotate = exports.rights = exports.reverseNonEmpty = exports.reverse = exports.replicate = exports.replaceOption = exports.replace = exports.remove = exports.reduceRight = exports.reduceKind = exports.reduce = exports.range = exports.prependAllNonEmpty = exports.prependAll = exports.prepend = exports.partitionMap = exports.partition = exports.of = exports.modifyOption = exports.modifyNonEmptyLast = exports.modifyNonEmptyHead = exports.modify = exports.min = void 0;\nvar E = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Either\"));\nvar _Function = /*#__PURE__*/require(\"@effect/data/Function\");\nvar readonlyArray = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/internal/ReadonlyArray\"));\nvar O = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Option\"));\nvar RR = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/ReadonlyRecord\"));\nvar string = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/String\"));\nvar applicative = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/typeclass/Applicative\"));\nvar chainable = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/typeclass/Chainable\"));\nvar covariant = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/typeclass/Covariant\"));\nvar flatMap_ = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/typeclass/FlatMap\"));\nvar foldable = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/typeclass/Foldable\"));\nvar invariant = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/typeclass/Invariant\"));\nvar monoid = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/typeclass/Monoid\"));\nvar of_ = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/typeclass/Of\"));\nvar order = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/typeclass/Order\"));\nvar semiApplicative = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/typeclass/SemiApplicative\"));\nvar semigroup = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/typeclass/Semigroup\"));\nvar semiProduct = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/typeclass/SemiProduct\"));\nvar traversable = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/typeclass/Traversable\"));\nvar traversableFilterable = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/typeclass/TraversableFilterable\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/**\n * This module provides utility functions for working with arrays in TypeScript.\n *\n * @since 1.0.0\n */\n\n/**\n * Builds a `NonEmptyArray` from an non-empty collection of elements.\n *\n * @category constructors\n * @since 1.0.0\n */\nconst make = (...elements) => elements;\n/**\n * Return a `NonEmptyArray` of length `n` with element `i` initialized with `f(i)`.\n *\n * **Note**. `n` is normalized to an integer >= 1.\n *\n * @example\n * import { makeBy } from '@effect/data/ReadonlyArray'\n *\n * assert.deepStrictEqual(makeBy(5, n => n * 2), [0, 2, 4, 6, 8])\n *\n * @category constructors\n * @since 1.0.0\n */\nexports.make = make;\nconst makeBy = (n, f) => {\n  const max = Math.max(1, Math.floor(n));\n  const out = [f(0)];\n  for (let i = 1; i < max; i++) {\n    out.push(f(i));\n  }\n  return out;\n};\n/**\n * Return a `NonEmptyArray` containing a range of integers, including both endpoints.\n *\n * @example\n * import { range } from '@effect/data/ReadonlyArray'\n *\n * assert.deepStrictEqual(range(1, 3), [1, 2, 3])\n *\n * @category constructors\n * @since 1.0.0\n */\nexports.makeBy = makeBy;\nconst range = (start, end) => start <= end ? makeBy(end - start + 1, i => start + i) : [start];\n/**\n * Return a `NonEmptyArray` containing a value repeated the specified number of times.\n *\n * **Note**. `n` is normalized to an integer >= 1.\n *\n * @example\n * import { replicate } from '@effect/data/ReadonlyArray'\n *\n * assert.deepStrictEqual(replicate(\"a\", 3), [\"a\", \"a\", \"a\"])\n *\n * @category constructors\n * @since 1.0.0\n */\nexports.range = range;\nconst replicate = /*#__PURE__*/(0, _Function.dual)(2, (a, n) => makeBy(n, () => a));\n/**\n * @category conversions\n * @since 1.0.0\n */\nexports.replicate = replicate;\nconst fromIterable = readonlyArray.fromIterable;\n/**\n * Takes a record and returns an array of tuples containing its keys and values.\n *\n * @param self - The record to transform.\n *\n * @example\n * import { fromRecord } from \"@effect/data/ReadonlyArray\"\n *\n * const x = { a: 1, b: 2, c: 3 }\n * assert.deepStrictEqual(fromRecord(x), [[\"a\", 1], [\"b\", 2], [\"c\", 3]])\n *\n * @category conversions\n * @since 1.0.0\n */\nexports.fromIterable = fromIterable;\nconst fromRecord = RR.toEntries;\n/**\n * @category conversions\n * @since 1.0.0\n */\nexports.fromRecord = fromRecord;\nconst fromOption = O.toArray;\n/**\n * @category conversions\n * @since 1.0.0\n */\nexports.fromOption = fromOption;\nconst fromEither = E.toArray;\n/**\n * @category pattern matching\n * @since 1.0.0\n */\nexports.fromEither = fromEither;\nconst match = /*#__PURE__*/(0, _Function.dual)(3, (self, onEmpty, onNonEmpty) => isNonEmptyReadonlyArray(self) ? onNonEmpty(self) : onEmpty());\n/**\n * @category pattern matching\n * @since 1.0.0\n */\nexports.match = match;\nconst matchLeft = /*#__PURE__*/(0, _Function.dual)(3, (self, onEmpty, onNonEmpty) => isNonEmptyReadonlyArray(self) ? onNonEmpty(headNonEmpty(self), tailNonEmpty(self)) : onEmpty());\n/**\n * @category pattern matching\n * @since 1.0.0\n */\nexports.matchLeft = matchLeft;\nconst matchRight = /*#__PURE__*/(0, _Function.dual)(3, (self, onEmpty, onNonEmpty) => isNonEmptyReadonlyArray(self) ? onNonEmpty(initNonEmpty(self), lastNonEmpty(self)) : onEmpty());\n/**\n * Prepend an element to the front of an `Iterable`, creating a new `NonEmptyArray`.\n *\n * @since 1.0.0\n */\nexports.matchRight = matchRight;\nconst prepend = /*#__PURE__*/(0, _Function.dual)(2, (self, head) => [head, ...self]);\n/**\n * @since 1.0.0\n */\nexports.prepend = prepend;\nconst prependAll = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => fromIterable(that).concat(fromIterable(self)));\n/**\n * @since 1.0.0\n */\nexports.prependAll = prependAll;\nconst prependAllNonEmpty = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => prependAll(self, that));\n/**\n * Append an element to the end of an `Iterable`, creating a new `NonEmptyArray`.\n *\n * @since 1.0.0\n */\nexports.prependAllNonEmpty = prependAllNonEmpty;\nconst append = /*#__PURE__*/(0, _Function.dual)(2, (self, last) => [...self, last]);\n/**\n * @since 1.0.0\n */\nexports.append = append;\nconst appendAll = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => fromIterable(self).concat(fromIterable(that)));\n/**\n * @since 1.0.0\n */\nexports.appendAll = appendAll;\nconst appendAllNonEmpty = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => appendAll(self, that));\n/**\n * Reduce an `Iterable` from the left, keeping all intermediate results instead of only the final result.\n *\n * @category folding\n * @since 1.0.0\n */\nexports.appendAllNonEmpty = appendAllNonEmpty;\nconst scan = /*#__PURE__*/(0, _Function.dual)(3, (self, b, f) => {\n  const out = [b];\n  let i = 0;\n  for (const a of self) {\n    out[i + 1] = f(out[i], a);\n    i++;\n  }\n  return out;\n});\n/**\n * Reduce an `Iterable` from the right, keeping all intermediate results instead of only the final result.\n *\n * @category folding\n * @since 1.0.0\n */\nexports.scan = scan;\nconst scanRight = /*#__PURE__*/(0, _Function.dual)(3, (self, b, f) => {\n  const input = fromIterable(self);\n  const out = new Array(input.length + 1);\n  out[input.length] = b;\n  for (let i = input.length - 1; i >= 0; i--) {\n    out[i] = f(out[i + 1], input[i]);\n  }\n  return out;\n});\n/**\n * Determine if an `Array` is empty narrowing down the type to `[]`.\n *\n * @param self - The `Array` to check.\n *\n * @example\n * import { isEmptyArray } from \"@effect/data/ReadonlyArray\"\n *\n * assert.deepStrictEqual(isEmptyArray([]), true);\n * assert.deepStrictEqual(isEmptyArray([1, 2, 3]), false);\n *\n * @category guards\n * @since 1.0.0\n */\nexports.scanRight = scanRight;\nconst isEmptyArray = self => self.length === 0;\n/**\n * Determine if a `ReadonlyArray` is empty narrowing down the type to `readonly []`.\n *\n * @param self - The `ReadonlyArray` to check.\n *\n * @example\n * import { isEmptyReadonlyArray } from \"@effect/data/ReadonlyArray\"\n *\n * assert.deepStrictEqual(isEmptyReadonlyArray([]), true);\n * assert.deepStrictEqual(isEmptyReadonlyArray([1, 2, 3]), false);\n *\n * @category guards\n * @since 1.0.0\n */\nexports.isEmptyArray = isEmptyArray;\nconst isEmptyReadonlyArray = isEmptyArray;\n/**\n * Determine if an `Array` is non empty narrowing down the type to `NonEmptyArray`.\n *\n * An `Array` is considered to be a `NonEmptyArray` if it contains at least one element.\n *\n * @param self - The `Array` to check.\n *\n * @example\n * import { isNonEmptyArray } from \"@effect/data/ReadonlyArray\"\n *\n * assert.deepStrictEqual(isNonEmptyArray([]), false);\n * assert.deepStrictEqual(isNonEmptyArray([1, 2, 3]), true);\n *\n * @category guards\n * @since 1.0.0\n */\nexports.isEmptyReadonlyArray = isEmptyReadonlyArray;\nconst isNonEmptyArray = readonlyArray.isNonEmptyArray;\n/**\n * Determine if a `ReadonlyArray` is non empty narrowing down the type to `NonEmptyReadonlyArray`.\n *\n * A `ReadonlyArray` is considered to be a `NonEmptyReadonlyArray` if it contains at least one element.\n *\n * @param self - The `ReadonlyArray` to check.\n *\n * @example\n * import { isNonEmptyReadonlyArray } from \"@effect/data/ReadonlyArray\"\n *\n * assert.deepStrictEqual(isNonEmptyReadonlyArray([]), false);\n * assert.deepStrictEqual(isNonEmptyReadonlyArray([1, 2, 3]), true);\n *\n * @category guards\n * @since 1.0.0\n */\nexports.isNonEmptyArray = isNonEmptyArray;\nconst isNonEmptyReadonlyArray = readonlyArray.isNonEmptyArray;\n/**\n * Return the number of elements in a `ReadonlyArray`.\n *\n * @category getters\n * @since 1.0.0\n */\nexports.isNonEmptyReadonlyArray = isNonEmptyReadonlyArray;\nconst length = self => self.length;\nexports.length = length;\nconst isOutOfBound = (i, as) => i < 0 || i >= as.length;\nconst clamp = (i, as) => Math.floor(Math.min(Math.max(0, i), as.length));\n/**\n * This function provides a safe way to read a value at a particular index from a `ReadonlyArray`.\n *\n * @category getters\n * @since 1.0.0\n */\nconst get = /*#__PURE__*/(0, _Function.dual)(2, (self, index) => {\n  const i = Math.floor(index);\n  return isOutOfBound(i, self) ? O.none() : O.some(self[i]);\n});\n/**\n * Gets an element unsafely, will throw on out of bounds.\n *\n * @since 1.0.0\n * @category unsafe\n */\nexports.get = get;\nconst unsafeGet = /*#__PURE__*/(0, _Function.dual)(2, (self, index) => {\n  const i = Math.floor(index);\n  if (isOutOfBound(i, self)) {\n    throw new Error(`Index ${i} out of bounds`);\n  }\n  return self[i];\n});\n/**\n * Return a tuple containing the first element, and a new `Array` of the remaining elements, if any.\n *\n * @category getters\n * @since 1.0.0\n */\nexports.unsafeGet = unsafeGet;\nconst unprepend = self => [headNonEmpty(self), tailNonEmpty(self)];\n/**\n * Return a tuple containing a copy of the `NonEmptyReadonlyArray` without its last element, and that last element.\n *\n * @category getters\n * @since 1.0.0\n */\nexports.unprepend = unprepend;\nconst unappend = self => [initNonEmpty(self), lastNonEmpty(self)];\n/**\n * Get the first element of a `ReadonlyArray`, or `None` if the `ReadonlyArray` is empty.\n *\n * @category getters\n * @since 1.0.0\n */\nexports.unappend = unappend;\nconst head = /*#__PURE__*/get(0);\n/**\n * @category getters\n * @since 1.0.0\n */\nexports.head = head;\nconst headNonEmpty = /*#__PURE__*/unsafeGet(0);\n/**\n * Get the last element in a `ReadonlyArray`, or `None` if the `ReadonlyArray` is empty.\n *\n * @category getters\n * @since 1.0.0\n */\nexports.headNonEmpty = headNonEmpty;\nconst last = self => isNonEmptyReadonlyArray(self) ? O.some(lastNonEmpty(self)) : O.none();\n/**\n * @category getters\n * @since 1.0.0\n */\nexports.last = last;\nconst lastNonEmpty = self => self[self.length - 1];\n/**\n * Get all but the first element of an `Iterable`, creating a new `Array`, or `None` if the `Iterable` is empty.\n *\n * @category getters\n * @since 1.0.0\n */\nexports.lastNonEmpty = lastNonEmpty;\nconst tail = self => {\n  const input = fromIterable(self);\n  return isNonEmptyReadonlyArray(input) ? O.some(tailNonEmpty(input)) : O.none();\n};\n/**\n * @category getters\n * @since 1.0.0\n */\nexports.tail = tail;\nconst tailNonEmpty = self => self.slice(1);\n/**\n * Get all but the last element of an `Iterable`, creating a new `Array`, or `None` if the `Iterable` is empty.\n *\n * @category getters\n * @since 1.0.0\n */\nexports.tailNonEmpty = tailNonEmpty;\nconst init = self => {\n  const input = fromIterable(self);\n  return isNonEmptyReadonlyArray(input) ? O.some(initNonEmpty(input)) : O.none();\n};\n/**\n * Get all but the last element of a non empty array, creating a new array.\n *\n * @category getters\n * @since 1.0.0\n */\nexports.init = init;\nconst initNonEmpty = self => self.slice(0, -1);\n/**\n * Keep only a max number of elements from the start of an `Iterable`, creating a new `Array`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @category getters\n * @since 1.0.0\n */\nexports.initNonEmpty = initNonEmpty;\nconst take = /*#__PURE__*/(0, _Function.dual)(2, (self, n) => {\n  const input = fromIterable(self);\n  return input.slice(0, clamp(n, input));\n});\n/**\n * Keep only a max number of elements from the end of an `Iterable`, creating a new `Array`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @category getters\n * @since 1.0.0\n */\nexports.take = take;\nconst takeRight = /*#__PURE__*/(0, _Function.dual)(2, (self, n) => {\n  const input = fromIterable(self);\n  const i = clamp(n, input);\n  return i === 0 ? [] : input.slice(-i);\n});\n/**\n * Calculate the longest initial subarray for which all element satisfy the specified predicate, creating a new `Array`.\n *\n * @category getters\n * @since 1.0.0\n */\nexports.takeRight = takeRight;\nconst takeWhile = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => {\n  const out = [];\n  for (const a of self) {\n    if (!predicate(a)) {\n      break;\n    }\n    out.push(a);\n  }\n  return out;\n});\nexports.takeWhile = takeWhile;\nconst spanIndex = (self, predicate) => {\n  let i = 0;\n  for (const a of self) {\n    if (!predicate(a)) {\n      break;\n    }\n    i++;\n  }\n  return i;\n};\n/**\n * Split an `Iterable` into two parts:\n *\n * 1. the longest initial subarray for which all elements satisfy the specified predicate\n * 2. the remaining elements\n *\n * @category filtering\n * @since 1.0.0\n */\nconst span = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => splitAt(self, spanIndex(self, predicate)));\n/**\n * Drop a max number of elements from the start of an `Iterable`, creating a new `Array`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @category getters\n * @since 1.0.0\n */\nexports.span = span;\nconst drop = /*#__PURE__*/(0, _Function.dual)(2, (self, n) => {\n  const input = fromIterable(self);\n  return input.slice(clamp(n, input), input.length);\n});\n/**\n * Drop a max number of elements from the end of an `Iterable`, creating a new `Array`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @category getters\n * @since 1.0.0\n */\nexports.drop = drop;\nconst dropRight = /*#__PURE__*/(0, _Function.dual)(2, (self, n) => {\n  const input = fromIterable(self);\n  return input.slice(0, input.length - clamp(n, input));\n});\n/**\n * Remove the longest initial subarray for which all element satisfy the specified predicate, creating a new `Array`.\n *\n * @category getters\n * @since 1.0.0\n */\nexports.dropRight = dropRight;\nconst dropWhile = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => fromIterable(self).slice(spanIndex(self, predicate)));\n/**\n * Return the first index for which a predicate holds.\n *\n * @category getters\n * @since 1.0.0\n */\nexports.dropWhile = dropWhile;\nconst findFirstIndex = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => {\n  let i = 0;\n  for (const a of self) {\n    if (predicate(a)) {\n      return O.some(i);\n    }\n    i++;\n  }\n  return O.none();\n});\n/**\n * Return the last index for which a predicate holds.\n *\n * @category getters\n * @since 1.0.0\n */\nexports.findFirstIndex = findFirstIndex;\nconst findLastIndex = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => {\n  const input = fromIterable(self);\n  for (let i = input.length - 1; i >= 0; i--) {\n    if (predicate(input[i])) {\n      return O.some(i);\n    }\n  }\n  return O.none();\n});\n/**\n * Find the first element for which a predicate holds.\n *\n * @category getters\n * @since 1.0.0\n */\nexports.findLastIndex = findLastIndex;\nconst findFirst = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => {\n  const input = fromIterable(self);\n  for (let i = 0; i < input.length; i++) {\n    if (predicate(input[i])) {\n      return O.some(input[i]);\n    }\n  }\n  return O.none();\n});\n/**\n * Find the last element for which a predicate holds.\n *\n * @category getters\n * @since 1.0.0\n */\nexports.findFirst = findFirst;\nconst findLast = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => {\n  const input = fromIterable(self);\n  for (let i = input.length - 1; i >= 0; i--) {\n    if (predicate(input[i])) {\n      return O.some(input[i]);\n    }\n  }\n  return O.none();\n});\n/**\n * Insert an element at the specified index, creating a new `NonEmptyArray`,\n * or return `None` if the index is out of bounds.\n *\n * @since 1.0.0\n */\nexports.findLast = findLast;\nconst insertAt = /*#__PURE__*/(0, _Function.dual)(3, (self, i, b) => {\n  const out = Array.from(self);\n  //             v--- `= self.length` is ok, it means inserting in last position\n  if (i < 0 || i > out.length) {\n    return O.none();\n  }\n  out.splice(i, 0, b);\n  return O.some(out);\n});\n/**\n * Change the element at the specified index, creating a new `Array`,\n * or return a copy of the input if the index is out of bounds.\n *\n * @since 1.0.0\n */\nexports.insertAt = insertAt;\nconst replace = /*#__PURE__*/(0, _Function.dual)(3, (self, i, b) => modify(self, i, () => b));\n/**\n * @since 1.0.0\n */\nexports.replace = replace;\nconst replaceOption = /*#__PURE__*/(0, _Function.dual)(3, (self, i, b) => modifyOption(self, i, () => b));\n/**\n * Apply a function to the element at the specified index, creating a new `Array`,\n * or return a copy of the input if the index is out of bounds.\n *\n * @since 1.0.0\n */\nexports.replaceOption = replaceOption;\nconst modify = /*#__PURE__*/(0, _Function.dual)(3, (self, i, f) => O.getOrElse(modifyOption(self, i, f), () => Array.from(self)));\n/**\n * Apply a function to the element at the specified index, creating a new `Array`,\n * or return `None` if the index is out of bounds.\n *\n * @since 1.0.0\n */\nexports.modify = modify;\nconst modifyOption = /*#__PURE__*/(0, _Function.dual)(3, (self, i, f) => {\n  const out = Array.from(self);\n  if (isOutOfBound(i, out)) {\n    return O.none();\n  }\n  const next = f(out[i]);\n  // @ts-expect-error\n  out[i] = next;\n  return O.some(out);\n});\n/**\n * Delete the element at the specified index, creating a new `Array`,\n * or return a copy of the input if the index is out of bounds.\n *\n * @since 1.0.0\n */\nexports.modifyOption = modifyOption;\nconst remove = /*#__PURE__*/(0, _Function.dual)(2, (self, i) => {\n  const out = Array.from(self);\n  if (isOutOfBound(i, out)) {\n    return out;\n  }\n  out.splice(i, 1);\n  return out;\n});\n/**\n * Reverse an `Iterable`, creating a new `Array`.\n *\n * @since 1.0.0\n */\nexports.remove = remove;\nconst reverse = self => Array.from(self).reverse();\n/**\n * @since 1.0.0\n */\nexports.reverse = reverse;\nconst reverseNonEmpty = self => [lastNonEmpty(self), ...self.slice(0, -1).reverse()];\n/**\n * Return all the `Right` elements from an `Interable` of `Either`s.\n *\n * @category getters\n * @since 1.0.0\n */\nexports.reverseNonEmpty = reverseNonEmpty;\nconst rights = E.rights;\n/**\n * Return all the `Left` elements from an `Interable` of `Either`s.\n *\n * @category getters\n * @since 1.0.0\n */\nexports.rights = rights;\nconst lefts = E.lefts;\n/**\n * Sort the elements of an `Iterable` in increasing order, creating a new `Array`.\n *\n * @category sorting\n * @since 1.0.0\n */\nexports.lefts = lefts;\nconst sort = /*#__PURE__*/(0, _Function.dual)(2, (self, O) => {\n  const out = Array.from(self);\n  out.sort(O.compare);\n  return out;\n});\n/**\n * Sort the elements of a `NonEmptyReadonlyArray` in increasing order, creating a new `NonEmptyArray`.\n *\n * @category sorting\n * @since 1.0.0\n */\nexports.sort = sort;\nconst sortNonEmpty = /*#__PURE__*/(0, _Function.dual)(2, (self, O) => sort(O)(self));\n/**\n * Sort the elements of an `Iterable` in increasing order, where elements are compared\n * using first `orders[0]`, then `orders[1]`, etc...\n *\n * @category sorting\n * @since 1.0.0\n */\nexports.sortNonEmpty = sortNonEmpty;\nconst sortBy = (...orders) => self => {\n  const input = fromIterable(self);\n  return isNonEmptyReadonlyArray(input) ? sortByNonEmpty(...orders)(input) : [];\n};\n/**\n * @category sorting\n * @since 1.0.0\n */\nexports.sortBy = sortBy;\nconst sortByNonEmpty = (...orders) => sortNonEmpty(order.getMonoid().combineAll(orders));\n/**\n * Takes two `Iterable`s and returns an `Array` of corresponding pairs.\n * If one input `Iterable` is short, excess elements of the\n * longer `Iterable` are discarded.\n *\n * @since 1.0.0\n */\nexports.sortByNonEmpty = sortByNonEmpty;\nconst zip = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => zipWith(self, that, (a, b) => [a, b]));\n/**\n * Apply a function to pairs of elements at the same index in two `Iterable`s, collecting the results in a new `Array`. If one\n * input `Iterable` is short, excess elements of the longer `Iterable` are discarded.\n *\n * @since 1.0.0\n */\nexports.zip = zip;\nconst zipWith = /*#__PURE__*/(0, _Function.dual)(3, (self, that, f) => {\n  const as = fromIterable(self);\n  const bs = fromIterable(that);\n  return isNonEmptyReadonlyArray(as) && isNonEmptyReadonlyArray(bs) ? zipNonEmptyWith(bs, f)(as) : [];\n});\n/**\n * @since 1.0.0\n */\nexports.zipWith = zipWith;\nconst zipNonEmpty = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => zipNonEmptyWith(self, that, (a, b) => [a, b]));\n/**\n * @since 1.0.0\n */\nexports.zipNonEmpty = zipNonEmpty;\nconst zipNonEmptyWith = /*#__PURE__*/(0, _Function.dual)(3, (self, that, f) => {\n  const cs = [f(headNonEmpty(self), headNonEmpty(that))];\n  const len = Math.min(self.length, that.length);\n  for (let i = 1; i < len; i++) {\n    cs[i] = f(self[i], that[i]);\n  }\n  return cs;\n});\n/**\n * This function is the inverse of `zip`. Takes an `Iterable` of pairs and return two corresponding `Array`s.\n *\n * @since 1.0.0\n */\nexports.zipNonEmptyWith = zipNonEmptyWith;\nconst unzip = self => {\n  const input = fromIterable(self);\n  return isNonEmptyReadonlyArray(input) ? unzipNonEmpty(input) : [[], []];\n};\n/**\n * @since 1.0.0\n */\nexports.unzip = unzip;\nconst unzipNonEmpty = self => {\n  const fa = [self[0][0]];\n  const fb = [self[0][1]];\n  for (let i = 1; i < self.length; i++) {\n    fa[i] = self[i][0];\n    fb[i] = self[i][1];\n  }\n  return [fa, fb];\n};\n/**\n * Places an element in between members of an `Iterable`\n *\n * @since 1.0.0\n */\nexports.unzipNonEmpty = unzipNonEmpty;\nconst intersperse = /*#__PURE__*/(0, _Function.dual)(2, (self, middle) => {\n  const input = fromIterable(self);\n  return isNonEmptyReadonlyArray(input) ? intersperseNonEmpty(input, middle) : [];\n});\n/**\n * Places an element in between members of a `NonEmptyReadonlyArray`\n *\n * @since 1.0.0\n */\nexports.intersperse = intersperse;\nconst intersperseNonEmpty = /*#__PURE__*/(0, _Function.dual)(2, (self, middle) => {\n  const out = [headNonEmpty(self)];\n  const tail = tailNonEmpty(self);\n  for (let i = 0; i < tail.length; i++) {\n    if (i < tail.length) {\n      out.push(middle);\n    }\n    out.push(tail[i]);\n  }\n  return out;\n});\n/**\n * Apply a function to the head, creating a new `NonEmptyReadonlyArray`.\n *\n * @since 1.0.0\n */\nexports.intersperseNonEmpty = intersperseNonEmpty;\nconst modifyNonEmptyHead = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => [f(headNonEmpty(self)), ...tailNonEmpty(self)]);\n/**\n * Change the head, creating a new `NonEmptyReadonlyArray`.\n *\n * @since 1.0.0\n */\nexports.modifyNonEmptyHead = modifyNonEmptyHead;\nconst setNonEmptyHead = /*#__PURE__*/(0, _Function.dual)(2, (self, b) => modifyNonEmptyHead(self, () => b));\n/**\n * Apply a function to the last element, creating a new `NonEmptyReadonlyArray`.\n *\n * @since 1.0.0\n */\nexports.setNonEmptyHead = setNonEmptyHead;\nconst modifyNonEmptyLast = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => append(initNonEmpty(self), f(lastNonEmpty(self))));\n/**\n * Change the last element, creating a new `NonEmptyReadonlyArray`.\n *\n * @since 1.0.0\n */\nexports.modifyNonEmptyLast = modifyNonEmptyLast;\nconst setNonEmptyLast = /*#__PURE__*/(0, _Function.dual)(2, (self, b) => modifyNonEmptyLast(self, () => b));\n/**\n * Rotate an `Iterable` by `n` steps.\n *\n * @since 1.0.0\n */\nexports.setNonEmptyLast = setNonEmptyLast;\nconst rotate = /*#__PURE__*/(0, _Function.dual)(2, (self, n) => {\n  const input = fromIterable(self);\n  return isNonEmptyReadonlyArray(input) ? rotateNonEmpty(input, n) : [];\n});\n/**\n * Rotate a `NonEmptyReadonlyArray` by `n` steps.\n *\n * @since 1.0.0\n */\nexports.rotate = rotate;\nconst rotateNonEmpty = /*#__PURE__*/(0, _Function.dual)(2, (self, n) => {\n  const len = self.length;\n  const m = Math.round(n) % len;\n  if (isOutOfBound(Math.abs(m), self) || m === 0) {\n    return copy(self);\n  }\n  if (m < 0) {\n    const [f, s] = splitNonEmptyAt(self, -m);\n    return appendAllNonEmpty(s, f);\n  } else {\n    return rotateNonEmpty(self, m - len);\n  }\n});\n/**\n * Returns a function that checks if a `ReadonlyArray` contains a given value using a provided `equivalence` function.\n *\n * @category predicates\n * @since 1.0.0\n */\nexports.rotateNonEmpty = rotateNonEmpty;\nconst contains = isEquivalent => (0, _Function.dual)(2, (self, a) => {\n  for (const i of self) {\n    if (isEquivalent(a, i)) {\n      return true;\n    }\n  }\n  return false;\n});\n/**\n * Remove duplicates from am `Iterable`, keeping the first occurrence of an element.\n *\n * @since 1.0.0\n */\nexports.contains = contains;\nconst uniq = /*#__PURE__*/(0, _Function.dual)(2, (self, isEquivalent) => {\n  const input = fromIterable(self);\n  return isNonEmptyReadonlyArray(input) ? uniqNonEmpty(isEquivalent)(input) : [];\n});\n/**\n * Remove duplicates from a `NonEmptyReadonlyArray`, keeping the first occurrence of an element.\n *\n * @since 1.0.0\n */\nexports.uniq = uniq;\nconst uniqNonEmpty = /*#__PURE__*/(0, _Function.dual)(2, (self, isEquivalent) => {\n  const out = [headNonEmpty(self)];\n  const rest = tailNonEmpty(self);\n  for (const a of rest) {\n    if (out.every(o => !isEquivalent(a, o))) {\n      out.push(a);\n    }\n  }\n  return out;\n});\n/**\n * A useful recursion pattern for processing an `Iterable` to produce a new `Array`, often used for \"chopping\" up the input\n * `Iterable`. Typically chop is called with some function that will consume an initial prefix of the `Iterable` and produce a\n * value and the rest of the `Array`.\n *\n * @since 1.0.0\n */\nexports.uniqNonEmpty = uniqNonEmpty;\nconst chop = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => {\n  const input = fromIterable(self);\n  return isNonEmptyReadonlyArray(input) ? chopNonEmpty(input, f) : [];\n});\n/**\n * A useful recursion pattern for processing a `NonEmptyReadonlyArray` to produce a new `NonEmptyReadonlyArray`, often used for \"chopping\" up the input\n * `NonEmptyReadonlyArray`. Typically `chop` is called with some function that will consume an initial prefix of the `NonEmptyReadonlyArray` and produce a\n * value and the tail of the `NonEmptyReadonlyArray`.\n *\n * @since 1.0.0\n */\nexports.chop = chop;\nconst chopNonEmpty = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => {\n  const [b, rest] = f(self);\n  const out = [b];\n  let next = rest;\n  while (readonlyArray.isNonEmptyArray(next)) {\n    const [b, rest] = f(next);\n    out.push(b);\n    next = rest;\n  }\n  return out;\n});\n/**\n * Splits an `Iterable` into two pieces, the first piece has max `n` elements.\n *\n * @category getters\n * @since 1.0.0\n */\nexports.chopNonEmpty = chopNonEmpty;\nconst splitAt = /*#__PURE__*/(0, _Function.dual)(2, (self, n) => {\n  const input = Array.from(self);\n  return n >= 1 && isNonEmptyReadonlyArray(input) ? splitNonEmptyAt(input, n) : isEmptyReadonlyArray(input) ? [input, []] : [[], input];\n});\n/**\n * @since 1.0.0\n */\nexports.splitAt = splitAt;\nconst copy = self => self.slice();\n/**\n * Splits a `NonEmptyReadonlyArray` into two pieces, the first piece has max `n` elements.\n *\n * @category getters\n * @since 1.0.0\n */\nexports.copy = copy;\nconst splitNonEmptyAt = /*#__PURE__*/(0, _Function.dual)(2, (self, n) => {\n  const m = Math.max(1, n);\n  return m >= self.length ? [copy(self), []] : [prepend(self.slice(1, m), headNonEmpty(self)), self.slice(m)];\n});\n/**\n * Splits an `Iterable` into length-`n` pieces. The last piece will be shorter if `n` does not evenly divide the length of\n * the `Iterable`. Note that `chunksOf(n)([])` is `[]`, not `[[]]`. This is intentional, and is consistent with a recursive\n * definition of `chunksOf`; it satisfies the property that\n *\n * ```ts\n * chunksOf(n)(xs).concat(chunksOf(n)(ys)) == chunksOf(n)(xs.concat(ys)))\n * ```\n *\n * whenever `n` evenly divides the length of `self`.\n *\n * @category getters\n * @since 1.0.0\n */\nexports.splitNonEmptyAt = splitNonEmptyAt;\nconst chunksOf = /*#__PURE__*/(0, _Function.dual)(2, (self, n) => {\n  const input = fromIterable(self);\n  return isNonEmptyReadonlyArray(input) ? chunksOfNonEmpty(input, n) : [];\n});\n/**\n * Splits a `NonEmptyReadonlyArray` into length-`n` pieces. The last piece will be shorter if `n` does not evenly divide the length of\n * the `NonEmptyReadonlyArray`.\n *\n * @category getters\n * @since 1.0.0\n */\nexports.chunksOf = chunksOf;\nconst chunksOfNonEmpty = /*#__PURE__*/(0, _Function.dual)(2, (self, n) => chopNonEmpty(self, splitNonEmptyAt(n)));\n/**\n * Group equal, consecutive elements of a `NonEmptyReadonlyArray` into `NonEmptyArray`s.\n *\n * @category grouping\n * @since 1.0.0\n */\nexports.chunksOfNonEmpty = chunksOfNonEmpty;\nconst group = /*#__PURE__*/(0, _Function.dual)(2, (self, isEquivalent) => chopNonEmpty(self, as => {\n  const h = headNonEmpty(as);\n  const out = [h];\n  let i = 1;\n  for (; i < as.length; i++) {\n    const a = as[i];\n    if (isEquivalent(a, h)) {\n      out.push(a);\n    } else {\n      break;\n    }\n  }\n  return [out, as.slice(i)];\n}));\n/**\n * Splits an `Iterable` into sub-non-empty-arrays stored in an object, based on the result of calling a `string`-returning\n * function on each element, and grouping the results according to values returned\n *\n * @category grouping\n * @since 1.0.0\n */\nexports.group = group;\nconst groupBy = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => {\n  const out = {};\n  for (const a of self) {\n    const k = f(a);\n    if (Object.prototype.hasOwnProperty.call(out, k)) {\n      out[k].push(a);\n    } else {\n      out[k] = [a];\n    }\n  }\n  return out;\n});\n/**\n * @since 1.0.0\n */\nexports.groupBy = groupBy;\nconst union = isEquivalent => (0, _Function.dual)(2, (self, that) => {\n  const a = Array.from(self);\n  const b = Array.from(that);\n  return isNonEmptyReadonlyArray(a) && isNonEmptyReadonlyArray(b) ? unionNonEmpty(isEquivalent)(a, b) : isNonEmptyReadonlyArray(a) ? a : b;\n});\n/**\n * @since 1.0.0\n */\nexports.union = union;\nconst unionNonEmpty = isEquivalent => (0, _Function.dual)(2, (self, that) => uniqNonEmpty(isEquivalent)(appendAllNonEmpty(self, that)));\n/**\n * Creates an `Array` of unique values that are included in all given `Iterable`s.\n * The order and references of result values are determined by the first `Iterable`.\n *\n * @since 1.0.0\n */\nexports.unionNonEmpty = unionNonEmpty;\nconst intersection = isEquivalent => {\n  const has = contains(isEquivalent);\n  return (0, _Function.dual)(2, (self, that) => fromIterable(self).filter(a => has(that, a)));\n};\n/**\n * Creates a `Array` of values not included in the other given `Iterable`.\n * The order and references of result values are determined by the first `Iterable`.\n *\n * @since 1.0.0\n */\nexports.intersection = intersection;\nconst difference = isEquivalent => {\n  const has = contains(isEquivalent);\n  return (0, _Function.dual)(2, (self, that) => fromIterable(self).filter(a => !has(that, a)));\n};\n/**\n * @category constructors\n * @since 1.0.0\n */\nexports.difference = difference;\nconst empty = () => [];\n/**\n * Constructs a new `NonEmptyArray<A>` from the specified value.\n *\n * @category constructors\n * @since 1.0.0\n */\nexports.empty = empty;\nconst of = a => [a];\nexports.of = of;\nconst Of = {\n  of\n};\n/**\n * @category mapping\n * @since 1.0.0\n */\nconst map = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => self.map(f));\n/**\n * @category mapping\n * @since 1.0.0\n */\nexports.map = map;\nconst mapNonEmpty = map;\nexports.mapNonEmpty = mapNonEmpty;\nconst imap = /*#__PURE__*/covariant.imap(map);\n/**\n * @category instances\n * @since 1.0.0\n */\nconst Covariant = {\n  imap,\n  map\n};\n/**\n * @category instances\n * @since 1.0.0\n */\nexports.Covariant = Covariant;\nconst Invariant = {\n  imap\n};\n/**\n * @category mapping\n * @since 1.0.0\n */\nexports.Invariant = Invariant;\nconst tupled = /*#__PURE__*/invariant.tupled(Invariant);\n/**\n * @category mapping\n * @since 1.0.0\n */\nexports.tupled = tupled;\nconst flap = /*#__PURE__*/covariant.flap(Covariant);\n/**\n * @category instances\n * @since 1.0.0\n */\nexports.flap = flap;\nconst Pointed = {\n  of,\n  imap,\n  map\n};\n/**\n * @category combining\n * @since 1.0.0\n */\nexports.Pointed = Pointed;\nconst flatMap = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => {\n  if (isEmptyReadonlyArray(self)) {\n    return [];\n  }\n  const out = [];\n  for (let i = 0; i < self.length; i++) {\n    out.push(...f(self[i], i));\n  }\n  return out;\n});\n/**\n * @category combining\n * @since 1.0.0\n */\nexports.flatMap = flatMap;\nconst flatMapNonEmpty = flatMap;\n/**\n * @category instances\n * @since 1.0.0\n */\nexports.flatMapNonEmpty = flatMapNonEmpty;\nconst FlatMap = {\n  flatMap\n};\n/**\n * @category combining\n * @since 1.0.0\n */\nexports.FlatMap = FlatMap;\nconst flatten = /*#__PURE__*/flatMap_.flatten(FlatMap);\n/**\n * @category combining\n * @since 1.0.0\n */\nexports.flatten = flatten;\nconst flattenNonEmpty = /*#__PURE__*/flatMapNonEmpty(_Function.identity);\n/**\n * @since 1.0.0\n */\nexports.flattenNonEmpty = flattenNonEmpty;\nconst composeK = /*#__PURE__*/flatMap_.composeK(FlatMap);\n/**\n * @category instances\n * @since 1.0.0\n */\nexports.composeK = composeK;\nconst Chainable = {\n  imap,\n  map,\n  flatMap\n};\n/**\n * @category filtering\n * @since 1.0.0\n */\nexports.Chainable = Chainable;\nconst filterMap = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => {\n  const as = fromIterable(self);\n  const out = [];\n  for (let i = 0; i < as.length; i++) {\n    const o = f(as[i], i);\n    if (O.isSome(o)) {\n      out.push(o.value);\n    }\n  }\n  return out;\n});\n/**\n * @category filtering\n * @since 1.0.0\n */\nexports.filterMap = filterMap;\nconst partitionMap = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => {\n  const left = [];\n  const right = [];\n  const as = fromIterable(self);\n  for (let i = 0; i < as.length; i++) {\n    const e = f(as[i], i);\n    if (E.isLeft(e)) {\n      left.push(e.left);\n    } else {\n      right.push(e.right);\n    }\n  }\n  return [left, right];\n});\n/**\n * @category instances\n * @since 1.0.0\n */\nexports.partitionMap = partitionMap;\nconst Filterable = {\n  partitionMap,\n  filterMap\n};\n/**\n * @category filtering\n * @since 1.0.0\n */\nexports.Filterable = Filterable;\nconst compact = /*#__PURE__*/filterMap(_Function.identity);\n/**\n * @category filtering\n * @since 1.0.0\n */\nexports.compact = compact;\nconst filter = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => {\n  const as = fromIterable(self);\n  const out = [];\n  for (let i = 0; i < as.length; i++) {\n    if (predicate(as[i], i)) {\n      out.push(as[i]);\n    }\n  }\n  return out;\n});\n/**\n * @category filtering\n * @since 1.0.0\n */\nexports.filter = filter;\nconst partition = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => {\n  const left = [];\n  const right = [];\n  const as = fromIterable(self);\n  for (let i = 0; i < as.length; i++) {\n    if (predicate(as[i], i)) {\n      right.push(as[i]);\n    } else {\n      left.push(as[i]);\n    }\n  }\n  return [left, right];\n});\n/**\n * @category filtering\n * @since 1.0.0\n */\nexports.partition = partition;\nconst separate = /*#__PURE__*/partitionMap(_Function.identity);\n/**\n * @category traversing\n * @since 1.0.0\n */\nexports.separate = separate;\nconst traverseNonEmpty = F => (0, _Function.dual)(2, (self, f) => {\n  const [head, ...tail] = mapNonEmpty(self, f);\n  return F.productMany(head, tail);\n});\n/**\n * @category traversing\n * @since 1.0.0\n */\nexports.traverseNonEmpty = traverseNonEmpty;\nconst traverse = F => (0, _Function.dual)(2, (self, f) => F.productAll(fromIterable(self).map(f)));\n/**\n * @category traversing\n * @since 1.0.0\n */\nexports.traverse = traverse;\nconst sequence = F => traverse(F)(_Function.identity);\n/**\n * @category instances\n * @since 1.0.0\n */\nexports.sequence = sequence;\nconst Traversable = {\n  traverse: traverse\n};\n/**\n * @category traversing\n * @since 1.0.0\n */\nexports.Traversable = Traversable;\nconst traverseTap = /*#__PURE__*/traversable.traverseTap(Traversable);\n/**\n * @category traversing\n * @since 1.0.0\n */\nexports.traverseTap = traverseTap;\nconst sequenceNonEmpty = F => traverseNonEmpty(F)(_Function.identity);\nexports.sequenceNonEmpty = sequenceNonEmpty;\nconst product = (self, that) => {\n  if (isEmptyReadonlyArray(self) || isEmptyReadonlyArray(that)) {\n    return empty();\n  }\n  const out = [];\n  for (let i = 0; i < self.length; i++) {\n    for (let j = 0; j < that.length; j++) {\n      out.push([self[i], that[j]]);\n    }\n  }\n  return out;\n};\nconst productMany = /*#__PURE__*/semiProduct.productMany(map, product);\n/**\n * @category instances\n * @since 1.0.0\n */\nconst SemiProduct = {\n  imap,\n  product,\n  productMany\n};\n/**\n * @category instances\n * @since 1.0.0\n */\nexports.SemiProduct = SemiProduct;\nconst SemiApplicative = {\n  imap,\n  map,\n  product,\n  productMany\n};\n/**\n * @since 1.0.0\n */\nexports.SemiApplicative = SemiApplicative;\nconst ap = /*#__PURE__*/semiApplicative.ap(SemiApplicative);\n/**\n * Lifts a binary function into `ReadonlyArray`.\n *\n * @param f - The function to lift.\n *\n * @category lifting\n * @since 1.0.0\n */\nexports.ap = ap;\nconst lift2 = /*#__PURE__*/semiApplicative.lift2(SemiApplicative);\n/**\n * @category instances\n * @since 1.0.0\n */\nexports.lift2 = lift2;\nconst Product = {\n  of,\n  imap,\n  product,\n  productMany,\n  productAll: collection => {\n    const arrays = fromIterable(collection);\n    return isEmptyReadonlyArray(arrays) ? empty() : SemiProduct.productMany(arrays[0], arrays.slice(1));\n  }\n};\n/**\n * @category instances\n * @since 1.0.0\n */\nexports.Product = Product;\nconst Applicative = {\n  imap,\n  of,\n  map,\n  product,\n  productMany,\n  productAll: Product.productAll\n};\n/**\n * @category lifting\n * @since 1.0.0\n */\nexports.Applicative = Applicative;\nconst liftMonoid = /*#__PURE__*/applicative.getMonoid(Applicative);\n/**\n * @category instances\n * @since 1.0.0\n */\nexports.liftMonoid = liftMonoid;\nconst Monad = {\n  imap,\n  of,\n  map,\n  flatMap\n};\n/**\n * @category folding\n * @since 1.0.0\n */\nexports.Monad = Monad;\nconst reduce = /*#__PURE__*/(0, _Function.dual)(3, (self, b, f) => fromIterable(self).reduce((b, a, i) => f(b, a, i), b));\n/**\n * @category folding\n * @since 1.0.0\n */\nexports.reduce = reduce;\nconst reduceRight = /*#__PURE__*/(0, _Function.dual)(3, (self, b, f) => fromIterable(self).reduceRight((b, a, i) => f(b, a, i), b));\n/**\n * @category instances\n * @since 1.0.0\n */\nexports.reduceRight = reduceRight;\nconst Foldable = {\n  reduce\n};\n/**\n * @category folding\n * @since 1.0.0\n */\nexports.Foldable = Foldable;\nconst combineMap = Monoid => (0, _Function.dual)(2, (self, f) => fromIterable(self).reduce((m, a, i) => Monoid.combine(m, f(a, i)), Monoid.empty));\n/**\n * @category folding\n * @since 1.0.0\n */\nexports.combineMap = combineMap;\nconst combineMapNonEmpty = S => (0, _Function.dual)(2, (self, f) => tailNonEmpty(self).reduce((s, a, i) => S.combine(s, f(a, i + 1)), f(headNonEmpty(self), 0)));\n/**\n * @category folding\n * @since 1.0.0\n */\nexports.combineMapNonEmpty = combineMapNonEmpty;\nconst reduceKind = /*#__PURE__*/foldable.reduceKind(Foldable);\n/**\n * @category folding\n * @since 1.0.0\n */\nexports.reduceKind = reduceKind;\nconst coproductMapKind = /*#__PURE__*/foldable.coproductMapKind(Foldable);\n/**\n * @category filtering\n * @since 1.0.0\n */\nexports.coproductMapKind = coproductMapKind;\nconst traversePartitionMap = F => (0, _Function.dual)(2, (self, f) => {\n  return F.map(traverse(F)(self, f), separate);\n});\n/**\n * @category filtering\n * @since 1.0.0\n */\nexports.traversePartitionMap = traversePartitionMap;\nconst traverseFilterMap = F => (0, _Function.dual)(2, (self, f) => {\n  return F.map(traverse(F)(self, f), compact);\n});\n/**\n * @category instances\n * @since 1.0.0\n */\nexports.traverseFilterMap = traverseFilterMap;\nconst TraversableFilterable = {\n  traversePartitionMap: traversePartitionMap,\n  traverseFilterMap: traverseFilterMap\n};\n/**\n * Filter values inside a context.\n *\n * @since 1.0.0\n */\nexports.TraversableFilterable = TraversableFilterable;\nconst traverseFilter = /*#__PURE__*/traversableFilterable.traverseFilter(TraversableFilterable);\n/**\n * @since 1.0.0\n */\nexports.traverseFilter = traverseFilter;\nconst traversePartition = /*#__PURE__*/traversableFilterable.traversePartition(TraversableFilterable);\n/**\n * @category lifting\n * @since 1.0.0\n */\nexports.traversePartition = traversePartition;\nconst liftPredicate = predicate => b => predicate(b) ? [b] : [];\n/**\n * @category lifting\n * @since 1.0.0\n */\nexports.liftPredicate = liftPredicate;\nconst liftOption = f => (...a) => fromOption(f(...a));\n/**\n * @category conversions\n * @since 1.0.0\n */\nexports.liftOption = liftOption;\nconst fromNullable = a => a == null ? empty() : [a];\n/**\n * @category lifting\n * @since 1.0.0\n */\nexports.fromNullable = fromNullable;\nconst liftNullable = f => (...a) => fromNullable(f(...a));\n/**\n * @category combining\n * @since 1.0.0\n */\nexports.liftNullable = liftNullable;\nconst flatMapNullable = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => isNonEmptyReadonlyArray(self) ? fromNullable(f(headNonEmpty(self))) : empty());\n/**\n * @category lifting\n * @since 1.0.0\n */\nexports.flatMapNullable = flatMapNullable;\nconst liftEither = f => (...a) => {\n  const e = f(...a);\n  return E.isLeft(e) ? [] : [e.right];\n};\nexports.liftEither = liftEither;\nfunction every(predicate) {\n  return self => self.every(predicate);\n}\n/**\n * Check if a predicate holds true for some `ReadonlyArray` member.\n *\n * @category predicates\n * @since 1.0.0\n */\nconst some = predicate => self => self.some(predicate);\n/**\n * Fold an `Iterable`, accumulating values in some `Monoid`, combining adjacent elements\n * using the specified separator.\n *\n * @since 1.0.0\n */\nexports.some = some;\nconst intercalate = M => (0, _Function.dual)(2, (self, middle) => {\n  const as = fromIterable(self);\n  return isNonEmptyReadonlyArray(as) ? intercalateNonEmpty(M)(as, middle) : M.empty;\n});\n/**\n * Places an element in between members of a `NonEmptyReadonlyArray`, then folds the results using the provided `Semigroup`.\n *\n * @since 1.0.0\n */\nexports.intercalate = intercalate;\nconst intercalateNonEmpty = S => (0, _Function.dual)(2, (self, middle) => semigroup.intercalate(S, middle).combineMany(headNonEmpty(self), tailNonEmpty(self)));\n/**\n * @since 1.0.0\n */\nexports.intercalateNonEmpty = intercalateNonEmpty;\nconst join = /*#__PURE__*/intercalate(string.Monoid);\n/**\n * @since 1.0.0\n */\nexports.join = join;\nconst extend = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => self.map((_, i, as) => f(as.slice(i))));\n/**\n * @since 1.0.0\n */\nexports.extend = extend;\nconst min = /*#__PURE__*/(0, _Function.dual)(2, (self, O) => {\n  const S = semigroup.min(O);\n  return self.reduce(S.combine);\n});\n/**\n * @since 1.0.0\n */\nexports.min = min;\nconst max = /*#__PURE__*/(0, _Function.dual)(2, (self, O) => {\n  const S = semigroup.max(O);\n  return self.reduce(S.combine);\n});\n/**\n * @category constructors\n * @since 1.0.0\n */\nexports.max = max;\nconst unfold = (b, f) => {\n  const out = [];\n  let next = b;\n  let o;\n  while (O.isSome(o = f(next))) {\n    const [a, b] = o.value;\n    out.push(a);\n    next = b;\n  }\n  return out;\n};\n/**\n * @category instances\n * @since 1.0.0\n */\nexports.unfold = unfold;\nconst getUnionSemigroup = isEquivalent => semigroup.make(union(isEquivalent));\n/**\n * @category instances\n * @since 1.0.0\n */\nexports.getUnionSemigroup = getUnionSemigroup;\nconst getUnionMonoid = isEquivalent => {\n  const S = getUnionSemigroup(isEquivalent);\n  return {\n    combine: S.combine,\n    combineMany: S.combineMany,\n    combineAll: collection => S.combineMany([], collection),\n    empty: []\n  };\n};\n/**\n * @category instances\n * @since 1.0.0\n */\nexports.getUnionMonoid = getUnionMonoid;\nconst getIntersectionSemigroup = isEquivalent => semigroup.make(intersection(isEquivalent));\n/**\n * Returns a `Semigroup` for `ReadonlyArray<A>`.\n *\n * @category instances\n * @since 1.0.0\n */\nexports.getIntersectionSemigroup = getIntersectionSemigroup;\nconst getSemigroup = semigroup.array;\n/**\n * Returns a `Monoid` for `ReadonlyArray<A>`.\n *\n * @category instances\n * @since 1.0.0\n */\nexports.getSemigroup = getSemigroup;\nconst getMonoid = monoid.array;\n/**\n * This function creates and returns a new `Order` for an array of values based on a given `Order` for the elements of the array.\n * The returned `Order` compares two arrays by applying the given `Order` to each element in the arrays.\n * If all elements are equal, the arrays are then compared based on their length.\n * It is useful when you need to compare two arrays of the same type and you have a specific way of comparing each element of the array.\n *\n * @category lifting\n * @since 1.0.0\n */\nexports.getMonoid = getMonoid;\nconst getOrder = order.array;\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * @category do notation\n * @since 1.0.0\n */\nexports.getOrder = getOrder;\nconst bindTo = /*#__PURE__*/invariant.bindTo(Invariant);\nexports.bindTo = bindTo;\nconst let_ = /*#__PURE__*/covariant.let(Covariant);\nexports.let = let_;\n/**\n * @category do notation\n * @since 1.0.0\n */\nconst Do = /*#__PURE__*/of_.Do(Of);\n/**\n * @category do notation\n * @since 1.0.0\n */\nexports.Do = Do;\nconst bind = /*#__PURE__*/chainable.bind(Chainable);\n/**\n * A variant of `bind` that sequentially ignores the scope.\n *\n * @category do notation\n * @since 1.0.0\n */\nexports.bind = bind;\nconst andThenBind = /*#__PURE__*/semiProduct.andThenBind(SemiProduct);\nexports.andThenBind = andThenBind;\n//# sourceMappingURL=ReadonlyArray.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.tupled = exports.traverseTap = exports.traversePartitionMap = exports.traversePartition = exports.traverseFilterMap = exports.traverseFilter = exports.traverse = exports.toEntries = exports.toArray = exports.size = exports.sequence = exports.separate = exports.replaceOption = exports.remove = exports.pop = exports.partitionMap = exports.partition = exports.modifyOption = exports.map = exports.isEmptyRecord = exports.isEmptyReadonlyRecord = exports.has = exports.get = exports.fromIterable = exports.fromEntries = exports.flap = exports.filterMap = exports.filter = exports.empty = exports.compact = exports.collect = exports.as = exports.TraversableFilterable = exports.Traversable = exports.Invariant = exports.Filterable = exports.Covariant = void 0;\nvar E = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Either\"));\nvar _Function = /*#__PURE__*/require(\"@effect/data/Function\");\nvar O = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Option\"));\nvar covariant = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/typeclass/Covariant\"));\nvar invariant = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/typeclass/Invariant\"));\nvar traversable = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/typeclass/Traversable\"));\nvar traversableFilterable = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/typeclass/TraversableFilterable\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/**\n * This module provides utility functions for working with records in TypeScript.\n *\n * @since 1.0.0\n */\n\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * Creates a new, empty record.\n *\n * @category constructors\n * @since 1.0.0\n */\nconst empty = () => ({});\n// -------------------------------------------------------------------------------------\n// guards\n// -------------------------------------------------------------------------------------\n/**\n * Determine if a `Record` is empty.\n *\n * @param self - `Record` to test for emptiness.\n *\n * @example\n * import { isEmptyRecord } from \"@effect/data/ReadonlyRecord\"\n *\n * assert.deepStrictEqual(isEmptyRecord({}), true);\n * assert.deepStrictEqual(isEmptyRecord({ a: 3 }), false);\n *\n * @category guards\n * @since 1.0.0\n */\nexports.empty = empty;\nconst isEmptyRecord = self => {\n  for (const k in self) {\n    if (has(self, k)) {\n      return false;\n    }\n  }\n  return true;\n};\n/**\n * Determine if a `ReadonlyRecord` is empty.\n *\n * @param self - `ReadonlyRecord` to test for emptiness.\n *\n * @example\n * import { isEmptyReadonlyRecord } from \"@effect/data/ReadonlyRecord\"\n *\n * assert.deepStrictEqual(isEmptyReadonlyRecord({}), true);\n * assert.deepStrictEqual(isEmptyReadonlyRecord({ a: 3 }), false);\n *\n * @category guards\n * @since 1.0.0\n */\nexports.isEmptyRecord = isEmptyRecord;\nconst isEmptyReadonlyRecord = isEmptyRecord;\n// -------------------------------------------------------------------------------------\n// conversions\n// -------------------------------------------------------------------------------------\n/**\n * Takes an iterable and a projection function and returns a record.\n * The projection function maps each value of the iterable to a tuple of a key and a value, which is then added to the resulting record.\n *\n * @param self - An iterable of values to be mapped to a record.\n * @param f - A projection function that maps values of the iterable to a tuple of a key and a value.\n *\n * @example\n * import { fromIterable } from '@effect/data/ReadonlyRecord'\n *\n * const input = [1, 2, 3, 4]\n *\n * assert.deepStrictEqual(\n *   fromIterable(input, a => [String(a), a * 2]),\n *   { '1': 2, '2': 4, '3': 6, '4': 8 }\n * )\n *\n * @category conversions\n * @since 1.0.0\n */\nexports.isEmptyReadonlyRecord = isEmptyReadonlyRecord;\nconst fromIterable = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => {\n  const out = {};\n  for (const a of self) {\n    const [k, b] = f(a);\n    out[k] = b;\n  }\n  return out;\n});\n/**\n * Builds a record from an iterable of key-value pairs.\n *\n * If there are conflicting keys when using `fromEntries`, the last occurrence of the key/value pair will overwrite the\n * previous ones. So the resulting record will only have the value of the last occurrence of each key.\n *\n * @param self - The iterable of key-value pairs.\n *\n * @example\n * import { fromEntries } from '@effect/data/ReadonlyRecord'\n *\n * const input: Array<[string, number]> = [[\"a\", 1], [\"b\", 2]]\n *\n * assert.deepStrictEqual(fromEntries(input), { a: 1, b: 2 })\n *\n * @category conversions\n * @since 1.0.0\n */\nexports.fromIterable = fromIterable;\nconst fromEntries = /*#__PURE__*/fromIterable(_Function.identity);\n/**\n * Transforms the values of a `ReadonlyRecord` into an `Array` with a custom mapping function.\n *\n * @param self - The `ReadonlyRecord` to transform.\n * @param f - The custom mapping function to apply to each key/value of the `ReadonlyRecord`.\n *\n * @example\n * import { collect } from \"@effect/data/ReadonlyRecord\"\n *\n * const x = { a: 1, b: 2, c: 3 }\n * assert.deepStrictEqual(collect(x, (key, n) => [key, n]), [[\"a\", 1], [\"b\", 2], [\"c\", 3]])\n *\n * @category conversions\n * @since 1.0.0\n */\nexports.fromEntries = fromEntries;\nconst collect = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => {\n  const out = [];\n  for (const key of Object.keys(self)) {\n    out.push(f(key, self[key]));\n  }\n  return out;\n});\n/**\n * Takes a record and returns an array of tuples containing its keys and values.\n *\n * @param self - The record to transform.\n *\n * @example\n * import { toEntries } from \"@effect/data/ReadonlyRecord\"\n *\n * const x = { a: 1, b: 2, c: 3 }\n * assert.deepStrictEqual(toEntries(x), [[\"a\", 1], [\"b\", 2], [\"c\", 3]])\n *\n * @category conversions\n * @since 1.0.0\n */\nexports.collect = collect;\nconst toEntries = /*#__PURE__*/collect((key, value) => [key, value]);\n/**\n * Takes a record and returns an array of tuples containing its keys and values.\n *\n * Alias of {@link toEntries}.\n *\n * @param self - The record to transform.\n *\n * @example\n * import { toArray } from \"@effect/data/ReadonlyRecord\"\n *\n * const x = { a: 1, b: 2, c: 3 }\n * assert.deepStrictEqual(toArray(x), [[\"a\", 1], [\"b\", 2], [\"c\", 3]])\n *\n * @category conversions\n * @since 1.0.0\n */\nexports.toEntries = toEntries;\nconst toArray = toEntries;\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * Returns the number of key/value pairs in a `ReadonlyRecord`.\n *\n * @param self - A `ReadonlyRecord` to calculate the number of key/value pairs in.\n *\n * @example\n * import { size } from \"@effect/data/ReadonlyRecord\";\n *\n * assert.deepStrictEqual(size({ a: \"a\", b: 1, c: true }), 3);\n *\n * @since 1.0.0\n */\nexports.toArray = toArray;\nconst size = self => Object.keys(self).length;\n/**\n * Check if a given `key` exists in a `ReadonlyRecord`.\n *\n * @param self - the `ReadonlyRecord` to look in.\n * @param key - the key to look for in the `ReadonlyRecord`.\n *\n * @example\n * import { has } from '@effect/data/ReadonlyRecord'\n *\n * assert.deepStrictEqual(has({ a: 1, b: 2 }, \"a\"), true);\n * assert.deepStrictEqual(has({ a: 1, b: 2 }, \"c\"), false);\n *\n * @since 1.0.0\n */\nexports.size = size;\nconst has = /*#__PURE__*/(0, _Function.dual)(2, (self, key) => Object.prototype.hasOwnProperty.call(self, key));\n/**\n * Retrieve a value at a particular key from a `ReadonlyRecord`, returning it wrapped in an `Option`.\n *\n * @param self - The `ReadonlyRecord` to retrieve value from.\n * @param key - Key to retrieve from `ReadonlyRecord`.\n *\n * @example\n * import { get } from \"@effect/data/ReadonlyRecord\"\n * import { some, none } from \"@effect/data/Option\"\n *\n * const person = { name: \"John Doe\", age: 35 }\n *\n * assert.deepStrictEqual(get(person, \"name\"), some(\"John Doe\"))\n * assert.deepStrictEqual(get(person, \"email\"), none())\n *\n * @since 1.0.0\n */\nexports.has = has;\nconst get = /*#__PURE__*/(0, _Function.dual)(2, (self, key) => has(self, key) ? O.some(self[key]) : O.none());\n/**\n * Apply a function to the element at the specified key, creating a new record,\n * or return `None` if the key doesn't exist.\n *\n * @param self - The `ReadonlyRecord` to be updated.\n * @param key - The key of the element to modify.\n * @param f - The function to apply to the element.\n *\n * @example\n * import { modifyOption } from \"@effect/data/ReadonlyRecord\"\n * import { some, none } from \"@effect/data/Option\"\n *\n * const f = (x: number) => x * 2\n *\n * assert.deepStrictEqual(\n *  modifyOption({ a: 3 }, 'a', f),\n *  some({ a: 6 })\n * )\n * assert.deepStrictEqual(\n *  modifyOption({ a: 3 }, 'b', f),\n *  none()\n * )\n *\n * @since 1.0.0\n */\nexports.get = get;\nconst modifyOption = /*#__PURE__*/(0, _Function.dual)(3, (self, key, f) => {\n  if (!has(self, key)) {\n    return O.none();\n  }\n  const out = {\n    ...self\n  };\n  out[key] = f(self[key]);\n  return O.some(out);\n});\n/**\n * Replaces a value in the record with the new value passed as parameter.\n *\n * @param self - The `ReadonlyRecord` to be updated.\n * @param key - The key to search for in the record.\n * @param b - The new value to replace the existing value with.\n *\n * @example\n * import { replaceOption } from \"@effect/data/ReadonlyRecord\"\n * import { some, none } from \"@effect/data/Option\"\n *\n * assert.deepStrictEqual(\n *   replaceOption({ a: 1, b: 2, c: 3 }, 'a', 10),\n *   some({ a: 10, b: 2, c: 3 })\n * )\n * assert.deepStrictEqual(replaceOption({}, 'a', 10), none())\n *\n * @since 1.0.0\n */\nexports.modifyOption = modifyOption;\nconst replaceOption = /*#__PURE__*/(0, _Function.dual)(3, (self, key, b) => modifyOption(self, key, () => b));\n/**\n * Removes a key from a `ReadonlyRecord` and returns a new `Record`\n *\n * @param self - the `ReadonlyRecord` to remove the key from.\n * @param key - the key to remove from the `ReadonlyRecord`.\n *\n * @example\n * import { remove } from '@effect/data/ReadonlyRecord'\n *\n * assert.deepStrictEqual(remove({ a: 1, b: 2 }, \"a\"), { b: 2 })\n *\n * @since 1.0.0\n */\nexports.replaceOption = replaceOption;\nconst remove = /*#__PURE__*/(0, _Function.dual)(2, (self, key) => {\n  const out = {\n    ...self\n  };\n  delete out[key];\n  return out;\n});\n/**\n * Retrieves the value of the property with the given `key` from a `ReadonlyRecord` and returns an `Option`\n * of a tuple with the value and the `ReadonlyRecord` with the removed property.\n * If the key is not present, returns `O.none`.\n *\n * @param self - The input `ReadonlyRecord`.\n * @param key - The key of the property to retrieve.\n *\n * @example\n * import { pop } from '@effect/data/ReadonlyRecord'\n * import { some, none } from '@effect/data/Option'\n *\n * assert.deepStrictEqual(pop({ a: 1, b: 2 }, \"a\"), some([1, { b: 2 }]))\n * assert.deepStrictEqual(pop({ a: 1, b: 2 }, \"c\"), none())\n *\n * @category record\n * @since 1.0.0\n */\nexports.remove = remove;\nconst pop = /*#__PURE__*/(0, _Function.dual)(2, (self, key) => has(self, key) ? O.some([self[key], remove(self, key)]) : O.none());\n/**\n * Maps a `ReadonlyRecord` into another `Record` by applying a transformation function to each of its values.\n *\n * @param self - The `ReadonlyRecord` to be mapped.\n * @param f - A transformation function that will be applied to each of the values in the `ReadonlyRecord`.\n *\n * @example\n * import { map } from \"@effect/data/ReadonlyRecord\"\n *\n * const f = (n: number) => `-${n}`\n *\n * assert.deepStrictEqual(map({ a: 3, b: 5 }, f), { a: \"-3\", b: \"-5\" })\n *\n * const g = (n: number, key: string) => `${key.toUpperCase()}-${n}`\n *\n * assert.deepStrictEqual(map({ a: 3, b: 5 }, g), { a: \"A-3\", b: \"B-5\" })\n *\n * @since 1.0.0\n */\nexports.pop = pop;\nconst map = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => {\n  const out = {};\n  for (const key of Object.keys(self)) {\n    out[key] = f(self[key], key);\n  }\n  return out;\n});\n/**\n * Transforms a `ReadonlyRecord` into a `Record` by applying the function `f` to each key and value in the original `ReadonlyRecord`.\n * If the function returns `Some`, the key-value pair is included in the output `Record`.\n *\n * @param self - The input `ReadonlyRecord`.\n * @param f - The transformation function.\n *\n * @example\n * import { filterMap } from '@effect/data/ReadonlyRecord'\n * import { some, none } from '@effect/data/Option'\n *\n * const x = { a: 1, b: 2, c: 3 }\n * const f = (a: number, key: string) => a > 2 ? some(a * 2) : none()\n * assert.deepStrictEqual(filterMap(x, f), { c: 6 })\n *\n * @since 1.0.0\n */\nexports.map = map;\nconst filterMap = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => {\n  const out = {};\n  for (const key of Object.keys(self)) {\n    const o = f(self[key], key);\n    if (O.isSome(o)) {\n      out[key] = o.value;\n    }\n  }\n  return out;\n});\n/**\n * Selects properties from a record whose values match the given predicate.\n *\n * @param self - The `ReadonlyRecord` to filter.\n * @param predicate - A function that returns a `boolean` value to determine if the entry should be included in the new record.\n *\n * @example\n * import { filter } from '@effect/data/ReadonlyRecord'\n *\n * const x = { a: 1, b: 2, c: 3, d: 4 }\n * assert.deepStrictEqual(filter(x, (n) => n > 2), { c: 3, d: 4 })\n *\n * @category filtering\n * @since 1.0.0\n */\nexports.filterMap = filterMap;\nconst filter = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => {\n  const out = {};\n  for (const key of Object.keys(self)) {\n    if (predicate(self[key], key)) {\n      out[key] = self[key];\n    }\n  }\n  return out;\n});\n/**\n * Given a `ReadonlyRecord` with `Option` values, returns a `Record` with only the `Some` values, with the same keys.\n *\n * @param self - A `ReadonlyRecord` with `Option` values.\n *\n * @example\n * import { compact } from '@effect/data/ReadonlyRecord'\n * import { some, none } from '@effect/data/Option'\n *\n * assert.deepStrictEqual(\n *   compact({ a: some(1), b: none(), c: some(2) }),\n *   { a: 1, c: 2 }\n * )\n *\n * @category filtering\n * @since 1.0.0\n */\nexports.filter = filter;\nconst compact = /*#__PURE__*/filterMap(_Function.identity);\n/**\n * Partitions the elements of a `ReadonlyRecord` into two groups: those that match a predicate, and those that don't.\n *\n * @param self - The `ReadonlyRecord` to partition.\n * @param f - The predicate function to apply to each element.\n *\n * @example\n * import { partitionMap } from '@effect/data/ReadonlyRecord'\n * import { left, right } from '@effect/data/Either'\n *\n * const x = { a: 1, b: 2, c: 3 }\n * const f = (n: number) => (n % 2 === 0 ? right(n) : left(n))\n * assert.deepStrictEqual(partitionMap(x, f), [{ a: 1, c: 3 }, { b: 2}])\n *\n * @category filtering\n * @since 1.0.0\n */\nexports.compact = compact;\nconst partitionMap = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => {\n  const left = {};\n  const right = {};\n  for (const key of Object.keys(self)) {\n    const e = f(self[key], key);\n    if (E.isLeft(e)) {\n      left[key] = e.left;\n    } else {\n      right[key] = e.right;\n    }\n  }\n  return [left, right];\n});\n/**\n * Partitions a `ReadonlyRecord` of `Either` values into two separate records,\n * one with the `Left` values and one with the `Right` values.\n *\n * @param self - the `ReadonlyRecord` to partition.\n *\n * @example\n * import { separate } from '@effect/data/ReadonlyRecord'\n * import { left, right } from '@effect/data/Either'\n *\n * assert.deepStrictEqual(\n *   separate({ a: left(\"e\"), b: right(1) }),\n *   [{ a: \"e\" }, { b: 1 }]\n * )\n *\n * @category filtering\n * @since 1.0.0\n */\nexports.partitionMap = partitionMap;\nconst separate = /*#__PURE__*/partitionMap(_Function.identity);\n/**\n * Partitions a `ReadonlyRecord` into two separate `Record`s based on the result of a predicate function.\n *\n * @param self - The input `ReadonlyRecord` to partition.\n * @param predicate - The partitioning function to determine the partitioning of each value of the `ReadonlyRecord`.\n *\n * @example\n * import { partition } from '@effect/data/ReadonlyRecord'\n *\n * assert.deepStrictEqual(\n *   partition({ a: 1, b: 3 }, (n) => n > 2),\n *   [{ a: 1 }, { b: 3 }]\n * )\n *\n * @category filtering\n * @since 1.0.0\n */\nexports.separate = separate;\nconst partition = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => {\n  const left = {};\n  const right = {};\n  for (const key of Object.keys(self)) {\n    if (predicate(self[key], key)) {\n      right[key] = self[key];\n    } else {\n      left[key] = self[key];\n    }\n  }\n  return [left, right];\n});\n/**\n * Maps each entry of a `ReadonlyRecord` to an effect and collects the results into a new record.\n *\n * @param F - an {@link applicative.Applicative Applicative} instance.\n * @param self - a `ReadonlyRecord` to map over.\n * @param f - the mapping function, which maps an entry `a` and its corresponding `key` to an effect.\n *\n * @example\n * import { traverse } from '@effect/data/ReadonlyRecord'\n * import { some, none, Applicative } from '@effect/data/Option'\n *\n * assert.deepStrictEqual(\n *   traverse(Applicative)({ a: 1, b: 2 }, (n: number) => (n <= 2 ? some(n) : none())),\n *   some({ a: 1, b: 2 })\n * )\n * assert.deepStrictEqual(\n *   traverse(Applicative)({ a: 1, b: 2 }, (n: number) => (n >= 2 ? some(n) : none())),\n *   none()\n * )\n *\n * @category traversing\n * @since 1.0.0\n */\nexports.partition = partition;\nconst traverse = F => (0, _Function.dual)(2, (self, f) => F.map(F.productAll(Object.entries(self).map(([key, a]) => F.map(f(a, key), b => [key, b]))), Object.fromEntries));\n/**\n * Transforms a `ReadonlyRecord` of `Kind` values into a `Kind` of `Record` values.\n *\n * @param F - an {@link applicative.Applicative Applicative} instance.\n * @param self - the `ReadonlyRecord` of `Kind` values.\n *\n * @example\n * import * as RR from '@effect/data/ReadonlyRecord'\n * import { some, none, Applicative } from '@effect/data/Option'\n *\n * const sequence = RR.sequence(Applicative)\n *\n * assert.deepStrictEqual(sequence({ a: some(1), b: some(2) }), some({ a: 1, b: 2 }))\n * assert.deepStrictEqual(sequence({ a: none(), b: some(2) }), none())\n *\n * @category traversing\n * @since 1.0.0\n */\nexports.traverse = traverse;\nconst sequence = F => traverse(F)(_Function.identity);\nexports.sequence = sequence;\nconst imap = /*#__PURE__*/covariant.imap(map);\n/**\n * @category instances\n * @since 1.0.0\n */\nconst Covariant = {\n  imap,\n  map\n};\n/**\n * @category instances\n * @since 1.0.0\n */\nexports.Covariant = Covariant;\nconst Invariant = {\n  imap\n};\n/**\n * @category mapping\n * @since 1.0.0\n */\nexports.Invariant = Invariant;\nconst tupled = /*#__PURE__*/invariant.tupled(Invariant);\n/**\n * @category mapping\n * @since 1.0.0\n */\nexports.tupled = tupled;\nconst flap = /*#__PURE__*/covariant.flap(Covariant);\n/**\n * Maps the success value of this effect to the specified constant value.\n *\n * @category mapping\n * @since 1.0.0\n */\nexports.flap = flap;\nconst as = /*#__PURE__*/covariant.as(Covariant);\n/**\n * @category instances\n * @since 1.0.0\n */\nexports.as = as;\nconst Filterable = {\n  partitionMap,\n  filterMap\n};\n/**\n * @category instances\n * @since 1.0.0\n */\nexports.Filterable = Filterable;\nconst Traversable = {\n  traverse\n};\n/**\n * @category traversing\n * @since 1.0.0\n */\nexports.Traversable = Traversable;\nconst traverseTap = /*#__PURE__*/traversable.traverseTap(Traversable);\n/**\n * @category filtering\n * @since 1.0.0\n */\nexports.traverseTap = traverseTap;\nconst traversePartitionMap = F => (0, _Function.dual)(2, (self, f) => {\n  return F.map(traverse(F)(self, f), separate);\n});\n/**\n * @category filtering\n * @since 1.0.0\n */\nexports.traversePartitionMap = traversePartitionMap;\nconst traverseFilterMap = F => (0, _Function.dual)(2, (self, f) => {\n  return F.map(traverse(F)(self, f), compact);\n});\n/**\n * @category instances\n * @since 1.0.0\n */\nexports.traverseFilterMap = traverseFilterMap;\nconst TraversableFilterable = {\n  traversePartitionMap,\n  traverseFilterMap\n};\n/**\n * Filter values inside a context.\n *\n * @since 1.0.0\n */\nexports.TraversableFilterable = TraversableFilterable;\nconst traverseFilter = /*#__PURE__*/traversableFilterable.traverseFilter(TraversableFilterable);\n/**\n * @since 1.0.0\n */\nexports.traverseFilter = traverseFilter;\nconst traversePartition = /*#__PURE__*/traversableFilterable.traversePartition(TraversableFilterable);\nexports.traversePartition = traversePartition;\n//# sourceMappingURL=ReadonlyRecord.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.valuesReversed = exports.values = exports.size = exports.reversed = exports.removeFirst = exports.reduceWithIndex = exports.reduce = exports.make = exports.lessThanReversed = exports.lessThanEqualReversed = exports.lessThanEqual = exports.lessThan = exports.last = exports.keysReversed = exports.keys = exports.isRedBlackTree = exports.insert = exports.has = exports.greaterThanReversed = exports.greaterThanEqualReversed = exports.greaterThanEqual = exports.greaterThan = exports.getOrder = exports.getAt = exports.fromIterable = exports.forEachLessThan = exports.forEachGreaterThanEqual = exports.forEachBetween = exports.forEach = exports.first = exports.findFirst = exports.find = exports.empty = exports.atReversed = exports.at = exports.Direction = void 0;\nvar RBT = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/internal/RedBlackTree\"));\nvar RBTI = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/internal/RedBlackTree/iterator\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\nconst TypeId = RBT.RedBlackTreeTypeId;\n/**\n * @since 1.0.0\n * @category constants\n */\nconst Direction = RBTI.Direction;\n/**\n * @since 1.0.0\n * @category refinements\n */\nexports.Direction = Direction;\nconst isRedBlackTree = RBT.isRedBlackTree;\n/**\n * Creates an empty `RedBlackTree`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.isRedBlackTree = isRedBlackTree;\nconst empty = RBT.empty;\n/**\n * Constructs a new tree from an iterable of key-value pairs.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.empty = empty;\nconst fromIterable = RBT.fromIterable;\n/**\n * Constructs a new `RedBlackTree` from the specified entries.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.fromIterable = fromIterable;\nconst make = RBT.make;\n/**\n * Returns an iterator that points to the element at the specified index of the\n * tree.\n *\n * **Note**: The iterator will run through elements in order.\n *\n * @since 1.0.0\n * @category traversing\n */\nexports.make = make;\nconst at = RBT.atForwards;\n/**\n * Returns an iterator that points to the element at the specified index of the\n * tree.\n *\n * **Note**: The iterator will run through elements in reverse order.\n *\n * @since 1.0.0\n * @category traversing\n */\nexports.at = at;\nconst atReversed = RBT.atBackwards;\n/**\n * Finds all values in the tree associated with the specified key.\n *\n * @since 1.0.0\n * @category elements\n */\nexports.atReversed = atReversed;\nconst find = RBT.find;\n/**\n * Finds the value in the tree associated with the specified key, if it exists.\n *\n * @since 1.0.0\n * @category elements\n */\nexports.find = find;\nconst findFirst = RBT.findFirst;\n/**\n * Returns the first entry in the tree, if it exists.\n *\n * @since 1.0.0\n * @category getters\n */\nexports.findFirst = findFirst;\nconst first = RBT.first;\n/**\n * Returns the element at the specified index within the tree or `None` if the\n * specified index does not exist.\n *\n * @since 1.0.0\n * @category elements\n */\nexports.first = first;\nconst getAt = RBT.getAt;\n/**\n * Gets the `Order<K>` that the `RedBlackTree<K, V>` is using.\n *\n * @since 1.0.0\n * @category getters\n */\nexports.getAt = getAt;\nconst getOrder = RBT.getOrder;\n/**\n * Returns an iterator that traverse entries in order with keys greater than the\n * specified key.\n *\n * @since 1.0.0\n * @category traversing\n */\nexports.getOrder = getOrder;\nconst greaterThan = RBT.greaterThanForwards;\n/**\n * Returns an iterator that traverse entries in reverse order with keys greater\n * than the specified key.\n *\n * @since 1.0.0\n * @category traversing\n */\nexports.greaterThan = greaterThan;\nconst greaterThanReversed = RBT.greaterThanBackwards;\n/**\n * Returns an iterator that traverse entries in order with keys greater than or\n * equal to the specified key.\n *\n * @since 1.0.0\n * @category traversing\n */\nexports.greaterThanReversed = greaterThanReversed;\nconst greaterThanEqual = RBT.greaterThanEqualForwards;\n/**\n * Returns an iterator that traverse entries in reverse order with keys greater\n * than or equal to the specified key.\n *\n * @since 1.0.0\n * @category traversing\n */\nexports.greaterThanEqual = greaterThanEqual;\nconst greaterThanEqualReversed = RBT.greaterThanEqualBackwards;\n/**\n * Finds the item with key, if it exists.\n *\n * @since 1.0.0\n * @category elements\n */\nexports.greaterThanEqualReversed = greaterThanEqualReversed;\nconst has = RBT.has;\n/**\n * Insert a new item into the tree.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.has = has;\nconst insert = RBT.insert;\n/**\n * Get all the keys present in the tree in order.\n *\n * @since 1.0.0\n * @category getters\n */\nexports.insert = insert;\nconst keys = RBT.keysForward;\n/**\n * Get all the keys present in the tree in reverse order.\n *\n * @since 1.0.0\n * @category getters\n */\nexports.keys = keys;\nconst keysReversed = RBT.keysBackward;\n/**\n * Returns the last entry in the tree, if it exists.\n *\n * @since 1.0.0\n * @category getters\n */\nexports.keysReversed = keysReversed;\nconst last = RBT.last;\n/**\n * Returns an iterator that traverse entries in order with keys less than the\n * specified key.\n *\n * @since 1.0.0\n * @category traversing\n */\nexports.last = last;\nconst lessThan = RBT.lessThanForwards;\n/**\n * Returns an iterator that traverse entries in reverse order with keys less\n * than the specified key.\n *\n * @since 1.0.0\n * @category traversing\n */\nexports.lessThan = lessThan;\nconst lessThanReversed = RBT.lessThanBackwards;\n/**\n * Returns an iterator that traverse entries in order with keys less than or\n * equal to the specified key.\n *\n * @since 1.0.0\n * @category traversing\n */\nexports.lessThanReversed = lessThanReversed;\nconst lessThanEqual = RBT.lessThanEqualForwards;\n/**\n * Returns an iterator that traverse entries in reverse order with keys less\n * than or equal to the specified key.\n *\n * @since 1.0.0\n * @category traversing\n */\nexports.lessThanEqual = lessThanEqual;\nconst lessThanEqualReversed = RBT.lessThanEqualBackwards;\n/**\n * Execute the specified function for each node of the tree, in order.\n *\n * @since 1.0.0\n * @category traversing\n */\nexports.lessThanEqualReversed = lessThanEqualReversed;\nconst forEach = RBT.forEach;\n/**\n * Visit each node of the tree in order with key greater then or equal to max.\n *\n * @since 1.0.0\n * @category traversing\n */\nexports.forEach = forEach;\nconst forEachGreaterThanEqual = RBT.forEachGreaterThanEqual;\n/**\n * Visit each node of the tree in order with key lower then max.\n *\n * @since 1.0.0\n * @category traversing\n */\nexports.forEachGreaterThanEqual = forEachGreaterThanEqual;\nconst forEachLessThan = RBT.forEachLessThan;\n/**\n * Visit each node of the tree in order with key lower than max and greater\n * than or equal to min.\n *\n * @since 1.0.0\n * @category traversing\n */\nexports.forEachLessThan = forEachLessThan;\nconst forEachBetween = RBT.forEachBetween;\n/**\n * Reduce a state over the map entries.\n *\n * @since 1.0.0\n * @category folding\n */\nexports.forEachBetween = forEachBetween;\nconst reduce = RBT.reduce;\n/**\n * Reduce a state over the entries of the tree.\n *\n * @since 1.0.0\n * @category folding\n */\nexports.reduce = reduce;\nconst reduceWithIndex = RBT.reduceWithIndex;\n/**\n * Removes the entry with the specified key, if it exists.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.reduceWithIndex = reduceWithIndex;\nconst removeFirst = RBT.removeFirst;\n/**\n * Traverse the tree in reverse order.\n *\n * @since 1.0.0\n * @category traversing\n */\nexports.removeFirst = removeFirst;\nconst reversed = RBT.reversed;\n/**\n * Returns the size of the tree.\n *\n * @since 1.0.0\n * @category getters\n */\nexports.reversed = reversed;\nconst size = RBT.size;\n/**\n * Get all values present in the tree in order.\n *\n * @since 1.0.0\n * @category getters\n */\nexports.size = size;\nconst values = RBT.valuesForward;\n/**\n * Get all values present in the tree in reverse order.\n *\n * @since 1.0.0\n * @category getters\n */\nexports.values = values;\nconst valuesReversed = RBT.valuesBackward;\nexports.valuesReversed = valuesReversed;\n//# sourceMappingURL=RedBlackTree.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.values = exports.union = exports.toggle = exports.some = exports.size = exports.remove = exports.partition = exports.map = exports.make = exports.isSubset = exports.isSortedSet = exports.intersection = exports.has = exports.fromIterable = exports.forEach = exports.flatMap = exports.filter = exports.every = exports.empty = exports.difference = exports.add = void 0;\nvar Equal = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Equal\"));\nvar Dual = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Function\"));\nvar Hash = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Hash\"));\nvar RBT = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/RedBlackTree\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/**\n * @since 1.0.0\n */\n\nconst TypeId = /*#__PURE__*/Symbol.for(\"@effect/data/SortedSet\");\n/** @internal */\nclass SortedSetImpl {\n  constructor(keyTree) {\n    this.keyTree = keyTree;\n    this._id = TypeId;\n  }\n  [Hash.symbol]() {\n    return Hash.combine(Hash.hash(\"@effect/data/SortedSet\"))(Hash.hash(this.keyTree));\n  }\n  [Equal.symbol](that) {\n    return isSortedSet(that) && Equal.equals(this.keyTree, that.keyTree);\n  }\n  [Symbol.iterator]() {\n    return RBT.keys(this.keyTree);\n  }\n  toString() {\n    return `SortedSet(${Array.from(this).map(String).join(\", \")})`;\n  }\n  toJSON() {\n    return {\n      _tag: \"SortedSet\",\n      values: Array.from(this)\n    };\n  }\n  [Symbol.for(\"nodejs.util.inspect.custom\")]() {\n    return this.toJSON();\n  }\n}\n/**\n * @since 1.0.0\n * @category refinements\n */\nconst isSortedSet = u => typeof u === \"object\" && u != null && \"_id\" in u && u[\"_id\"] === TypeId;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexports.isSortedSet = isSortedSet;\nconst empty = O => new SortedSetImpl(RBT.empty(O));\n/**\n * @since 1.0.0\n * @category constructors\n */\nexports.empty = empty;\nconst fromIterable = ord => iterable => new SortedSetImpl(RBT.fromIterable(ord)(Array.from(iterable).map(k => [k, true])));\n/**\n * @since 1.0.0\n * @category constructors\n */\nexports.fromIterable = fromIterable;\nconst make = ord => (...entries) => fromIterable(ord)(entries);\n/**\n * @since 1.0.0\n * @category elements\n */\nexports.make = make;\nconst add = /*#__PURE__*/Dual.dual(2, (self, value) => RBT.has(self.keyTree, value) ? self : new SortedSetImpl(RBT.insert(self.keyTree, value, true)));\n/**\n * @since 1.0.0\n * @category mutations\n */\nexports.add = add;\nconst difference = /*#__PURE__*/Dual.dual(2, (self, that) => {\n  let out = self;\n  for (const value of that) {\n    out = remove(out, value);\n  }\n  return out;\n});\n/**\n * @since 1.0.0\n * @category elements\n */\nexports.difference = difference;\nconst every = /*#__PURE__*/Dual.dual(2, (self, predicate) => {\n  for (const value of self) {\n    if (!predicate(value)) {\n      return false;\n    }\n  }\n  return true;\n});\n/**\n * @since 1.0.0\n * @category filtering\n */\nexports.every = every;\nconst filter = /*#__PURE__*/Dual.dual(2, (self, predicate) => {\n  const ord = RBT.getOrder(self.keyTree);\n  let out = empty(ord);\n  for (const value of self) {\n    if (predicate(value)) {\n      out = add(out, value);\n    }\n  }\n  return out;\n});\n/**\n * @since 1.0.0\n * @category sequencing\n */\nexports.filter = filter;\nconst flatMap = /*#__PURE__*/Dual.dual(3, (self, O, f) => {\n  let out = empty(O);\n  forEach(self, a => {\n    for (const b of f(a)) {\n      out = add(out, b);\n    }\n  });\n  return out;\n});\n/**\n * @since 1.0.0\n * @category traversing\n */\nexports.flatMap = flatMap;\nconst forEach = /*#__PURE__*/Dual.dual(2, (self, f) => RBT.forEach(self.keyTree, f));\n/**\n * @since 1.0.0\n * @category elements\n */\nexports.forEach = forEach;\nconst has = /*#__PURE__*/Dual.dual(2, (self, value) => RBT.has(self.keyTree, value));\n/**\n * @since 1.0.0\n * @category mutations\n */\nexports.has = has;\nconst intersection = /*#__PURE__*/Dual.dual(2, (self, that) => {\n  const ord = RBT.getOrder(self.keyTree);\n  let out = empty(ord);\n  for (const value of that) {\n    if (has(self, value)) {\n      out = add(out, value);\n    }\n  }\n  return out;\n});\n/**\n * @since 1.0.0\n * @category elements\n */\nexports.intersection = intersection;\nconst isSubset = /*#__PURE__*/Dual.dual(2, (self, that) => every(self, a => has(that, a)));\n/**\n * @since 1.0.0\n * @category mapping\n */\nexports.isSubset = isSubset;\nconst map = /*#__PURE__*/Dual.dual(3, (self, O, f) => {\n  let out = empty(O);\n  forEach(self, a => {\n    const b = f(a);\n    if (!has(out, b)) {\n      out = add(out, b);\n    }\n  });\n  return out;\n});\n/**\n * @since 1.0.0\n * @category filtering\n */\nexports.map = map;\nconst partition = /*#__PURE__*/Dual.dual(2, (self, predicate) => {\n  const ord = RBT.getOrder(self.keyTree);\n  let right = empty(ord);\n  let left = empty(ord);\n  for (const value of self) {\n    if (predicate(value)) {\n      right = add(right, value);\n    } else {\n      left = add(left, value);\n    }\n  }\n  return [left, right];\n});\n/**\n * @since 1.0.0\n * @category elements\n */\nexports.partition = partition;\nconst remove = /*#__PURE__*/Dual.dual(2, (self, value) => new SortedSetImpl(RBT.removeFirst(self.keyTree, value)));\n/**\n * @since 1.0.0\n * @category getters\n */\nexports.remove = remove;\nconst size = self => RBT.size(self.keyTree);\n/**\n * @since 1.0.0\n * @category elements\n */\nexports.size = size;\nconst some = /*#__PURE__*/Dual.dual(2, (self, predicate) => {\n  for (const value of self) {\n    if (predicate(value)) {\n      return true;\n    }\n  }\n  return false;\n});\n/**\n * @since 1.0.0\n * @category elements\n */\nexports.some = some;\nconst toggle = /*#__PURE__*/Dual.dual(2, (self, value) => has(self, value) ? remove(self, value) : add(self, value));\n/**\n * @since 1.0.0\n * @category mutations\n */\nexports.toggle = toggle;\nconst union = /*#__PURE__*/Dual.dual(2, (self, that) => {\n  const ord = RBT.getOrder(self.keyTree);\n  let out = empty(ord);\n  for (const value of self) {\n    out = add(value)(out);\n  }\n  for (const value of that) {\n    out = add(value)(out);\n  }\n  return out;\n});\n/**\n * @since 1.0.0\n * @category getters\n */\nexports.union = union;\nconst values = self => RBT.keys(self.keyTree);\nexports.values = values;\n//# sourceMappingURL=SortedSet.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.trimStart = exports.trimEnd = exports.trim = exports.toUpperCase = exports.toLowerCase = exports.takeRight = exports.takeLeft = exports.stripMarginWith = exports.stripMargin = exports.startsWithPosition = exports.startsWith = exports.split = exports.slice = exports.replace = exports.linesWithSeparators = exports.length = exports.isString = exports.isNonEmpty = exports.isEmpty = exports.includesWithPosition = exports.includes = exports.endsWithPosition = exports.endsWith = exports.empty = exports.concat = exports.Semigroup = exports.Order = exports.Monoid = exports.Equivalence = void 0;\nvar _Function = /*#__PURE__*/require(\"@effect/data/Function\");\nvar readonlyArray = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/internal/ReadonlyArray\"));\nvar predicate = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Predicate\"));\nvar equivalence = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/typeclass/Equivalence\"));\nvar monoid = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/typeclass/Monoid\"));\nvar order = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/typeclass/Order\"));\nvar semigroup = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/typeclass/Semigroup\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/**\n * This module provides utility functions and type class instances for working with the `string` type in TypeScript.\n * It includes functions for basic string manipulation, as well as type class instances for\n * `Equivalence`, `Order`, `Semigroup`, and `Monoid`.\n *\n * @since 1.0.0\n */\n\n/**\n * Tests if a value is a `string`.\n *\n * @param input - The value to test.\n *\n * @example\n * import { isString } from '@effect/data/String'\n *\n * assert.deepStrictEqual(isString(\"a\"), true)\n * assert.deepStrictEqual(isString(1), false)\n *\n * @category guards\n * @since 1.0.0\n */\nconst isString = predicate.isString;\n/**\n * @category instances\n * @since 1.0.0\n */\nexports.isString = isString;\nconst Equivalence = equivalence.string;\n/**\n * @category instances\n * @since 1.0.0\n */\nexports.Equivalence = Equivalence;\nconst Order = order.string;\n/**\n * `string` semigroup under concatenation.\n *\n * @category instances\n * @since 1.0.0\n */\nexports.Order = Order;\nconst Semigroup = semigroup.string;\n/**\n * `string` monoid under concatenation.\n *\n * The `empty` value is `''`.\n *\n * @category instances\n * @since 1.0.0\n */\nexports.Semigroup = Semigroup;\nconst Monoid = monoid.string;\n/**\n * The empty string `\"\"`.\n *\n * @since 1.0.0\n */\nexports.Monoid = Monoid;\nconst empty = \"\";\n/**\n * @since 1.0.0\n */\nexports.empty = empty;\nconst concat = /*#__PURE__*/(0, _Function.dual)(2, Semigroup.combine);\n/**\n * @example\n * import * as S from '@effect/data/String'\n * import { pipe } from '@effect/data/Function'\n *\n * assert.deepStrictEqual(pipe('a', S.toUpperCase), 'A')\n *\n * @since 1.0.0\n */\nexports.concat = concat;\nconst toUpperCase = self => self.toUpperCase();\n/**\n * @example\n * import * as S from '@effect/data/String'\n * import { pipe } from '@effect/data/Function'\n *\n * assert.deepStrictEqual(pipe('A', S.toLowerCase), 'a')\n *\n * @since 1.0.0\n */\nexports.toUpperCase = toUpperCase;\nconst toLowerCase = self => self.toLowerCase();\n/**\n * @example\n * import * as S from '@effect/data/String'\n * import { pipe } from '@effect/data/Function'\n *\n * assert.deepStrictEqual(pipe('abc', S.replace('b', 'd')), 'adc')\n *\n * @since 1.0.0\n */\nexports.toLowerCase = toLowerCase;\nconst replace = /*#__PURE__*/(0, _Function.dual)(3, (self, searchValue, replaceValue) => self.replace(searchValue, replaceValue));\n/**\n * @example\n * import * as S from '@effect/data/String'\n *\n * assert.deepStrictEqual(S.trim(' a '), 'a')\n *\n * @since 1.0.0\n */\nexports.replace = replace;\nconst trim = self => self.trim();\n/**\n * @example\n * import * as S from '@effect/data/String'\n *\n * assert.deepStrictEqual(S.trimStart(' a '), 'a ')\n *\n * @since 1.0.0\n */\nexports.trim = trim;\nconst trimStart = self => self.trimStart();\n/**\n * @example\n * import * as S from '@effect/data/String'\n *\n * assert.deepStrictEqual(S.trimEnd(' a '), ' a')\n *\n * @since 1.0.0\n */\nexports.trimStart = trimStart;\nconst trimEnd = self => self.trimEnd();\n/**\n * @example\n * import * as S from '@effect/data/String'\n * import { pipe } from '@effect/data/Function'\n *\n * assert.deepStrictEqual(pipe('abcd', S.slice(1, 3)), 'bc')\n *\n * @since 1.0.0\n */\nexports.trimEnd = trimEnd;\nconst slice = /*#__PURE__*/(0, _Function.dual)(3, (self, start, end) => self.slice(start, end));\n/**\n * Test whether a `string` is empty.\n *\n * @example\n * import * as S from '@effect/data/String'\n *\n * assert.deepStrictEqual(S.isEmpty(''), true)\n * assert.deepStrictEqual(S.isEmpty('a'), false)\n *\n * @since 1.0.0\n */\nexports.slice = slice;\nconst isEmpty = self => self.length === 0;\n/**\n * Test whether a `string` is non empty.\n *\n * @since 1.0.0\n */\nexports.isEmpty = isEmpty;\nconst isNonEmpty = self => self.length > 0;\n/**\n * Calculate the number of characters in a `string`.\n *\n * @example\n * import * as S from '@effect/data/String'\n *\n * assert.deepStrictEqual(S.length('abc'), 3)\n *\n * @since 1.0.0\n */\nexports.isNonEmpty = isNonEmpty;\nconst length = self => self.length;\n/**\n * @example\n * import * as S from '@effect/data/String'\n * import { pipe } from '@effect/data/Function'\n *\n * assert.deepStrictEqual(pipe('abc', S.split('')), ['a', 'b', 'c'])\n * assert.deepStrictEqual(pipe('', S.split('')), [''])\n *\n * @since 1.0.0\n */\nexports.length = length;\nconst split = /*#__PURE__*/(0, _Function.dual)(2, (self, separator) => {\n  const out = self.split(separator);\n  return readonlyArray.isNonEmptyArray(out) ? out : [self];\n});\n/**\n * Returns `true` if `searchString` appears as a substring of `self`, at one or more positions that are\n * greater than or equal to `0`; otherwise, returns `false`.\n *\n * @example\n * import * as S from '@effect/data/String'\n *\n * assert.deepStrictEqual(S.includes(\"abc\", \"b\"), true)\n * assert.deepStrictEqual(S.includes(\"abc\", \"d\"), false)\n *\n * @since 1.0.0\n */\nexports.split = split;\nconst includes = /*#__PURE__*/(0, _Function.dual)(2, (self, searchString) => self.includes(searchString));\n/**\n * Returns `true` if `searchString` appears as a substring of `self`, at one or more positions that are\n * greater than or equal to `position`; otherwise, returns `false`.\n *\n * @example\n * import * as S from '@effect/data/String'\n *\n * assert.deepStrictEqual(S.includesWithPosition(\"abc\", \"b\", 1), true)\n * assert.deepStrictEqual(S.includesWithPosition(\"abc\", \"a\", 1), false)\n *\n * @since 1.0.0\n */\nexports.includes = includes;\nconst includesWithPosition = /*#__PURE__*/(0, _Function.dual)(3, (self, searchString, position) => self.includes(searchString, position));\n/**\n * Returns `true` if the sequence of elements of `searchString` is the\n * same as the corresponding elements of `s` starting at\n * position. Otherwise returns false.\n *\n * @example\n * import * as S from '@effect/data/String'\n *\n * assert.deepStrictEqual(S.startsWith(\"abc\", \"a\"), true)\n * assert.deepStrictEqual(S.startsWith(\"bc\", \"a\"), false)\n *\n * @since 1.0.0\n */\nexports.includesWithPosition = includesWithPosition;\nconst startsWith = /*#__PURE__*/(0, _Function.dual)(2, (self, searchString) => self.startsWith(searchString));\n/**\n * @example\n * import * as S from '@effect/data/String'\n *\n * assert.deepStrictEqual(S.startsWithPosition(\"abc\", \"b\", 1), true)\n * assert.deepStrictEqual(S.startsWithPosition(\"bc\", \"a\", 1), false)\n *\n * @since 1.0.0\n */\nexports.startsWith = startsWith;\nconst startsWithPosition = /*#__PURE__*/(0, _Function.dual)(3, (self, searchString, position) => self.startsWith(searchString, position));\n/**\n * @example\n * import * as S from '@effect/data/String'\n *\n * assert.deepStrictEqual(S.endsWith(\"abc\", \"c\"), true)\n * assert.deepStrictEqual(S.endsWith(\"ab\", \"c\"), false)\n *\n * @since 1.0.0\n */\nexports.startsWithPosition = startsWithPosition;\nconst endsWith = /*#__PURE__*/(0, _Function.dual)(2, (self, searchString) => self.endsWith(searchString));\n/**\n * @example\n * import * as S from '@effect/data/String'\n *\n * assert.deepStrictEqual(S.endsWithPosition(\"abc\", \"b\", 2), true)\n * assert.deepStrictEqual(S.endsWithPosition(\"abc\", \"c\", 2), false)\n *\n * @since 1.0.0\n */\nexports.endsWith = endsWith;\nconst endsWithPosition = /*#__PURE__*/(0, _Function.dual)(3, (self, searchString, position) => self.endsWith(searchString, position));\n/**\n * Keep the specified number of characters from the start of a string.\n *\n * If `n` is larger than the available number of characters, the string will\n * be returned whole.\n *\n * If `n` is not a positive number, an empty string will be returned.\n *\n * If `n` is a float, it will be rounded down to the nearest integer.\n *\n * @example\n * import * as S from '@effect/data/String'\n *\n * assert.deepStrictEqual(S.takeLeft(\"Hello World\", 5), \"Hello\")\n *\n * @since 1.0.0\n */\nexports.endsWithPosition = endsWithPosition;\nconst takeLeft = /*#__PURE__*/(0, _Function.dual)(2, (self, n) => self.slice(0, Math.max(n, 0)));\n/**\n * Keep the specified number of characters from the end of a string.\n *\n * If `n` is larger than the available number of characters, the string will\n * be returned whole.\n *\n * If `n` is not a positive number, an empty string will be returned.\n *\n * If `n` is a float, it will be rounded down to the nearest integer.\n *\n * @example\n * import * as S from '@effect/data/String'\n *\n * assert.deepStrictEqual(S.takeRight(\"Hello World\", 5), \"World\")\n *\n * @since 1.0.0\n */\nexports.takeLeft = takeLeft;\nconst takeRight = /*#__PURE__*/(0, _Function.dual)(2, (self, n) => self.slice(Math.max(0, self.length - Math.floor(n)), Infinity));\n/*\n\n  Missing:\n\n  - charCodeAt\n  - substring\n  - at\n  - charAt\n  - codePointAt\n  - indexOf\n  - lastIndexOf\n  - localeCompare\n  - match\n  - matchAll\n  - normalize\n  - padEnd\n  - padStart\n  - repeat\n  - replaceAll\n  - search\n  - toLocaleLowerCase\n  - toLocaleUpperCase\n*/\nexports.takeRight = takeRight;\nconst CR = 0x0d;\nconst LF = 0x0a;\n/**\n * Returns an `IterableIterator` which yields each line contained within the\n * string, trimming off the trailing newline character.\n *\n * @since 1.0.0\n */\n// export const linesIterator = (self: string): LinesIterator => linesSeparated(self, true)\n/**\n * Returns an `IterableIterator` which yields each line contained within the\n * string as well as the trailing newline character.\n *\n * @since 1.0.0\n */\nconst linesWithSeparators = s => linesSeparated(s, false);\n/**\n * For every line in this string, strip a leading prefix consisting of blanks\n * or control characters followed by the character specified by `marginChar`\n * from the line.\n *\n * @since 1.0.0\n */\nexports.linesWithSeparators = linesWithSeparators;\nconst stripMarginWith = /*#__PURE__*/(0, _Function.dual)(2, (self, marginChar) => {\n  let out = \"\";\n  for (const line of linesWithSeparators(self)) {\n    let index = 0;\n    while (index < line.length && line.charAt(index) <= \" \") {\n      index = index + 1;\n    }\n    const stripped = index < line.length && line.charAt(index) === marginChar ? line.substring(index + 1) : line;\n    out = out + stripped;\n  }\n  return out;\n});\n/**\n * For every line in this string, strip a leading prefix consisting of blanks\n * or control characters followed by the `\"|\"` character from the line.\n *\n * @since 1.0.0\n */\nexports.stripMarginWith = stripMarginWith;\nconst stripMargin = self => stripMarginWith(\"|\")(self);\nexports.stripMargin = stripMargin;\nclass LinesIterator {\n  constructor(s, stripped = false) {\n    this.s = s;\n    this.stripped = stripped;\n    this.index = 0;\n    this.length = s.length;\n  }\n  next() {\n    if (this.done) {\n      return {\n        done: true,\n        value: undefined\n      };\n    }\n    const start = this.index;\n    while (!this.done && !isLineBreak(this.s[this.index])) {\n      this.index = this.index + 1;\n    }\n    let end = this.index;\n    if (!this.done) {\n      const char = this.s[this.index];\n      this.index = this.index + 1;\n      if (!this.done && isLineBreak2(char, this.s[this.index])) {\n        this.index = this.index + 1;\n      }\n      if (!this.stripped) {\n        end = this.index;\n      }\n    }\n    return {\n      done: false,\n      value: this.s.substring(start, end)\n    };\n  }\n  [Symbol.iterator]() {\n    return new LinesIterator(this.s, this.stripped);\n  }\n  get done() {\n    return this.index >= this.length;\n  }\n}\n/**\n * Test if the provided character is a line break character (i.e. either `\"\\r\"`\n * or `\"\\n\"`).\n */\nconst isLineBreak = char => {\n  const code = char.charCodeAt(0);\n  return code === CR || code === LF;\n};\n/**\n * Test if the provided characters combine to form a carriage return/line-feed\n * (i.e. `\"\\r\\n\"`).\n */\nconst isLineBreak2 = (char0, char1) => char0.charCodeAt(0) === CR && char1.charCodeAt(0) === LF;\nconst linesSeparated = (self, stripped) => new LinesIterator(self, stripped);\n//# sourceMappingURL=String.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.unsafeGet = exports.pick = exports.merge = exports.make = exports.isTag = exports.isContext = exports.getOption = exports.get = exports.empty = exports.add = exports.TagTypeId = exports.TagImpl = exports.ContextTypeId = exports.ContextImpl = void 0;\nvar Equal = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Equal\"));\nvar Dual = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Function\"));\nvar G = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Global\"));\nvar Hash = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Hash\"));\nvar option = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Option\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/** @internal */\nconst TagTypeId = /*#__PURE__*/Symbol.for(\"@effect/data/Context/Tag\");\n/** @internal */\nexports.TagTypeId = TagTypeId;\nclass TagImpl {\n  constructor(id) {\n    this._id = TagTypeId;\n    this._S = _ => _;\n    if (typeof id !== \"undefined\") {\n      return G.globalValue(id, () => this);\n    }\n  }\n}\n/** @internal */\nexports.TagImpl = TagImpl;\nconst ContextTypeId = /*#__PURE__*/Symbol.for(\"@effect/data/Context\");\n/** @internal */\nexports.ContextTypeId = ContextTypeId;\nclass ContextImpl {\n  [Equal.symbol](that) {\n    if (isContext(that)) {\n      if (this.unsafeMap.size === that.unsafeMap.size) {\n        for (const k of this.unsafeMap.keys()) {\n          if (!that.unsafeMap.has(k) || !Equal.equals(this.unsafeMap.get(k), that.unsafeMap.get(k))) {\n            return false;\n          }\n        }\n        return true;\n      }\n    }\n    return false;\n  }\n  [Hash.symbol]() {\n    return Hash.number(this.unsafeMap.size);\n  }\n  constructor(unsafeMap) {\n    this.unsafeMap = unsafeMap;\n    this._id = ContextTypeId;\n    this._S = _ => _;\n  }\n}\n/** @internal */\nexports.ContextImpl = ContextImpl;\nconst isContext = u => typeof u === \"object\" && u !== null && \"_id\" in u && u[\"_id\"] === ContextTypeId;\n/** @internal */\nexports.isContext = isContext;\nconst isTag = u => typeof u === \"object\" && u !== null && \"_id\" in u && u[\"_id\"] === TagTypeId;\n/** @internal */\nexports.isTag = isTag;\nconst empty = () => new ContextImpl(new Map());\n/** @internal */\nexports.empty = empty;\nconst make = (tag, service) => new ContextImpl(new Map([[tag, service]]));\n/** @internal */\nexports.make = make;\nconst add = /*#__PURE__*/Dual.dual(3, (self, tag, service) => {\n  const map = new Map(self.unsafeMap);\n  map.set(tag, service);\n  return new ContextImpl(map);\n});\n/** @internal */\nexports.add = add;\nconst get = /*#__PURE__*/Dual.dual(2, (self, tag) => {\n  if (!self.unsafeMap.has(tag)) {\n    throw new Error(\"Service not found\");\n  }\n  return self.unsafeMap.get(tag);\n});\n/** @internal */\nexports.get = get;\nconst unsafeGet = /*#__PURE__*/Dual.dual(2, (self, tag) => {\n  if (!self.unsafeMap.has(tag)) {\n    throw new Error(\"Service not found\");\n  }\n  return self.unsafeMap.get(tag);\n});\n/** @internal */\nexports.unsafeGet = unsafeGet;\nconst getOption = /*#__PURE__*/Dual.dual(2, (self, tag) => {\n  if (!self.unsafeMap.has(tag)) {\n    return option.none();\n  }\n  return option.some(self.unsafeMap.get(tag));\n});\n/** @internal */\nexports.getOption = getOption;\nconst merge = /*#__PURE__*/Dual.dual(2, (self, that) => {\n  const map = new Map(self.unsafeMap);\n  for (const [tag, s] of that.unsafeMap) {\n    map.set(tag, s);\n  }\n  return new ContextImpl(map);\n});\n/** @internal */\nexports.merge = merge;\nconst pick = (...tags) => self => {\n  const tagSet = new Set(tags);\n  const newEnv = new Map();\n  for (const [tag, s] of self.unsafeMap.entries()) {\n    if (tagSet.has(tag)) {\n      newEnv.set(tag, s);\n    }\n  }\n  return new ContextImpl(newEnv);\n};\nexports.pick = pick;\n//# sourceMappingURL=Context.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.zip = exports.updateWith = exports.update = exports.transform = exports.orElseResult = exports.make = exports.hashSet = exports.hashMap = exports.environment = exports.chunk = exports.DifferTypeId = void 0;\nvar ChunkPatch = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Differ/ChunkPatch\"));\nvar ContextPatch = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Differ/ContextPatch\"));\nvar HashMapPatch = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Differ/HashMapPatch\"));\nvar HashSetPatch = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Differ/HashSetPatch\"));\nvar OrPatch = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Differ/OrPatch\"));\nvar Equal = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Equal\"));\nvar Dual = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Function\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/** @internal */\nconst DifferTypeId = /*#__PURE__*/Symbol.for(\"@effect/data/Differ\");\n/** @internal */\nexports.DifferTypeId = DifferTypeId;\nclass DifferImpl {\n  constructor(params) {\n    this._id = DifferTypeId;\n    this._P = Dual.identity;\n    this._V = Dual.identity;\n    this.empty = params.empty;\n    this.diff = params.diff;\n    this.combine = params.combine;\n    this.patch = params.patch;\n  }\n}\n/** @internal */\nconst make = params => new DifferImpl(params);\n/** @internal */\nexports.make = make;\nconst environment = () => make({\n  empty: ContextPatch.empty(),\n  combine: (first, second) => ContextPatch.combine(second)(first),\n  diff: (oldValue, newValue) => ContextPatch.diff(oldValue, newValue),\n  patch: (patch, oldValue) => ContextPatch.patch(oldValue)(patch)\n});\n/** @internal */\nexports.environment = environment;\nconst chunk = differ => make({\n  empty: ChunkPatch.empty(),\n  combine: (first, second) => ChunkPatch.combine(second)(first),\n  diff: (oldValue, newValue) => ChunkPatch.diff(oldValue, newValue, differ),\n  patch: (patch, oldValue) => ChunkPatch.patch(oldValue, differ)(patch)\n});\n/** @internal */\nexports.chunk = chunk;\nconst hashMap = differ => make({\n  empty: HashMapPatch.empty(),\n  combine: (first, second) => HashMapPatch.combine(second)(first),\n  diff: (oldValue, newValue) => HashMapPatch.diff(oldValue, newValue, differ),\n  patch: (patch, oldValue) => HashMapPatch.patch(oldValue, differ)(patch)\n});\n/** @internal */\nexports.hashMap = hashMap;\nconst hashSet = () => make({\n  empty: HashSetPatch.empty(),\n  combine: (first, second) => HashSetPatch.combine(second)(first),\n  diff: (oldValue, newValue) => HashSetPatch.diff(oldValue, newValue),\n  patch: (patch, oldValue) => HashSetPatch.patch(oldValue)(patch)\n});\n/** @internal */\nexports.hashSet = hashSet;\nconst orElseResult = /*#__PURE__*/Dual.dual(2, (self, that) => make({\n  empty: OrPatch.empty(),\n  combine: (first, second) => OrPatch.combine(second)(first),\n  diff: (oldValue, newValue) => OrPatch.diff(oldValue, newValue, self, that),\n  patch: (patch, oldValue) => OrPatch.patch(oldValue, self, that)(patch)\n}));\n/** @internal */\nexports.orElseResult = orElseResult;\nconst transform = /*#__PURE__*/Dual.dual(3, (self, f, g) => make({\n  empty: self.empty,\n  combine: (first, second) => self.combine(first, second),\n  diff: (oldValue, newValue) => self.diff(g(oldValue), g(newValue)),\n  patch: (patch, oldValue) => f(self.patch(patch, g(oldValue)))\n}));\n/** @internal */\nexports.transform = transform;\nconst update = () => updateWith((_, a) => a);\n/** @internal */\nexports.update = update;\nconst updateWith = f => make({\n  empty: Dual.identity,\n  combine: (first, second) => {\n    if (first === Dual.identity) {\n      return second;\n    }\n    if (second === Dual.identity) {\n      return first;\n    }\n    return a => second(first(a));\n  },\n  diff: (oldValue, newValue) => {\n    if (Equal.equals(oldValue, newValue)) {\n      return Dual.identity;\n    }\n    return (0, Dual.constant)(newValue);\n  },\n  patch: (patch, oldValue) => f(oldValue, patch(oldValue))\n});\n/** @internal */\nexports.updateWith = updateWith;\nconst zip = /*#__PURE__*/Dual.dual(2, (self, that) => make({\n  empty: [self.empty, that.empty],\n  combine: (first, second) => [self.combine(first[0], second[0]), that.combine(first[1], second[1])],\n  diff: (oldValue, newValue) => [self.diff(oldValue[0], newValue[0]), that.diff(oldValue[1], newValue[1])],\n  patch: (patch, oldValue) => [self.patch(patch[0], oldValue[0]), that.patch(patch[1], oldValue[1])]\n}));\nexports.zip = zip;\n//# sourceMappingURL=Differ.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.patch = exports.empty = exports.diff = exports.combine = exports.ChunkPatchTypeId = void 0;\nvar Chunk = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Chunk\"));\nvar Equal = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Equal\"));\nvar Dual = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Function\"));\nvar Hash = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Hash\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/** @internal */\nconst ChunkPatchTypeId = /*#__PURE__*/Symbol.for(\"@effect/data/Differ/ChunkPatch\");\nexports.ChunkPatchTypeId = ChunkPatchTypeId;\nfunction variance(a) {\n  return a;\n}\nclass Empty {\n  constructor() {\n    this._tag = \"Empty\";\n    this._Value = variance;\n    this._Patch = variance;\n    this._id = ChunkPatchTypeId;\n  }\n  [Hash.symbol]() {\n    return Hash.string(`ChunkPatch(Empty)`);\n  }\n  [Equal.symbol](that) {\n    return typeof that === \"object\" && that !== null && \"_id\" in that && that[\"_id\"] === this._id && \"_tag\" in that && that[\"_tag\"] === this._id;\n  }\n}\nclass AndThen {\n  constructor(first, second) {\n    this.first = first;\n    this.second = second;\n    this._tag = \"AndThen\";\n    this._Value = variance;\n    this._Patch = variance;\n    this._id = ChunkPatchTypeId;\n  }\n  [Hash.symbol]() {\n    return Hash.string(`ChunkPatch(AndThen)`);\n  }\n  [Equal.symbol](that) {\n    return typeof that === \"object\" && that !== null && \"_id\" in that && that[\"_id\"] === this._id && \"_tag\" in that && that[\"_tag\"] === this._id && Equal.equals(this.first, that.first) && Equal.equals(this.second, that.second);\n  }\n}\nclass Append {\n  constructor(values) {\n    this.values = values;\n    this._tag = \"Append\";\n    this._Value = variance;\n    this._Patch = variance;\n    this._id = ChunkPatchTypeId;\n  }\n  [Hash.symbol]() {\n    return Hash.string(`ChunkPatch(Append)`);\n  }\n  [Equal.symbol](that) {\n    return typeof that === \"object\" && that !== null && \"_id\" in that && that[\"_id\"] === this._id && \"_tag\" in that && that[\"_tag\"] === this._id && Equal.equals(this.values, that.values);\n  }\n}\nclass Slice {\n  constructor(from, until) {\n    this.from = from;\n    this.until = until;\n    this._tag = \"Slice\";\n    this._Value = variance;\n    this._Patch = variance;\n    this._id = ChunkPatchTypeId;\n  }\n  [Hash.symbol]() {\n    return Hash.string(`ChunkPatch(Slice)`);\n  }\n  [Equal.symbol](that) {\n    return typeof that === \"object\" && that !== null && \"_id\" in that && that[\"_id\"] === this._id && \"_tag\" in that && that[\"_tag\"] === this._id && Equal.equals(this.from, that.from) && Equal.equals(this.until, that.until);\n  }\n}\nclass Update {\n  constructor(index, patch) {\n    this.index = index;\n    this.patch = patch;\n    this._tag = \"Update\";\n    this._Value = variance;\n    this._Patch = variance;\n    this._id = ChunkPatchTypeId;\n  }\n  [Hash.symbol]() {\n    return Hash.string(`ChunkPatch(AndThen)`);\n  }\n  [Equal.symbol](that) {\n    return typeof that === \"object\" && that !== null && \"_id\" in that && that[\"_id\"] === this._id && \"_tag\" in that && that[\"_tag\"] === this._id && Equal.equals(this.index, that.index) && Equal.equals(this.patch, that.patch);\n  }\n}\n/** @internal */\nconst empty = () => new Empty();\n/** @internal */\nexports.empty = empty;\nconst diff = (oldValue, newValue, differ) => {\n  let i = 0;\n  let patch = empty();\n  while (i < oldValue.length && i < newValue.length) {\n    const oldElement = Chunk.unsafeGet(i)(oldValue);\n    const newElement = Chunk.unsafeGet(i)(newValue);\n    const valuePatch = differ.diff(oldElement, newElement);\n    if (!Equal.equals(valuePatch, differ.empty)) {\n      patch = combine(new Update(i, valuePatch))(patch);\n    }\n    i = i + 1;\n  }\n  if (i < oldValue.length) {\n    patch = combine(new Slice(0, i))(patch);\n  }\n  if (i < newValue.length) {\n    patch = combine(new Append(Chunk.drop(i)(newValue)))(patch);\n  }\n  return patch;\n};\n/** @internal */\nexports.diff = diff;\nconst combine = /*#__PURE__*/Dual.dual(2, (self, that) => new AndThen(self, that));\n/** @internal */\nexports.combine = combine;\nconst patch = /*#__PURE__*/Dual.dual(3, (self, oldValue, differ) => {\n  let chunk = oldValue;\n  let patches = Chunk.of(self);\n  while (Chunk.isNonEmpty(patches)) {\n    const head = Chunk.headNonEmpty(patches);\n    const tail = Chunk.tailNonEmpty(patches);\n    switch (head._tag) {\n      case \"Empty\":\n        {\n          patches = tail;\n          break;\n        }\n      case \"AndThen\":\n        {\n          patches = Chunk.prepend(head.first)(Chunk.prepend(head.second)(tail));\n          break;\n        }\n      case \"Append\":\n        {\n          chunk = Chunk.concat(head.values)(chunk);\n          patches = tail;\n          break;\n        }\n      case \"Slice\":\n        {\n          const array = Chunk.toReadonlyArray(chunk);\n          chunk = Chunk.unsafeFromArray(array.slice(head.from, head.until));\n          patches = tail;\n          break;\n        }\n      case \"Update\":\n        {\n          const array = Chunk.toReadonlyArray(chunk);\n          array[head.index] = differ.patch(head.patch, array[head.index]);\n          chunk = Chunk.unsafeFromArray(array);\n          patches = tail;\n          break;\n        }\n    }\n  }\n  return chunk;\n});\nexports.patch = patch;\n//# sourceMappingURL=ChunkPatch.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.patch = exports.empty = exports.diff = exports.combine = exports.UpdateService = exports.RemoveService = exports.Empty = exports.ContextPatchTypeId = exports.AndThen = exports.AddService = void 0;\nvar Chunk = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Chunk\"));\nvar Equal = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Equal\"));\nvar Dual = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Function\"));\nvar Hash = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Hash\"));\nvar _Context = /*#__PURE__*/require(\"@effect/data/internal/Context\");\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/** @internal */\nconst ContextPatchTypeId = /*#__PURE__*/Symbol.for(\"@effect/data/Differ/ContextPatch\");\nexports.ContextPatchTypeId = ContextPatchTypeId;\nfunction variance(a) {\n  return a;\n}\n/** @internal */\nclass Empty {\n  constructor() {\n    this._tag = \"Empty\";\n    this._Input = variance;\n    this._Output = variance;\n    this._id = ContextPatchTypeId;\n  }\n  [Hash.symbol]() {\n    return Hash.string(`ContextPatch(Empty)`);\n  }\n  [Equal.symbol](that) {\n    return typeof that === \"object\" && that !== null && \"_id\" in that && that[\"_id\"] === this._id && \"_tag\" in that && that[\"_tag\"] === this._id;\n  }\n}\n/** @internal */\nexports.Empty = Empty;\nclass AndThen {\n  constructor(first, second) {\n    this.first = first;\n    this.second = second;\n    this._tag = \"AndThen\";\n    this._id = ContextPatchTypeId;\n    this._Input = variance;\n    this._Output = variance;\n  }\n  [Hash.symbol]() {\n    return Hash.string(`ContextPatch(AndThen)`);\n  }\n  [Equal.symbol](that) {\n    return typeof that === \"object\" && that !== null && \"_id\" in that && that[\"_id\"] === this._id && \"_tag\" in that && that[\"_tag\"] === this._id && Equal.equals(this.first, that.first) && Equal.equals(this.second, that.second);\n  }\n}\n/** @internal */\nexports.AndThen = AndThen;\nclass AddService {\n  constructor(tag, service) {\n    this.tag = tag;\n    this.service = service;\n    this._tag = \"AddService\";\n    this._id = ContextPatchTypeId;\n    this._Input = variance;\n    this._Output = variance;\n  }\n  [Hash.symbol]() {\n    return Hash.string(`ContextPatch(AddService)`);\n  }\n  [Equal.symbol](that) {\n    return typeof that === \"object\" && that !== null && \"_id\" in that && that[\"_id\"] === this._id && \"_tag\" in that && that[\"_tag\"] === this._id && Equal.equals(this.tag, that.tag) && Equal.equals(this.service, that.service);\n  }\n}\n/** @internal */\nexports.AddService = AddService;\nclass RemoveService {\n  constructor(tag) {\n    this.tag = tag;\n    this._tag = \"RemoveService\";\n    this._id = ContextPatchTypeId;\n    this._Input = variance;\n    this._Output = variance;\n  }\n  [Hash.symbol]() {\n    return Hash.string(`ContextPatch(RemoveService)`);\n  }\n  [Equal.symbol](that) {\n    return typeof that === \"object\" && that !== null && \"_id\" in that && that[\"_id\"] === this._id && \"_tag\" in that && that[\"_tag\"] === this._id && Equal.equals(this.tag, that.tag);\n  }\n}\n/** @internal */\nexports.RemoveService = RemoveService;\nclass UpdateService {\n  constructor(tag, update) {\n    this.tag = tag;\n    this.update = update;\n    this._tag = \"UpdateService\";\n    this._id = ContextPatchTypeId;\n    this._Input = variance;\n    this._Output = variance;\n  }\n  [Hash.symbol]() {\n    return Hash.string(`ContextPatch(AndThen)`);\n  }\n  [Equal.symbol](that) {\n    return typeof that === \"object\" && that !== null && \"_id\" in that && that[\"_id\"] === this._id && \"_tag\" in that && that[\"_tag\"] === this._id && Equal.equals(this.tag, that.tag) && Equal.equals(this.update, that.update);\n  }\n}\n/** @internal */\nexports.UpdateService = UpdateService;\nconst empty = () => new Empty();\n/** @internal */\nexports.empty = empty;\nconst diff = (oldValue, newValue) => {\n  const missingServices = new Map(oldValue.unsafeMap);\n  let patch = empty();\n  for (const [tag, newService] of newValue.unsafeMap.entries()) {\n    if (missingServices.has(tag)) {\n      const old = missingServices.get(tag);\n      missingServices.delete(tag);\n      if (!Equal.equals(old, newService)) {\n        patch = combine(new UpdateService(tag, () => newService))(patch);\n      }\n    } else {\n      missingServices.delete(tag);\n      patch = combine(new AddService(tag, newService))(patch);\n    }\n  }\n  for (const [tag] of missingServices.entries()) {\n    patch = combine(new RemoveService(tag))(patch);\n  }\n  return patch;\n};\n/** @internal */\nexports.diff = diff;\nconst combine = /*#__PURE__*/Dual.dual(2, (self, that) => new AndThen(self, that));\n/** @internal */\nexports.combine = combine;\nconst patch = /*#__PURE__*/Dual.dual(2, (self, context) => {\n  let wasServiceUpdated = false;\n  let patches = Chunk.of(self);\n  const updatedContext = new Map(context.unsafeMap);\n  while (Chunk.isNonEmpty(patches)) {\n    const head = Chunk.headNonEmpty(patches);\n    const tail = Chunk.tailNonEmpty(patches);\n    switch (head._tag) {\n      case \"Empty\":\n        {\n          patches = tail;\n          break;\n        }\n      case \"AddService\":\n        {\n          updatedContext.set(head.tag, head.service);\n          patches = tail;\n          break;\n        }\n      case \"AndThen\":\n        {\n          patches = Chunk.prepend(Chunk.prepend(tail, head.second), head.first);\n          break;\n        }\n      case \"RemoveService\":\n        {\n          updatedContext.delete(head.tag);\n          patches = tail;\n          break;\n        }\n      case \"UpdateService\":\n        {\n          updatedContext.set(head.tag, head.update(updatedContext.get(head.tag)));\n          wasServiceUpdated = true;\n          patches = tail;\n          break;\n        }\n    }\n  }\n  if (!wasServiceUpdated) {\n    return new _Context.ContextImpl(updatedContext);\n  }\n  const map = new Map();\n  for (const [tag] of context.unsafeMap) {\n    if (updatedContext.has(tag)) {\n      map.set(tag, updatedContext.get(tag));\n      updatedContext.delete(tag);\n    }\n  }\n  for (const [tag, s] of updatedContext) {\n    map.set(tag, s);\n  }\n  return new _Context.ContextImpl(map);\n});\nexports.patch = patch;\n//# sourceMappingURL=ContextPatch.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.patch = exports.empty = exports.diff = exports.combine = exports.HashMapPatchTypeId = void 0;\nvar Chunk = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Chunk\"));\nvar Equal = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Equal\"));\nvar Dual = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Function\"));\nvar Hash = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Hash\"));\nvar HashMap = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/HashMap\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/** @internal */\nconst HashMapPatchTypeId = /*#__PURE__*/Symbol.for(\"@effect/data/Differ/HashMapPatch\");\nexports.HashMapPatchTypeId = HashMapPatchTypeId;\nfunction variance(a) {\n  return a;\n}\nclass Empty {\n  constructor() {\n    this._tag = \"Empty\";\n    this._Key = variance;\n    this._Value = variance;\n    this._Patch = variance;\n    this._id = HashMapPatchTypeId;\n  }\n  [Hash.symbol]() {\n    return Hash.string(`HashMapPatch(Empty)`);\n  }\n  [Equal.symbol](that) {\n    return typeof that === \"object\" && that !== null && \"_id\" in that && that[\"_id\"] === this._id && \"_tag\" in that && that[\"_tag\"] === this._id;\n  }\n}\nclass AndThen {\n  constructor(first, second) {\n    this.first = first;\n    this.second = second;\n    this._tag = \"AndThen\";\n    this._Key = variance;\n    this._Value = variance;\n    this._Patch = variance;\n    this._id = HashMapPatchTypeId;\n  }\n  [Hash.symbol]() {\n    return Hash.string(`HashMapPatch(AndThen)`);\n  }\n  [Equal.symbol](that) {\n    return typeof that === \"object\" && that !== null && \"_id\" in that && that[\"_id\"] === this._id && \"_tag\" in that && that[\"_tag\"] === this._id && Equal.equals(this.first, that.first) && Equal.equals(this.second, that.second);\n  }\n}\nclass Add {\n  constructor(key, value) {\n    this.key = key;\n    this.value = value;\n    this._tag = \"Add\";\n    this._Key = variance;\n    this._Value = variance;\n    this._Patch = variance;\n    this._id = HashMapPatchTypeId;\n  }\n  [Hash.symbol]() {\n    return Hash.string(`HashMapPatch(Add)`);\n  }\n  [Equal.symbol](that) {\n    return typeof that === \"object\" && that !== null && \"_id\" in that && that[\"_id\"] === this._id && \"_tag\" in that && that[\"_tag\"] === this._id && Equal.equals(this.key, that.key) && Equal.equals(this.value, that.value);\n  }\n}\nclass Remove {\n  constructor(key) {\n    this.key = key;\n    this._tag = \"Remove\";\n    this._Key = variance;\n    this._Value = variance;\n    this._Patch = variance;\n    this._id = HashMapPatchTypeId;\n  }\n  [Hash.symbol]() {\n    return Hash.string(`HashMapPatch(Remove)`);\n  }\n  [Equal.symbol](that) {\n    return typeof that === \"object\" && that !== null && \"_id\" in that && that[\"_id\"] === this._id && \"_tag\" in that && that[\"_tag\"] === this._id && Equal.equals(this.key, that.key);\n  }\n}\nclass Update {\n  constructor(key, patch) {\n    this.key = key;\n    this.patch = patch;\n    this._tag = \"Update\";\n    this._Key = variance;\n    this._Value = variance;\n    this._Patch = variance;\n    this._id = HashMapPatchTypeId;\n  }\n  [Hash.symbol]() {\n    return Hash.string(`HashMapPatch(Update)`);\n  }\n  [Equal.symbol](that) {\n    return typeof that === \"object\" && that !== null && \"_id\" in that && that[\"_id\"] === this._id && \"_tag\" in that && that[\"_tag\"] === this._id && Equal.equals(this.key, that.key) && Equal.equals(this.patch, that.patch);\n  }\n}\n/** @internal */\nconst empty = () => new Empty();\n/** @internal */\nexports.empty = empty;\nconst diff = (oldValue, newValue, differ) => {\n  const [removed, patch] = HashMap.reduceWithIndex([oldValue, empty()], ([map, patch], newValue, key) => {\n    const option = HashMap.get(key)(map);\n    switch (option._tag) {\n      case \"Some\":\n        {\n          const valuePatch = differ.diff(option.value, newValue);\n          if (Equal.equals(valuePatch, differ.empty)) {\n            return [HashMap.remove(key)(map), patch];\n          }\n          return [HashMap.remove(key)(map), combine(new Update(key, valuePatch))(patch)];\n        }\n      case \"None\":\n        {\n          return [map, combine(new Add(key, newValue))(patch)];\n        }\n    }\n  })(newValue);\n  return HashMap.reduceWithIndex(patch, (patch, _, key) => combine(new Remove(key))(patch))(removed);\n};\n/** @internal */\nexports.diff = diff;\nconst combine = /*#__PURE__*/Dual.dual(2, (self, that) => new AndThen(self, that));\n/** @internal */\nexports.combine = combine;\nconst patch = /*#__PURE__*/Dual.dual(3, (self, oldValue, differ) => {\n  let map = oldValue;\n  let patches = Chunk.of(self);\n  while (Chunk.isNonEmpty(patches)) {\n    const head = Chunk.headNonEmpty(patches);\n    const tail = Chunk.tailNonEmpty(patches);\n    switch (head._tag) {\n      case \"Empty\":\n        {\n          patches = tail;\n          break;\n        }\n      case \"AndThen\":\n        {\n          patches = Chunk.prepend(head.first)(Chunk.prepend(head.second)(tail));\n          break;\n        }\n      case \"Add\":\n        {\n          map = HashMap.set(head.key, head.value)(map);\n          patches = tail;\n          break;\n        }\n      case \"Remove\":\n        {\n          map = HashMap.remove(head.key)(map);\n          patches = tail;\n          break;\n        }\n      case \"Update\":\n        {\n          const option = HashMap.get(head.key)(map);\n          if (option._tag === \"Some\") {\n            map = HashMap.set(head.key, differ.patch(head.patch, option.value))(map);\n          }\n          patches = tail;\n          break;\n        }\n    }\n  }\n  return map;\n});\nexports.patch = patch;\n//# sourceMappingURL=HashMapPatch.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.patch = exports.empty = exports.diff = exports.combine = exports.HashSetPatchTypeId = void 0;\nvar Chunk = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Chunk\"));\nvar Equal = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Equal\"));\nvar Dual = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Function\"));\nvar Hash = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Hash\"));\nvar HashSet = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/HashSet\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/** @internal */\nconst HashSetPatchTypeId = /*#__PURE__*/Symbol.for(\"@effect/data/Differ/HashSetPatch\");\nexports.HashSetPatchTypeId = HashSetPatchTypeId;\nfunction variance(a) {\n  return a;\n}\nclass Empty {\n  constructor() {\n    this._tag = \"Empty\";\n    this._Value = variance;\n    this._id = HashSetPatchTypeId;\n  }\n  [Hash.symbol]() {\n    return Hash.string(`HashSetPatch(Empty)`);\n  }\n  [Equal.symbol](that) {\n    return typeof that === \"object\" && that !== null && \"_id\" in that && that[\"_id\"] === this._id && \"_tag\" in that && that[\"_tag\"] === this._id;\n  }\n}\nclass AndThen {\n  constructor(first, second) {\n    this.first = first;\n    this.second = second;\n    this._tag = \"AndThen\";\n    this._Value = variance;\n    this._id = HashSetPatchTypeId;\n  }\n  [Hash.symbol]() {\n    return Hash.string(`HashSetPatch(AndThen)`);\n  }\n  [Equal.symbol](that) {\n    return typeof that === \"object\" && that !== null && \"_id\" in that && that[\"_id\"] === this._id && \"_tag\" in that && that[\"_tag\"] === this._id && Equal.equals(this.first, that.first) && Equal.equals(this.second, that.second);\n  }\n}\nclass Add {\n  constructor(value) {\n    this.value = value;\n    this._tag = \"Add\";\n    this._Value = variance;\n    this._id = HashSetPatchTypeId;\n  }\n  [Hash.symbol]() {\n    return Hash.string(`HashSetPatch(Add)`);\n  }\n  [Equal.symbol](that) {\n    return typeof that === \"object\" && that !== null && \"_id\" in that && that[\"_id\"] === this._id && \"_tag\" in that && that[\"_tag\"] === this._id && Equal.equals(this.value, that.value);\n  }\n}\nclass Remove {\n  constructor(value) {\n    this.value = value;\n    this._tag = \"Remove\";\n    this._Value = variance;\n    this._id = HashSetPatchTypeId;\n  }\n  [Hash.symbol]() {\n    return Hash.string(`HashSetPatch(Remove)`);\n  }\n  [Equal.symbol](that) {\n    return typeof that === \"object\" && that !== null && \"_id\" in that && that[\"_id\"] === this._id && \"_tag\" in that && that[\"_tag\"] === this._id && Equal.equals(this.value, that.value);\n  }\n}\n/** @internal */\nconst empty = () => new Empty();\n/** @internal */\nexports.empty = empty;\nconst diff = (oldValue, newValue) => {\n  const [removed, patch] = HashSet.reduce([oldValue, empty()], ([set, patch], value) => {\n    if (HashSet.has(value)(set)) {\n      return [HashSet.remove(value)(set), patch];\n    }\n    return [set, combine(new Add(value))(patch)];\n  })(newValue);\n  return HashSet.reduce(patch, (patch, value) => combine(new Remove(value))(patch))(removed);\n};\n/** @internal */\nexports.diff = diff;\nconst combine = /*#__PURE__*/Dual.dual(2, (self, that) => new AndThen(self, that));\n/** @internal */\nexports.combine = combine;\nconst patch = /*#__PURE__*/Dual.dual(2, (self, oldValue) => {\n  let set = oldValue;\n  let patches = Chunk.of(self);\n  while (Chunk.isNonEmpty(patches)) {\n    const head = Chunk.headNonEmpty(patches);\n    const tail = Chunk.tailNonEmpty(patches);\n    switch (head._tag) {\n      case \"Empty\":\n        {\n          patches = tail;\n          break;\n        }\n      case \"AndThen\":\n        {\n          patches = Chunk.prepend(head.first)(Chunk.prepend(head.second)(tail));\n          break;\n        }\n      case \"Add\":\n        {\n          set = HashSet.add(head.value)(set);\n          patches = tail;\n          break;\n        }\n      case \"Remove\":\n        {\n          set = HashSet.remove(head.value)(set);\n          patches = tail;\n        }\n    }\n  }\n  return set;\n});\nexports.patch = patch;\n//# sourceMappingURL=HashSetPatch.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.patch = exports.empty = exports.diff = exports.combine = exports.UpdateRight = exports.UpdateLeft = exports.SetRight = exports.SetLeft = exports.OrPatchTypeId = exports.Empty = exports.AndThen = void 0;\nvar Chunk = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Chunk\"));\nvar E = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Either\"));\nvar Equal = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Equal\"));\nvar Dual = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Function\"));\nvar Hash = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Hash\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/** @internal */\nconst OrPatchTypeId = /*#__PURE__*/Symbol.for(\"@effect/data/Differ/OrPatch\");\nexports.OrPatchTypeId = OrPatchTypeId;\nfunction variance(a) {\n  return a;\n}\n/** @internal */\nclass Empty {\n  constructor() {\n    this._tag = \"Empty\";\n    this._Value = variance;\n    this._Value2 = variance;\n    this._Patch = variance;\n    this._Patch2 = variance;\n    this._id = OrPatchTypeId;\n  }\n  [Hash.symbol]() {\n    return Hash.string(`OrPatch(Empty)`);\n  }\n  [Equal.symbol](that) {\n    return typeof that === \"object\" && that !== null && \"_id\" in that && that[\"_id\"] === this._id && \"_tag\" in that && that[\"_tag\"] === this._id;\n  }\n}\n/** @internal */\nexports.Empty = Empty;\nclass AndThen {\n  constructor(first, second) {\n    this.first = first;\n    this.second = second;\n    this._tag = \"AndThen\";\n    this._Value = variance;\n    this._Value2 = variance;\n    this._Patch = variance;\n    this._Patch2 = variance;\n    this._id = OrPatchTypeId;\n  }\n  [Hash.symbol]() {\n    return Hash.string(`OrPatch(AndThen)`);\n  }\n  [Equal.symbol](that) {\n    return typeof that === \"object\" && that !== null && \"_id\" in that && that[\"_id\"] === this._id && \"_tag\" in that && that[\"_tag\"] === this._id && Equal.equals(this.first, that.first) && Equal.equals(this.second, that.second);\n  }\n}\n/** @internal */\nexports.AndThen = AndThen;\nclass SetLeft {\n  constructor(value) {\n    this.value = value;\n    this._tag = \"SetLeft\";\n    this._Value = variance;\n    this._Value2 = variance;\n    this._Patch = variance;\n    this._Patch2 = variance;\n    this._id = OrPatchTypeId;\n  }\n  [Hash.symbol]() {\n    return Hash.string(`OrPatch(SetLeft)`);\n  }\n  [Equal.symbol](that) {\n    return typeof that === \"object\" && that !== null && \"_id\" in that && that[\"_id\"] === this._id && \"_tag\" in that && that[\"_tag\"] === this._id && Equal.equals(this.value, that.value);\n  }\n}\n/** @internal */\nexports.SetLeft = SetLeft;\nclass SetRight {\n  constructor(value) {\n    this.value = value;\n    this._tag = \"SetRight\";\n    this._Value = variance;\n    this._Value2 = variance;\n    this._Patch = variance;\n    this._Patch2 = variance;\n    this._id = OrPatchTypeId;\n  }\n  [Hash.symbol]() {\n    return Hash.string(`OrPatch(SetRight)`);\n  }\n  [Equal.symbol](that) {\n    return typeof that === \"object\" && that !== null && \"_id\" in that && that[\"_id\"] === this._id && \"_tag\" in that && that[\"_tag\"] === this._id && Equal.equals(this.value, that.value);\n  }\n}\n/** @internal */\nexports.SetRight = SetRight;\nclass UpdateLeft {\n  constructor(patch) {\n    this.patch = patch;\n    this._tag = \"UpdateLeft\";\n    this._Value = variance;\n    this._Value2 = variance;\n    this._Patch = variance;\n    this._Patch2 = variance;\n    this._id = OrPatchTypeId;\n  }\n  [Hash.symbol]() {\n    return Hash.string(`OrPatch(UpdateLeft)`);\n  }\n  [Equal.symbol](that) {\n    return typeof that === \"object\" && that !== null && \"_id\" in that && that[\"_id\"] === this._id && \"_tag\" in that && that[\"_tag\"] === this._id && Equal.equals(this.patch, that.patch);\n  }\n}\n/** @internal */\nexports.UpdateLeft = UpdateLeft;\nclass UpdateRight {\n  constructor(patch) {\n    this.patch = patch;\n    this._tag = \"UpdateRight\";\n    this._Value = variance;\n    this._Value2 = variance;\n    this._Patch = variance;\n    this._Patch2 = variance;\n    this._id = OrPatchTypeId;\n  }\n  [Hash.symbol]() {\n    return Hash.string(`OrPatch(UpdateRight)`);\n  }\n  [Equal.symbol](that) {\n    return typeof that === \"object\" && that !== null && \"_id\" in that && that[\"_id\"] === this._id && \"_tag\" in that && that[\"_tag\"] === this._id && Equal.equals(this.patch, that.patch);\n  }\n}\n/** @internal */\nexports.UpdateRight = UpdateRight;\nconst empty = () => new Empty();\n/** @internal */\nexports.empty = empty;\nconst diff = (oldValue, newValue, left, right) => {\n  switch (oldValue._tag) {\n    case \"Left\":\n      {\n        switch (newValue._tag) {\n          case \"Left\":\n            {\n              const valuePatch = left.diff(oldValue.left, newValue.left);\n              if (Equal.equals(valuePatch, left.empty)) {\n                return new Empty();\n              }\n              return new UpdateLeft(valuePatch);\n            }\n          case \"Right\":\n            {\n              return new SetRight(newValue.right);\n            }\n        }\n      }\n    case \"Right\":\n      {\n        switch (newValue._tag) {\n          case \"Left\":\n            {\n              return new SetLeft(newValue.left);\n            }\n          case \"Right\":\n            {\n              const valuePatch = right.diff(oldValue.right, newValue.right);\n              if (Equal.equals(valuePatch, right.empty)) {\n                return new Empty();\n              }\n              return new UpdateRight(valuePatch);\n            }\n        }\n      }\n  }\n};\n/** @internal */\nexports.diff = diff;\nconst combine = /*#__PURE__*/Dual.dual(2, (self, that) => new AndThen(self, that));\n/** @internal */\nexports.combine = combine;\nconst patch = /*#__PURE__*/Dual.dual(4, (self, oldValue, left, right) => {\n  let patches = Chunk.of(self);\n  let result = oldValue;\n  while (Chunk.isNonEmpty(patches)) {\n    const head = Chunk.headNonEmpty(patches);\n    const tail = Chunk.tailNonEmpty(patches);\n    switch (head._tag) {\n      case \"Empty\":\n        {\n          patches = tail;\n          break;\n        }\n      case \"AndThen\":\n        {\n          patches = Chunk.prepend(head.first)(Chunk.prepend(head.second)(tail));\n          break;\n        }\n      case \"UpdateLeft\":\n        {\n          if (result._tag === \"Left\") {\n            result = E.left(left.patch(head.patch, result.left));\n          }\n          patches = tail;\n          break;\n        }\n      case \"UpdateRight\":\n        {\n          if (result._tag === \"Right\") {\n            result = E.right(right.patch(head.patch, result.right));\n          }\n          patches = tail;\n          break;\n        }\n      case \"SetLeft\":\n        {\n          result = E.left(head.value);\n          patches = tail;\n          break;\n        }\n      case \"SetRight\":\n        {\n          result = E.right(head.value);\n          patches = tail;\n          break;\n        }\n    }\n  }\n  return result;\n});\nexports.patch = patch;\n//# sourceMappingURL=OrPatch.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.right = exports.left = exports.isRight = exports.isLeft = exports.getRight = exports.getLeft = exports.fromOption = void 0;\nvar Data = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Data\"));\nvar _Function = /*#__PURE__*/require(\"@effect/data/Function\");\nvar option = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/internal/Option\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/**\n * @since 1.0.0\n */\n\n/** @internal */\nconst isLeft = ma => ma._tag === \"Left\";\n/** @internal */\nexports.isLeft = isLeft;\nconst isRight = ma => ma._tag === \"Right\";\n/** @internal */\nexports.isRight = isRight;\nconst left = e => Data.struct({\n  _tag: \"Left\",\n  left: e\n});\n/** @internal */\nexports.left = left;\nconst right = a => Data.struct({\n  _tag: \"Right\",\n  right: a\n});\n/** @internal */\nexports.right = right;\nconst getLeft = self => isRight(self) ? option.none : option.some(self.left);\n/** @internal */\nexports.getLeft = getLeft;\nconst getRight = self => isLeft(self) ? option.none : option.some(self.right);\n/** @internal */\nexports.getRight = getRight;\nconst fromOption = /*#__PURE__*/(0, _Function.dual)(2, (self, onNone) => option.isNone(self) ? left(onNone()) : right(self.value));\nexports.fromOption = fromOption;\n//# sourceMappingURL=Either.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.values = exports.unsafeGet = exports.union = exports.size = exports.setTree = exports.set = exports.removeMany = exports.remove = exports.reduceWithIndex = exports.reduce = exports.mutate = exports.modifyHash = exports.modifyAt = exports.modify = exports.mapWithIndex = exports.map = exports.make = exports.keys = exports.isHashMap = exports.isEmpty = exports.hasHash = exports.has = exports.getHash = exports.get = exports.fromIterable = exports.forEachWithIndex = exports.forEach = exports.flatMapWithIndex = exports.flatMap = exports.filterWithIndex = exports.filterMapWithIndex = exports.filterMap = exports.filter = exports.endMutation = exports.empty = exports.compact = exports.beginMutation = exports.HashMapTypeId = exports.HashMapImpl = void 0;\nvar Equal = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Equal\"));\nvar Dual = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Function\"));\nvar Hash = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Hash\"));\nvar _bitwise = /*#__PURE__*/require(\"@effect/data/internal/HashMap/bitwise\");\nvar _config = /*#__PURE__*/require(\"@effect/data/internal/HashMap/config\");\nvar Node = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/internal/HashMap/node\"));\nvar Option = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Option\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/** @internal */\nconst HashMapTypeId = /*#__PURE__*/Symbol.for(\"@effect/data/HashMap\");\n/** @internal */\nexports.HashMapTypeId = HashMapTypeId;\nclass HashMapImpl {\n  constructor(_editable, _edit, _root, _size) {\n    this._editable = _editable;\n    this._edit = _edit;\n    this._root = _root;\n    this._size = _size;\n    this._id = HashMapTypeId;\n  }\n  [Symbol.iterator]() {\n    return new HashMapIterator(this, (k, v) => [k, v]);\n  }\n  [Hash.symbol]() {\n    let hash = Hash.hash(\"HashMap\");\n    for (const item of this) {\n      hash ^= Hash.combine(Hash.hash(item[0]))(Hash.hash(item[1]));\n    }\n    return hash;\n  }\n  [Equal.symbol](that) {\n    if (isHashMap(that)) {\n      if (that._size !== this._size) {\n        return false;\n      }\n      for (const item of this) {\n        const elem = getHash(item[0], Hash.hash(item[0]))(that);\n        if (Option.isNone(elem)) {\n          return false;\n        } else {\n          if (!Equal.equals(item[1], elem.value)) {\n            return false;\n          }\n        }\n      }\n      return true;\n    }\n    return false;\n  }\n  toString() {\n    return `HashMap(${Array.from(this).map(([k, v]) => `[${String(k)}, ${String(v)}]`).join(\", \")})`;\n  }\n  toJSON() {\n    return {\n      _tag: \"HashMap\",\n      values: Array.from(this)\n    };\n  }\n  [Symbol.for(\"nodejs.util.inspect.custom\")]() {\n    return this.toJSON();\n  }\n}\nexports.HashMapImpl = HashMapImpl;\nclass HashMapIterator {\n  constructor(map, f) {\n    this.map = map;\n    this.f = f;\n    this.v = visitLazy(this.map._root, this.f, undefined);\n  }\n  next() {\n    if (Option.isNone(this.v)) {\n      return {\n        done: true,\n        value: undefined\n      };\n    }\n    const v0 = this.v.value;\n    this.v = applyCont(v0.cont);\n    return {\n      done: false,\n      value: v0.value\n    };\n  }\n  [Symbol.iterator]() {\n    return new HashMapIterator(this.map, this.f);\n  }\n}\nconst applyCont = cont => cont ? visitLazyChildren(cont[0], cont[1], cont[2], cont[3], cont[4]) : Option.none();\nconst visitLazy = (node, f, cont = undefined) => {\n  switch (node._tag) {\n    case \"LeafNode\":\n      {\n        if (Option.isSome(node.value)) {\n          return Option.some({\n            value: f(node.key, node.value.value),\n            cont\n          });\n        }\n        return applyCont(cont);\n      }\n    case \"CollisionNode\":\n    case \"ArrayNode\":\n    case \"IndexedNode\":\n      {\n        const children = node.children;\n        return visitLazyChildren(children.length, children, 0, f, cont);\n      }\n    default:\n      {\n        return applyCont(cont);\n      }\n  }\n};\nconst visitLazyChildren = (len, children, i, f, cont) => {\n  while (i < len) {\n    const child = children[i++];\n    if (child && !Node.isEmptyNode(child)) {\n      return visitLazy(child, f, [len, children, i, f, cont]);\n    }\n  }\n  return applyCont(cont);\n};\n/** @internal */\nconst empty = () => new HashMapImpl(false, 0, new Node.EmptyNode(), 0);\n/** @internal */\nexports.empty = empty;\nconst make = (...entries) => fromIterable(entries);\n/** @internal */\nexports.make = make;\nconst fromIterable = entries => {\n  const map = beginMutation(empty());\n  for (const entry of entries) {\n    set(entry[0], entry[1])(map);\n  }\n  return endMutation(map);\n};\n/** @internal */\nexports.fromIterable = fromIterable;\nconst isHashMap = u => typeof u === \"object\" && u != null && \"_id\" in u && u[\"_id\"] === HashMapTypeId;\n/** @internal */\nexports.isHashMap = isHashMap;\nconst isEmpty = self => self && Node.isEmptyNode(self._root);\n/** @internal */\nexports.isEmpty = isEmpty;\nconst get = /*#__PURE__*/Dual.dual(2, (self, key) => getHash(self, key, Hash.hash(key)));\n/** @internal */\nexports.get = get;\nconst getHash = /*#__PURE__*/Dual.dual(3, (self, key, hash) => {\n  let node = self._root;\n  let shift = 0;\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    switch (node._tag) {\n      case \"LeafNode\":\n        {\n          return Equal.equals(key, node.key) ? node.value : Option.none();\n        }\n      case \"CollisionNode\":\n        {\n          if (hash === node.hash) {\n            const children = node.children;\n            for (let i = 0, len = children.length; i < len; ++i) {\n              const child = children[i];\n              if (\"key\" in child && Equal.equals(key, child.key)) {\n                return child.value;\n              }\n            }\n          }\n          return Option.none();\n        }\n      case \"IndexedNode\":\n        {\n          const frag = (0, _bitwise.hashFragment)(shift, hash);\n          const bit = (0, _bitwise.toBitmap)(frag);\n          if (node.mask & bit) {\n            node = node.children[(0, _bitwise.fromBitmap)(node.mask, bit)];\n            shift += _config.SIZE;\n            break;\n          }\n          return Option.none();\n        }\n      case \"ArrayNode\":\n        {\n          node = node.children[(0, _bitwise.hashFragment)(shift, hash)];\n          if (node) {\n            shift += _config.SIZE;\n            break;\n          }\n          return Option.none();\n        }\n      default:\n        return Option.none();\n    }\n  }\n});\n/** @internal */\nexports.getHash = getHash;\nconst unsafeGet = /*#__PURE__*/Dual.dual(2, (self, key) => {\n  const element = getHash(self, key, Hash.hash(key));\n  if (Option.isNone(element)) {\n    throw new Error(\"Error: Expected map to contain key\");\n  }\n  return element.value;\n});\n/** @internal */\nexports.unsafeGet = unsafeGet;\nconst has = /*#__PURE__*/Dual.dual(2, (self, key) => Option.isSome(getHash(self, key, Hash.hash(key))));\n/** @internal */\nexports.has = has;\nconst hasHash = /*#__PURE__*/Dual.dual(3, (self, key, hash) => Option.isSome(getHash(self, key, hash)));\n/** @internal */\nexports.hasHash = hasHash;\nconst set = /*#__PURE__*/Dual.dual(3, (self, key, value) => modifyAt(self, key, () => Option.some(value)));\n/** @internal */\nexports.set = set;\nconst setTree = /*#__PURE__*/Dual.dual(3, (self, newRoot, newSize) => {\n  if (self._editable) {\n    ;\n    self._root = newRoot;\n    self._size = newSize;\n    return self;\n  }\n  return newRoot === self._root ? self : new HashMapImpl(self._editable, self._edit, newRoot, newSize);\n});\n/** @internal */\nexports.setTree = setTree;\nconst keys = self => new HashMapIterator(self, key => key);\n/** @internal */\nexports.keys = keys;\nconst values = self => new HashMapIterator(self, (_, value) => value);\n/** @internal */\nexports.values = values;\nconst size = self => self._size;\n/** @internal */\nexports.size = size;\nconst beginMutation = self => new HashMapImpl(true, self._edit + 1, self._root, self._size);\n/** @internal */\nexports.beginMutation = beginMutation;\nconst endMutation = self => {\n  ;\n  self._editable = false;\n  return self;\n};\n/** @internal */\nexports.endMutation = endMutation;\nconst mutate = /*#__PURE__*/Dual.dual(2, (self, f) => {\n  const transient = beginMutation(self);\n  f(transient);\n  return endMutation(transient);\n});\n/** @internal */\nexports.mutate = mutate;\nconst modifyAt = /*#__PURE__*/Dual.dual(3, (self, key, f) => modifyHash(self, key, Hash.hash(key), f));\n/** @internal */\nexports.modifyAt = modifyAt;\nconst modifyHash = /*#__PURE__*/Dual.dual(4, (self, key, hash, f) => {\n  const size = {\n    value: self._size\n  };\n  const newRoot = self._root.modify(self._editable ? self._edit : NaN, 0, f, hash, key, size);\n  return setTree(newRoot, size.value)(self);\n});\n/** @internal */\nexports.modifyHash = modifyHash;\nconst modify = /*#__PURE__*/Dual.dual(3, (self, key, f) => modifyAt(self, key, Option.map(f)));\n/** @internal */\nexports.modify = modify;\nconst union = /*#__PURE__*/Dual.dual(2, (self, that) => {\n  const result = beginMutation(self);\n  forEachWithIndex(that, (v, k) => set(result, k, v));\n  return endMutation(result);\n});\n/** @internal */\nexports.union = union;\nconst remove = /*#__PURE__*/Dual.dual(2, (self, key) => modifyAt(self, key, Option.none));\n/** @internal */\nexports.remove = remove;\nconst removeMany = /*#__PURE__*/Dual.dual(2, (self, keys) => mutate(self, map => {\n  for (const key of keys) {\n    remove(key)(map);\n  }\n}));\n/** @internal */\nexports.removeMany = removeMany;\nconst map = /*#__PURE__*/Dual.dual(2, (self, f) => mapWithIndex(self, v => f(v)));\n/**\n * Maps over the entries of the `HashMap` using the specified function.\n *\n * @since 1.0.0\n * @category mapping\n */\nexports.map = map;\nconst mapWithIndex = /*#__PURE__*/Dual.dual(2, (self, f) => reduceWithIndex(self, empty(), (map, value, key) => set(map, key, f(value, key))));\n/** @internal */\nexports.mapWithIndex = mapWithIndex;\nconst flatMap = /*#__PURE__*/Dual.dual(2, (self, f) => flatMapWithIndex(self, v => f(v)));\n/** @internal */\nexports.flatMap = flatMap;\nconst flatMapWithIndex = /*#__PURE__*/Dual.dual(2, (self, f) => reduceWithIndex(self, empty(), (zero, value, key) => mutate(zero, map => forEachWithIndex(f(value, key), (value, key) => set(map, key, value)))));\n/** @internal */\nexports.flatMapWithIndex = flatMapWithIndex;\nconst forEach = /*#__PURE__*/Dual.dual(2, (self, f) => forEachWithIndex(self, value => f(value)));\n/** @internal */\nexports.forEach = forEach;\nconst forEachWithIndex = /*#__PURE__*/Dual.dual(2, (self, f) => reduceWithIndex(self, void 0, (_, value, key) => f(value, key)));\n/** @internal */\nexports.forEachWithIndex = forEachWithIndex;\nconst reduce = /*#__PURE__*/Dual.dual(3, (self, z, f) => reduceWithIndex(self, z, (acc, v) => f(acc, v)));\n/** @internal */\nexports.reduce = reduce;\nconst reduceWithIndex = /*#__PURE__*/Dual.dual(3, (self, zero, f) => {\n  const root = self._root;\n  if (root._tag === \"LeafNode\") {\n    return Option.isSome(root.value) ? f(zero, root.value.value, root.key) : zero;\n  }\n  if (root._tag === \"EmptyNode\") {\n    return zero;\n  }\n  const toVisit = [root.children];\n  let children;\n  while (children = toVisit.pop()) {\n    for (let i = 0, len = children.length; i < len;) {\n      const child = children[i++];\n      if (child && !Node.isEmptyNode(child)) {\n        if (child._tag === \"LeafNode\") {\n          if (Option.isSome(child.value)) {\n            zero = f(zero, child.value.value, child.key);\n          }\n        } else {\n          toVisit.push(child.children);\n        }\n      }\n    }\n  }\n  return zero;\n});\n/** @internal */\nexports.reduceWithIndex = reduceWithIndex;\nconst filter = /*#__PURE__*/Dual.dual(2, (self, f) => filterWithIndex(self, f));\n/** @internal */\nexports.filter = filter;\nconst filterWithIndex = /*#__PURE__*/Dual.dual(2, (self, f) => mutate(empty(), map => {\n  for (const [k, a] of self) {\n    if (f(a, k)) {\n      set(map, k, a);\n    }\n  }\n}));\n/** @internal */\nexports.filterWithIndex = filterWithIndex;\nconst compact = self => filterMap(self, Dual.identity);\n/** @internal */\nexports.compact = compact;\nconst filterMap = /*#__PURE__*/Dual.dual(2, (self, f) => filterMapWithIndex(self, f));\n/** @internal */\nexports.filterMap = filterMap;\nconst filterMapWithIndex = /*#__PURE__*/Dual.dual(2, (self, f) => mutate(empty(), map => {\n  for (const [k, a] of self) {\n    const option = f(a, k);\n    if (Option.isSome(option)) {\n      set(map, k, option.value);\n    }\n  }\n}));\nexports.filterMapWithIndex = filterMapWithIndex;\n//# sourceMappingURL=HashMap.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.arraySpliceIn = arraySpliceIn;\nexports.arraySpliceOut = arraySpliceOut;\nexports.arrayUpdate = arrayUpdate;\n/** @internal */\nfunction arrayUpdate(mutate, at, v, arr) {\n  let out = arr;\n  if (!mutate) {\n    const len = arr.length;\n    out = new Array(len);\n    for (let i = 0; i < len; ++i) out[i] = arr[i];\n  }\n  out[at] = v;\n  return out;\n}\n/** @internal */\nfunction arraySpliceOut(mutate, at, arr) {\n  const newLen = arr.length - 1;\n  let i = 0;\n  let g = 0;\n  let out = arr;\n  if (mutate) {\n    i = g = at;\n  } else {\n    out = new Array(newLen);\n    while (i < at) out[g++] = arr[i++];\n  }\n  ;\n  ++i;\n  while (i <= newLen) out[g++] = arr[i++];\n  if (mutate) {\n    out.length = newLen;\n  }\n  return out;\n}\n/** @internal */\nfunction arraySpliceIn(mutate, at, v, arr) {\n  const len = arr.length;\n  if (mutate) {\n    let i = len;\n    while (i >= at) arr[i--] = arr[i];\n    arr[at] = v;\n    return arr;\n  }\n  let i = 0,\n    g = 0;\n  const out = new Array(len + 1);\n  while (i < at) out[g++] = arr[i++];\n  out[at] = v;\n  while (i < len) out[++g] = arr[i++];\n  return out;\n}\n//# sourceMappingURL=array.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.fromBitmap = fromBitmap;\nexports.hashFragment = hashFragment;\nexports.popcount = popcount;\nexports.toBitmap = toBitmap;\nvar _config = /*#__PURE__*/require(\"@effect/data/internal/HashMap/config\");\n/**\n * Hamming weight.\n *\n * Taken from: http://jsperf.com/hamming-weight\n *\n * @internal\n */\nfunction popcount(x) {\n  x -= x >> 1 & 0x55555555;\n  x = (x & 0x33333333) + (x >> 2 & 0x33333333);\n  x = x + (x >> 4) & 0x0f0f0f0f;\n  x += x >> 8;\n  x += x >> 16;\n  return x & 0x7f;\n}\n/** @internal */\nfunction hashFragment(shift, h) {\n  return h >>> shift & _config.MASK;\n}\n/** @internal */\nfunction toBitmap(x) {\n  return 1 << x;\n}\n/** @internal */\nfunction fromBitmap(bitmap, bit) {\n  return popcount(bitmap & bit - 1);\n}\n//# sourceMappingURL=bitwise.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SIZE = exports.MIN_ARRAY_NODE = exports.MAX_INDEX_NODE = exports.MASK = exports.BUCKET_SIZE = void 0;\n/** @internal */\nconst SIZE = 5;\n/** @internal */\nexports.SIZE = SIZE;\nconst BUCKET_SIZE = /*#__PURE__*/Math.pow(2, SIZE);\n/** @internal */\nexports.BUCKET_SIZE = BUCKET_SIZE;\nconst MASK = BUCKET_SIZE - 1;\n/** @internal */\nexports.MASK = MASK;\nconst MAX_INDEX_NODE = BUCKET_SIZE / 2;\n/** @internal */\nexports.MAX_INDEX_NODE = MAX_INDEX_NODE;\nconst MIN_ARRAY_NODE = BUCKET_SIZE / 4;\nexports.MIN_ARRAY_NODE = MIN_ARRAY_NODE;\n//# sourceMappingURL=config.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.keySet = keySet;\nvar _HashSet = /*#__PURE__*/require(\"@effect/data/internal/HashSet\");\n/** @internal */\nfunction keySet(self) {\n  return new _HashSet.HashSetImpl(self);\n}\n//# sourceMappingURL=keySet.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.LeafNode = exports.IndexedNode = exports.EmptyNode = exports.CollisionNode = exports.ArrayNode = void 0;\nexports.canEditNode = canEditNode;\nexports.isEmptyNode = isEmptyNode;\nexports.isLeafNode = isLeafNode;\nvar _Equal = /*#__PURE__*/require(\"@effect/data/Equal\");\nvar _array = /*#__PURE__*/require(\"@effect/data/internal/HashMap/array\");\nvar _bitwise = /*#__PURE__*/require(\"@effect/data/internal/HashMap/bitwise\");\nvar _config = /*#__PURE__*/require(\"@effect/data/internal/HashMap/config\");\nvar _Stack = /*#__PURE__*/require(\"@effect/data/internal/Stack\");\nvar O = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Option\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/** @internal */\nclass EmptyNode {\n  constructor() {\n    this._tag = \"EmptyNode\";\n  }\n  modify(edit, _shift, f, hash, key, size) {\n    const v = f(O.none());\n    if (O.isNone(v)) return new EmptyNode();\n    ++size.value;\n    return new LeafNode(edit, hash, key, v);\n  }\n}\n/** @internal */\nexports.EmptyNode = EmptyNode;\nfunction isEmptyNode(a) {\n  return a instanceof EmptyNode;\n}\n/** @internal */\nfunction isLeafNode(node) {\n  return isEmptyNode(node) || node._tag === \"LeafNode\" || node._tag === \"CollisionNode\";\n}\n/** @internal */\nfunction canEditNode(node, edit) {\n  return isEmptyNode(node) ? false : edit === node.edit;\n}\n/** @internal */\nclass LeafNode {\n  constructor(edit, hash, key, value) {\n    this.edit = edit;\n    this.hash = hash;\n    this.key = key;\n    this.value = value;\n    this._tag = \"LeafNode\";\n  }\n  modify(edit, shift, f, hash, key, size) {\n    if ((0, _Equal.equals)(key, this.key)) {\n      const v = f(this.value);\n      if (v === this.value) return this;else if (O.isNone(v)) {\n        ;\n        --size.value;\n        return new EmptyNode();\n      }\n      if (canEditNode(this, edit)) {\n        this.value = v;\n        return this;\n      }\n      return new LeafNode(edit, hash, key, v);\n    }\n    const v = f(O.none());\n    if (O.isNone(v)) return this;\n    ++size.value;\n    return mergeLeaves(edit, shift, this.hash, this, hash, new LeafNode(edit, hash, key, v));\n  }\n}\n/** @internal */\nexports.LeafNode = LeafNode;\nclass CollisionNode {\n  constructor(edit, hash, children) {\n    this.edit = edit;\n    this.hash = hash;\n    this.children = children;\n    this._tag = \"CollisionNode\";\n  }\n  modify(edit, shift, f, hash, key, size) {\n    if (hash === this.hash) {\n      const canEdit = canEditNode(this, edit);\n      const list = this.updateCollisionList(canEdit, edit, this.hash, this.children, f, key, size);\n      if (list === this.children) return this;\n      return list.length > 1 ? new CollisionNode(edit, this.hash, list) : list[0]; // collapse single element collision list\n    }\n\n    const v = f(O.none());\n    if (O.isNone(v)) return this;\n    ++size.value;\n    return mergeLeaves(edit, shift, this.hash, this, hash, new LeafNode(edit, hash, key, v));\n  }\n  updateCollisionList(mutate, edit, hash, list, f, key, size) {\n    const len = list.length;\n    for (let i = 0; i < len; ++i) {\n      const child = list[i];\n      if (\"key\" in child && (0, _Equal.equals)(key, child.key)) {\n        const value = child.value;\n        const newValue = f(value);\n        if (newValue === value) return list;\n        if (O.isNone(newValue)) {\n          ;\n          --size.value;\n          return (0, _array.arraySpliceOut)(mutate, i, list);\n        }\n        return (0, _array.arrayUpdate)(mutate, i, new LeafNode(edit, hash, key, newValue), list);\n      }\n    }\n    const newValue = f(O.none());\n    if (O.isNone(newValue)) return list;\n    ++size.value;\n    return (0, _array.arrayUpdate)(mutate, len, new LeafNode(edit, hash, key, newValue), list);\n  }\n}\n/** @internal */\nexports.CollisionNode = CollisionNode;\nclass IndexedNode {\n  constructor(edit, mask, children) {\n    this.edit = edit;\n    this.mask = mask;\n    this.children = children;\n    this._tag = \"IndexedNode\";\n  }\n  modify(edit, shift, f, hash, key, size) {\n    const mask = this.mask;\n    const children = this.children;\n    const frag = (0, _bitwise.hashFragment)(shift, hash);\n    const bit = (0, _bitwise.toBitmap)(frag);\n    const indx = (0, _bitwise.fromBitmap)(mask, bit);\n    const exists = mask & bit;\n    const canEdit = canEditNode(this, edit);\n    if (!exists) {\n      const _newChild = new EmptyNode().modify(edit, shift + _config.SIZE, f, hash, key, size);\n      if (!_newChild) return this;\n      return children.length >= _config.MAX_INDEX_NODE ? expand(edit, frag, _newChild, mask, children) : new IndexedNode(edit, mask | bit, (0, _array.arraySpliceIn)(canEdit, indx, _newChild, children));\n    }\n    const current = children[indx];\n    const child = current.modify(edit, shift + _config.SIZE, f, hash, key, size);\n    if (current === child) return this;\n    let bitmap = mask;\n    let newChildren;\n    if (isEmptyNode(child)) {\n      // remove\n      bitmap &= ~bit;\n      if (!bitmap) return new EmptyNode();\n      if (children.length <= 2 && isLeafNode(children[indx ^ 1])) {\n        return children[indx ^ 1]; // collapse\n      }\n\n      newChildren = (0, _array.arraySpliceOut)(canEdit, indx, children);\n    } else {\n      // modify\n      newChildren = (0, _array.arrayUpdate)(canEdit, indx, child, children);\n    }\n    if (canEdit) {\n      this.mask = bitmap;\n      this.children = newChildren;\n      return this;\n    }\n    return new IndexedNode(edit, bitmap, newChildren);\n  }\n}\n/** @internal */\nexports.IndexedNode = IndexedNode;\nclass ArrayNode {\n  constructor(edit, size, children) {\n    this.edit = edit;\n    this.size = size;\n    this.children = children;\n    this._tag = \"ArrayNode\";\n  }\n  modify(edit, shift, f, hash, key, size) {\n    let count = this.size;\n    const children = this.children;\n    const frag = (0, _bitwise.hashFragment)(shift, hash);\n    const child = children[frag];\n    const newChild = (child || new EmptyNode()).modify(edit, shift + _config.SIZE, f, hash, key, size);\n    if (child === newChild) return this;\n    const canEdit = canEditNode(this, edit);\n    let newChildren;\n    if (isEmptyNode(child) && !isEmptyNode(newChild)) {\n      // add\n      ;\n      ++count;\n      newChildren = (0, _array.arrayUpdate)(canEdit, frag, newChild, children);\n    } else if (!isEmptyNode(child) && isEmptyNode(newChild)) {\n      // remove\n      ;\n      --count;\n      if (count <= _config.MIN_ARRAY_NODE) {\n        return pack(edit, count, frag, children);\n      }\n      newChildren = (0, _array.arrayUpdate)(canEdit, frag, new EmptyNode(), children);\n    } else {\n      // modify\n      newChildren = (0, _array.arrayUpdate)(canEdit, frag, newChild, children);\n    }\n    if (canEdit) {\n      this.size = count;\n      this.children = newChildren;\n      return this;\n    }\n    return new ArrayNode(edit, count, newChildren);\n  }\n}\nexports.ArrayNode = ArrayNode;\nfunction pack(edit, count, removed, elements) {\n  const children = new Array(count - 1);\n  let g = 0;\n  let bitmap = 0;\n  for (let i = 0, len = elements.length; i < len; ++i) {\n    if (i !== removed) {\n      const elem = elements[i];\n      if (elem && !isEmptyNode(elem)) {\n        children[g++] = elem;\n        bitmap |= 1 << i;\n      }\n    }\n  }\n  return new IndexedNode(edit, bitmap, children);\n}\nfunction expand(edit, frag, child, bitmap, subNodes) {\n  const arr = [];\n  let bit = bitmap;\n  let count = 0;\n  for (let i = 0; bit; ++i) {\n    if (bit & 1) arr[i] = subNodes[count++];\n    bit >>>= 1;\n  }\n  arr[frag] = child;\n  return new ArrayNode(edit, count + 1, arr);\n}\nfunction mergeLeavesInner(edit, shift, h1, n1, h2, n2) {\n  if (h1 === h2) return new CollisionNode(edit, h1, [n2, n1]);\n  const subH1 = (0, _bitwise.hashFragment)(shift, h1);\n  const subH2 = (0, _bitwise.hashFragment)(shift, h2);\n  if (subH1 === subH2) {\n    return child => new IndexedNode(edit, (0, _bitwise.toBitmap)(subH1) | (0, _bitwise.toBitmap)(subH2), [child]);\n  } else {\n    const children = subH1 < subH2 ? [n1, n2] : [n2, n1];\n    return new IndexedNode(edit, (0, _bitwise.toBitmap)(subH1) | (0, _bitwise.toBitmap)(subH2), children);\n  }\n}\nfunction mergeLeaves(edit, shift, h1, n1, h2, n2) {\n  let stack = undefined;\n  let currentShift = shift;\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    const res = mergeLeavesInner(edit, currentShift, h1, n1, h2, n2);\n    if (typeof res === \"function\") {\n      stack = new _Stack.Stack(res, stack);\n      currentShift = currentShift + _config.SIZE;\n    } else {\n      let final = res;\n      while (stack != null) {\n        final = stack.value(final);\n        stack = stack.previous;\n      }\n      return final;\n    }\n  }\n}\n//# sourceMappingURL=node.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.values = exports.union = exports.toggle = exports.some = exports.size = exports.remove = exports.reduce = exports.partition = exports.mutate = exports.map = exports.make = exports.isSubset = exports.isHashSet = exports.intersection = exports.has = exports.fromIterable = exports.forEach = exports.flatMap = exports.filter = exports.every = exports.endMutation = exports.empty = exports.difference = exports.beginMutation = exports.add = exports.HashSetTypeId = exports.HashSetImpl = void 0;\nvar Equal = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Equal\"));\nvar Dual = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Function\"));\nvar Hash = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Hash\"));\nvar HM = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/internal/HashMap\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/** @internal */\nconst HashSetTypeId = /*#__PURE__*/Symbol.for(\"@effect/data/HashSet\");\n/** @internal */\nexports.HashSetTypeId = HashSetTypeId;\nclass HashSetImpl {\n  constructor(_keyMap) {\n    this._keyMap = _keyMap;\n    this._id = HashSetTypeId;\n  }\n  [Symbol.iterator]() {\n    return HM.keys(this._keyMap);\n  }\n  [Hash.symbol]() {\n    return Hash.combine(Hash.hash(this._keyMap))(Hash.hash(\"HashSet\"));\n  }\n  [Equal.symbol](that) {\n    if (isHashSet(that)) {\n      return HM.size(this._keyMap) === HM.size(that._keyMap) && Equal.equals(this._keyMap, that._keyMap);\n    }\n    return false;\n  }\n  toString() {\n    return `HashSet(${Array.from(this).map(String).join(\", \")})`;\n  }\n  toJSON() {\n    return {\n      _tag: \"HashSet\",\n      values: Array.from(this)\n    };\n  }\n  [Symbol.for(\"nodejs.util.inspect.custom\")]() {\n    return this.toJSON();\n  }\n}\n/** @internal */\nexports.HashSetImpl = HashSetImpl;\nconst isHashSet = u => typeof u === \"object\" && u != null && \"_id\" in u && u[\"_id\"] === HashSetTypeId;\n/** @internal */\nexports.isHashSet = isHashSet;\nconst empty = () => new HashSetImpl(HM.empty());\n/** @internal */\nexports.empty = empty;\nconst fromIterable = elements => {\n  const set = beginMutation(empty());\n  for (const value of elements) {\n    add(set, value);\n  }\n  return endMutation(set);\n};\n/** @internal */\nexports.fromIterable = fromIterable;\nconst make = (...elements) => {\n  const set = beginMutation(empty());\n  for (const value of elements) {\n    add(set, value);\n  }\n  return endMutation(set);\n};\n/** @internal */\nexports.make = make;\nconst has = /*#__PURE__*/Dual.dual(2, (self, value) => HM.has(self._keyMap, value));\n/** @internal */\nexports.has = has;\nconst some = /*#__PURE__*/Dual.dual(2, (self, f) => {\n  let found = false;\n  for (const value of self) {\n    found = f(value);\n    if (found) {\n      break;\n    }\n  }\n  return found;\n});\n/** @internal */\nexports.some = some;\nconst every = /*#__PURE__*/Dual.dual(2, (self, f) => !some(self, a => !f(a)));\n/** @internal */\nexports.every = every;\nconst isSubset = /*#__PURE__*/Dual.dual(2, (self, that) => every(self, value => has(that, value)));\n/** @internal */\nexports.isSubset = isSubset;\nconst values = self => HM.keys(self._keyMap);\n/** @internal */\nexports.values = values;\nconst size = self => HM.size(self._keyMap);\n/** @internal */\nexports.size = size;\nconst beginMutation = self => new HashSetImpl(HM.beginMutation(self._keyMap));\n/** @internal */\nexports.beginMutation = beginMutation;\nconst endMutation = self => {\n  ;\n  self._keyMap._editable = false;\n  return self;\n};\n/** @internal */\nexports.endMutation = endMutation;\nconst mutate = /*#__PURE__*/Dual.dual(2, (self, f) => {\n  const transient = beginMutation(self);\n  f(transient);\n  return endMutation(transient);\n});\n/** @internal */\nexports.mutate = mutate;\nconst add = /*#__PURE__*/Dual.dual(2, (self, value) => self._keyMap._editable ? (HM.set(value, true)(self._keyMap), self) : new HashSetImpl(HM.set(value, true)(self._keyMap)));\n/** @internal */\nexports.add = add;\nconst remove = /*#__PURE__*/Dual.dual(2, (self, value) => self._keyMap._editable ? (HM.remove(value)(self._keyMap), self) : new HashSetImpl(HM.remove(value)(self._keyMap)));\n/** @internal */\nexports.remove = remove;\nconst difference = /*#__PURE__*/Dual.dual(2, (self, that) => mutate(self, set => {\n  for (const value of that) {\n    remove(set, value);\n  }\n}));\n/** @internal */\nexports.difference = difference;\nconst intersection = /*#__PURE__*/Dual.dual(2, (self, that) => mutate(empty(), set => {\n  for (const value of that) {\n    if (has(value)(self)) {\n      add(value)(set);\n    }\n  }\n}));\n/** @internal */\nexports.intersection = intersection;\nconst union = /*#__PURE__*/Dual.dual(2, (self, that) => mutate(empty(), set => {\n  forEach(self, value => add(set, value));\n  for (const value of that) {\n    add(set, value);\n  }\n}));\n/** @internal */\nexports.union = union;\nconst toggle = /*#__PURE__*/Dual.dual(2, (self, value) => has(self, value) ? remove(self, value) : add(self, value));\n/** @internal */\nexports.toggle = toggle;\nconst map = /*#__PURE__*/Dual.dual(2, (self, f) => mutate(empty(), set => {\n  forEach(self, a => {\n    const b = f(a);\n    if (!has(set, b)) {\n      add(set, b);\n    }\n  });\n}));\n/** @internal */\nexports.map = map;\nconst flatMap = /*#__PURE__*/Dual.dual(2, (self, f) => mutate(empty(), set => {\n  forEach(self, a => {\n    for (const b of f(a)) {\n      if (!has(set, b)) {\n        add(set, b);\n      }\n    }\n  });\n}));\n/** @internal */\nexports.flatMap = flatMap;\nconst forEach = /*#__PURE__*/Dual.dual(2, (self, f) => HM.forEachWithIndex(self._keyMap, (_, k) => f(k)));\n/** @internal */\nexports.forEach = forEach;\nconst reduce = /*#__PURE__*/Dual.dual(3, (self, zero, f) => HM.reduceWithIndex(self._keyMap, zero, (z, _, a) => f(z, a)));\n/** @internal */\nexports.reduce = reduce;\nconst filter = /*#__PURE__*/Dual.dual(2, (self, f) => {\n  return mutate(empty(), set => {\n    const iterator = values(self);\n    let next;\n    while (!(next = iterator.next()).done) {\n      const value = next.value;\n      if (f(value)) {\n        add(set, value);\n      }\n    }\n  });\n});\n/** @internal */\nexports.filter = filter;\nconst partition = /*#__PURE__*/Dual.dual(2, (self, f) => {\n  const iterator = values(self);\n  let next;\n  const right = beginMutation(empty());\n  const left = beginMutation(empty());\n  while (!(next = iterator.next()).done) {\n    const value = next.value;\n    if (f(value)) {\n      add(right, value);\n    } else {\n      add(left, value);\n    }\n  }\n  return [endMutation(left), endMutation(right)];\n});\nexports.partition = partition;\n//# sourceMappingURL=HashSet.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.some = exports.none = exports.isSome = exports.isNone = void 0;\nvar Data = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Data\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/**\n * @since 1.0.0\n */\n\n/** @internal */\nconst isNone = fa => fa._tag === \"None\";\n/** @internal */\nexports.isNone = isNone;\nconst isSome = fa => fa._tag === \"Some\";\n/** @internal */\nexports.isSome = isSome;\nconst none = /*#__PURE__*/Data.struct({\n  _tag: \"None\"\n});\n/** @internal */\nexports.none = none;\nconst some = a => Data.struct({\n  _tag: \"Some\",\n  value: a\n});\nexports.some = some;\n//# sourceMappingURL=Option.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isNonEmptyArray = exports.fromIterable = void 0;\n/**\n * @since 1.0.0\n */\n/** @internal */\nconst isNonEmptyArray = self => self.length > 0;\n/** @internal */\nexports.isNonEmptyArray = isNonEmptyArray;\nconst fromIterable = collection => Array.isArray(collection) ? collection : Array.from(collection);\nexports.fromIterable = fromIterable;\n//# sourceMappingURL=ReadonlyArray.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.valuesForward = exports.valuesBackward = exports.size = exports.reversed = exports.removeFirst = exports.reduceWithIndex = exports.reduce = exports.make = exports.lessThanForwards = exports.lessThanEqualForwards = exports.lessThanEqualBackwards = exports.lessThanBackwards = exports.last = exports.keysForward = exports.keysBackward = exports.isRedBlackTree = exports.insert = exports.has = exports.greaterThanForwards = exports.greaterThanEqualForwards = exports.greaterThanEqualBackwards = exports.greaterThanBackwards = exports.getOrder = exports.getAt = exports.fromIterable = exports.forEachLessThan = exports.forEachGreaterThanEqual = exports.forEachBetween = exports.forEach = exports.first = exports.findFirst = exports.find = exports.empty = exports.atForwards = exports.atBackwards = exports.RedBlackTreeTypeId = exports.RedBlackTreeImpl = void 0;\nvar Chunk = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Chunk\"));\nvar Equal = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Equal\"));\nvar Dual = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Function\"));\nvar Hash = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Hash\"));\nvar _iterator = /*#__PURE__*/require(\"@effect/data/internal/RedBlackTree/iterator\");\nvar Node = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/internal/RedBlackTree/node\"));\nvar _Stack = /*#__PURE__*/require(\"@effect/data/internal/Stack\");\nvar Option = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Option\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\nconst RedBlackTreeSymbolKey = \"@effect/data/RedBlackTree\";\n/** @internal */\nconst RedBlackTreeTypeId = /*#__PURE__*/Symbol.for(RedBlackTreeSymbolKey);\nexports.RedBlackTreeTypeId = RedBlackTreeTypeId;\nclass RedBlackTreeImpl {\n  constructor(_ord, _root) {\n    this._ord = _ord;\n    this._root = _root;\n    this._id = RedBlackTreeTypeId;\n  }\n  [Hash.symbol]() {\n    return Hash.combine(Hash.hash(RedBlackTreeSymbolKey))(Hash.array(Array.from(this)));\n  }\n  [Equal.symbol](that) {\n    if (isRedBlackTree(that)) {\n      if ((this._root?.count ?? 0) !== (that._root?.count ?? 0)) {\n        return false;\n      }\n      return Equal.equals(Array.from(this), Array.from(that));\n    }\n    return false;\n  }\n  [Symbol.iterator]() {\n    const stack = [];\n    let n = this._root;\n    while (n != null) {\n      stack.push(n);\n      n = n.left;\n    }\n    return new _iterator.RedBlackTreeIterator(this, stack, _iterator.Direction.Forward);\n  }\n  toString() {\n    return `RedBlackTree(${Array.from(this).map(([k, v]) => `[${String(k)}, ${String(v)}]`).join(\", \")})`;\n  }\n  toJSON() {\n    return {\n      _tag: \"RedBlackTree\",\n      values: Array.from(this)\n    };\n  }\n  [Symbol.for(\"nodejs.util.inspect.custom\")]() {\n    return this.toJSON();\n  }\n}\n/** @internal */\nexports.RedBlackTreeImpl = RedBlackTreeImpl;\nconst isRedBlackTree = u => typeof u === \"object\" && u != null && \"_id\" in u && u[\"_id\"] === RedBlackTreeTypeId;\n/** @internal */\nexports.isRedBlackTree = isRedBlackTree;\nconst empty = ord => new RedBlackTreeImpl(ord, undefined);\n/** @internal */\nexports.empty = empty;\nconst fromIterable = ord => entries => {\n  let tree = empty(ord);\n  for (const [key, value] of entries) {\n    tree = insert(tree, key, value);\n  }\n  return tree;\n};\n/** @internal */\nexports.fromIterable = fromIterable;\nconst make = ord => (...entries) => {\n  return fromIterable(ord)(entries);\n};\n/** @internal */\nexports.make = make;\nconst atBackwards = /*#__PURE__*/Dual.dual(2, (self, index) => at(self, index, _iterator.Direction.Backward));\n/** @internal */\nexports.atBackwards = atBackwards;\nconst atForwards = /*#__PURE__*/Dual.dual(2, (self, index) => at(self, index, _iterator.Direction.Forward));\nexports.atForwards = atForwards;\nconst at = (self, index, direction) => {\n  return {\n    [Symbol.iterator]: () => {\n      if (index < 0) {\n        return new _iterator.RedBlackTreeIterator(self, [], direction);\n      }\n      let node = self._root;\n      const stack = [];\n      while (node !== undefined) {\n        stack.push(node);\n        if (node.left !== undefined) {\n          if (index < node.left.count) {\n            node = node.left;\n            continue;\n          }\n          index -= node.left.count;\n        }\n        if (!index) {\n          return new _iterator.RedBlackTreeIterator(self, stack, direction);\n        }\n        index -= 1;\n        if (node.right !== undefined) {\n          if (index >= node.right.count) {\n            break;\n          }\n          node = node.right;\n        } else {\n          break;\n        }\n      }\n      return new _iterator.RedBlackTreeIterator(self, [], direction);\n    }\n  };\n};\n/** @internal */\nconst find = /*#__PURE__*/Dual.dual(2, (self, key) => {\n  const cmp = self._ord.compare;\n  let node = self._root;\n  let result = Chunk.empty();\n  while (node !== undefined) {\n    const d = cmp(key, node.key);\n    if (d === 0 && Equal.equals(key, node.key)) {\n      result = Chunk.prepend(node.value)(result);\n    }\n    if (d <= 0) {\n      node = node.left;\n    } else {\n      node = node.right;\n    }\n  }\n  return result;\n});\n/** @internal */\nexports.find = find;\nconst findFirst = /*#__PURE__*/Dual.dual(2, (self, key) => {\n  const cmp = self._ord.compare;\n  let node = self._root;\n  while (node !== undefined) {\n    const d = cmp(key, node.key);\n    if (Equal.equals(key, node.key)) {\n      return Option.some(node.value);\n    }\n    if (d <= 0) {\n      node = node.left;\n    } else {\n      node = node.right;\n    }\n  }\n  return Option.none();\n});\n/** @internal */\nexports.findFirst = findFirst;\nconst first = self => {\n  let node = self._root;\n  let current = self._root;\n  while (node !== undefined) {\n    current = node;\n    node = node.left;\n  }\n  return current ? Option.some([current.key, current.value]) : Option.none();\n};\n/** @internal */\nexports.first = first;\nconst getAt = /*#__PURE__*/Dual.dual(2, (self, index) => {\n  if (index < 0) {\n    return Option.none();\n  }\n  let root = self._root;\n  let node = undefined;\n  while (root !== undefined) {\n    node = root;\n    if (root.left) {\n      if (index < root.left.count) {\n        root = root.left;\n        continue;\n      }\n      index -= root.left.count;\n    }\n    if (!index) {\n      return Option.some([node.key, node.value]);\n    }\n    index -= 1;\n    if (root.right) {\n      if (index >= root.right.count) {\n        break;\n      }\n      root = root.right;\n    } else {\n      break;\n    }\n  }\n  return Option.none();\n});\n/** @internal */\nexports.getAt = getAt;\nconst getOrder = tree => tree._ord;\n/** @internal */\nexports.getOrder = getOrder;\nconst has = /*#__PURE__*/Dual.dual(2, (self, key) => Option.isSome(findFirst(self, key)));\n/** @internal */\nexports.has = has;\nconst insert = /*#__PURE__*/Dual.dual(3, (self, key, value) => {\n  const cmp = self._ord.compare;\n  // Find point to insert new node at\n  let n = self._root;\n  const n_stack = [];\n  const d_stack = [];\n  while (n != null) {\n    const d = cmp(key, n.key);\n    n_stack.push(n);\n    d_stack.push(d);\n    if (d <= 0) {\n      n = n.left;\n    } else {\n      n = n.right;\n    }\n  }\n  // Rebuild path to leaf node\n  n_stack.push(new Node.Node(Node.Color.Red, key, value, undefined, undefined, 1));\n  for (let s = n_stack.length - 2; s >= 0; --s) {\n    const n2 = n_stack[s];\n    if (d_stack[s] <= 0) {\n      n_stack[s] = new Node.Node(n2.color, n2.key, n2.value, n_stack[s + 1], n2.right, n2.count + 1);\n    } else {\n      n_stack[s] = new Node.Node(n2.color, n2.key, n2.value, n2.left, n_stack[s + 1], n2.count + 1);\n    }\n  }\n  // Rebalance tree using rotations\n  for (let s = n_stack.length - 1; s > 1; --s) {\n    const p = n_stack[s - 1];\n    const n3 = n_stack[s];\n    if (p.color === Node.Color.Black || n3.color === Node.Color.Black) {\n      break;\n    }\n    const pp = n_stack[s - 2];\n    if (pp.left === p) {\n      if (p.left === n3) {\n        const y = pp.right;\n        if (y && y.color === Node.Color.Red) {\n          p.color = Node.Color.Black;\n          pp.right = Node.repaint(y, Node.Color.Black);\n          pp.color = Node.Color.Red;\n          s -= 1;\n        } else {\n          pp.color = Node.Color.Red;\n          pp.left = p.right;\n          p.color = Node.Color.Black;\n          p.right = pp;\n          n_stack[s - 2] = p;\n          n_stack[s - 1] = n3;\n          Node.recount(pp);\n          Node.recount(p);\n          if (s >= 3) {\n            const ppp = n_stack[s - 3];\n            if (ppp.left === pp) {\n              ppp.left = p;\n            } else {\n              ppp.right = p;\n            }\n          }\n          break;\n        }\n      } else {\n        const y = pp.right;\n        if (y && y.color === Node.Color.Red) {\n          p.color = Node.Color.Black;\n          pp.right = Node.repaint(y, Node.Color.Black);\n          pp.color = Node.Color.Red;\n          s -= 1;\n        } else {\n          p.right = n3.left;\n          pp.color = Node.Color.Red;\n          pp.left = n3.right;\n          n3.color = Node.Color.Black;\n          n3.left = p;\n          n3.right = pp;\n          n_stack[s - 2] = n3;\n          n_stack[s - 1] = p;\n          Node.recount(pp);\n          Node.recount(p);\n          Node.recount(n3);\n          if (s >= 3) {\n            const ppp = n_stack[s - 3];\n            if (ppp.left === pp) {\n              ppp.left = n3;\n            } else {\n              ppp.right = n3;\n            }\n          }\n          break;\n        }\n      }\n    } else {\n      if (p.right === n3) {\n        const y = pp.left;\n        if (y && y.color === Node.Color.Red) {\n          p.color = Node.Color.Black;\n          pp.left = Node.repaint(y, Node.Color.Black);\n          pp.color = Node.Color.Red;\n          s -= 1;\n        } else {\n          pp.color = Node.Color.Red;\n          pp.right = p.left;\n          p.color = Node.Color.Black;\n          p.left = pp;\n          n_stack[s - 2] = p;\n          n_stack[s - 1] = n3;\n          Node.recount(pp);\n          Node.recount(p);\n          if (s >= 3) {\n            const ppp = n_stack[s - 3];\n            if (ppp.right === pp) {\n              ppp.right = p;\n            } else {\n              ppp.left = p;\n            }\n          }\n          break;\n        }\n      } else {\n        const y = pp.left;\n        if (y && y.color === Node.Color.Red) {\n          p.color = Node.Color.Black;\n          pp.left = Node.repaint(y, Node.Color.Black);\n          pp.color = Node.Color.Red;\n          s -= 1;\n        } else {\n          p.left = n3.right;\n          pp.color = Node.Color.Red;\n          pp.right = n3.left;\n          n3.color = Node.Color.Black;\n          n3.right = p;\n          n3.left = pp;\n          n_stack[s - 2] = n3;\n          n_stack[s - 1] = p;\n          Node.recount(pp);\n          Node.recount(p);\n          Node.recount(n3);\n          if (s >= 3) {\n            const ppp = n_stack[s - 3];\n            if (ppp.right === pp) {\n              ppp.right = n3;\n            } else {\n              ppp.left = n3;\n            }\n          }\n          break;\n        }\n      }\n    }\n  }\n  // Return new tree\n  n_stack[0].color = Node.Color.Black;\n  return new RedBlackTreeImpl(self._ord, n_stack[0]);\n});\n/** @internal */\nexports.insert = insert;\nconst keysForward = self => keys(self, _iterator.Direction.Forward);\n/** @internal */\nexports.keysForward = keysForward;\nconst keysBackward = self => keys(self, _iterator.Direction.Backward);\nexports.keysBackward = keysBackward;\nconst keys = (self, direction) => {\n  const begin = self[Symbol.iterator]();\n  let count = 0;\n  return {\n    [Symbol.iterator]: () => keys(self, direction),\n    next: () => {\n      count++;\n      const entry = begin.key;\n      if (direction === _iterator.Direction.Forward) {\n        begin.moveNext();\n      } else {\n        begin.movePrev();\n      }\n      switch (entry._tag) {\n        case \"None\":\n          {\n            return {\n              done: true,\n              value: count\n            };\n          }\n        case \"Some\":\n          {\n            return {\n              done: false,\n              value: entry.value\n            };\n          }\n      }\n    }\n  };\n};\n/** @internal */\nconst last = self => {\n  let node = self._root;\n  let current = self._root;\n  while (node !== undefined) {\n    current = node;\n    node = node.right;\n  }\n  return current ? Option.some([current.key, current.value]) : Option.none();\n};\n/** @internal */\nexports.last = last;\nconst reversed = self => {\n  return {\n    [Symbol.iterator]: () => {\n      const stack = [];\n      let node = self._root;\n      while (node !== undefined) {\n        stack.push(node);\n        node = node.right;\n      }\n      return new _iterator.RedBlackTreeIterator(self, stack, _iterator.Direction.Backward);\n    }\n  };\n};\n/** @internal */\nexports.reversed = reversed;\nconst greaterThanBackwards = /*#__PURE__*/Dual.dual(2, (self, key) => greaterThan(self, key, _iterator.Direction.Backward));\n/** @internal */\nexports.greaterThanBackwards = greaterThanBackwards;\nconst greaterThanForwards = /*#__PURE__*/Dual.dual(2, (self, key) => greaterThan(self, key, _iterator.Direction.Forward));\nexports.greaterThanForwards = greaterThanForwards;\nconst greaterThan = (self, key, direction) => {\n  return {\n    [Symbol.iterator]: () => {\n      const cmp = self._ord.compare;\n      let node = self._root;\n      const stack = [];\n      let last_ptr = 0;\n      while (node !== undefined) {\n        const d = cmp(key, node.key);\n        stack.push(node);\n        if (d < 0) {\n          last_ptr = stack.length;\n        }\n        if (d < 0) {\n          node = node.left;\n        } else {\n          node = node.right;\n        }\n      }\n      stack.length = last_ptr;\n      return new _iterator.RedBlackTreeIterator(self, stack, direction);\n    }\n  };\n};\n/** @internal */\nconst greaterThanEqualBackwards = /*#__PURE__*/Dual.dual(2, (self, key) => greaterThanEqual(self, key, _iterator.Direction.Backward));\n/** @internal */\nexports.greaterThanEqualBackwards = greaterThanEqualBackwards;\nconst greaterThanEqualForwards = /*#__PURE__*/Dual.dual(2, (self, key) => greaterThanEqual(self, key, _iterator.Direction.Forward));\nexports.greaterThanEqualForwards = greaterThanEqualForwards;\nconst greaterThanEqual = (self, key, direction = _iterator.Direction.Forward) => {\n  return {\n    [Symbol.iterator]: () => {\n      const cmp = self._ord.compare;\n      let node = self._root;\n      const stack = [];\n      let last_ptr = 0;\n      while (node !== undefined) {\n        const d = cmp(key, node.key);\n        stack.push(node);\n        if (d <= 0) {\n          last_ptr = stack.length;\n        }\n        if (d <= 0) {\n          node = node.left;\n        } else {\n          node = node.right;\n        }\n      }\n      stack.length = last_ptr;\n      return new _iterator.RedBlackTreeIterator(self, stack, direction);\n    }\n  };\n};\n/** @internal */\nconst lessThanBackwards = /*#__PURE__*/Dual.dual(2, (self, key) => lessThan(self, key, _iterator.Direction.Backward));\n/** @internal */\nexports.lessThanBackwards = lessThanBackwards;\nconst lessThanForwards = /*#__PURE__*/Dual.dual(2, (self, key) => lessThan(self, key, _iterator.Direction.Forward));\nexports.lessThanForwards = lessThanForwards;\nconst lessThan = (self, key, direction) => {\n  return {\n    [Symbol.iterator]: () => {\n      const cmp = self._ord.compare;\n      let node = self._root;\n      const stack = [];\n      let last_ptr = 0;\n      while (node !== undefined) {\n        const d = cmp(key, node.key);\n        stack.push(node);\n        if (d > 0) {\n          last_ptr = stack.length;\n        }\n        if (d <= 0) {\n          node = node.left;\n        } else {\n          node = node.right;\n        }\n      }\n      stack.length = last_ptr;\n      return new _iterator.RedBlackTreeIterator(self, stack, direction);\n    }\n  };\n};\n/** @internal */\nconst lessThanEqualBackwards = /*#__PURE__*/Dual.dual(2, (self, key) => lessThanEqual(self, key, _iterator.Direction.Backward));\n/** @internal */\nexports.lessThanEqualBackwards = lessThanEqualBackwards;\nconst lessThanEqualForwards = /*#__PURE__*/Dual.dual(2, (self, key) => lessThanEqual(self, key, _iterator.Direction.Forward));\nexports.lessThanEqualForwards = lessThanEqualForwards;\nconst lessThanEqual = (self, key, direction) => {\n  return {\n    [Symbol.iterator]: () => {\n      const cmp = self._ord.compare;\n      let node = self._root;\n      const stack = [];\n      let last_ptr = 0;\n      while (node !== undefined) {\n        const d = cmp(key, node.key);\n        stack.push(node);\n        if (d >= 0) {\n          last_ptr = stack.length;\n        }\n        if (d < 0) {\n          node = node.left;\n        } else {\n          node = node.right;\n        }\n      }\n      stack.length = last_ptr;\n      return new _iterator.RedBlackTreeIterator(self, stack, direction);\n    }\n  };\n};\n/** @internal */\nconst forEach = /*#__PURE__*/Dual.dual(2, (self, f) => {\n  const root = self._root;\n  if (root !== undefined) {\n    visitFull(root, (key, value) => {\n      f(key, value);\n      return Option.none();\n    });\n  }\n});\n/** @internal */\nexports.forEach = forEach;\nconst forEachGreaterThanEqual = /*#__PURE__*/Dual.dual(3, (self, min, f) => {\n  const root = self._root;\n  const ord = self._ord;\n  if (root !== undefined) {\n    visitGreaterThanEqual(root, min, ord, (key, value) => {\n      f(key, value);\n      return Option.none();\n    });\n  }\n});\n/** @internal */\nexports.forEachGreaterThanEqual = forEachGreaterThanEqual;\nconst forEachLessThan = /*#__PURE__*/Dual.dual(3, (self, max, f) => {\n  const root = self._root;\n  const ord = self._ord;\n  if (root !== undefined) {\n    visitLessThan(root, max, ord, (key, value) => {\n      f(key, value);\n      return Option.none();\n    });\n  }\n});\n/** @internal */\nexports.forEachLessThan = forEachLessThan;\nconst forEachBetween = /*#__PURE__*/Dual.dual(4, (self, min, max, f) => {\n  const root = self._root;\n  const ord = self._ord;\n  if (root) {\n    visitBetween(root, min, max, ord, (key, value) => {\n      f(key, value);\n      return Option.none();\n    });\n  }\n});\n/** @internal */\nexports.forEachBetween = forEachBetween;\nconst reduce = /*#__PURE__*/Dual.dual(3, (self, zero, f) => reduceWithIndex(self, zero, (accumulator, value) => f(accumulator, value)));\n/** @internal */\nexports.reduce = reduce;\nconst reduceWithIndex = /*#__PURE__*/Dual.dual(3, (self, zero, f) => {\n  let accumulator = zero;\n  for (const entry of self) {\n    accumulator = f(accumulator, entry[1], entry[0]);\n  }\n  return accumulator;\n});\n/** @internal */\nexports.reduceWithIndex = reduceWithIndex;\nconst removeFirst = /*#__PURE__*/Dual.dual(2, (self, key) => {\n  if (!has(self, key)) {\n    return self;\n  }\n  const ord = self._ord;\n  const cmp = ord.compare;\n  let node = self._root;\n  const stack = [];\n  while (node !== undefined) {\n    const d = cmp(key, node.key);\n    stack.push(node);\n    if (Equal.equals(key, node.key)) {\n      node = undefined;\n    } else if (d <= 0) {\n      node = node.left;\n    } else {\n      node = node.right;\n    }\n  }\n  if (stack.length === 0) {\n    return self;\n  }\n  const cstack = new Array(stack.length);\n  let n = stack[stack.length - 1];\n  cstack[cstack.length - 1] = new Node.Node(n.color, n.key, n.value, n.left, n.right, n.count);\n  for (let i = stack.length - 2; i >= 0; --i) {\n    n = stack[i];\n    if (n.left === stack[i + 1]) {\n      cstack[i] = new Node.Node(n.color, n.key, n.value, cstack[i + 1], n.right, n.count);\n    } else {\n      cstack[i] = new Node.Node(n.color, n.key, n.value, n.left, cstack[i + 1], n.count);\n    }\n  }\n  // Get node\n  n = cstack[cstack.length - 1];\n  // If not leaf, then swap with previous node\n  if (n.left !== undefined && n.right !== undefined) {\n    // First walk to previous leaf\n    const split = cstack.length;\n    n = n.left;\n    while (n.right != null) {\n      cstack.push(n);\n      n = n.right;\n    }\n    // Copy path to leaf\n    const v = cstack[split - 1];\n    cstack.push(new Node.Node(n.color, v.key, v.value, n.left, n.right, n.count));\n    cstack[split - 1].key = n.key;\n    cstack[split - 1].value = n.value;\n    // Fix up stack\n    for (let i = cstack.length - 2; i >= split; --i) {\n      n = cstack[i];\n      cstack[i] = new Node.Node(n.color, n.key, n.value, n.left, cstack[i + 1], n.count);\n    }\n    cstack[split - 1].left = cstack[split];\n  }\n  // Remove leaf node\n  n = cstack[cstack.length - 1];\n  if (n.color === Node.Color.Red) {\n    // Easy case: removing red leaf\n    const p = cstack[cstack.length - 2];\n    if (p.left === n) {\n      p.left = undefined;\n    } else if (p.right === n) {\n      p.right = undefined;\n    }\n    cstack.pop();\n    for (let i = 0; i < cstack.length; ++i) {\n      cstack[i].count--;\n    }\n    return new RedBlackTreeImpl(ord, cstack[0]);\n  } else {\n    if (n.left !== undefined || n.right !== undefined) {\n      // Second easy case:  Single child black parent\n      if (n.left !== undefined) {\n        Node.swap(n, n.left);\n      } else if (n.right !== undefined) {\n        Node.swap(n, n.right);\n      }\n      // Child must be red, so repaint it black to balance color\n      n.color = Node.Color.Black;\n      for (let i = 0; i < cstack.length - 1; ++i) {\n        cstack[i].count--;\n      }\n      return new RedBlackTreeImpl(ord, cstack[0]);\n    } else if (cstack.length === 1) {\n      // Third easy case: root\n      return new RedBlackTreeImpl(ord, undefined);\n    } else {\n      // Hard case: Repaint n, and then do some nasty stuff\n      for (let i = 0; i < cstack.length; ++i) {\n        cstack[i].count--;\n      }\n      const parent = cstack[cstack.length - 2];\n      fixDoubleBlack(cstack);\n      // Fix up links\n      if (parent.left === n) {\n        parent.left = undefined;\n      } else {\n        parent.right = undefined;\n      }\n    }\n  }\n  return new RedBlackTreeImpl(ord, cstack[0]);\n});\n/** @internal */\nexports.removeFirst = removeFirst;\nconst size = self => self._root?.count ?? 0;\n/** @internal */\nexports.size = size;\nconst valuesForward = self => values(self, _iterator.Direction.Forward);\n/** @internal */\nexports.valuesForward = valuesForward;\nconst valuesBackward = self => values(self, _iterator.Direction.Backward);\n/** @internal */\nexports.valuesBackward = valuesBackward;\nconst values = (self, direction) => {\n  const begin = self[Symbol.iterator]();\n  let count = 0;\n  return {\n    [Symbol.iterator]: () => values(self, direction),\n    next: () => {\n      count++;\n      const entry = begin.value;\n      if (direction === _iterator.Direction.Forward) {\n        begin.moveNext();\n      } else {\n        begin.movePrev();\n      }\n      switch (entry._tag) {\n        case \"None\":\n          {\n            return {\n              done: true,\n              value: count\n            };\n          }\n        case \"Some\":\n          {\n            return {\n              done: false,\n              value: entry.value\n            };\n          }\n      }\n    }\n  };\n};\nconst visitFull = (node, visit) => {\n  let current = node;\n  let stack = undefined;\n  let done = false;\n  while (!done) {\n    if (current != null) {\n      stack = new _Stack.Stack(current, stack);\n      current = current.left;\n    } else if (stack != null) {\n      const value = visit(stack.value.key, stack.value.value);\n      if (Option.isSome(value)) {\n        return value;\n      }\n      current = stack.value.right;\n      stack = stack.previous;\n    } else {\n      done = true;\n    }\n  }\n  return Option.none();\n};\nconst visitGreaterThanEqual = (node, min, ord, visit) => {\n  let current = node;\n  let stack = undefined;\n  let done = false;\n  while (!done) {\n    if (current !== undefined) {\n      stack = new _Stack.Stack(current, stack);\n      if (ord.compare(min, current.key) <= 0) {\n        current = current.left;\n      } else {\n        current = undefined;\n      }\n    } else if (stack !== undefined) {\n      if (ord.compare(min, stack.value.key) <= 0) {\n        const value = visit(stack.value.key, stack.value.value);\n        if (Option.isSome(value)) {\n          return value;\n        }\n      }\n      current = stack.value.right;\n      stack = stack.previous;\n    } else {\n      done = true;\n    }\n  }\n  return Option.none();\n};\nconst visitLessThan = (node, max, ord, visit) => {\n  let current = node;\n  let stack = undefined;\n  let done = false;\n  while (!done) {\n    if (current !== undefined) {\n      stack = new _Stack.Stack(current, stack);\n      current = current.left;\n    } else if (stack !== undefined && ord.compare(max, stack.value.key) > 0) {\n      const value = visit(stack.value.key, stack.value.value);\n      if (Option.isSome(value)) {\n        return value;\n      }\n      current = stack.value.right;\n      stack = stack.previous;\n    } else {\n      done = true;\n    }\n  }\n  return Option.none();\n};\nconst visitBetween = (node, min, max, ord, visit) => {\n  let current = node;\n  let stack = undefined;\n  let done = false;\n  while (!done) {\n    if (current !== undefined) {\n      stack = new _Stack.Stack(current, stack);\n      if (ord.compare(min, current.key) <= 0) {\n        current = current.left;\n      } else {\n        current = undefined;\n      }\n    } else if (stack !== undefined && ord.compare(max, stack.value.key) > 0) {\n      if (ord.compare(min, stack.value.key) <= 0) {\n        const value = visit(stack.value.key, stack.value.value);\n        if (Option.isSome(value)) {\n          return value;\n        }\n      }\n      current = stack.value.right;\n      stack = stack.previous;\n    } else {\n      done = true;\n    }\n  }\n  return Option.none();\n};\n/**\n * Fix up a double black node in a Red-Black Tree.\n */\nconst fixDoubleBlack = stack => {\n  let n, p, s, z;\n  for (let i = stack.length - 1; i >= 0; --i) {\n    n = stack[i];\n    if (i === 0) {\n      n.color = Node.Color.Black;\n      return;\n    }\n    p = stack[i - 1];\n    if (p.left === n) {\n      s = p.right;\n      if (s !== undefined && s.right !== undefined && s.right.color === Node.Color.Red) {\n        s = p.right = Node.clone(s);\n        z = s.right = Node.clone(s.right);\n        p.right = s.left;\n        s.left = p;\n        s.right = z;\n        s.color = p.color;\n        n.color = Node.Color.Black;\n        p.color = Node.Color.Black;\n        z.color = Node.Color.Black;\n        Node.recount(p);\n        Node.recount(s);\n        if (i > 1) {\n          const pp = stack[i - 2];\n          if (pp.left === p) {\n            pp.left = s;\n          } else {\n            pp.right = s;\n          }\n        }\n        stack[i - 1] = s;\n        return;\n      } else if (s !== undefined && s.left !== undefined && s.left.color === Node.Color.Red) {\n        s = p.right = Node.clone(s);\n        z = s.left = Node.clone(s.left);\n        p.right = z.left;\n        s.left = z.right;\n        z.left = p;\n        z.right = s;\n        z.color = p.color;\n        p.color = Node.Color.Black;\n        s.color = Node.Color.Black;\n        n.color = Node.Color.Black;\n        Node.recount(p);\n        Node.recount(s);\n        Node.recount(z);\n        if (i > 1) {\n          const pp = stack[i - 2];\n          if (pp.left === p) {\n            pp.left = z;\n          } else {\n            pp.right = z;\n          }\n        }\n        stack[i - 1] = z;\n        return;\n      }\n      if (s !== undefined && s.color === Node.Color.Black) {\n        if (p.color === Node.Color.Red) {\n          p.color = Node.Color.Black;\n          p.right = Node.repaint(s, Node.Color.Red);\n          return;\n        } else {\n          p.right = Node.repaint(s, Node.Color.Red);\n          continue;\n        }\n      } else if (s !== undefined) {\n        s = Node.clone(s);\n        p.right = s.left;\n        s.left = p;\n        s.color = p.color;\n        p.color = Node.Color.Red;\n        Node.recount(p);\n        Node.recount(s);\n        if (i > 1) {\n          const pp = stack[i - 2];\n          if (pp.left === p) {\n            pp.left = s;\n          } else {\n            pp.right = s;\n          }\n        }\n        stack[i - 1] = s;\n        stack[i] = p;\n        if (i + 1 < stack.length) {\n          stack[i + 1] = n;\n        } else {\n          stack.push(n);\n        }\n        i = i + 2;\n      }\n    } else {\n      s = p.left;\n      if (s !== undefined && s.left !== undefined && s.left.color === Node.Color.Red) {\n        s = p.left = Node.clone(s);\n        z = s.left = Node.clone(s.left);\n        p.left = s.right;\n        s.right = p;\n        s.left = z;\n        s.color = p.color;\n        n.color = Node.Color.Black;\n        p.color = Node.Color.Black;\n        z.color = Node.Color.Black;\n        Node.recount(p);\n        Node.recount(s);\n        if (i > 1) {\n          const pp = stack[i - 2];\n          if (pp.right === p) {\n            pp.right = s;\n          } else {\n            pp.left = s;\n          }\n        }\n        stack[i - 1] = s;\n        return;\n      } else if (s !== undefined && s.right !== undefined && s.right.color === Node.Color.Red) {\n        s = p.left = Node.clone(s);\n        z = s.right = Node.clone(s.right);\n        p.left = z.right;\n        s.right = z.left;\n        z.right = p;\n        z.left = s;\n        z.color = p.color;\n        p.color = Node.Color.Black;\n        s.color = Node.Color.Black;\n        n.color = Node.Color.Black;\n        Node.recount(p);\n        Node.recount(s);\n        Node.recount(z);\n        if (i > 1) {\n          const pp = stack[i - 2];\n          if (pp.right === p) {\n            pp.right = z;\n          } else {\n            pp.left = z;\n          }\n        }\n        stack[i - 1] = z;\n        return;\n      }\n      if (s !== undefined && s.color === Node.Color.Black) {\n        if (p.color === Node.Color.Red) {\n          p.color = Node.Color.Black;\n          p.left = Node.repaint(s, Node.Color.Red);\n          return;\n        } else {\n          p.left = Node.repaint(s, Node.Color.Red);\n          continue;\n        }\n      } else if (s !== undefined) {\n        s = Node.clone(s);\n        p.left = s.right;\n        s.right = p;\n        s.color = p.color;\n        p.color = Node.Color.Red;\n        Node.recount(p);\n        Node.recount(s);\n        if (i > 1) {\n          const pp = stack[i - 2];\n          if (pp.right === p) {\n            pp.right = s;\n          } else {\n            pp.left = s;\n          }\n        }\n        stack[i - 1] = s;\n        stack[i] = p;\n        if (i + 1 < stack.length) {\n          stack[i + 1] = n;\n        } else {\n          stack.push(n);\n        }\n        i = i + 2;\n      }\n    }\n  }\n};\n//# sourceMappingURL=RedBlackTree.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.RedBlackTreeIterator = exports.Direction = void 0;\nvar Option = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Option\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/** @internal */\nconst Direction = {\n  Forward: 0,\n  Backward: 1 << 0\n};\n/** @internal */\nexports.Direction = Direction;\nclass RedBlackTreeIterator {\n  constructor(self, stack, direction) {\n    this.self = self;\n    this.stack = stack;\n    this.direction = direction;\n    this.count = 0;\n  }\n  /**\n   * Clones the iterator\n   */\n  clone() {\n    return new RedBlackTreeIterator(this.self, this.stack.slice(), this.direction);\n  }\n  /**\n   * Reverse the traversal direction\n   */\n  reversed() {\n    return new RedBlackTreeIterator(this.self, this.stack.slice(), this.direction === Direction.Forward ? Direction.Backward : Direction.Forward);\n  }\n  /**\n   * Iterator next\n   */\n  next() {\n    const entry = this.entry;\n    this.count++;\n    if (this.direction === Direction.Forward) {\n      this.moveNext();\n    } else {\n      this.movePrev();\n    }\n    switch (entry._tag) {\n      case \"None\":\n        {\n          return {\n            done: true,\n            value: this.count\n          };\n        }\n      case \"Some\":\n        {\n          return {\n            done: false,\n            value: entry.value\n          };\n        }\n    }\n  }\n  /**\n   * Returns the key\n   */\n  get key() {\n    if (this.stack.length > 0) {\n      return Option.some(this.stack[this.stack.length - 1].key);\n    }\n    return Option.none();\n  }\n  /**\n   * Returns the value\n   */\n  get value() {\n    if (this.stack.length > 0) {\n      return Option.some(this.stack[this.stack.length - 1].value);\n    }\n    return Option.none();\n  }\n  /**\n   * Returns the key\n   */\n  get entry() {\n    if (this.stack.length > 0) {\n      return Option.some([this.stack[this.stack.length - 1].key, this.stack[this.stack.length - 1].value]);\n    }\n    return Option.none();\n  }\n  /**\n   * Returns the position of this iterator in the sorted list\n   */\n  get index() {\n    let idx = 0;\n    const stack = this.stack;\n    if (stack.length === 0) {\n      const r = this.self._root;\n      if (r != null) {\n        return r.count;\n      }\n      return 0;\n    } else if (stack[stack.length - 1].left != null) {\n      idx = stack[stack.length - 1].left.count;\n    }\n    for (let s = stack.length - 2; s >= 0; --s) {\n      if (stack[s + 1] === stack[s].right) {\n        ;\n        ++idx;\n        if (stack[s].left != null) {\n          idx += stack[s].left.count;\n        }\n      }\n    }\n    return idx;\n  }\n  /**\n   * Advances iterator to next element in list\n   */\n  moveNext() {\n    const stack = this.stack;\n    if (stack.length === 0) {\n      return;\n    }\n    let n = stack[stack.length - 1];\n    if (n.right != null) {\n      n = n.right;\n      while (n != null) {\n        stack.push(n);\n        n = n.left;\n      }\n    } else {\n      stack.pop();\n      while (stack.length > 0 && stack[stack.length - 1].right === n) {\n        n = stack[stack.length - 1];\n        stack.pop();\n      }\n    }\n  }\n  /**\n   * Checks if there is a next element\n   */\n  get hasNext() {\n    const stack = this.stack;\n    if (stack.length === 0) {\n      return false;\n    }\n    if (stack[stack.length - 1].right != null) {\n      return true;\n    }\n    for (let s = stack.length - 1; s > 0; --s) {\n      if (stack[s - 1].left === stack[s]) {\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\n   * Advances iterator to previous element in list\n   */\n  movePrev() {\n    const stack = this.stack;\n    if (stack.length === 0) {\n      return;\n    }\n    let n = stack[stack.length - 1];\n    if (n != null && n.left != null) {\n      n = n.left;\n      while (n != null) {\n        stack.push(n);\n        n = n.right;\n      }\n    } else {\n      stack.pop();\n      while (stack.length > 0 && stack[stack.length - 1].left === n) {\n        n = stack[stack.length - 1];\n        stack.pop();\n      }\n    }\n  }\n  /**\n   * Checks if there is a previous element\n   */\n  get hasPrev() {\n    const stack = this.stack;\n    if (stack.length === 0) {\n      return false;\n    }\n    if (stack[stack.length - 1].left != null) {\n      return true;\n    }\n    for (let s = stack.length - 1; s > 0; --s) {\n      if (stack[s - 1].right === stack[s]) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\nexports.RedBlackTreeIterator = RedBlackTreeIterator;\n//# sourceMappingURL=iterator.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Node = exports.Color = void 0;\nexports.clone = clone;\nexports.recount = recount;\nexports.repaint = repaint;\nexports.swap = swap;\n/** @internal */\nconst Color = {\n  Red: 0,\n  Black: 1 << 0\n};\n/** @internal */\nexports.Color = Color;\nclass Node {\n  constructor(color, key, value, left, right, count) {\n    this.color = color;\n    this.key = key;\n    this.value = value;\n    this.left = left;\n    this.right = right;\n    this.count = count;\n  }\n}\n/** @internal */\nexports.Node = Node;\nfunction clone(node) {\n  return new Node(node.color, node.key, node.value, node.left, node.right, node.count);\n}\n/** @internal */\nfunction swap(n, v) {\n  n.key = v.key;\n  n.value = v.value;\n  n.left = v.left;\n  n.right = v.right;\n  n.color = v.color;\n  n.count = v.count;\n}\n/** @internal */\nfunction repaint(node, color) {\n  return new Node(color, node.key, node.value, node.left, node.right, node.count);\n}\n/** @internal */\nfunction recount(node) {\n  node.count = 1 + (node.left?.count ?? 0) + (node.right?.count ?? 0);\n}\n//# sourceMappingURL=node.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Stack = void 0;\n/** @internal */\nclass Stack {\n  constructor(value, previous) {\n    this.value = value;\n    this.previous = previous;\n  }\n}\nexports.Stack = Stack;\n//# sourceMappingURL=Stack.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getMonoid = void 0;\nvar monoid = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/typeclass/Monoid\"));\nvar semiApplicative = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/typeclass/SemiApplicative\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/**\n * Lift a `Monoid` into `F`, combining the inner values using the provided `Monoid`:\n *\n * - `combine` is provided by {@link semiApplicative.getSemigroup}.\n * - `empty` is `F.of(M.empty)`\n *\n * @param F - The `Applicative` instance for `F`.\n * @param M - The `Monoid` instance for `A`.\n *\n * @since 1.0.0\n */\nconst getMonoid = F => M => monoid.fromSemigroup(semiApplicative.getSemigroup(F)(M), F.of(M.empty));\nexports.getMonoid = getMonoid;\n//# sourceMappingURL=Applicative.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.mapLeft = exports.map = exports.bimapComposition = void 0;\nvar _Function = /*#__PURE__*/require(\"@effect/data/Function\");\n/**\n * @since 1.0.0\n */\n\n/**\n * Returns a default ternary `bimap` composition.\n *\n * @since 1.0.0\n */\nconst bimapComposition = (CovariantF, BicovariantG) => (self, f, g) => CovariantF.map(self, BicovariantG.bimap(f, g));\n/**\n * Returns a default `mapLeft` implementation.\n *\n * @since 1.0.0\n */\nexports.bimapComposition = bimapComposition;\nconst mapLeft = F => (0, _Function.dual)(2, (self, f) => F.bimap(self, f, _Function.identity));\n/**\n * Returns a default `map` implementation.\n *\n * @since 1.0.0\n */\nexports.mapLeft = mapLeft;\nconst map = F => (0, _Function.dual)(2, (self, f) => F.bimap(self, _Function.identity, f));\nexports.map = map;\n//# sourceMappingURL=Bicovariant.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.reverse = exports.number = exports.min = exports.max = exports.clamp = exports.between = void 0;\nvar monoid = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/typeclass/Monoid\"));\nvar order = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/typeclass/Order\"));\nvar semigroup = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/typeclass/Semigroup\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/**\n * `Monoid` that returns last minimum of elements.\n *\n * @category constructors\n * @since 1.0.0\n */\nconst min = B => monoid.fromSemigroup(semigroup.min(B), B.maxBound);\n/**\n * `Monoid` that returns last maximum of elements.\n *\n * @category constructors\n * @since 1.0.0\n */\nexports.min = min;\nconst max = B => monoid.fromSemigroup(semigroup.max(B), B.minBound);\n/**\n * @category instances\n * @since 1.0.0\n */\nexports.max = max;\nconst number = {\n  compare: order.number.compare,\n  maxBound: Infinity,\n  minBound: -Infinity\n};\n/**\n * Checks if a value is between the lower and upper limit of a bound.\n *\n * @category predicates\n * @since 1.0.0\n */\nexports.number = number;\nconst between = B => order.between(B)(B.minBound, B.maxBound);\n/**\n * Clamp a value between `minBound` and `maxBound` values.\n *\n * @category utils\n * @since 1.0.0\n */\nexports.between = between;\nconst clamp = B => order.clamp(B)(B.minBound, B.maxBound);\n/**\n * Reverses the `Order` of a `Bounded` and flips `maxBound` and `minBound` values.\n *\n * @category utils\n * @since 1.0.0\n */\nexports.clamp = clamp;\nconst reverse = B => ({\n  ...order.reverse(B),\n  minBound: B.maxBound,\n  maxBound: B.minBound\n});\nexports.reverse = reverse;\n//# sourceMappingURL=Bounded.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.tap = exports.bind = exports.andThenDiscard = void 0;\nvar _Function = /*#__PURE__*/require(\"@effect/data/Function\");\n/**\n * @since 1.0.0\n */\n\n/**\n * Sequences the specified effect after this effect, but ignores the value\n * produced by the effect.\n *\n * @category combining\n * @since 1.0.0\n */\nconst andThenDiscard = F => (0, _Function.dual)(2, (self, that) => tap(F)(self, () => that));\n/**\n * Returns an effect that effectfully \"peeks\" at the success of this effect.\n *\n * @since 1.0.0\n */\nexports.andThenDiscard = andThenDiscard;\nconst tap = F => (0, _Function.dual)(2, (self, f) => F.flatMap(self, a => F.map(f(a), () => a)));\n/**\n * @category do notation\n * @since 1.0.0\n */\nexports.tap = tap;\nconst bind = F => (0, _Function.dual)(3, (self, name, f) => F.flatMap(self, a => F.map(f(a), b => Object.assign({}, a, {\n  [name]: b\n}))));\nexports.bind = bind;\n//# sourceMappingURL=Chainable.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.imap = exports.contramapComposition = void 0;\nvar _Function = /*#__PURE__*/require(\"@effect/data/Function\");\n/**\n * @since 1.0.0\n */\n\n/**\n * Composing two contravariant functors yields a Covariant functor.\n *\n * Returns a default binary `map` composition.\n *\n * @since 1.0.0\n */\nconst contramapComposition = (F, G) => (self, f) => F.contramap(self, G.contramap(f));\n/**\n * Returns a default `imap` implementation.\n *\n * @since 1.0.0\n */\nexports.contramapComposition = contramapComposition;\nconst imap = contramap => (0, _Function.dual)(3, (self, _, from) => contramap(self, from));\nexports.imap = imap;\n//# sourceMappingURL=Contravariant.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.mapComposition = exports.let = exports.imap = exports.flap = exports.asUnit = exports.as = void 0;\nvar _Function = /*#__PURE__*/require(\"@effect/data/Function\");\n/**\n * @since 1.0.0\n */\n\n/**\n * Returns a default `map` composition.\n *\n * @since 1.0.0\n */\nconst mapComposition = (F, G) => (self, f) => F.map(self, G.map(f));\n/**\n * Returns a default `imap` implementation.\n *\n * @since 1.0.0\n */\nexports.mapComposition = mapComposition;\nconst imap = map => (0, _Function.dual)(3, (self, to, _) => map(self, to));\n/**\n * @category mapping\n * @since 1.0.0\n */\nexports.imap = imap;\nconst flap = F => (0, _Function.dual)(2, (a, self) => F.map(self, f => f(a)));\n/**\n * @category mapping\n * @since 1.0.0\n */\nexports.flap = flap;\nconst as = F => (0, _Function.dual)(2, (self, b) => F.map(self, () => b));\n/**\n * @category mapping\n * @since 1.0.0\n */\nexports.as = as;\nconst asUnit = F => as(F)(undefined);\nexports.asUnit = asUnit;\nconst let_ = F => (0, _Function.dual)(3, (self, name, f) => F.map(self, a => Object.assign({}, a, {\n  [name]: f(a)\n})));\nexports.let = let_;\n//# sourceMappingURL=Covariant.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.tuple = exports.symbol = exports.struct = exports.string = exports.strict = exports.number = exports.make = exports.getSemigroup = exports.getMonoid = exports.contramap = exports.boolean = exports.bigint = exports.SemiProduct = exports.Product = exports.Invariant = exports.Contravariant = void 0;\nvar _Function = /*#__PURE__*/require(\"@effect/data/Function\");\nvar readonlyArray = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/internal/ReadonlyArray\"));\nvar contravariant = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/typeclass/Contravariant\"));\nvar monoid = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/typeclass/Monoid\"));\nvar product_ = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/typeclass/Product\"));\nvar semigroup = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/typeclass/Semigroup\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/**\n * This module provides an implementation of the `Equivalence` type class, which defines a binary relation\n * that is reflexive, symmetric, and transitive. In other words, it defines a notion of equivalence between values of a certain type.\n * These properties are also known in mathematics as an \"equivalence relation\".\n *\n * @since 1.0.0\n */\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nconst make = isEquivalent => (self, that) => self === that || isEquivalent(self, that);\nexports.make = make;\nconst isStrictEquivalent = (x, y) => x === y;\n/**\n * Return an `Equivalence` that uses strict equality (===) to compare values.\n *\n * @since 1.0.0\n * @category constructors\n */\nconst strict = () => isStrictEquivalent;\n/**\n * @category instances\n * @since 1.0.0\n */\nexports.strict = strict;\nconst string = /*#__PURE__*/strict();\n/**\n * @category instances\n * @since 1.0.0\n */\nexports.string = string;\nconst number = /*#__PURE__*/strict();\n/**\n * @category instances\n * @since 1.0.0\n */\nexports.number = number;\nconst boolean = /*#__PURE__*/strict();\n/**\n * @category instances\n * @since 1.0.0\n */\nexports.boolean = boolean;\nconst bigint = /*#__PURE__*/strict();\n/**\n * @category instances\n * @since 1.0.0\n */\nexports.bigint = bigint;\nconst symbol = /*#__PURE__*/strict();\n/**\n * @category instances\n * @since 1.0.0\n */\nexports.symbol = symbol;\nconst getSemigroup = () => semigroup.make((self, that) => make((x, y) => self(x, y) && that(x, y)), (self, collection) => make((x, y) => {\n  if (!self(x, y)) {\n    return false;\n  }\n  for (const equivalence of collection) {\n    if (!equivalence(x, y)) {\n      return false;\n    }\n  }\n  return true;\n}));\nexports.getSemigroup = getSemigroup;\nconst isAlwaysEquivalent = (_x, _y) => true;\n/**\n * @category instances\n * @since 1.0.0\n */\nconst getMonoid = () => monoid.fromSemigroup(getSemigroup(), isAlwaysEquivalent);\n/**\n * @category combinators\n * @since 1.0.0\n */\nexports.getMonoid = getMonoid;\nconst contramap = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => make((x, y) => self(f(x), f(y))));\nexports.contramap = contramap;\nconst imap = /*#__PURE__*/contravariant.imap(contramap);\n/**\n * @category instances\n * @since 1.0.0\n */\nconst Contravariant = {\n  imap,\n  contramap\n};\n/**\n * @category instances\n * @since 1.0.0\n */\nexports.Contravariant = Contravariant;\nconst Invariant = {\n  imap\n};\nexports.Invariant = Invariant;\nconst product = (self, that) => make(([xa, xb], [ya, yb]) => self(xa, ya) && that(xb, yb));\nconst productAll = collection => {\n  const equivalences = readonlyArray.fromIterable(collection);\n  return make((x, y) => {\n    const len = Math.min(x.length, y.length, equivalences.length);\n    for (let i = 0; i < len; i++) {\n      if (!equivalences[i](x[i], y[i])) {\n        return false;\n      }\n    }\n    return true;\n  });\n};\nconst productMany = (self, collection) => {\n  const equivalence = productAll(collection);\n  return make((x, y) => !self(x[0], y[0]) ? false : equivalence(x.slice(1), y.slice(1)));\n};\n/**\n * @category instances\n * @since 1.0.0\n */\nconst SemiProduct = {\n  imap,\n  product,\n  productMany\n};\nexports.SemiProduct = SemiProduct;\nconst of = () => isAlwaysEquivalent;\n/**\n * @category instances\n * @since 1.0.0\n */\nconst Product = {\n  of,\n  imap,\n  product,\n  productMany,\n  productAll\n};\n/**\n * Similar to `Promise.all` but operates on `Equivalence`s.\n *\n * ```\n * [Equivalence<A>, Equivalence<B>, ...] -> Equivalence<[A, B, ...]>\n * ```\n *\n * Given a tuple of `Equivalence`s returns a new `Equivalence` that compares values of a tuple\n * by applying each `Equivalence` to the corresponding element of the tuple.\n *\n * @category combinators\n * @since 1.0.0\n */\nexports.Product = Product;\nconst tuple = /*#__PURE__*/product_.tuple(Product);\n/**\n * Given a struct of `Equivalence`s returns a new `Equivalence` that compares values of a struct\n * by applying each `Equivalence` to the corresponding property of the struct.\n *\n * @category combinators\n * @since 1.0.0\n */\nexports.tuple = tuple;\nconst struct = /*#__PURE__*/product_.struct(Product);\nexports.struct = struct;\n//# sourceMappingURL=Equivalence.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.separate = exports.partitionMapComposition = exports.partition = exports.filterMapComposition = exports.filter = exports.compact = void 0;\nvar _Function = /*#__PURE__*/require(\"@effect/data/Function\");\nvar either = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/internal/Either\"));\nvar option = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/internal/Option\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/**\n * Returns a default binary `partitionMap` composition.\n *\n * @since 1.0.0\n */\nconst partitionMapComposition = (F, G) => (self, f) => {\n  const filterMap = filterMapComposition(F, G);\n  return [filterMap(self, a => either.getLeft(f(a))), filterMap(self, a => either.getRight(f(a)))];\n};\n/**\n * Returns a default binary `filterMap` composition.\n *\n * @since 1.0.0\n */\nexports.partitionMapComposition = partitionMapComposition;\nconst filterMapComposition = (F, G) => (self, f) => F.map(self, G.filterMap(f));\n/**\n * @since 1.0.0\n */\nexports.filterMapComposition = filterMapComposition;\nconst compact = F => F.filterMap(_Function.identity);\n/**\n * @since 1.0.0\n */\nexports.compact = compact;\nconst separate = F => F.partitionMap(_Function.identity);\n/**\n * @since 1.0.0\n */\nexports.separate = separate;\nconst filter = Filterable => (0, _Function.dual)(2, (self, predicate) => Filterable.filterMap(self, b => predicate(b) ? option.some(b) : option.none));\n/**\n * @since 1.0.0\n */\nexports.filter = filter;\nconst partition = F => (0, _Function.dual)(2, (self, predicate) => F.partitionMap(self, b => predicate(b) ? either.right(b) : either.left(b)));\nexports.partition = partition;\n//# sourceMappingURL=Filterable.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.flatten = exports.composeK = exports.andThen = void 0;\nvar _Function = /*#__PURE__*/require(\"@effect/data/Function\");\n/**\n * @since 1.0.0\n */\n\n/**\n * @since 1.0.0\n */\nconst flatten = F => self => F.flatMap(self, _Function.identity);\n/**\n * A variant of `flatMap` that ignores the value produced by this effect.\n *\n * @since 1.0.0\n */\nexports.flatten = flatten;\nconst andThen = F => (0, _Function.dual)(2, (self, that) => F.flatMap(self, () => that));\n/**\n * @since 1.0.0\n */\nexports.andThen = andThen;\nconst composeK = F => (0, _Function.dual)(2, (afb, bfc) => a => F.flatMap(afb(a), bfc));\nexports.composeK = composeK;\n//# sourceMappingURL=FlatMap.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.toArrayMap = exports.toArray = exports.reduceKind = exports.reduceComposition = exports.coproductMapKind = exports.combineMap = void 0;\nvar _Function = /*#__PURE__*/require(\"@effect/data/Function\");\n/**\n * @since 1.0.0\n */\n\n/**\n * Returns a default ternary `reduce` composition.\n *\n * @since 1.0.0\n */\nconst reduceComposition = (F, G) => (self, b, f) => F.reduce(self, b, (b, ga) => G.reduce(ga, b, f));\n/**\n * @since 1.0.0\n */\nexports.reduceComposition = reduceComposition;\nconst toArrayMap = F => (0, _Function.dual)(2, (self, f) => F.reduce(self, [], (out, a) => [...out, f(a)]));\n/**\n * @since 1.0.0\n */\nexports.toArrayMap = toArrayMap;\nconst toArray = F => toArrayMap(F)(_Function.identity);\n/**\n * @since 1.0.0\n */\nexports.toArray = toArray;\nconst combineMap = F => M => (0, _Function.dual)(2, (self, f) => F.reduce(self, M.empty, (m, a) => M.combine(m, f(a))));\n/**\n * @since 1.0.0\n */\nexports.combineMap = combineMap;\nconst reduceKind = F => G => (0, _Function.dual)(3, (self, b, f) => F.reduce(self, G.of(b), (gb, a) => G.flatMap(gb, b => f(b, a))));\n/**\n * @since 1.0.0\n */\nexports.reduceKind = reduceKind;\nconst coproductMapKind = F => G => (0, _Function.dual)(2, (self, f) => F.reduce(self, G.zero(), (gb, a) => G.coproduct(gb, f(a))));\nexports.coproductMapKind = coproductMapKind;\n//# sourceMappingURL=Foldable.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.tupled = exports.imapComposition = exports.bindTo = void 0;\nvar _Function = /*#__PURE__*/require(\"@effect/data/Function\");\n/**\n * The `Invariant` typeclass is a higher-order abstraction over types that allow mapping the contents of a type in both directions.\n * It is similar to the `Covariant` typeclass but provides an `imap` opration, which allows transforming a value in both directions.\n * This typeclass is useful when dealing with data types that can be converted to and from some other types.\n * The `imap` operation provides a way to convert such data types to other types that they can interact with while preserving their invariants.\n *\n * @since 1.0.0\n */\n\n/**\n * Returns a default ternary `imap` composition.\n *\n * @since 1.0.0\n */\nconst imapComposition = (F, G) => (self, to, from) => F.imap(self, G.imap(to, from), G.imap(from, to));\n/**\n * @category do notation\n * @since 1.0.0\n */\nexports.imapComposition = imapComposition;\nconst bindTo = F => (0, _Function.dual)(2, (self, name) => F.imap(self, a => ({\n  [name]: a\n}), ({\n  [name]: a\n}) => a));\n/**\n * Convert a value in a singleton array in a given effect.\n *\n * @since 1.0.0\n */\nexports.bindTo = bindTo;\nconst tupled = F => F.imap(a => [a], ([a]) => a);\nexports.tupled = tupled;\n//# sourceMappingURL=Invariant.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.tuple = exports.struct = exports.string = exports.reverse = exports.numberSum = exports.numberMultiply = exports.min = exports.max = exports.fromSemigroup = exports.booleanXor = exports.booleanSome = exports.booleanEvery = exports.booleanEqv = exports.bigintSum = exports.bigintMultiply = exports.array = void 0;\nvar semigroup = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/typeclass/Semigroup\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/**\n * @category constructors\n * @since 1.0.0\n */\nconst fromSemigroup = (S, empty) => ({\n  combine: S.combine,\n  combineMany: S.combineMany,\n  empty,\n  combineAll: collection => S.combineMany(empty, collection)\n});\n/**\n * Get a monoid where `combine` will return the minimum, based on the provided bounded order.\n *\n * The `empty` value is the `maxBound` value.\n *\n * @category constructors\n * @since 1.0.0\n */\nexports.fromSemigroup = fromSemigroup;\nconst min = B => fromSemigroup(semigroup.min(B), B.maxBound);\n/**\n * Get a monoid where `combine` will return the maximum, based on the provided bounded order.\n *\n * The `empty` value is the `minimum` value.\n *\n * @category constructors\n * @since 1.0.0\n */\nexports.min = min;\nconst max = B => fromSemigroup(semigroup.max(B), B.minBound);\n/**\n * The dual of a `Monoid`, obtained by swapping the arguments of `combine`.\n *\n * @category combinators\n * @since 1.0.0\n */\nexports.max = max;\nconst reverse = M => fromSemigroup(semigroup.reverse(M), M.empty);\n/**\n * @category instances\n * @since 1.0.0\n */\nexports.reverse = reverse;\nconst string = /*#__PURE__*/fromSemigroup(semigroup.string, \"\");\n/**\n * `number` monoid under addition.\n *\n * The `empty` value is `0`.\n *\n * @category instances\n * @since 1.0.0\n */\nexports.string = string;\nconst numberSum = /*#__PURE__*/fromSemigroup(semigroup.numberSum, 0);\n/**\n * `number` monoid under multiplication.\n *\n * The `empty` value is `1`.\n *\n * @category instances\n * @since 1.0.0\n */\nexports.numberSum = numberSum;\nconst numberMultiply = /*#__PURE__*/fromSemigroup(semigroup.numberMultiply, 1);\n/**\n * `number` monoid under addition.\n *\n * The `bigint` value is `0n`.\n *\n * @category instances\n * @since 1.0.0\n */\nexports.numberMultiply = numberMultiply;\nconst bigintSum = /*#__PURE__*/fromSemigroup(semigroup.bigintSum, 0n);\n/**\n * `bigint` monoid under multiplication.\n *\n * The `empty` value is `1n`.\n *\n * @category instances\n * @since 1.0.0\n */\nexports.bigintSum = bigintSum;\nconst bigintMultiply = /*#__PURE__*/fromSemigroup(semigroup.bigintMultiply, 1n);\n/**\n * `boolean` monoid under conjunction.\n *\n * The `empty` value is `true`.\n *\n * @category instances\n * @since 1.0.0\n */\nexports.bigintMultiply = bigintMultiply;\nconst booleanEvery = /*#__PURE__*/fromSemigroup(semigroup.booleanEvery, true);\n/**\n * `boolean` monoid under disjunction.\n *\n * The `empty` value is `false`.\n *\n * @category instances\n * @since 1.0.0\n */\nexports.booleanEvery = booleanEvery;\nconst booleanSome = /*#__PURE__*/fromSemigroup(semigroup.booleanSome, false);\n/**\n * `boolean` monoid under exclusive disjunction.\n *\n * The `empty` value is `false`.\n *\n * @category instances\n * @since 1.0.0\n */\nexports.booleanSome = booleanSome;\nconst booleanXor = /*#__PURE__*/fromSemigroup(semigroup.booleanXor, false);\n/**\n * `boolean` monoid under equivalence.\n *\n * The `empty` value is `true`.\n *\n * @category instances\n * @since 1.0.0\n */\nexports.booleanXor = booleanXor;\nconst booleanEqv = /*#__PURE__*/fromSemigroup(semigroup.booleanEqv, true);\n/**\n * Similar to `Promise.all` but operates on `Monoid`s.\n *\n * ```\n * [Monoid<A>, Monoid<B>, ...] -> Monoid<[A, B, ...]>\n * ```\n *\n * This function creates and returns a new `Monoid` for a tuple of values based on the given `Monoid`s for each element in the tuple.\n * The returned `Monoid` combines two tuples of the same type by applying the corresponding `Monoid` passed as arguments to each element in the tuple.\n *\n * The `empty` value of the returned `Monoid` is the tuple of `empty` values of the input `Monoid`s.\n *\n * It is useful when you need to combine two tuples of the same type and you have a specific way of combining each element of the tuple.\n *\n * @category combinators\n * @since 1.0.0\n */\nexports.booleanEqv = booleanEqv;\nconst tuple = (...elements) => {\n  const empty = elements.map(m => m.empty);\n  return fromSemigroup(semigroup.tuple(...elements), empty);\n};\n/**\n * Given a type `A`, this function creates and returns a `Semigroup` for `ReadonlyArray<A>`.\n *\n * The `empty` value is the empty array.\n *\n * @category combinators\n * @since 1.0.0\n */\nexports.tuple = tuple;\nconst array = () => fromSemigroup(semigroup.array(), []);\n/**\n * This function creates and returns a new `Monoid` for a struct of values based on the given `Monoid`s for each property in the struct.\n * The returned `Monoid` combines two structs of the same type by applying the corresponding `Monoid` passed as arguments to each property in the struct.\n *\n * The `empty` value of the returned `Monoid` is a struct where each property is the `empty` value of the corresponding `Monoid` in the input `monoids` object.\n *\n * It is useful when you need to combine two structs of the same type and you have a specific way of combining each property of the struct.\n *\n * @category combinators\n * @since 1.0.0\n */\nexports.array = array;\nconst struct = fields => {\n  const empty = {};\n  for (const k in fields) {\n    if (Object.prototype.hasOwnProperty.call(fields, k)) {\n      empty[k] = fields[k].empty;\n    }\n  }\n  return fromSemigroup(semigroup.struct(fields), empty);\n};\nexports.struct = struct;\n//# sourceMappingURL=Monoid.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.unit = exports.ofComposition = exports.Do = void 0;\n/**\n * Returns a default `of` composition.\n *\n * @since 1.0.0\n */\nconst ofComposition = (F, G) => a => F.of(G.of(a));\n/**\n * @since 1.0.0\n */\nexports.ofComposition = ofComposition;\nconst unit = F => F.of(undefined);\n/**\n * @category do notation\n * @since 1.0.0\n */\nexports.unit = unit;\nconst Do = F => F.of({});\nexports.Do = Do;\n//# sourceMappingURL=Of.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.tuple = exports.struct = exports.string = exports.reverse = exports.number = exports.min = exports.max = exports.make = exports.lessThanOrEqualTo = exports.lessThan = exports.greaterThanOrEqualTo = exports.greaterThan = exports.getSemigroup = exports.getMonoid = exports.contramap = exports.clamp = exports.boolean = exports.bigint = exports.between = exports.array = exports.SemiProduct = exports.Product = exports.Invariant = exports.Contravariant = void 0;\nvar _Function = /*#__PURE__*/require(\"@effect/data/Function\");\nvar readonlyArray = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/internal/ReadonlyArray\"));\nvar contravariant = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/typeclass/Contravariant\"));\nvar monoid = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/typeclass/Monoid\"));\nvar product_ = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/typeclass/Product\"));\nvar semigroup = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/typeclass/Semigroup\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/**\n * @since 1.0.0\n */\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nconst make = compare => ({\n  compare: (self, that) => self === that ? 0 : compare(self, that)\n});\n/**\n * @category instances\n * @since 1.0.0\n */\nexports.make = make;\nconst string = /*#__PURE__*/make((self, that) => self < that ? -1 : 1);\n/**\n * @category instances\n * @since 1.0.0\n */\nexports.string = string;\nconst number = /*#__PURE__*/make((self, that) => self < that ? -1 : 1);\n/**\n * @category instances\n * @since 1.0.0\n */\nexports.number = number;\nconst boolean = /*#__PURE__*/make((self, that) => self < that ? -1 : 1);\n/**\n * @category instances\n * @since 1.0.0\n */\nexports.boolean = boolean;\nconst bigint = /*#__PURE__*/make((self, that) => self < that ? -1 : 1);\n/**\n * @since 1.0.0\n */\nexports.bigint = bigint;\nconst reverse = O => make((self, that) => O.compare(that, self));\n/**\n * @category instances\n * @since 1.0.0\n */\nexports.reverse = reverse;\nconst getSemigroup = () => semigroup.make((O1, O2) => make((self, that) => {\n  const out = O1.compare(self, that);\n  if (out !== 0) {\n    return out;\n  }\n  return O2.compare(self, that);\n}), (self, collection) => make((a1, a2) => {\n  let out = self.compare(a1, a2);\n  if (out !== 0) {\n    return out;\n  }\n  for (const O of collection) {\n    out = O.compare(a1, a2);\n    if (out !== 0) {\n      return out;\n    }\n  }\n  return out;\n}));\nexports.getSemigroup = getSemigroup;\nconst empty = /*#__PURE__*/make(() => 0);\n/**\n * @category instances\n * @since 1.0.0\n */\nconst getMonoid = () => monoid.fromSemigroup(getSemigroup(), empty);\n/**\n * @category combinators\n * @since 1.0.0\n */\nexports.getMonoid = getMonoid;\nconst contramap = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => make((b1, b2) => self.compare(f(b1), f(b2))));\nexports.contramap = contramap;\nconst imap = /*#__PURE__*/contravariant.imap(contramap);\n/**\n * @category instances\n * @since 1.0.0\n */\nconst Contravariant = {\n  imap,\n  contramap\n};\n/**\n * @category instances\n * @since 1.0.0\n */\nexports.Contravariant = Contravariant;\nconst Invariant = {\n  imap\n};\nexports.Invariant = Invariant;\nconst product = (self, that) => make(([xa, xb], [ya, yb]) => {\n  const o = self.compare(xa, ya);\n  return o !== 0 ? o : that.compare(xb, yb);\n});\nconst productAll = collection => {\n  const orders = readonlyArray.fromIterable(collection);\n  return make((x, y) => {\n    const len = Math.min(x.length, y.length, orders.length);\n    for (let i = 0; i < len; i++) {\n      const o = orders[i].compare(x[i], y[i]);\n      if (o !== 0) {\n        return o;\n      }\n    }\n    return 0;\n  });\n};\nconst productMany = (self, collection) => {\n  const order = productAll(collection);\n  return make((x, y) => {\n    const o = self.compare(x[0], y[0]);\n    return o !== 0 ? o : order.compare(x.slice(1), y.slice(1));\n  });\n};\n/**\n * @category instances\n * @since 1.0.0\n */\nconst SemiProduct = {\n  imap,\n  product,\n  productMany\n};\nexports.SemiProduct = SemiProduct;\nconst of = () => empty;\n/**\n * @category instances\n * @since 1.0.0\n */\nconst Product = {\n  of,\n  imap,\n  product,\n  productMany,\n  productAll\n};\n/**\n * Similar to `Promise.all` but operates on `Order`s.\n *\n * ```\n * [Order<A>, Order<B>, ...] -> Order<[A, B, ...]>\n * ```\n *\n * This function creates and returns a new `Order` for a tuple of values based on the given `Order`s for each element in the tuple.\n * The returned `Order` compares two tuples of the same type by applying the corresponding `Order` to each element in the tuple.\n * It is useful when you need to compare two tuples of the same type and you have a specific way of comparing each element\n * of the tuple.\n *\n * @category combinators\n * @since 1.0.0\n */\nexports.Product = Product;\nconst tuple = /*#__PURE__*/product_.tuple(Product);\n/**\n * This function creates and returns a new `Order` for an array of values based on a given `Order` for the elements of the array.\n * The returned `Order` compares two arrays by applying the given `Order` to each element in the arrays.\n * If all elements are equal, the arrays are then compared based on their length.\n * It is useful when you need to compare two arrays of the same type and you have a specific way of comparing each element of the array.\n *\n * @category combinators\n * @since 1.0.0\n */\nexports.tuple = tuple;\nconst array = O => make((self, that) => {\n  const aLen = self.length;\n  const bLen = that.length;\n  const len = Math.min(aLen, bLen);\n  for (let i = 0; i < len; i++) {\n    const o = O.compare(self[i], that[i]);\n    if (o !== 0) {\n      return o;\n    }\n  }\n  return number.compare(aLen, bLen);\n});\n/**\n * This function creates and returns a new `Order` for a struct of values based on the given `Order`s\n * for each property in the struct.\n *\n * @category combinators\n * @since 1.0.0\n */\nexports.array = array;\nconst struct = /*#__PURE__*/product_.struct(Product);\n/**\n * Test whether one value is _strictly less than_ another.\n *\n * @since 1.0.0\n */\nexports.struct = struct;\nconst lessThan = O => (0, _Function.dual)(2, (self, that) => O.compare(self, that) === -1);\n/**\n * Test whether one value is _strictly greater than_ another.\n *\n * @since 1.0.0\n */\nexports.lessThan = lessThan;\nconst greaterThan = O => (0, _Function.dual)(2, (self, that) => O.compare(self, that) === 1);\n/**\n * Test whether one value is _non-strictly less than_ another.\n *\n * @since 1.0.0\n */\nexports.greaterThan = greaterThan;\nconst lessThanOrEqualTo = O => (0, _Function.dual)(2, (self, that) => O.compare(self, that) !== 1);\n/**\n * Test whether one value is _non-strictly greater than_ another.\n *\n * @since 1.0.0\n */\nexports.lessThanOrEqualTo = lessThanOrEqualTo;\nconst greaterThanOrEqualTo = O => (0, _Function.dual)(2, (self, that) => O.compare(self, that) !== -1);\n/**\n * Take the minimum of two values. If they are considered equal, the first argument is chosen.\n *\n * @since 1.0.0\n */\nexports.greaterThanOrEqualTo = greaterThanOrEqualTo;\nconst min = O => (0, _Function.dual)(2, (self, that) => self === that || O.compare(self, that) < 1 ? self : that);\n/**\n * Take the maximum of two values. If they are considered equal, the first argument is chosen.\n *\n * @since 1.0.0\n */\nexports.min = min;\nconst max = O => (0, _Function.dual)(2, (self, that) => self === that || O.compare(self, that) > -1 ? self : that);\n/**\n * Clamp a value between a minimum and a maximum.\n *\n * @since 1.0.0\n */\nexports.max = max;\nconst clamp = O => (0, _Function.dual)(3, (self, minimum, maximum) => min(O)(maximum, max(O)(minimum, self)));\n/**\n * Test whether a value is between a minimum and a maximum (inclusive).\n *\n * @since 1.0.0\n */\nexports.clamp = clamp;\nconst between = O => (0, _Function.dual)(3, (self, minimum, maximum) => !lessThan(O)(self, minimum) && !greaterThan(O)(self, maximum));\nexports.between = between;\n//# sourceMappingURL=Order.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.tuple = exports.struct = void 0;\n/**\n * @since 1.0.0\n */\n/**\n * @since 1.0.0\n */\nconst tuple = F => (...elements) => F.productAll(elements);\n/**\n * @since 1.0.0\n */\nexports.tuple = tuple;\nconst struct = F => fields => {\n  const keys = Object.keys(fields);\n  return F.imap(F.productAll(keys.map(k => fields[k])), values => {\n    const out = {};\n    for (let i = 0; i < values.length; i++) {\n      out[keys[i]] = values[i];\n    }\n    return out;\n  }, r => keys.map(k => r[k]));\n};\nexports.struct = struct;\n//# sourceMappingURL=Product.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.zipWith = exports.lift2 = exports.getSemigroup = exports.ap = exports.andThenDiscard = exports.andThen = void 0;\nvar _Function = /*#__PURE__*/require(\"@effect/data/Function\");\nvar semigroup = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/typeclass/Semigroup\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/**\n * @since 1.0.0\n */\n\n/**\n * Lift a `Semigroup` into 'F', the inner values are combined using the provided `Semigroup`.\n *\n * @category lifting\n * @since 1.0.0\n */\nconst getSemigroup = F => S => semigroup.make((self, that) => F.map(F.product(self, that), ([a1, a2]) => S.combine(a1, a2)), (self, collection) => F.map(F.productMany(self, collection), ([head, ...tail]) => S.combineMany(head, tail)));\n/**\n * Zips two `F` values together using a provided function, returning a new `F` of the result.\n *\n * @param self - The left-hand side of the zip operation\n * @param that - The right-hand side of the zip operation\n * @param f - The function used to combine the values of the two `Option`s\n *\n * @since 1.0.0\n */\nexports.getSemigroup = getSemigroup;\nconst zipWith = F => (0, _Function.dual)(3, (self, that, f) => F.map(F.product(self, that), ([a, b]) => f(a, b)));\n/**\n * @since 1.0.0\n */\nexports.zipWith = zipWith;\nconst ap = F => (0, _Function.dual)(2, (self, that) => zipWith(F)(self, that, (f, a) => f(a)));\n/**\n * @since 1.0.0\n */\nexports.ap = ap;\nconst andThenDiscard = F => (0, _Function.dual)(2, (self, that) => zipWith(F)(self, that, _Function.identity));\n/**\n * @since 1.0.0\n */\nexports.andThenDiscard = andThenDiscard;\nconst andThen = F => (0, _Function.dual)(2, (self, that) => zipWith(F)(self, that, _Function.SK));\n/**\n * Lifts a binary function into `F`.\n *\n * @param f - The function to lift.\n *\n * @category lifting\n * @since 1.0.0\n */\nexports.andThen = andThen;\nconst lift2 = F => f => (0, _Function.dual)(2, (self, that) => zipWith(F)(self, that, f));\nexports.lift2 = lift2;\n//# sourceMappingURL=SemiApplicative.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getSemigroup = void 0;\n/**\n * @since 1.0.0\n */\n/**\n * @since 1.0.0\n */\nconst getSemigroup = F => () => ({\n  combine: F.coproduct,\n  combineMany: F.coproductMany\n});\nexports.getSemigroup = getSemigroup;\n//# sourceMappingURL=SemiCoproduct.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.productManyComposition = exports.productMany = exports.productComposition = exports.nonEmptyTuple = exports.nonEmptyStruct = exports.appendElement = exports.andThenBind = void 0;\nvar _Function = /*#__PURE__*/require(\"@effect/data/Function\");\n/**\n * @since 1.0.0\n */\n\n/**\n * Returns a default `productMany` implementation.\n *\n * @category constructors\n * @since 1.0.0\n */\nconst productMany = (map, product) => (self, collection) => {\n  let out = map(self, a => [a]);\n  for (const fa of collection) {\n    out = map(product(out, fa), ([[head, ...tail], a]) => [head, ...tail, a]);\n  }\n  return out;\n};\n/**\n * Returns a default `product` composition.\n *\n * @since 1.0.0\n */\nexports.productMany = productMany;\nconst productComposition = (F, G) => (self, that) => F.map(F.product(self, that), ([ga, gb]) => G.product(ga, gb));\n/**\n * Returns a default `productMany` composition.\n *\n * @since 1.0.0\n */\nexports.productComposition = productComposition;\nconst productManyComposition = (F, G) => (self, collection) => F.map(F.productMany(self, collection), ([ga, ...gas]) => G.productMany(ga, gas));\n/**\n * @category do notation\n * @since 1.0.0\n */\nexports.productManyComposition = productManyComposition;\nconst andThenBind = F => (0, _Function.dual)(3, (self, name, that) => F.imap(F.product(self, that), ([a, b]) => Object.assign({}, a, {\n  [name]: b\n}), ({\n  [name]: b,\n  ...rest\n}) => [rest, b]));\n/**\n * Appends an element to the end of a tuple.\n *\n * @since 1.0.0\n */\nexports.andThenBind = andThenBind;\nconst appendElement = F => (0, _Function.dual)(2, (self, that) => F.imap(F.product(self, that), ([a, b]) => [...a, b], ab => [ab.slice(0, -1), ab[ab.length - 1]]));\n/**\n * @since 1.0.0\n */\nexports.appendElement = appendElement;\nconst nonEmptyTuple = F => (...elements) => F.productMany(elements[0], elements.slice(1));\n/**\n * @since 1.0.0\n */\nexports.nonEmptyTuple = nonEmptyTuple;\nconst nonEmptyStruct = F => fields => {\n  const keys = Object.keys(fields);\n  return F.imap(F.productMany(fields[keys[0]], keys.slice(1).map(k => fields[k])), ([value, ...values]) => {\n    const out = {\n      [keys[0]]: value\n    };\n    for (let i = 0; i < values.length; i++) {\n      out[keys[i + 1]] = values[i];\n    }\n    return out;\n  }, r => keys.map(k => r[k]));\n};\nexports.nonEmptyStruct = nonEmptyStruct;\n//# sourceMappingURL=SemiProduct.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.tuple = exports.struct = exports.string = exports.reverse = exports.numberSum = exports.numberMultiply = exports.min = exports.max = exports.make = exports.last = exports.intercalate = exports.imap = exports.first = exports.constant = exports.booleanXor = exports.booleanSome = exports.booleanEvery = exports.booleanEqv = exports.bigintSum = exports.bigintMultiply = exports.array = exports.SemiProduct = exports.Product = exports.Invariant = void 0;\nvar _Function = /*#__PURE__*/require(\"@effect/data/Function\");\nvar readonlyArray = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/internal/ReadonlyArray\"));\nvar product_ = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/typeclass/Product\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/**\n * @since 1.0.0\n */\n\n/**\n * @param combineMany - Useful when `combineMany` can be optimised\n *\n * @category constructors\n * @since 1.0.0\n */\nconst make = (combine, combineMany = (self, collection) => (0, readonlyArray.fromIterable)(collection).reduce(combine, self)) => ({\n  combine,\n  combineMany\n});\n/**\n * @category instances\n * @since 1.0.0\n */\nexports.make = make;\nconst string = /*#__PURE__*/make((self, that) => self + that);\n/**\n * `number` semigroup under addition.\n *\n * @category instances\n * @since 1.0.0\n */\nexports.string = string;\nconst numberSum = /*#__PURE__*/make((self, that) => self + that);\n/**\n * `number` semigroup under multiplication.\n *\n * @category instances\n * @since 1.0.0\n */\nexports.numberSum = numberSum;\nconst numberMultiply = /*#__PURE__*/make((self, that) => self * that, (self, collection) => {\n  if (self === 0) {\n    return 0;\n  }\n  let out = self;\n  for (const n of collection) {\n    if (n === 0) {\n      return 0;\n    }\n    out = out * n;\n  }\n  return out;\n});\n/**\n * `bigint` semigroup under addition.\n *\n * @category instances\n * @since 1.0.0\n */\nexports.numberMultiply = numberMultiply;\nconst bigintSum = /*#__PURE__*/make((self, that) => self + that);\n/**\n * `bigint` semigroup under multiplication.\n *\n * @category instances\n * @since 1.0.0\n */\nexports.bigintSum = bigintSum;\nconst bigintMultiply = /*#__PURE__*/make((self, that) => self * that, (self, collection) => {\n  if (self === 0n) {\n    return 0n;\n  }\n  let out = self;\n  for (const n of collection) {\n    if (n === 0n) {\n      return 0n;\n    }\n    out = out * n;\n  }\n  return out;\n});\n/**\n * `boolean` semigroup under conjunction.\n *\n * @category instances\n * @since 1.0.0\n */\nexports.bigintMultiply = bigintMultiply;\nconst booleanEvery = /*#__PURE__*/make((self, that) => self && that, (self, collection) => {\n  if (self === false) {\n    return false;\n  }\n  for (const b of collection) {\n    if (b === false) {\n      return false;\n    }\n  }\n  return true;\n});\n/**\n * `boolean` semigroup under disjunction.\n *\n * @category instances\n * @since 1.0.0\n */\nexports.booleanEvery = booleanEvery;\nconst booleanSome = /*#__PURE__*/make((self, that) => self || that, (self, collection) => {\n  if (self === true) {\n    return true;\n  }\n  for (const b of collection) {\n    if (b === true) {\n      return true;\n    }\n  }\n  return false;\n});\n/**\n * `boolean` semigroup under exclusive disjunction.\n *\n * @category instances\n * @since 1.0.0\n */\nexports.booleanSome = booleanSome;\nconst booleanXor = /*#__PURE__*/make((self, that) => self !== that);\n/**\n * `boolean` semigroup under equivalence.\n *\n * @category instances\n * @since 1.0.0\n */\nexports.booleanXor = booleanXor;\nconst booleanEqv = /*#__PURE__*/make((self, that) => self === that);\n/**\n * `Semigroup` that returns last minimum of elements.\n *\n * @category constructors\n * @since 1.0.0\n */\nexports.booleanEqv = booleanEqv;\nconst min = O => make((self, that) => O.compare(self, that) === -1 ? self : that);\n/**\n * `Semigroup` that returns last maximum of elements.\n *\n * @category constructors\n * @since 1.0.0\n */\nexports.min = min;\nconst max = O => make((self, that) => O.compare(self, that) === 1 ? self : that);\n/**\n * @category constructors\n * @since 1.0.0\n */\nexports.max = max;\nconst constant = a => make(() => a, () => a);\n/**\n * The dual of a `Semigroup`, obtained by flipping the arguments of `combine`.\n *\n * @since 1.0.0\n */\nexports.constant = constant;\nconst reverse = S => make((self, that) => S.combine(that, self), (self, collection) => {\n  const reversed = Array.from(collection).reverse();\n  return reversed.length > 0 ? S.combine(S.combineMany(reversed[0], reversed.slice(1)), self) : self;\n});\n/**\n * @since 1.0.0\n */\nexports.reverse = reverse;\nconst intercalate = /*#__PURE__*/(0, _Function.dual)(2, (S, separator) => make((self, that) => S.combineMany(self, [separator, that])));\n/**\n * Always return the first argument.\n *\n * @category instances\n * @since 1.0.0\n */\nexports.intercalate = intercalate;\nconst first = () => make(a => a, a => a);\n/**\n * Always return the last argument.\n *\n * @category instances\n * @since 1.0.0\n */\nexports.first = first;\nconst last = () => make((_, second) => second, (self, collection) => {\n  let a = self;\n  // eslint-disable-next-line no-empty\n  for (a of collection) {}\n  return a;\n});\n/**\n * @since 1.0.0\n */\nexports.last = last;\nconst imap = /*#__PURE__*/(0, _Function.dual)(3, (S, to, from) => make((self, that) => to(S.combine(from(self), from(that))), (self, collection) => to(S.combineMany(from(self), (0, readonlyArray.fromIterable)(collection).map(from)))));\n/**\n * @category instances\n * @since 1.0.0\n */\nexports.imap = imap;\nconst Invariant = {\n  imap\n};\nexports.Invariant = Invariant;\nconst product = (self, that) => make(([xa, xb], [ya, yb]) => [self.combine(xa, ya), that.combine(xb, yb)]);\nconst productAll = collection => {\n  const semigroups = readonlyArray.fromIterable(collection);\n  return make((x, y) => {\n    const len = Math.min(x.length, y.length, semigroups.length);\n    const out = [];\n    for (let i = 0; i < len; i++) {\n      out.push(semigroups[i].combine(x[i], y[i]));\n    }\n    return out;\n  });\n};\nconst productMany = (self, collection) => {\n  const semigroup = productAll(collection);\n  return make((x, y) => [self.combine(x[0], y[0]), ...semigroup.combine(x.slice(1), y.slice(1))]);\n};\n/**\n * @category instances\n * @since 1.0.0\n */\nconst SemiProduct = {\n  imap,\n  product,\n  productMany\n};\nexports.SemiProduct = SemiProduct;\nconst of = constant;\n/**\n * @category instances\n * @since 1.0.0\n */\nconst Product = {\n  of,\n  imap,\n  product,\n  productMany,\n  productAll\n};\n/**\n * Similar to `Promise.all` but operates on `Semigroup`s.\n *\n * ```\n * [Semigroup<A>, Semigroup<B>, ...] -> Semigroup<[A, B, ...]>\n * ```\n *\n * This function creates and returns a new `Semigroup` for a tuple of values based on the given `Semigroup`s for each element in the tuple.\n * The returned `Semigroup` combines two tuples of the same type by applying the corresponding `Semigroup` passed as arguments to each element in the tuple.\n *\n * It is useful when you need to combine two tuples of the same type and you have a specific way of combining each element of the tuple.\n *\n * @category combinators\n * @since 1.0.0\n */\nexports.Product = Product;\nconst tuple = /*#__PURE__*/product_.tuple(Product);\n/**\n * Given a type `A`, this function creates and returns a `Semigroup` for `ReadonlyArray<A>`.\n * The returned `Semigroup` combines two arrays by concatenating them.\n *\n * @category combinators\n * @since 1.0.0\n */\nexports.tuple = tuple;\nconst array = () => make((self, that) => self.concat(that));\n/**\n * This function creates and returns a new `Semigroup` for a struct of values based on the given `Semigroup`s for each property in the struct.\n * The returned `Semigroup` combines two structs of the same type by applying the corresponding `Semigroup` passed as arguments to each property in the struct.\n *\n * It is useful when you need to combine two structs of the same type and you have a specific way of combining each property of the struct.\n *\n * @category combinators\n * @since 1.0.0\n */\nexports.array = array;\nconst struct = /*#__PURE__*/product_.struct(Product);\nexports.struct = struct;\n//# sourceMappingURL=Semigroup.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.traverseTap = exports.traverseComposition = exports.sequence = void 0;\nvar _Function = /*#__PURE__*/require(\"@effect/data/Function\");\n/**\n * @since 1.0.0\n */\n\n/**\n * Returns a default binary `traverse` composition.\n *\n * @since 1.0.0\n */\nconst traverseComposition = (T, G) => F => (self, f) => T.traverse(F)(self, G.traverse(F)(f));\n/**\n * Returns a default `sequence` implementation.\n *\n * @since 1.0.0\n */\nexports.traverseComposition = traverseComposition;\nconst sequence = T => F => self => T.traverse(F)(self, _Function.identity);\n/**\n * Given a function which returns a `F` effect, thread this effect\n * through the running of this function on all the values in `T`,\n * returning an `T<A>` in a `F` context, ignoring the values\n * returned by the provided function.\n *\n * @since 1.0.0\n */\nexports.sequence = sequence;\nconst traverseTap = T => F => (0, _Function.dual)(2, (self, f) => T.traverse(F)(self, a => F.map(f(a), () => a)));\nexports.traverseTap = traverseTap;\n//# sourceMappingURL=Traversable.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.traversePartitionMap = exports.traversePartition = exports.traverseFilterMap = exports.traverseFilter = void 0;\nvar E = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Either\"));\nvar _Function = /*#__PURE__*/require(\"@effect/data/Function\");\nvar O = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Option\"));\nvar filterable = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/typeclass/Filterable\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/**\n * Returns a default binary `traversePartitionMap` implementation.\n *\n * @since 1.0.0\n */\nconst traversePartitionMap = T => F => (self, f) => F.map(T.traverse(F)(self, f), filterable.separate(T));\n/**\n * Returns a default binary `traverseFilterMap` implementation.\n *\n * @since 1.0.0\n */\nexports.traversePartitionMap = traversePartitionMap;\nconst traverseFilterMap = T => F => (self, f) => F.map(T.traverse(F)(self, f), filterable.compact(T));\n/**\n * @since 1.0.0\n */\nexports.traverseFilterMap = traverseFilterMap;\nconst traverseFilter = T => F => (0, _Function.dual)(2, (self, predicate) => T.traverseFilterMap(F)(self, b => F.map(predicate(b), keep => keep ? O.some(b) : O.none())));\n/**\n * @since 1.0.0\n */\nexports.traverseFilter = traverseFilter;\nconst traversePartition = T => F => (0, _Function.dual)(2, (self, predicate) => T.traversePartitionMap(F)(self, b => F.map(predicate(b), keep => keep ? E.right(b) : E.left(b))));\nexports.traversePartition = traversePartition;\n//# sourceMappingURL=TraversableFilterable.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.unannotate = exports.stripSomeDefects = exports.stripFailures = exports.squashWith = exports.squash = exports.size = exports.sequential = exports.reduceWithContext = exports.reduce = exports.pretty = exports.parallel = exports.match = exports.map = exports.linearize = exports.keepDefects = exports.isStackAnnotation = exports.isSequentialType = exports.isRuntimeException = exports.isParallelType = exports.isNoSuchElementException = exports.isInterruptedOnly = exports.isInterruptedException = exports.isInterrupted = exports.isInterruptType = exports.isIllegalArgumentException = exports.isFailure = exports.isFailType = exports.isEmptyType = exports.isEmpty = exports.isDieType = exports.isDie = exports.isCause = exports.isAnnotatedType = exports.interruptors = exports.interruptOption = exports.interrupt = exports.globalErrorSeq = exports.flipCauseOption = exports.flatten = exports.flatMap = exports.find = exports.filter = exports.failures = exports.failureOrCause = exports.failureOption = exports.fail = exports.empty = exports.dieOption = exports.die = exports.defects = exports.contains = exports.as = exports.annotated = exports.StackAnnotationTypeId = exports.StackAnnotation = exports.RuntimeExceptionTypeId = exports.RuntimeException = exports.NoSuchElementExceptionTypeId = exports.NoSuchElementException = exports.InvalidHubCapacityExceptionTypeId = exports.InterruptedExceptionTypeId = exports.InterruptedException = exports.IllegalArgumentExceptionTypeId = exports.IllegalArgumentException = exports.CauseTypeId = void 0;\nvar internal = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/cause\"));\nvar _pretty = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/cause-pretty\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/**\n * @since 1.0.0\n * @category symbols\n */\nconst CauseTypeId = internal.CauseTypeId;\n/**\n * @since 1.0.0\n * @category symbols\n */\nexports.CauseTypeId = CauseTypeId;\nconst RuntimeExceptionTypeId = internal.RuntimeExceptionTypeId;\n/**\n * @since 1.0.0\n * @category symbols\n */\nexports.RuntimeExceptionTypeId = RuntimeExceptionTypeId;\nconst InterruptedExceptionTypeId = internal.InterruptedExceptionTypeId;\n/**\n * @since 1.0.0\n * @category symbols\n */\nexports.InterruptedExceptionTypeId = InterruptedExceptionTypeId;\nconst IllegalArgumentExceptionTypeId = internal.IllegalArgumentExceptionTypeId;\n/**\n * @since 1.0.0\n * @category symbols\n */\nexports.IllegalArgumentExceptionTypeId = IllegalArgumentExceptionTypeId;\nconst NoSuchElementExceptionTypeId = internal.NoSuchElementExceptionTypeId;\n/**\n * @since 1.0.0\n * @category symbols\n */\nexports.NoSuchElementExceptionTypeId = NoSuchElementExceptionTypeId;\nconst InvalidHubCapacityExceptionTypeId = internal.InvalidHubCapacityExceptionTypeId;\n/**\n * @since 1.0.0\n * @category symbols\n */\nexports.InvalidHubCapacityExceptionTypeId = InvalidHubCapacityExceptionTypeId;\nconst StackAnnotationTypeId = internal.StackAnnotationTypeId;\n/**\n * @since 1.0.0\n * @category stack\n */\nexports.StackAnnotationTypeId = StackAnnotationTypeId;\nconst StackAnnotation = internal.StackAnnotation;\n/**\n * @since 1.0.0\n * @category stack\n */\nexports.StackAnnotation = StackAnnotation;\nconst globalErrorSeq = internal.globalErrorSeq;\n/**\n * Constructs a new `Empty` cause.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.globalErrorSeq = globalErrorSeq;\nconst empty = internal.empty;\n/**\n * Constructs a new `Fail` cause from the specified `error`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.empty = empty;\nconst fail = internal.fail;\n/**\n * Constructs a new `Die` cause from the specified `defect`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.fail = fail;\nconst die = internal.die;\n/**\n * Constructs a new `Interrupt` cause from the specified `fiberId`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.die = die;\nconst interrupt = internal.interrupt;\n/**\n * Constructs a new `Annotated` cause from the specified `annotation`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.interrupt = interrupt;\nconst annotated = internal.annotated;\n/**\n * Constructs a new `Parallel` cause from the specified `left` and `right`\n * causes.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.annotated = annotated;\nconst parallel = internal.parallel;\n/**\n * Constructs a new `Sequential` cause from the specified pecified `left` and\n * `right` causes.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.parallel = parallel;\nconst sequential = internal.sequential;\n/**\n * Returns `true` if the specified value is a `Cause`, `false` otherwise.\n *\n * @since 1.0.0\n * @category refinements\n */\nexports.sequential = sequential;\nconst isCause = internal.isCause;\n/**\n * Returns `true` if the specified `Cause` is an `Empty` type, `false`\n * otherwise.\n *\n * @since 1.0.0\n * @category refinements\n */\nexports.isCause = isCause;\nconst isEmptyType = internal.isEmptyType;\n/**\n * Returns `true` if the specified `Cause` is a `Fail` type, `false`\n * otherwise.\n *\n * @since 1.0.0\n * @category refinements\n */\nexports.isEmptyType = isEmptyType;\nconst isFailType = internal.isFailType;\n/**\n * Returns `true` if the specified `Cause` is a `Die` type, `false`\n * otherwise.\n *\n * @since 1.0.0\n * @category refinements\n */\nexports.isFailType = isFailType;\nconst isDieType = internal.isDieType;\n/**\n * Returns `true` if the specified `Cause` is an `Interrupt` type, `false`\n * otherwise.\n *\n * @since 1.0.0\n * @category refinements\n */\nexports.isDieType = isDieType;\nconst isInterruptType = internal.isInterruptType;\n/**\n * Returns `true` if the specified `Cause` is an `Annotated` type, `false`\n * otherwise.\n *\n * @since 1.0.0\n * @category refinements\n */\nexports.isInterruptType = isInterruptType;\nconst isAnnotatedType = internal.isAnnotatedType;\n/**\n * Returns `true` if the specified `Cause` is a `Sequential` type, `false`\n * otherwise.\n *\n * @since 1.0.0\n * @category refinements\n */\nexports.isAnnotatedType = isAnnotatedType;\nconst isSequentialType = internal.isSequentialType;\n/**\n * Returns `true` if the specified `Cause` is a `Parallel` type, `false`\n * otherwise.\n *\n * @since 1.0.0\n * @category refinements\n */\nexports.isSequentialType = isSequentialType;\nconst isParallelType = internal.isParallelType;\n/**\n * Returns the size of the cause, calculated as the number of individual `Cause`\n * nodes found in the `Cause` semiring structure.\n *\n * @since 1.0.0\n * @category getters\n */\nexports.isParallelType = isParallelType;\nconst size = internal.size;\n/**\n * Returns `true` if the specified cause is empty, `false` otherwise.\n *\n * @since 1.0.0\n * @category getters\n */\nexports.size = size;\nconst isEmpty = internal.isEmpty;\n/**\n * Returns `true` if the specified cause contains a failure, `false` otherwise.\n *\n * @since 1.0.0\n * @category getters\n */\nexports.isEmpty = isEmpty;\nconst isFailure = internal.isFailure;\n/**\n * Returns `true` if the specified cause contains a defect, `false` otherwise.\n *\n * @since 1.0.0\n * @category getters\n */\nexports.isFailure = isFailure;\nconst isDie = internal.isDie;\n/**\n * Returns `true` if the specified cause contains an interruption, `false`\n * otherwise.\n *\n * @since 1.0.0\n * @category getters\n */\nexports.isDie = isDie;\nconst isInterrupted = internal.isInterrupted;\n/**\n * Returns `true` if the specified cause contains only interruptions (without\n * any `Die` or `Fail` causes), `false` otherwise.\n *\n * @since 1.0.0\n * @category getters\n */\nexports.isInterrupted = isInterrupted;\nconst isInterruptedOnly = internal.isInterruptedOnly;\n/**\n * Returns a `List` of all recoverable errors of type `E` in the specified\n * cause.\n *\n * @since 1.0.0\n * @category getters\n */\nexports.isInterruptedOnly = isInterruptedOnly;\nconst failures = internal.failures;\n/**\n * Returns a `List` of all unrecoverable defects in the specified cause.\n *\n * @since 1.0.0\n * @category getters\n */\nexports.failures = failures;\nconst defects = internal.defects;\n/**\n * Returns a `HashSet` of `FiberId`s for all fibers that interrupted the fiber\n * described by the specified cause.\n *\n * @since 1.0.0\n * @category getters\n */\nexports.defects = defects;\nconst interruptors = internal.interruptors;\n/**\n * Returns the `E` associated with the first `Fail` in this `Cause`, if one\n * exists.\n *\n * @since 1.0.0\n * @category getters\n */\nexports.interruptors = interruptors;\nconst failureOption = internal.failureOption;\n/**\n * Returns the first checked error on the `Left` if available, if there are\n * no checked errors return the rest of the `Cause` that is known to contain\n * only `Die` or `Interrupt` causes.\n *\n * @since 1.0.0\n * @category getters\n */\nexports.failureOption = failureOption;\nconst failureOrCause = internal.failureOrCause;\n/**\n * Converts the specified `Cause<Option<E>>` to an `Option<Cause<E>>` by\n * recursively stripping out any failures with the error `None`.\n *\n * @since 1.0.0\n * @category getters\n */\nexports.failureOrCause = failureOrCause;\nconst flipCauseOption = internal.flipCauseOption;\n/**\n * Returns the defect associated with the first `Die` in this `Cause`, if one\n * exists.\n *\n * @since 1.0.0\n * @category getters\n */\nexports.flipCauseOption = flipCauseOption;\nconst dieOption = internal.dieOption;\n/**\n * Returns the `FiberId` associated with the first `Interrupt` in the specified\n * cause, if one exists.\n *\n * @since 1.0.0\n * @category getters\n */\nexports.dieOption = dieOption;\nconst interruptOption = internal.interruptOption;\n/**\n * Remove all `Fail` and `Interrupt` nodes from the specified cause, and return\n * a cause containing only `Die` cause/finalizer defects.\n *\n * @since 1.0.0\n * @category getters\n */\nexports.interruptOption = interruptOption;\nconst keepDefects = internal.keepDefects;\n/**\n * Linearizes the specified cause into a `HashSet` of parallel causes where each\n * parallel cause contains a linear sequence of failures.\n *\n * @since 1.0.0\n * @category getters\n */\nexports.keepDefects = keepDefects;\nconst linearize = internal.linearize;\n/**\n * Remove all `Fail` and `Interrupt` nodes from the specified cause, and return\n * a cause containing only `Die` cause/finalizer defects.\n *\n * @since 1.0.0\n * @category getters\n */\nexports.linearize = linearize;\nconst stripFailures = internal.stripFailures;\n/**\n * Remove all `Die` causes that the specified partial function is defined at,\n * returning `Some` with the remaining causes or `None` if there are no\n * remaining causes.\n *\n * @since 1.0.0\n * @category getters\n */\nexports.stripFailures = stripFailures;\nconst stripSomeDefects = internal.stripSomeDefects;\n/**\n * @since 1.0.0\n * @category mapping\n */\nexports.stripSomeDefects = stripSomeDefects;\nconst as = internal.as;\n/**\n * @since 1.0.0\n * @category mapping\n */\nexports.as = as;\nconst map = internal.map;\n/**\n * @since 1.0.0\n * @category sequencing\n */\nexports.map = map;\nconst flatMap = internal.flatMap;\n/**\n * @since 1.0.0\n * @category sequencing\n */\nexports.flatMap = flatMap;\nconst flatten = internal.flatten;\n/**\n * Returns `true` if the `self` cause contains or is equal to `that` cause,\n * `false` otherwise.\n *\n * @since 1.0.0\n * @category elements\n */\nexports.flatten = flatten;\nconst contains = internal.contains;\n/**\n * Squashes a `Cause` down to a single defect, chosen to be the \"most important\"\n * defect.\n *\n * @since 1.0.0\n * @category destructors\n */\nexports.contains = contains;\nconst squash = internal.squash;\n/**\n * Squashes a `Cause` down to a single defect, chosen to be the \"most important\"\n * defect. If a recoverable error is found, the provided function will be used\n * to map the error a defect, and the resulting value will be returned.\n *\n * @since 1.0.0\n * @category destructors\n */\nexports.squash = squash;\nconst squashWith = internal.squashWith;\n/**\n * Uses the provided partial function to search the specified cause and attempt\n * to extract information from it.\n *\n * @since 1.0.0\n * @category elements\n */\nexports.squashWith = squashWith;\nconst find = internal.find;\n/**\n * Filters causes which match the provided predicate out of the specified cause.\n *\n * @since 1.0.0\n * @category filtering\n */\nexports.find = find;\nconst filter = internal.filter;\n/**\n * Folds the specified cause into a value of type `Z`.\n *\n * @since 1.0.0\n * @category folding\n */\nexports.filter = filter;\nconst match = internal.match;\n/**\n * Reduces the specified cause into a value of type `Z`, beginning with the\n * provided `zero` value.\n *\n * @since 1.0.0\n * @category folding\n */\nexports.match = match;\nconst reduce = internal.reduce;\n/**\n * Reduces the specified cause into a value of type `Z` using a `Cause.Reducer`.\n * Also allows for accessing the provided context during reduction.\n *\n * @since 1.0.0\n * @category folding\n */\nexports.reduce = reduce;\nconst reduceWithContext = internal.reduceWithContext;\n/**\n * Represents a checked exception which occurs when a `Fiber` is interrupted.\n *\n * @since 1.0.0\n * @category errors\n */\nexports.reduceWithContext = reduceWithContext;\nconst InterruptedException = internal.InterruptedException;\n/**\n * Returns `true` if the specified value is an `InterruptedException`, `false`\n * otherwise.\n\n * @since 1.0.0\n * @category refinements\n */\nexports.InterruptedException = InterruptedException;\nconst isInterruptedException = internal.isInterruptedException;\n/**\n * Represents a checked exception which occurs when an invalid argument is\n * provided to a method.\n *\n * @since 1.0.0\n * @category errors\n */\nexports.isInterruptedException = isInterruptedException;\nconst IllegalArgumentException = internal.IllegalArgumentException;\n/**\n * Returns `true` if the specified value is an `IllegalArgumentException`, `false`\n * otherwise.\n\n * @since 1.0.0\n * @category refinements\n */\nexports.IllegalArgumentException = IllegalArgumentException;\nconst isIllegalArgumentException = internal.isIllegalArgumentException;\n/**\n * Represents a checked exception which occurs when an expected element was\n * unable to be found.\n *\n * @since 1.0.0\n * @category errors\n */\nexports.isIllegalArgumentException = isIllegalArgumentException;\nconst NoSuchElementException = internal.NoSuchElementException;\n/**\n  * Returns `true` if the specified value is an `IllegalArgumentException`, `false`\n  * otherwise.\n\n  * @since 1.0.0\n  * @category refinements\n  */\nexports.NoSuchElementException = NoSuchElementException;\nconst isNoSuchElementException = internal.isNoSuchElementException;\n/**\n * Represents a generic checked exception which occurs at runtime.\n *\n * @since 1.0.0\n * @category errors\n */\nexports.isNoSuchElementException = isNoSuchElementException;\nconst RuntimeException = internal.RuntimeException;\n/**\n  * Returns `true` if the specified value is an `RuntimeException`, `false`\n  * otherwise.\n\n  * @since 1.0.0\n  * @category refinements\n  */\nexports.RuntimeException = RuntimeException;\nconst isRuntimeException = internal.isRuntimeException;\n/**\n * Returns the specified `Cause` as a pretty-printed string.\n *\n * @since 1.0.0\n * @category rendering\n */\nexports.isRuntimeException = isRuntimeException;\nconst pretty = _pretty.pretty;\n/**\n * Checks if an annotation is a StackAnnotation\n *\n * @since 1.0.0\n * @category guards\n */\nexports.pretty = pretty;\nconst isStackAnnotation = internal.isStackAnnotation;\n/**\n * Removes any annotation from the cause\n *\n * @since 1.0.0\n * @category filtering\n */\nexports.isStackAnnotation = isStackAnnotation;\nconst unannotate = internal.unannotate;\nexports.unannotate = unannotate;\n//# sourceMappingURL=Cause.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.sleep = exports.make = exports.currentTimeMillis = exports.clockWith = exports.Tag = exports.ClockTypeId = void 0;\nvar internal = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/clock\"));\nvar defaultServices = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/defaultServices\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/**\n * @since 1.0.0\n * @category symbols\n */\nconst ClockTypeId = internal.ClockTypeId;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexports.ClockTypeId = ClockTypeId;\nconst make = internal.make;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexports.make = make;\nconst sleep = defaultServices.sleep;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexports.sleep = sleep;\nconst currentTimeMillis = defaultServices.currentTimeMillis;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexports.currentTimeMillis = currentTimeMillis;\nconst clockWith = defaultServices.clockWith;\n/**\n * @since 1.0.0\n * @category context\n */\nexports.clockWith = clockWith;\nconst Tag = internal.clockTag;\nexports.Tag = Tag;\n//# sourceMappingURL=Clock.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.zipWith = exports.zip = exports.withDescription = exports.withDefault = exports.validate = exports.unwrap = exports.table = exports.sync = exports.succeed = exports.string = exports.setOf = exports.secret = exports.repeat = exports.primitive = exports.orElseIf = exports.orElse = exports.optional = exports.nested = exports.mapOrFail = exports.mapAttempt = exports.map = exports.isConfig = exports.integer = exports.float = exports.fail = exports.defer = exports.date = exports.chunkOf = exports.bool = exports.arrayOf = exports.all = exports.ConfigTypeId = void 0;\nvar internal = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/config\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/**\n * @since 1.0.0\n * @category symbols\n */\nconst ConfigTypeId = internal.ConfigTypeId;\n/**\n * Constructs a config for an array of values.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.ConfigTypeId = ConfigTypeId;\nconst arrayOf = internal.arrayOf;\n/**\n * Constructs a config for a boolean value.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.arrayOf = arrayOf;\nconst bool = internal.bool;\n/**\n * Constructs a config for a sequence of values.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.bool = bool;\nconst chunkOf = internal.chunkOf;\n/**\n * Constructs a config for a date value.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.chunkOf = chunkOf;\nconst date = internal.date;\n/**\n * Lazily constructs a config.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.date = date;\nconst defer = internal.defer;\n/**\n * Constructs a config that fails with the specified message.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.defer = defer;\nconst fail = internal.fail;\n/**\n * Constructs a config for a float value.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.fail = fail;\nconst float = internal.float;\n/**\n * Constructs a config for a integer value.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.float = float;\nconst integer = internal.integer;\n/**\n * This function returns `true` if the specified value is an `Config` value,\n * `false` otherwise.\n *\n * This function can be useful for checking the type of a value before\n * attempting to operate on it as an `Config` value. For example, you could\n * use `isConfig` to check the type of a value before using it as an\n * argument to a function that expects an `Config` value.\n *\n * @param u - The value to check for being a `Config` value.\n *\n * @returns `true` if the specified value is a `Config` value, `false`\n * otherwise.\n *\n * @since 1.0.0\n * @category refinements\n */\nexports.integer = integer;\nconst isConfig = internal.isConfig;\n/**\n * Returns a  config whose structure is the same as this one, but which produces\n * a different value, constructed using the specified function.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.isConfig = isConfig;\nconst map = internal.map;\n/**\n * Returns a config whose structure is the same as this one, but which may\n * produce a different value, constructed using the specified function, which\n * may throw exceptions that will be translated into validation errors.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.map = map;\nconst mapAttempt = internal.mapAttempt;\n/**\n * Returns a new config whose structure is the samea as this one, but which\n * may produce a different value, constructed using the specified fallible\n * function.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.mapAttempt = mapAttempt;\nconst mapOrFail = internal.mapOrFail;\n/**\n * Returns a config that has this configuration nested as a property of the\n * specified name.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.mapOrFail = mapOrFail;\nconst nested = internal.nested;\n/**\n * Returns a config whose structure is preferentially described by this\n * config, but which falls back to the specified config if there is an issue\n * reading from this config.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.nested = nested;\nconst orElse = internal.orElse;\n/**\n * Returns configuration which reads from this configuration, but which falls\n * back to the specified configuration if reading from this configuration\n * fails with an error satisfying the specified predicate.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.orElse = orElse;\nconst orElseIf = internal.orElseIf;\n/**\n * Returns an optional version of this config, which will be `None` if the\n * data is missing from configuration, and `Some` otherwise.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.orElseIf = orElseIf;\nconst optional = internal.optional;\n/**\n * Constructs a new primitive config.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.optional = optional;\nconst primitive = internal.primitive;\n/**\n * Returns a config that describes a sequence of values, each of which has the\n * structure of this config.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.primitive = primitive;\nconst repeat = internal.repeat;\n/**\n * Constructs a config for a secret value.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.repeat = repeat;\nconst secret = internal.secret;\n/**\n * Constructs a config for a sequence of values.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.secret = secret;\nconst setOf = internal.setOf;\n/**\n * Constructs a config for a string value.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.setOf = setOf;\nconst string = internal.string;\n/**\n * Constructs a config which contains the specified value.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.string = string;\nconst succeed = internal.succeed;\n/**\n * Constructs a config which contains the specified lazy value.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.succeed = succeed;\nconst sync = internal.sync;\n/**\n * Constructs a config for a sequence of values.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.sync = sync;\nconst table = internal.table;\n/**\n * Constructs a config from a tuple / struct / arguments of configs.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.table = table;\nconst all = internal.all;\n/**\n * Constructs a config from some configuration wrapped with the `Wrap<A>` utility type.\n *\n * For example:\n *\n * ```\n * import { Config, unwrap } from \"@effect/io/Config\"\n *\n * interface Options { key: string }\n *\n * const makeConfig = (config: Config.Wrap<Options>): Config<Options> => unwrap(config)\n * ```\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.all = all;\nconst unwrap = internal.unwrap;\n/**\n * Returns a config that describes the same structure as this one, but which\n * performs validation during loading.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.unwrap = unwrap;\nconst validate = internal.validate;\n/**\n * Returns a config that describes the same structure as this one, but has the\n * specified default value in case the information cannot be found.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.validate = validate;\nconst withDefault = internal.withDefault;\n/**\n * Adds a description to this configuration, which is intended for humans.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.withDefault = withDefault;\nconst withDescription = internal.withDescription;\n/**\n * Returns a config that is the composition of this config and the specified\n * config.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.withDescription = withDescription;\nconst zip = internal.zip;\n/**\n * Returns a config that is the composes this config and the specified config\n * using the provided function.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.zip = zip;\nconst zipWith = internal.zipWith;\nexports.zipWith = zipWith;\n//# sourceMappingURL=Config.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.reduceWithContext = exports.prefixed = exports.isUnsupported = exports.isSourceUnavailable = exports.isOr = exports.isMissingDataOnly = exports.isMissingData = exports.isInvalidData = exports.isConfigError = exports.isAnd = exports.Unsupported = exports.SourceUnavailable = exports.Or = exports.MissingData = exports.InvalidData = exports.ConfigErrorTypeId = exports.And = void 0;\nvar internal = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/configError\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/**\n * @since 1.0.0\n * @category symbols\n */\nconst ConfigErrorTypeId = internal.ConfigErrorTypeId;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexports.ConfigErrorTypeId = ConfigErrorTypeId;\nconst And = internal.And;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexports.And = And;\nconst Or = internal.Or;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexports.Or = Or;\nconst MissingData = internal.MissingData;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexports.MissingData = MissingData;\nconst InvalidData = internal.InvalidData;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexports.InvalidData = InvalidData;\nconst SourceUnavailable = internal.SourceUnavailable;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexports.SourceUnavailable = SourceUnavailable;\nconst Unsupported = internal.Unsupported;\n/**\n * Returns `true` if the specified value is a `ConfigError`, `false` otherwise.\n *\n * @since 1.0.0\n * @category refinements\n */\nexports.Unsupported = Unsupported;\nconst isConfigError = internal.isConfigError;\n/**\n * Returns `true` if the specified `ConfigError` is an `And`, `false` otherwise.\n *\n * @since 1.0.0\n * @category refinements\n */\nexports.isConfigError = isConfigError;\nconst isAnd = internal.isAnd;\n/**\n * Returns `true` if the specified `ConfigError` is an `Or`, `false` otherwise.\n *\n * @since 1.0.0\n * @category refinements\n */\nexports.isAnd = isAnd;\nconst isOr = internal.isOr;\n/**\n * Returns `true` if the specified `ConfigError` is an `InvalidData`, `false`\n * otherwise.\n *\n * @since 1.0.0\n * @category refinements\n */\nexports.isOr = isOr;\nconst isInvalidData = internal.isInvalidData;\n/**\n * Returns `true` if the specified `ConfigError` is an `MissingData`, `false`\n * otherwise.\n *\n * @since 1.0.0\n * @category refinements\n */\nexports.isInvalidData = isInvalidData;\nconst isMissingData = internal.isMissingData;\n/**\n * Returns `true` if the specified `ConfigError` contains only `MissingData` errors, `false` otherwise.\n *\n * @since 1.0.0\n * @categer getters\n */\nexports.isMissingData = isMissingData;\nconst isMissingDataOnly = internal.isMissingDataOnly;\n/**\n * Returns `true` if the specified `ConfigError` is a `SourceUnavailable`,\n * `false` otherwise.\n *\n * @since 1.0.0\n * @category refinements\n */\nexports.isMissingDataOnly = isMissingDataOnly;\nconst isSourceUnavailable = internal.isSourceUnavailable;\n/**\n * Returns `true` if the specified `ConfigError` is an `Unsupported`, `false`\n * otherwise.\n *\n * @since 1.0.0\n * @category refinements\n */\nexports.isSourceUnavailable = isSourceUnavailable;\nconst isUnsupported = internal.isUnsupported;\n/**\n * @since 1.0.0\n * @category mutations\n */\nexports.isUnsupported = isUnsupported;\nconst prefixed = internal.prefixed;\n/**\n * @since 1.0.0\n * @category folding\n */\nexports.prefixed = prefixed;\nconst reduceWithContext = internal.reduceWithContext;\nexports.reduceWithContext = reduceWithContext;\n//# sourceMappingURL=Error.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.within = exports.upperCase = exports.unnested = exports.snakeCase = exports.orElse = exports.nested = exports.makeFlat = exports.make = exports.lowerCase = exports.kebabCase = exports.fromMap = exports.fromFlat = exports.fromEnv = exports.contramapPath = exports.constantCase = exports.Tag = exports.FlatConfigProviderTypeId = exports.ConfigProviderTypeId = void 0;\nvar internal = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/configProvider\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/**\n * @since 1.0.0\n * @category symbols\n */\nconst ConfigProviderTypeId = internal.ConfigProviderTypeId;\n/**\n * @since 1.0.0\n * @category symbols\n */\nexports.ConfigProviderTypeId = ConfigProviderTypeId;\nconst FlatConfigProviderTypeId = internal.FlatConfigProviderTypeId;\n/**\n * The service tag for `ConfigProvider`.\n *\n * @since 1.0.0\n * @category context\n */\nexports.FlatConfigProviderTypeId = FlatConfigProviderTypeId;\nconst Tag = internal.configProviderTag;\n/**\n * Creates a new config provider.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.Tag = Tag;\nconst make = internal.make;\n/**\n * Creates a new flat config provider.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.make = make;\nconst makeFlat = internal.makeFlat;\n/**\n * A config provider that loads configuration from context variables,\n * using the default System service.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.makeFlat = makeFlat;\nconst fromEnv = internal.fromEnv;\n/**\n * Constructs a new `ConfigProvider` from a key/value (flat) provider, where\n * nesting is embedded into the string keys.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.fromEnv = fromEnv;\nconst fromFlat = internal.fromFlat;\n/**\n * Constructs a ConfigProvider using a map and the specified delimiter string,\n * which determines how to split the keys in the map into path segments.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.fromFlat = fromFlat;\nconst fromMap = internal.fromMap;\n/**\n * Returns a new config provider that will automatically convert all property\n * names to constant case. This can be utilized to adapt the names of\n * configuration properties from the default naming convention of camel case\n * to the naming convention of a config provider.\n *\n * @since 1.0.0\n * @category combinators\n */\nexports.fromMap = fromMap;\nconst constantCase = internal.constantCase;\n/**\n * Returns a new config provider that will automatically tranform all path\n * configuration names with the specified function. This can be utilized to\n * adapt the names of configuration properties from one naming convention to\n * another.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.constantCase = constantCase;\nconst contramapPath = internal.contramapPath;\n/**\n * Returns a new config provider that will automatically convert all property\n * names to kebab case. This can be utilized to adapt the names of\n * configuration properties from the default naming convention of camel case\n * to the naming convention of a config provider.\n *\n * @since 1.0.0\n * @category combinators\n */\nexports.contramapPath = contramapPath;\nconst kebabCase = internal.kebabCase;\n/**\n * Returns a new config provider that will automatically convert all property\n * names to lower case. This can be utilized to adapt the names of\n * configuration properties from the default naming convention of camel case\n * to the naming convention of a config provider.\n *\n * @since 1.0.0\n * @category combinators\n */\nexports.kebabCase = kebabCase;\nconst lowerCase = internal.lowerCase;\n/**\n * Returns a new config provider that will automatically nest all\n * configuration under the specified property name. This can be utilized to\n * aggregate separate configuration sources that are all required to load a\n * single configuration value.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.lowerCase = lowerCase;\nconst nested = internal.nested;\n/**\n * Returns a new config provider that preferentially loads configuration data\n * from this one, but which will fall back to the specified alternate provider\n * if there are any issues loading the configuration from this provider.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.nested = nested;\nconst orElse = internal.orElse;\n/**\n * Returns a new config provider that will automatically un-nest all\n * configuration under the specified property name. This can be utilized to\n * de-aggregate separate configuration sources that are all required to load a\n * single configuration value.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.orElse = orElse;\nconst unnested = internal.unnested;\n/**\n * Returns a new config provider that will automatically convert all property\n * names to upper case. This can be utilized to adapt the names of\n * configuration properties from the default naming convention of camel case\n * to the naming convention of a config provider.\n *\n * @since 1.0.0\n * @category combinators\n */\nexports.unnested = unnested;\nconst snakeCase = internal.snakeCase;\n/**\n * Returns a new config provider that will automatically convert all property\n * names to upper case. This can be utilized to adapt the names of\n * configuration properties from the default naming convention of camel case\n * to the naming convention of a config provider.\n *\n * @since 1.0.0\n * @category combinators\n */\nexports.snakeCase = snakeCase;\nconst upperCase = internal.upperCase;\n/**\n * Returns a new config provider that transforms the config provider with the\n * specified function within the specified path.\n *\n * @since 1.0.0\n * @category combinators\n */\nexports.upperCase = upperCase;\nconst within = internal.within;\nexports.within = within;\n//# sourceMappingURL=Provider.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.value = exports.unsafeWipe = exports.make = exports.isConfigSecret = exports.fromString = exports.fromChunk = exports.ConfigSecretTypeId = void 0;\nvar internal = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/configSecret\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/**\n * @since 1.0.0\n * @category symbols\n */\nconst ConfigSecretTypeId = internal.ConfigSecretTypeId;\n/**\n * @since 1.0.0\n * @category refinements\n */\nexports.ConfigSecretTypeId = ConfigSecretTypeId;\nconst isConfigSecret = internal.isConfigSecret;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexports.isConfigSecret = isConfigSecret;\nconst make = internal.make;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexports.make = make;\nconst fromChunk = internal.fromChunk;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexports.fromChunk = fromChunk;\nconst fromString = internal.fromString;\n/**\n * @since 1.0.0\n * @category getters\n */\nexports.fromString = fromString;\nconst value = internal.value;\n/**\n * @since 1.0.0\n * @category unsafe\n */\nexports.value = value;\nconst unsafeWipe = internal.unsafeWipe;\nexports.unsafeWipe = unsafeWipe;\n//# sourceMappingURL=Secret.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.untracedMethod = exports.untracedDual = exports.untraced = exports.traced = exports.sourceLocation = exports.runtimeDebug = exports.pipeableWithTrace = exports.methodWithTrace = exports.dualWithTrace = exports.bodyWithTrace = void 0;\nvar debug = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/debug\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/**\n * @since 1.0.0\n */\n\n/**\n * @since 1.0.0\n * @category debug\n */\nconst runtimeDebug = debug.runtimeDebug;\nexports.runtimeDebug = runtimeDebug;\nconst sourceLocationProto = /*#__PURE__*/Object.setPrototypeOf({\n  toFrame() {\n    if (\"parsed\" in this) {\n      return this.parsed;\n    }\n    const stack = runtimeDebug.parseStack(this);\n    if (stack && stack.length >= 2 && stack[0] && stack[1]) {\n      this.parsed = {\n        ...stack[this.depth - 1],\n        name: stack[this.depth - 2]?.name\n      };\n    } else {\n      this.parsed = undefined;\n    }\n    return this.parsed;\n  }\n}, Error.prototype);\n/**\n * @since 1.0.0\n */\nconst sourceLocation = error => {\n  ;\n  error.depth = Error.stackTraceLimit;\n  Object.setPrototypeOf(error, sourceLocationProto);\n  return error;\n};\n/**\n * @since 1.0.0\n */\nexports.sourceLocation = sourceLocation;\nconst bodyWithTrace = body => {\n  if (!runtimeDebug.tracingEnabled) {\n    return body(void 0, debug.restoreOff);\n  }\n  runtimeDebug.tracingEnabled = false;\n  try {\n    const limit = Error.stackTraceLimit;\n    Error.stackTraceLimit = 3;\n    const source = sourceLocation(new Error());\n    Error.stackTraceLimit = limit;\n    return body(source, debug.restoreOn);\n  } finally {\n    runtimeDebug.tracingEnabled = true;\n  }\n};\n/**\n * @since 1.0.0\n */\nexports.bodyWithTrace = bodyWithTrace;\nconst methodWithTrace = body => {\n  // @ts-expect-error\n  return function () {\n    if (!runtimeDebug.tracingEnabled) {\n      // @ts-expect-error\n      return body(void 0, debug.restoreOff).apply(this, arguments);\n    }\n    runtimeDebug.tracingEnabled = false;\n    try {\n      const limit = Error.stackTraceLimit;\n      Error.stackTraceLimit = 2;\n      const error = sourceLocation(new Error());\n      Error.stackTraceLimit = limit;\n      // @ts-expect-error\n      return body(error, debug.restoreOn).apply(this, arguments);\n    } finally {\n      runtimeDebug.tracingEnabled = true;\n    }\n  };\n};\n/**\n * @since 1.0.0\n */\nexports.methodWithTrace = methodWithTrace;\nconst pipeableWithTrace = body => {\n  // @ts-expect-error\n  return function () {\n    if (!runtimeDebug.tracingEnabled) {\n      const a = body(void 0, debug.restoreOff);\n      // @ts-expect-error\n      return self => untraced(() => a.apply(this, arguments)(self));\n    }\n    runtimeDebug.tracingEnabled = false;\n    try {\n      const limit = Error.stackTraceLimit;\n      Error.stackTraceLimit = 2;\n      const source = sourceLocation(new Error());\n      Error.stackTraceLimit = limit;\n      const f = body(source, debug.restoreOn);\n      // @ts-expect-error\n      return self => untraced(() => f.apply(this, arguments)(self));\n    } finally {\n      runtimeDebug.tracingEnabled = true;\n    }\n  };\n};\n/**\n * @since 1.0.0\n */\nexports.pipeableWithTrace = pipeableWithTrace;\nconst dualWithTrace = (dfLen, body) => {\n  const isDataFirst = typeof dfLen === \"number\" ? args => args.length === dfLen : dfLen;\n  return function () {\n    if (!runtimeDebug.tracingEnabled) {\n      const f = body(void 0, debug.restoreOff);\n      if (isDataFirst(arguments)) {\n        // @ts-expect-error\n        return untraced(() => f.apply(this, arguments));\n      }\n      return self => untraced(() => f(self, ...arguments));\n    }\n    runtimeDebug.tracingEnabled = false;\n    try {\n      const limit = Error.stackTraceLimit;\n      Error.stackTraceLimit = 2;\n      const source = sourceLocation(new Error());\n      Error.stackTraceLimit = limit;\n      const f = body(source, debug.restoreOn);\n      if (isDataFirst(arguments)) {\n        // @ts-expect-error\n        return untraced(() => f.apply(this, arguments));\n      }\n      return self => untraced(() => f(self, ...arguments));\n    } finally {\n      runtimeDebug.tracingEnabled = true;\n    }\n  };\n};\n/**\n * @since 1.0.0\n */\nexports.dualWithTrace = dualWithTrace;\nconst untraced = body => {\n  if (!runtimeDebug.tracingEnabled) {\n    return body(debug.restoreOff);\n  }\n  runtimeDebug.tracingEnabled = false;\n  try {\n    return body(debug.restoreOn);\n  } finally {\n    runtimeDebug.tracingEnabled = true;\n  }\n};\n/**\n * @since 1.0.0\n */\nexports.untraced = untraced;\nconst untracedDual = (dfLen, body) => {\n  // @ts-expect-error\n  return function () {\n    if (!runtimeDebug.tracingEnabled) {\n      const f = body(debug.restoreOff);\n      if (arguments.length === dfLen) {\n        // @ts-expect-error\n        return untraced(() => f.apply(this, arguments));\n      }\n      return self => untraced(() => f(self, ...arguments));\n    }\n    runtimeDebug.tracingEnabled = false;\n    try {\n      const f = body(debug.restoreOn);\n      if (arguments.length === dfLen) {\n        // @ts-expect-error\n        return untraced(() => f.apply(this, arguments));\n      }\n      return self => untraced(() => f(self, ...arguments));\n    } finally {\n      runtimeDebug.tracingEnabled = true;\n    }\n  };\n};\n/**\n * @since 1.0.0\n */\nexports.untracedDual = untracedDual;\nconst untracedMethod = body => {\n  // @ts-expect-error\n  return function () {\n    if (!runtimeDebug.tracingEnabled) {\n      // @ts-expect-error\n      return untraced(() => body(debug.restoreOff).apply(this, arguments));\n    }\n    runtimeDebug.tracingEnabled = false;\n    try {\n      // @ts-expect-error\n      return untraced(() => body(debug.restoreOn).apply(this, arguments));\n    } finally {\n      runtimeDebug.tracingEnabled = true;\n    }\n  };\n};\n/**\n * @since 1.0.0\n */\nexports.untracedMethod = untracedMethod;\nconst traced = body => {\n  if (runtimeDebug.tracingEnabled) {\n    return body(debug.restoreOn);\n  }\n  runtimeDebug.tracingEnabled = true;\n  try {\n    return body(debug.restoreOff);\n  } finally {\n    runtimeDebug.tracingEnabled = false;\n  }\n};\nexports.traced = traced;\n//# sourceMappingURL=Debug.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.unsafeMake = exports.unsafeDone = exports.sync = exports.succeed = exports.poll = exports.makeAs = exports.make = exports.isDone = exports.interruptWith = exports.interrupt = exports.failSync = exports.failCauseSync = exports.failCause = exports.fail = exports.done = exports.dieSync = exports.die = exports.completeWith = exports.complete = exports.await = exports.DeferredTypeId = void 0;\nvar core = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/core\"));\nvar internal = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/deferred\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/**\n * @since 1.0.0\n * @category symbols\n */\nconst DeferredTypeId = internal.DeferredTypeId;\n/**\n * Creates a new `Deferred`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.DeferredTypeId = DeferredTypeId;\nconst make = core.deferredMake;\n/**\n * Creates a new `Deferred` from the specified `FiberId`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.make = make;\nconst makeAs = core.deferredMakeAs;\nexports.makeAs = makeAs;\nconst _await = core.deferredAwait;\nexports.await = _await;\n/**\n * Completes the deferred with the result of the specified effect. If the\n * deferred has already been completed, the method will produce false.\n *\n * Note that `Deferred.completeWith` will be much faster, so consider using\n * that if you do not need to memoize the result of the specified effect.\n *\n * @since 1.0.0\n * @category mutations\n */\nconst complete = core.deferredComplete;\n/**\n * Completes the deferred with the result of the specified effect. If the\n * deferred has already been completed, the method will produce false.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.complete = complete;\nconst completeWith = core.deferredCompleteWith;\n/**\n * Exits the `Deferred` with the specified `Exit` value, which will be\n * propagated to all fibers waiting on the value of the `Deferred`.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.completeWith = completeWith;\nconst done = core.deferredDone;\n/**\n * Fails the `Deferred` with the specified error, which will be propagated to\n * all fibers waiting on the value of the `Deferred`.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.done = done;\nconst fail = core.deferredFail;\n/**\n * Fails the `Deferred` with the specified error, which will be propagated to\n * all fibers waiting on the value of the `Deferred`.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.fail = fail;\nconst failSync = core.deferredFailSync;\n/**\n * Fails the `Deferred` with the specified `Cause`, which will be propagated to\n * all fibers waiting on the value of the `Deferred`.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.failSync = failSync;\nconst failCause = core.deferredFailCause;\n/**\n * Fails the `Deferred` with the specified `Cause`, which will be propagated to\n * all fibers waiting on the value of the `Deferred`.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.failCause = failCause;\nconst failCauseSync = core.deferredFailCauseSync;\n/**\n * Kills the `Deferred` with the specified defect, which will be propagated to\n * all fibers waiting on the value of the `Deferred`.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.failCauseSync = failCauseSync;\nconst die = core.deferredDie;\n/**\n * Kills the `Deferred` with the specified defect, which will be propagated to\n * all fibers waiting on the value of the `Deferred`.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.die = die;\nconst dieSync = core.deferredDieSync;\n/**\n * Completes the `Deferred` with interruption. This will interrupt all fibers\n * waiting on the value of the `Deferred` with the `FiberId` of the fiber\n * calling this method.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.dieSync = dieSync;\nconst interrupt = core.deferredInterrupt;\n/**\n * Completes the `Deferred` with interruption. This will interrupt all fibers\n * waiting on the value of the `Deferred` with the specified `FiberId`.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.interrupt = interrupt;\nconst interruptWith = core.deferredInterruptWith;\n/**\n * Returns `true` if this `Deferred` has already been completed with a value or\n * an error, `false` otherwise.\n *\n * @since 1.0.0\n * @category getters\n */\nexports.interruptWith = interruptWith;\nconst isDone = core.deferredIsDone;\n/**\n * Returns a `Some<Effect<R, E, A>>` from the `Deferred` if this `Deferred` has\n * already been completed, `None` otherwise.\n *\n * @since 1.0.0\n * @category getters\n */\nexports.isDone = isDone;\nconst poll = core.deferredPoll;\n/**\n * Completes the `Deferred` with the specified value.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.poll = poll;\nconst succeed = core.deferredSucceed;\n/**\n * Completes the `Deferred` with the specified lazily evaluated value.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.succeed = succeed;\nconst sync = core.deferredSync;\n/**\n * Unsafely creates a new `Deferred` from the specified `FiberId`.\n *\n * @since 1.0.0\n * @category unsafe\n */\nexports.sync = sync;\nconst unsafeMake = core.deferredUnsafeMake;\n/**\n * Unsafely exits the `Deferred` with the specified `Exit` value, which will be\n * propagated to all fibers waiting on the value of the `Deferred`.\n *\n * @since 1.0.0\n * @category unsafe\n */\nexports.unsafeMake = unsafeMake;\nconst unsafeDone = core.deferredUnsafeDone;\nexports.unsafeDone = unsafeDone;\n//# sourceMappingURL=Deferred.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.fiberIdWith = exports.fiberId = exports.failSync = exports.failCauseSync = exports.failCause = exports.fail = exports.exit = exports.existsPar = exports.exists = exports.eventually = exports.ensuringChildren = exports.ensuringChild = exports.ensuring = exports.either = exports.dropWhile = exports.dropUntil = exports.done = exports.disconnect = exports.diffFiberRefs = exports.dieSync = exports.dieMessage = exports.die = exports.descriptorWith = exports.descriptor = exports.delay = exports.daemonChildren = exports.contramapContext = exports.continueOrFailEffect = exports.continueOrFail = exports.contextWithEffect = exports.contextWith = exports.context = exports.configProviderWith = exports.config = exports.cond = exports.collectWhile = exports.collectPar = exports.collectFirst = exports.collectAllWithPar = exports.collectAllWithEffect = exports.collectAllWith = exports.collectAllSuccessesPar = exports.collectAllSuccesses = exports.collectAllParDiscard = exports.collectAllPar = exports.collectAllDiscard = exports.collectAll = exports.collect = exports.clockWith = exports.clock = exports.checkInterruptible = exports.cause = exports.catchTags = exports.catchTag = exports.catchSomeDefect = exports.catchSomeCause = exports.catchSome = exports.catchAllDefect = exports.catchAllCause = exports.catchAll = exports.catch = exports.cachedInvalidate = exports.cached = exports.bindValue = exports.bind = exports.awaitAllChildren = exports.attemptSuspend = exports.attemptPromiseInterrupt = exports.attemptPromise = exports.attemptOrElse = exports.attemptCatchPromiseInterrupt = exports.attemptCatchPromise = exports.attemptCatch = exports.attempt = exports.asyncOption = exports.asyncInterruptEither = exports.asyncInterrupt = exports.asyncEffect = exports.async = exports.asUnit = exports.asSomeError = exports.asSome = exports.asRightError = exports.asRight = exports.asLeftError = exports.asLeft = exports.as = exports.allowInterrupt = exports.allPar = exports.all = exports.addFinalizer = exports.acquireUseRelease = exports.acquireReleaseInterruptible = exports.acquireRelease = exports.absorbWith = exports.absorb = exports.absolveWith = exports.absolve = exports.EffectTypeId = exports.Do = void 0;\nexports.mergeAllPar = exports.mergeAll = exports.merge = exports.memoizeFunction = exports.memoize = exports.matchEffect = exports.matchCauseEffect = exports.matchCause = exports.match = exports.mapTryCatch = exports.mapErrorCause = exports.mapError = exports.mapBoth = exports.mapAccum = exports.map = exports.makeSemaphore = exports.loopDiscard = exports.loop = exports.logWarningCauseMessage = exports.logWarningCause = exports.logWarning = exports.logTraceCauseMessage = exports.logTraceCause = exports.logTrace = exports.logSpan = exports.logInfoCauseMessage = exports.logInfoCause = exports.logInfo = exports.logFatalCauseMessage = exports.logFatalCause = exports.logFatal = exports.logErrorCauseMessage = exports.logErrorCause = exports.logError = exports.logDebugCauseMessage = exports.logDebugCause = exports.logDebug = exports.logAnnotations = exports.logAnnotate = exports.log = exports.leftWith = exports.left = exports.iterate = exports.isSuccess = exports.isFailure = exports.isEffect = exports.intoDeferred = exports.interruptibleMask = exports.interruptible = exports.interruptWith = exports.interrupt = exports.inheritFiberRefs = exports.ignoreLogged = exports.ignore = exports.ifEffect = exports.head = exports.getOrFailWith = exports.getOrFailDiscard = exports.getOrFail = exports.getFiberRefs = exports.gen = exports.fromOption = exports.fromFiberEffect = exports.fromFiber = exports.fromEitherCause = exports.fromEither = exports.forkWithErrorHandler = exports.forkScoped = exports.forkIn = exports.forkDaemon = exports.forkAllDiscard = exports.forkAll = exports.fork = exports.forever = exports.forEachWithIndex = exports.forEachParWithIndex = exports.forEachParDiscard = exports.forEachPar = exports.forEachOption = exports.forEachExec = exports.forEachEffect = exports.forEachDiscard = exports.forEach = exports.forAll = exports.flipWith = exports.flip = exports.flattenErrorOption = exports.flatten = exports.flatMap = exports.firstSuccessOf = exports.find = exports.filterPar = exports.filterOrFail = exports.filterOrElseWith = exports.filterOrElse = exports.filterOrDieMessage = exports.filterOrDie = exports.filterNotPar = exports.filterNot = exports.filter = void 0;\nexports.setConfigProvider = exports.serviceWithEffect = exports.serviceWith = exports.service = exports.sequentialFinalizers = exports.scoped = exports.scopeWith = exports.scope = exports.scheduleFrom = exports.scheduleForked = exports.schedule = exports.sandbox = exports.runtimeFlags = exports.runtime = exports.runSyncExitOrFiber = exports.runSyncExit = exports.runSyncEither = exports.runSync = exports.runPromiseExit = exports.runPromiseEither = exports.runPromise = exports.runFork = exports.runCallback = exports.rightWith = exports.right = exports.retryWhileEquals = exports.retryWhileEffect = exports.retryWhile = exports.retryUntilEquals = exports.retryUntilEffect = exports.retryUntil = exports.retryOrElseEither = exports.retryOrElse = exports.retryN = exports.retry = exports.resurrect = exports.replicateEffectDiscard = exports.replicateEffect = exports.replicate = exports.repeatWhileEquals = exports.repeatWhileEffect = exports.repeatWhile = exports.repeatUntilEquals = exports.repeatUntilEffect = exports.repeatUntil = exports.repeatOrElseEither = exports.repeatOrElse = exports.repeatN = exports.repeat = exports.rejectEffect = exports.reject = exports.refineTagOrDieWith = exports.refineTagOrDie = exports.refineOrDieWith = exports.refineOrDie = exports.reduceWhile = exports.reduceRight = exports.reduceAllPar = exports.reduceAll = exports.reduce = exports.randomWith = exports.random = exports.raceWith = exports.raceFirst = exports.raceFibersWith = exports.raceEither = exports.raceAwait = exports.raceAll = exports.race = exports.provideSomeLayer = exports.provideServiceEffect = exports.provideService = exports.provideLayer = exports.provideContext = exports.promiseInterrupt = exports.promise = exports.patchFiberRefs = exports.partitionPar = exports.partition = exports.parallelFinalizers = exports.parallelErrors = exports.orElseSucceed = exports.orElseOptional = exports.orElseFail = exports.orElseEither = exports.orElse = exports.orDieWith = exports.orDie = exports.option = exports.once = exports.onInterrupt = exports.onExit = exports.onError = exports.onDoneCause = exports.onDone = exports.noneOrFailWith = exports.noneOrFail = exports.none = exports.never = exports.negate = void 0;\nexports.zipWithPar = exports.zipWith = exports.zipRight = exports.zipParRight = exports.zipParLeft = exports.zipPar = exports.zipLeft = exports.zip = exports.yieldNow = exports.withRuntimeFlagsScoped = exports.withRuntimeFlags = exports.withParallelismUnbounded = exports.withParallelism = exports.withMetric = exports.withEarlyRelease = exports.withConfigProviderScoped = exports.withConfigProvider = exports.withClockScoped = exports.withClock = exports.whileLoop = exports.whenRef = exports.whenFiberRef = exports.whenEffect = exports.whenCaseEffect = exports.whenCase = exports.when = exports.validateWithPar = exports.validateWith = exports.validatePar = exports.validateFirstPar = exports.validateFirst = exports.validateAllParDiscard = exports.validateAllPar = exports.validateAllDiscard = exports.validateAll = exports.validate = exports.using = exports.updateService = exports.updateRuntimeFlags = exports.updateFiberRefs = exports.unsome = exports.unsandbox = exports.unsafeMakeSemaphore = exports.unright = exports.unrefineWith = exports.unrefine = exports.unlessEffect = exports.unless = exports.unleft = exports.unit = exports.uninterruptibleMask = exports.uninterruptible = exports.unified = exports.unfold = exports.uncause = exports.transplant = exports.toLayerScopedDiscard = exports.toLayerScoped = exports.toLayerDiscard = exports.toLayerContext = exports.toLayer = exports.timeoutTo = exports.timeoutFailCause = exports.timeoutFail = exports.timeout = exports.timedWith = exports.timed = exports.tapSome = exports.tapErrorCause = exports.tapError = exports.tapEither = exports.tapDefect = exports.tapBoth = exports.tap = exports.takeWhile = exports.tags = exports.taggedWithLabels = exports.taggedWithLabelSet = exports.taggedScopedWithLabels = exports.taggedScopedWithLabelSet = exports.taggedScoped = exports.tagged = exports.sync = exports.suspend = exports.supervised = exports.summarized = exports.succeedSome = exports.succeedRight = exports.succeedNone = exports.succeedLeft = exports.succeed = exports.someWith = exports.someOrFailException = exports.someOrFail = exports.someOrElseEffect = exports.someOrElse = exports.some = exports.sleep = exports.setFiberRefs = void 0;\nvar core = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/core\"));\nvar defaultServices = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/defaultServices\"));\nvar effect = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/effect\"));\nvar circular = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/effect/circular\"));\nvar fiberRuntime = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/fiberRuntime\"));\nvar layer = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/layer\"));\nvar circularLayer = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/layer/circular\"));\nvar _runtime = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/runtime\"));\nvar _schedule = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/schedule\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/**\n * @since 1.0.0\n * @category symbols\n */\nconst EffectTypeId = core.EffectTypeId;\n/**\n * This function returns `true` if the specified value is an `Effect` value,\n * `false` otherwise.\n *\n * This function can be useful for checking the type of a value before\n * attempting to operate on it as an `Effect` value. For example, you could\n * use `isEffect` to check the type of a value before using it as an\n * argument to a function that expects an `Effect` value.\n *\n * @param u - The value to check for being an `Effect` value.\n *\n * @returns `true` if the specified value is an `Effect` value, `false`\n * otherwise.\n *\n * @since 1.0.0\n * @category refinements\n */\nexports.EffectTypeId = EffectTypeId;\nconst isEffect = core.isEffect;\n/**\n * This function adds a finalizer to the scope of the calling `Effect` value.\n * The finalizer is guaranteed to be run when the scope is closed, and it may\n * depend on the `Exit` value that the scope is closed with.\n *\n * @param finalizer - The finalizer to add to the scope of the calling\n * `Effect` value. This function must take an `Exit` value as its parameter,\n * and return a new `Effect` value.\n *\n * @returns A new `Effect` value that represents the addition of the finalizer\n * to the scope of the calling `Effect` value.\n *\n * @since 1.0.0\n * @category finalization\n */\nexports.isEffect = isEffect;\nconst addFinalizer = fiberRuntime.addFinalizer;\n/**\n * This function submerges the error case of an `Either` value into an\n * `Effect` value. It is the inverse operation of `either`.\n *\n * If the `Either` value is a `Right` value, then the `Effect` value will\n * succeed with the value contained in the `Right`. If the `Either` value\n * is a `Left` value, then the `Effect` value will fail with the error\n * contained in the `Left`.\n *\n * @param self - The `Effect` value that contains an `Either` value as its\n * result.\n *\n * @returns A new `Effect` value that has the same context as the original\n * `Effect` value, but has the error case of the `Either` value submerged\n * into it.\n *\n * @since 1.0.0\n * @category error handling\n */\nexports.addFinalizer = addFinalizer;\nconst absolve = effect.absolve;\n/**\n * This function takes a mapping function f that maps over `Effect` value\n * and returns `Either` and returns a new function that submerges the error\n * case of an `Either` value into an `Effect` value.\n * It is the inverse operation of `either`.\n *\n * If the `Either` value is a `Right` value, then the `Effect` value will\n * succeed with the value contained in the `Right`. If the `Either` value\n * is a `Left` value, then the `Effect` value will fail with the error\n * contained in the `Left`.\n *\n * @param self - The `Effect` value that contains an `Either` value as its\n * result.\n *\n * @returns A new `Effect` value that has the same context as the original\n * `Effect` value, but has the error case of the `Either` value submerged\n * into it.\n *\n * @since 1.0.0\n * @category error handling\n */\nexports.absolve = absolve;\nconst absolveWith = effect.absolveWith;\n/**\n * This function transforms an `Effect` value that may fail with a defect\n * into a new `Effect` value that may fail with an unknown error.\n *\n * The resulting `Effect` value will have the same context and success\n * type as the original `Effect` value, but it will have a more general\n * error type that allows it to fail with any type of error.\n *\n * @param self - The `Effect` value to transform.\n *\n * @returns A new `Effect` value that has the same context and success\n * type as the original `Effect` value, but a more general error type that\n * allows it to fail with any type of error.\n *\n * @since 1.0.0\n * @category error handling\n */\nexports.absolveWith = absolveWith;\nconst absorb = effect.absorb;\n/**\n * This function takes a mapping function `f` and returns a new function\n * that transforms an `Effect` value that may fail with a defect into a new\n * `Effect` value that may fail with an unknown error.\n *\n * If the original `Effect` value fails with a known error, then the\n * mapping function `f` will be applied to the error to convert it to an\n * unknown structure.\n *\n * The resulting `Effect` value will have the same context and success\n * type as the original `Effect` value, but it will have a more general\n * error type that allows it to fail with any type of error.\n *\n * @param f - The mapping function to apply to known errors. This function\n * must take an error of type `E` and return an unknown structure.\n *\n * @returns A new function that transforms an `Effect` value that may fail\n * with a defect into a new `Effect` value that may fail with an unknown\n * error.\n *\n * @since 1.0.0\n * @category error handling\n */\nexports.absorb = absorb;\nconst absorbWith = effect.absorbWith;\n/**\n * This function constructs a scoped resource from an `acquire` and `release`\n * `Effect` value.\n *\n * If the `acquire` `Effect` value successfully completes execution, then the\n * `release` `Effect` value will be added to the finalizers associated with the\n * scope of this `Effect` value, and it is guaranteed to be run when the scope\n * is closed.\n *\n * The `acquire` and `release` `Effect` values will be run uninterruptibly.\n * Additionally, the `release` `Effect` value may depend on the `Exit` value\n * specified when the scope is closed.\n *\n * @param acquire - The `Effect` value that acquires the resource.\n * @param release - The `Effect` value that releases the resource.\n *\n * @returns A new `Effect` value that represents the scoped resource.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.absorbWith = absorbWith;\nconst acquireRelease = fiberRuntime.acquireRelease;\n/**\n * This function is a variant of `acquireRelease` that allows the `acquire`\n * `Effect` value to be interruptible.\n *\n * Since the `acquire` `Effect` value could be interrupted after partially\n * acquiring resources, the `release` `Effect` value is not allowed to access\n * the resource produced by `acquire` and must independently determine what\n * finalization, if any, needs to be performed (e.g. by examining in memory\n * state).\n *\n * Additionally, the `release` `Effect` value may depend on the `Exit` value\n * specified when the scope is closed.\n *\n * @param acquire - The interruptible `Effect` value that acquires the\n * resource.\n * @param release - The `Effect` value that releases the resource. This function\n * must take an `Exit` value as its parameter, and return a new `Effect` value.\n *\n * @returns A new `Effect` value that represents the interruptible scoped\n * resource.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.acquireRelease = acquireRelease;\nconst acquireReleaseInterruptible = circular.acquireReleaseInterruptible;\n/**\n * This function is used to ensure that an `Effect` value that represents the\n * acquisition of a resource (for example, opening a file, launching a thread,\n * etc.) will not be interrupted, and that the resource will always be released\n * when the `Effect` value completes execution.\n *\n * `acquireUseRelease` does the following:\n *\n *   1. Ensures that the `Effect` value that acquires the resource will not be\n *      interrupted. Note that acquisition may still fail due to internal\n *      reasons (such as an uncaught exception).\n *   2. Ensures that the `release` `Effect` value will not be interrupted,\n *      and will be executed as long as the acquisition `Effect` value\n *      successfully acquires the resource.\n *\n * During the time period between the acquisition and release of the resource,\n * the `use` `Effect` value will be executed.\n *\n * If the `release` `Effect` value fails, then the entire `Effect` value will\n * fail, even if the `use` `Effect` value succeeds. If this fail-fast behavior\n * is not desired, errors produced by the `release` `Effect` value can be caught\n * and ignored.\n *\n * @param acquire - The `Effect` value that acquires the resource.\n * @param use - The `Effect` value that is executed between the acquisition\n * and release of the resource.\n * @param release - The `Effect` value that releases the resource.\n *\n * @returns A new `Effect` value that represents the acquisition, use, and\n * release of the resource.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.acquireReleaseInterruptible = acquireReleaseInterruptible;\nconst acquireUseRelease = core.acquireUseRelease;\n/**\n * This function checks if any fibers are attempting to interrupt the current\n * fiber, and if so, performs self-interruption.\n *\n * Note that this allows for interruption to occur in uninterruptible regions.\n *\n * @returns A new `Effect` value that represents the check for interruption\n * and the potential self-interruption of the current fiber.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.acquireUseRelease = acquireUseRelease;\nconst allowInterrupt = effect.allowInterrupt;\n/**\n * This function maps the success value of an `Effect` value to a specified\n * constant value.\n *\n * @param value - The constant value that the success value of the `Effect`\n * value will be mapped to.\n * @param self - The `Effect` value whose success value will be mapped to the\n * specified constant value.\n *\n * @returns A new `Effect` value that represents the mapping of the success\n * value of the original `Effect` value to the specified constant value.\n *\n * @since 1.0.0\n * @category mapping\n */\nexports.allowInterrupt = allowInterrupt;\nconst as = core.as;\n/**\n * This function maps the success value of an `Effect` value to a `Left` value\n * in an `Either` value.\n *\n * @param self - The `Effect` value whose success value will be mapped to a\n * `Left` value in an `Either` value.\n *\n * @returns A new `Effect` value that represents the mapping of the success\n * value of the original `Effect` value to a `Left` value in an `Either`\n * value.\n *\n * @since 1.0.0\n * @category mapping\n */\nexports.as = as;\nconst asLeft = effect.asLeft;\n/**\n * This function maps the error value of an `Effect` value to a `Left` value\n * in an `Either` value.\n *\n * @param self - The `Effect` value whose error value will be mapped to a\n * `Left` value in an `Either` value.\n *\n * @returns A new `Effect` value that represents the mapping of the error\n * value of the original `Effect` value to a `Left` value in an `Either`\n * value.\n *\n * @since 1.0.0\n * @category mapping\n */\nexports.asLeft = asLeft;\nconst asLeftError = effect.asLeftError;\n/**\n * This function maps the success value of an `Effect` value to a `Right` value\n * in an `Either` value.\n *\n * @param self - The `Effect` value whose success value will be mapped to a\n * `Right` value in an `Either` value.\n *\n * @returns A new `Effect` value that represents the mapping of the success\n * value of the original `Effect` value to a `Right` value in an `Either`\n * value.\n *\n * @since 1.0.0\n * @category mapping\n */\nexports.asLeftError = asLeftError;\nconst asRight = effect.asRight;\n/**\n * This function maps the error value of an `Effect` value to a `Right` value\n * in an `Either` value.\n *\n * @param self - The `Effect` value whose error value will be mapped to a\n * `Right` value in an `Either` value.\n *\n * @returns A new `Effect` value that represents the mapping of the error\n * value of the original `Effect` value to a `Right` value in an `Either`\n * value.\n *\n * @since 1.0.0\n * @category mapping\n */\nexports.asRight = asRight;\nconst asRightError = effect.asRightError;\n/**\n * This function maps the success value of an `Effect` value to a `Some` value\n * in an `Option` value. If the original `Effect` value fails, the returned\n * `Effect` value will also fail.\n *\n * @param self - The `Effect` value whose success value will be mapped to a\n * `Some` value in an `Option` value.\n *\n * @returns A new `Effect` value that represents the mapping of the success\n * value of the original `Effect` value to a `Some` value in an `Option`\n * value. The returned `Effect` value may fail if the original `Effect` value\n * fails.\n *\n * @category mapping\n * @since 1.0.0\n */\nexports.asRightError = asRightError;\nconst asSome = effect.asSome;\n/**\n * This function maps the error value of an `Effect` value to a `Some` value\n * in an `Option` value. If the original `Effect` value succeeds, the returned\n * `Effect` value will also succeed.\n *\n * @param self - The `Effect` value whose error value will be mapped to a\n * `Some` value in an `Option` value.\n *\n * @returns A new `Effect` value that represents the mapping of the error\n * value of the original `Effect` value to a `Some` value in an `Option`\n * value. The returned `Effect` value may succeed if the original `Effect`\n * value succeeds.\n *\n * @category mapping\n * @since 1.0.0\n */\nexports.asSome = asSome;\nconst asSomeError = effect.asSomeError;\n/**\n * This function maps the success value of an `Effect` value to `void`. If the\n * original `Effect` value succeeds, the returned `Effect` value will also\n * succeed. If the original `Effect` value fails, the returned `Effect` value\n * will fail with the same error.\n *\n * @param self - The `Effect` value whose success value will be mapped to `void`.\n *\n * @returns A new `Effect` value that represents the mapping of the success\n * value of the original `Effect` value to `void`.\n *\n * @since 1.0.0\n * @category mapping\n */\nexports.asSomeError = asSomeError;\nconst asUnit = core.asUnit;\n/**\n * Imports an asynchronous side-effect into a pure `Effect` value. See\n * `asyncMaybe` for the more expressive variant of this function that can\n * return a value synchronously.\n *\n * The callback function `Effect<R, E, A> => void` must be called at most once.\n *\n * The `FiberId` of the fiber that may complete the async callback may be\n * provided to allow for better diagnostics.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.asUnit = asUnit;\nconst async = core.async;\n/**\n * Converts an asynchronous, callback-style API into an `Effect`, which will\n * be executed asynchronously.\n *\n * With this variant, the registration function may return a an `Effect`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.async = async;\nconst asyncEffect = _runtime.asyncEffect;\n/**\n * Imports an asynchronous effect into a pure `Effect` value, possibly returning\n * the value synchronously.\n *\n * If the register function returns a value synchronously, then the callback\n * function `Effect<R, E, A> => void` must not be called. Otherwise the callback\n * function must be called at most once.\n *\n * The `FiberId` of the fiber that may complete the async callback may be\n * provided to allow for better diagnostics.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.asyncEffect = asyncEffect;\nconst asyncOption = effect.asyncOption;\n/**\n * Imports an asynchronous side-effect into an effect. It has the option of\n * returning the value synchronously, which is useful in cases where it cannot\n * be determined if the effect is synchronous or asynchronous until the register\n * is actually executed. It also has the option of returning a canceler,\n * which will be used by the runtime to cancel the asynchronous effect if the fiber\n * executing the effect is interrupted.\n *\n * If the register function returns a value synchronously, then the callback\n * function `Effect<R, E, A> => void` must not be called. Otherwise the callback\n * function must be called at most once.\n *\n * The `FiberId` of the fiber that may complete the async callback may be\n * provided to allow for better diagnostics.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.asyncOption = asyncOption;\nconst asyncInterruptEither = core.asyncInterruptEither;\n/**\n * Imports an asynchronous side-effect into an effect allowing control of interruption.\n *\n * The `FiberId` of the fiber that may complete the async callback may be\n * provided to allow for better diagnostics.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.asyncInterruptEither = asyncInterruptEither;\nconst asyncInterrupt = core.asyncInterrupt;\n/**\n * Imports a synchronous side-effect into a pure `Effect` value, translating any\n * thrown exceptions into typed failed effects creating with `Effect.fail`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.asyncInterrupt = asyncInterrupt;\nconst attempt = effect.attempt;\n/**\n * Returns a new effect that will not succeed with its value before first\n * waiting for the end of all child fibers forked by the effect.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.attempt = attempt;\nconst awaitAllChildren = circular.awaitAllChildren;\n/**\n * Returns an effect that, if evaluated, will return the cached result of this\n * effect. Cached results will expire after `timeToLive` duration.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.awaitAllChildren = awaitAllChildren;\nconst cached = circular.cached;\n/**\n * Returns an effect that, if evaluated, will return the cached result of this\n * effect. Cached results will expire after `timeToLive` duration. In\n * addition, returns an effect that can be used to invalidate the current\n * cached value before the `timeToLive` duration expires.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.cached = cached;\nconst cachedInvalidate = circular.cachedInvalidate;\nexports.cachedInvalidate = cachedInvalidate;\nconst _catch = effect._catch;\nexports.catch = _catch;\n/**\n * Recovers from all recoverable errors.\n *\n * **Note**: that `Effect.catchAll` will not recover from unrecoverable defects. To\n * recover from both recoverable and unrecoverable errors use\n * `Effect.catchAllCause`.\n *\n * @since 1.0.0\n * @category error handling\n */\nconst catchAll = core.catchAll;\n/**\n * Recovers from both recoverable and unrecoverable errors.\n *\n * See `absorb`, `sandbox`, `mapErrorCause` for other functions that can\n * recover from defects.\n *\n * @since 1.0.0\n * @category error handling\n */\nexports.catchAll = catchAll;\nconst catchAllCause = core.catchAllCause;\n/**\n * Recovers from all defects with provided function.\n *\n * **WARNING**: There is no sensible way to recover from defects. This\n * method should be used only at the boundary between Effect and an external\n * system, to transmit information on a defect for diagnostic or explanatory\n * purposes.\n *\n * @since 1.0.0\n * @category error handling\n */\nexports.catchAllCause = catchAllCause;\nconst catchAllDefect = effect.catchAllDefect;\n/**\n * Recovers from some or all of the error cases.\n *\n * @since 1.0.0\n * @category error handling\n */\nexports.catchAllDefect = catchAllDefect;\nconst catchSome = core.catchSome;\n/**\n * Recovers from some or all of the error cases with provided cause.\n *\n * @since 1.0.0\n * @category error handling\n */\nexports.catchSome = catchSome;\nconst catchSomeCause = effect.catchSomeCause;\n/**\n * Recovers from some or all of the defects with provided partial function.\n *\n * **WARNING**: There is no sensible way to recover from defects. This\n * method should be used only at the boundary between Effect and an external\n * system, to transmit information on a defect for diagnostic or explanatory\n * purposes.\n *\n * @since 1.0.0\n * @category error handling\n */\nexports.catchSomeCause = catchSomeCause;\nconst catchSomeDefect = effect.catchSomeDefect;\n/**\n * Recovers from the specified tagged error.\n *\n * @since 1.0.0\n * @category error handling\n */\nexports.catchSomeDefect = catchSomeDefect;\nconst catchTag = effect.catchTag;\n/**\n * Recovers from the specified tagged errors.\n *\n * @since 1.0.0\n * @category error handling\n */\nexports.catchTag = catchTag;\nconst catchTags = effect.catchTags;\n/**\n * Returns an effect that succeeds with the cause of failure of this effect,\n * or `Cause.empty` if the effect did succeed.\n *\n * @since 1.0.0\n * @category error handling\n */\nexports.catchTags = catchTags;\nconst cause = effect.cause;\n/**\n * Checks the interrupt status, and produces the effect returned by the\n * specified callback.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.cause = cause;\nconst checkInterruptible = core.checkInterruptible;\n/**\n * Retreives the `Clock` service from the context\n *\n * @since 1.0.0\n * @category context\n */\nexports.checkInterruptible = checkInterruptible;\nconst clock = effect.clock;\n/**\n * Retreives the `Clock` service from the context and provides it to the\n * specified effectful function.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.clock = clock;\nconst clockWith = effect.clockWith;\n/**\n * Uses the default config provider to load the specified config, or fail with\n * an error of type Config.Error.\n *\n * @since 1.0.0\n * @category config\n */\nexports.clockWith = clockWith;\nconst config = defaultServices.config;\n/**\n * Retrieves the default config provider, and passes it to the specified\n * function, which may return an effect that uses the provider to perform some\n * work or compute some value.\n *\n * @since 1.0.0\n * @category config\n */\nexports.config = config;\nconst configProviderWith = defaultServices.configProviderWith;\n/**\n * Evaluate each effect in the structure from left to right, collecting the\n * the successful values and discarding the empty cases. For a parallel version, see `collectPar`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.configProviderWith = configProviderWith;\nconst collect = fiberRuntime.collect;\n/**\n * Evaluate each effect in the structure from left to right, and collect the\n * results. For a parallel version, see `collectAllPar`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.collect = collect;\nconst collectAll = effect.collectAll;\n/**\n * Evaluate each effect in the structure from left to right, and discard the\n * results. For a parallel version, see `collectAllParDiscard`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.collectAll = collectAll;\nconst collectAllDiscard = effect.collectAllDiscard;\n/**\n * Evaluate each effect in the structure in parallel, and collect the results.\n * For a sequential version, see `collectAll`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.collectAllDiscard = collectAllDiscard;\nconst collectAllPar = fiberRuntime.collectAllPar;\n/**\n * Evaluate each effect in the structure in parallel, and discard the results.\n * For a sequential version, see `collectAllDiscard`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.collectAllPar = collectAllPar;\nconst collectAllParDiscard = fiberRuntime.collectAllParDiscard;\n/**\n * Evaluate each effect in the structure with `collectAll`, and collect the\n * results with given partial function.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.collectAllParDiscard = collectAllParDiscard;\nconst collectAllWith = effect.collectAllWith;\n/**\n * Evaluate each effect in the structure with `collectAllPar`, and collect\n * the results with given partial function.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.collectAllWith = collectAllWith;\nconst collectAllWithPar = fiberRuntime.collectAllWithPar;\n/**\n * Returns a filtered, mapped subset of the elements of the iterable based on a\n * partial function.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.collectAllWithPar = collectAllWithPar;\nconst collectAllWithEffect = effect.collectAllWithEffect;\n/**\n * Evaluate and run each effect in the structure and collect the results,\n * discarding results from failed effects.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.collectAllWithEffect = collectAllWithEffect;\nconst collectAllSuccesses = effect.collectAllSuccesses;\n/**\n * Evaluate and run each effect in the structure in parallel and collect the\n * results, discarding results from failed effects.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.collectAllSuccesses = collectAllSuccesses;\nconst collectAllSuccessesPar = fiberRuntime.collectAllSuccessesPar;\n/**\n * Collects the first element of the `Collection<A>` for which the effectual\n * function `f` returns `Some`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.collectAllSuccessesPar = collectAllSuccessesPar;\nconst collectFirst = effect.collectFirst;\n/**\n * Evaluate each effect in the structure in parallel, collecting the successful\n * values and discarding the empty cases.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.collectFirst = collectFirst;\nconst collectPar = fiberRuntime.collectPar;\n/**\n * Transforms all elements of the chunk for as long as the specified partial\n * function is defined.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.collectPar = collectPar;\nconst collectWhile = effect.collectWhile;\n/**\n * Evaluate the predicate, return the given `A` as success if predicate returns\n * true, and the given `E` as error otherwise\n *\n * For effectful conditionals, see `ifEffect`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.collectWhile = collectWhile;\nconst cond = effect.cond;\n/**\n * @since 1.0.0\n * @category context\n */\nexports.cond = cond;\nconst context = core.context;\n/**\n * Accesses the context of the effect.\n *\n * @since 1.0.0\n * @category context\n */\nexports.context = context;\nconst contextWith = effect.contextWith;\n/**\n * Effectually accesses the context of the effect.\n *\n * @since 1.0.0\n * @category context\n */\nexports.contextWith = contextWith;\nconst contextWithEffect = core.contextWithEffect;\n/**\n * Fail with the specifed `error` if the supplied partial function does not\n * match, otherwise continue with the returned value.\n *\n * @since 1.0.0\n * @category error handling\n */\nexports.contextWithEffect = contextWithEffect;\nconst continueOrFail = effect.continueOrFail;\n/**\n * Fail with the specifed `error` if the supplied partial function does not\n * match, otherwise continue with the returned value.\n *\n * @since 1.0.0\n * @category error handling\n */\nexports.continueOrFail = continueOrFail;\nconst continueOrFailEffect = effect.continueOrFailEffect;\n/**\n * Provides some of the context required to run this effect,\n * leaving the remainder `R0`.\n *\n * @since 1.0.0\n * @category context\n */\nexports.continueOrFailEffect = continueOrFailEffect;\nconst contramapContext = core.contramapContext;\n/**\n * Returns a new workflow that will not supervise any fibers forked by this\n * workflow.\n *\n * @since 1.0.0\n * @category supervision\n */\nexports.contramapContext = contramapContext;\nconst daemonChildren = fiberRuntime.daemonChildren;\n/**\n * Returns an effect that is delayed from this effect by the specified\n * `Duration`.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.daemonChildren = daemonChildren;\nconst delay = effect.delay;\n/**\n * Constructs an effect with information about the current `Fiber`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.delay = delay;\nconst descriptor = effect.descriptor;\n/**\n * Constructs an effect based on information about the current `Fiber`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.descriptor = descriptor;\nconst descriptorWith = effect.descriptorWith;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexports.descriptorWith = descriptorWith;\nconst die = core.die;\n/**\n * Returns an effect that dies with a `RuntimeException` having the specified\n * text message. This method can be used for terminating a fiber because a\n * defect has been detected in the code.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.die = die;\nconst dieMessage = effect.dieMessage;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexports.dieMessage = dieMessage;\nconst dieSync = core.dieSync;\n/**\n * Returns an effect whose interruption will be disconnected from the\n * fiber's own interruption, being performed in the background without\n * slowing down the fiber's interruption.\n *\n * This method is useful to create \"fast interrupting\" effects. For\n * example, if you call this on a bracketed effect, then even if the\n * effect is \"stuck\" in acquire or release, its interruption will return\n * immediately, while the acquire / release are performed in the\n * background.\n *\n * See timeout and race for other applications.\n *\n * @since 1.0.0\n * @category interruption\n */\nexports.dieSync = dieSync;\nconst disconnect = circular.disconnect;\n/**\n * Returns a new workflow that executes this one and captures the changes in\n * `FiberRef` values.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.disconnect = disconnect;\nconst diffFiberRefs = effect.diffFiberRefs;\n/**\n * Binds an effectful value in a `do` scope\n *\n * @since 1.0.0\n * @category do notation\n */\nexports.diffFiberRefs = diffFiberRefs;\nconst bind = effect.bind;\n/**\n * Like bind for values\n *\n * @since 1.0.0\n * @category do notation\n */\nexports.bind = bind;\nconst bindValue = effect.bindValue;\n/**\n * @since 1.0.0\n * @category do notation\n */\nexports.bindValue = bindValue;\nconst Do = effect.Do;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexports.Do = Do;\nconst done = core.done;\n/**\n * Drops all elements until the effectful predicate returns true.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.done = done;\nconst dropUntil = effect.dropUntil;\n/**\n * Drops all elements so long as the predicate returns true.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.dropUntil = dropUntil;\nconst dropWhile = effect.dropWhile;\n/**\n * Returns an effect whose failure and success have been lifted into an\n * `Either`. The resulting effect cannot fail, because the failure case has\n * been exposed as part of the `Either` success case.\n *\n * This method is useful for recovering from effects that may fail.\n *\n * The error parameter of the returned `Effect` is `never`, since it is\n * guaranteed the effect does not model failure.\n *\n * @since 1.0.0\n * @category conversions\n */\nexports.dropWhile = dropWhile;\nconst either = core.either;\n/**\n * Returns an effect that, if this effect _starts_ execution, then the\n * specified `finalizer` is guaranteed to be executed, whether this effect\n * succeeds, fails, or is interrupted.\n *\n * For use cases that need access to the effect's result, see `onExit`.\n *\n * Finalizers offer very powerful guarantees, but they are low-level, and\n * should generally not be used for releasing resources. For higher-level\n * logic built on `ensuring`, see the `acquireRelease` family of methods.\n *\n * @since 1.0.0\n * @category finalization\n */\nexports.either = either;\nconst ensuring = circular.ensuring;\n/**\n * Acts on the children of this fiber (collected into a single fiber),\n * guaranteeing the specified callback will be invoked, whether or not this\n * effect succeeds.\n *\n * @since 1.0.0\n * @category finalization\n */\nexports.ensuring = ensuring;\nconst ensuringChild = circular.ensuringChild;\n/**\n * Acts on the children of this fiber, guaranteeing the specified callback\n * will be invoked, whether or not this effect succeeds.\n *\n * @since 1.0.0\n * @category finalization\n */\nexports.ensuringChild = ensuringChild;\nconst ensuringChildren = circular.ensuringChildren;\n/**\n * Returns an effect that ignores errors and runs repeatedly until it\n * eventually succeeds.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.ensuringChildren = ensuringChildren;\nconst eventually = effect.eventually;\n/**\n * Determines whether any element of the `Iterable<A>` satisfies the effectual\n * predicate `f`, working sequentially.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.eventually = eventually;\nconst exists = effect.exists;\n/**\n * Determines whether any element of the `Iterable<A>` satisfies the effectual\n * predicate `f`, working in parallel. Interrupts all effects on any failure or\n * finding an element that satisfies the predicate.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.exists = exists;\nconst existsPar = fiberRuntime.existsPar;\n/**\n * @since 1.0.0\n * @category utilities\n */\nexports.existsPar = existsPar;\nconst exit = core.exit;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexports.exit = exit;\nconst fail = core.fail;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexports.fail = fail;\nconst failSync = core.failSync;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexports.failSync = failSync;\nconst failCause = core.failCause;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexports.failCause = failCause;\nconst failCauseSync = core.failCauseSync;\n/**\n * @since 1.0.0\n * @category utilities\n */\nexports.failCauseSync = failCauseSync;\nconst fiberId = core.fiberId;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexports.fiberId = fiberId;\nconst fiberIdWith = core.fiberIdWith;\n/**\n * Filters the collection using the specified effectful predicate.\n *\n * @since 1.0.0\n * @category filtering\n */\nexports.fiberIdWith = fiberIdWith;\nconst filter = effect.filter;\n/**\n * Filters the collection in parallel using the specified effectual predicate.\n * See `filter` for a sequential version of it.\n *\n * @since 1.0.0\n * @category filtering\n */\nexports.filter = filter;\nconst filterPar = fiberRuntime.filterPar;\n/**\n * Filters the collection using the specified effectual predicate, removing\n * all elements that satisfy the predicate.\n *\n * @since 1.0.0\n * @category filtering\n */\nexports.filterPar = filterPar;\nconst filterNot = effect.filterNot;\n/**\n * Filters the collection in parallel using the specified effectual predicate.\n * See `filterNot` for a sequential version.\n *\n * @since 1.0.0\n * @category filtering\n */\nexports.filterNot = filterNot;\nconst filterNotPar = fiberRuntime.filterNotPar;\n/**\n * Filter the specified effect with the provided function, dying with specified\n * defect if the predicate fails.\n *\n * @since 1.0.0\n * @category filtering\n */\nexports.filterNotPar = filterNotPar;\nconst filterOrDie = effect.filterOrDie;\n/**\n * Filter the specified effect with the provided function, dying with specified\n * message if the predicate fails.\n *\n * @since 1.0.0\n * @category filtering\n */\nexports.filterOrDie = filterOrDie;\nconst filterOrDieMessage = effect.filterOrDieMessage;\n/**\n * Filters the specified effect with the provided function returning the value\n * of the effect if it is successful, otherwise returns the value of `orElse`.\n *\n * @since 1.0.0\n * @category filtering\n */\nexports.filterOrDieMessage = filterOrDieMessage;\nconst filterOrElse = effect.filterOrElse;\n/**\n * Filters the specified effect with the provided function returning the value\n * of the effect if it is successful, otherwise returns the value of `orElse`.\n *\n * @since 1.0.0\n * @category filtering\n */\nexports.filterOrElse = filterOrElse;\nconst filterOrElseWith = effect.filterOrElseWith;\n/**\n * Filter the specified effect with the provided function, failing with specified\n * error if the predicate fails.\n *\n * @since 1.0.0\n * @category filtering\n */\nexports.filterOrElseWith = filterOrElseWith;\nconst filterOrFail = effect.filterOrFail;\n/**\n * Returns the first element that satisfies the effectful predicate.\n *\n * @since 1.0.0\n * @category elements\n */\nexports.filterOrFail = filterOrFail;\nconst find = effect.find;\n/**\n * This function takes an iterable of `Effect` values and returns a new\n * `Effect` value that represents the first `Effect` value in the iterable\n * that succeeds. If all of the `Effect` values in the iterable fail, then\n * the resulting `Effect` value will fail as well.\n *\n * This function is sequential, meaning that the `Effect` values in the\n * iterable will be executed in sequence, and the first one that succeeds\n * will determine the outcome of the resulting `Effect` value.\n *\n * @param effects - The iterable of `Effect` values to evaluate.\n *\n * @returns A new `Effect` value that represents the first successful\n * `Effect` value in the iterable, or a failed `Effect` value if all of the\n * `Effect` values in the iterable fail.\n *\n * @since 1.0.0\n * @category elements\n */\nexports.find = find;\nconst firstSuccessOf = effect.firstSuccessOf;\n/**\n * This function is a pipeable operator that maps over an `Effect` value,\n * flattening the result of the mapping function into a new `Effect` value.\n *\n * @param f - The mapping function to apply to the `Effect` value.\n * This function must return another `Effect` value.\n *\n * @returns A new `Effect` value that is the result of flattening the\n * mapped `Effect` value.\n *\n * @since 1.0.0\n * @category sequencing\n */\nexports.firstSuccessOf = firstSuccessOf;\nconst flatMap = core.flatMap;\n/**\n * @since 1.0.0\n * @category sequencing\n */\nexports.flatMap = flatMap;\nconst flatten = core.flatten;\n/**\n * Unwraps the optional error, defaulting to the provided value.\n *\n * @since 1.0.0\n * @category sequencing\n */\nexports.flatten = flatten;\nconst flattenErrorOption = effect.flattenErrorOption;\n/**\n * Returns an effect that swaps the error/success cases. This allows you to\n * use all methods on the error channel, possibly before flipping back.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.flattenErrorOption = flattenErrorOption;\nconst flip = core.flip;\n/**\n * Swaps the error/value parameters, applies the function `f` and flips the\n * parameters back\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.flip = flip;\nconst flipWith = effect.flipWith;\n/**\n * Determines whether all elements of the `Collection<A>` satisfies the effectual\n * predicate `f`.\n *\n * @since 1.0.0\n * @category elements\n */\nexports.flipWith = flipWith;\nconst forAll = effect.forAll;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexports.forAll = forAll;\nconst forEach = core.forEach;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexports.forEach = forEach;\nconst forEachDiscard = core.forEachDiscard;\n/**\n * Returns a new effect that will pass the success value of this effect to the\n * provided callback. If this effect fails, then the failure will be ignored.\n *\n * @since 1.0.0\n * @category elements\n */\nexports.forEachDiscard = forEachDiscard;\nconst forEachEffect = effect.forEachEffect;\n/**\n * Applies the function `f` to each element of the `Collection<A>` and returns\n * the result in a new `Chunk<B>` using the specified execution strategy.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.forEachEffect = forEachEffect;\nconst forEachExec = fiberRuntime.forEachExec;\n/**\n * Applies the function `f` if the argument is non-empty and returns the\n * results in a new `Option<B>`.\n *\n * @since 1.0.0\n * @category elements\n */\nexports.forEachExec = forEachExec;\nconst forEachOption = effect.forEachOption;\n/**\n * Same as `forEach`, except that the function `f` is supplied\n * a second argument that corresponds to the index (starting from 0)\n * of the current element being iterated over.\n *\n * @since 1.0.0\n * @category traversing\n */\nexports.forEachOption = forEachOption;\nconst forEachWithIndex = effect.forEachWithIndex;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexports.forEachWithIndex = forEachWithIndex;\nconst forEachPar = fiberRuntime.forEachPar;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexports.forEachPar = forEachPar;\nconst forEachParDiscard = fiberRuntime.forEachParDiscard;\n/**\n * Same as `forEachPar`, except that the function `f` is supplied\n * a second argument that corresponds to the index (starting from 0)\n * of the current element being iterated over.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.forEachParDiscard = forEachParDiscard;\nconst forEachParWithIndex = fiberRuntime.forEachParWithIndex;\n/**\n * Repeats this effect forever (until the first error).\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.forEachParWithIndex = forEachParWithIndex;\nconst forever = effect.forever;\n/**\n * Returns an effect that forks this effect into its own separate fiber,\n * returning the fiber immediately, without waiting for it to begin executing\n * the effect.\n *\n * You can use the `fork` method whenever you want to execute an effect in a\n * new fiber, concurrently and without \"blocking\" the fiber executing other\n * effects. Using fibers can be tricky, so instead of using this method\n * directly, consider other higher-level methods, such as `raceWith`,\n * `zipPar`, and so forth.\n *\n * The fiber returned by this method has methods to interrupt the fiber and to\n * wait for it to finish executing the effect. See `Fiber` for more\n * information.\n *\n * Whenever you use this method to launch a new fiber, the new fiber is\n * attached to the parent fiber's scope. This means when the parent fiber\n * terminates, the child fiber will be terminated as well, ensuring that no\n * fibers leak. This behavior is called \"auto supervision\", and if this\n * behavior is not desired, you may use the `forkDaemon` or `forkIn` methods.\n *\n * @since 1.0.0\n * @category supervision\n */\nexports.forever = forever;\nconst fork = fiberRuntime.fork;\n/**\n * Forks the effect into a new fiber attached to the global scope. Because the\n * new fiber is attached to the global scope, when the fiber executing the\n * returned effect terminates, the forked fiber will continue running.\n *\n * @since 1.0.0\n * @category supervision\n */\nexports.fork = fork;\nconst forkDaemon = fiberRuntime.forkDaemon;\n/**\n * Returns an effect that forks all of the specified values, and returns a\n * composite fiber that produces a list of their results, in order.\n *\n * @since 1.0.0\n * @category supervision\n */\nexports.forkDaemon = forkDaemon;\nconst forkAll = circular.forkAll;\n/**\n * Returns an effect that forks all of the specified values, and returns a\n * composite fiber that produces unit. This version is faster than `forkAll`\n * in cases where the results of the forked fibers are not needed.\n *\n * @since 1.0.0\n * @category supervision\n */\nexports.forkAll = forkAll;\nconst forkAllDiscard = fiberRuntime.forkAllDiscard;\n/**\n * Forks the effect in the specified scope. The fiber will be interrupted\n * when the scope is closed.\n *\n * @since 1.0.0\n * @category supervision\n */\nexports.forkAllDiscard = forkAllDiscard;\nconst forkIn = circular.forkIn;\n/**\n * Forks the fiber in a `Scope`, interrupting it when the scope is closed.\n *\n * @since 1.0.0\n * @category supervision\n */\nexports.forkIn = forkIn;\nconst forkScoped = circular.forkScoped;\n/**\n * Like fork but handles an error with the provided handler.\n *\n * @since 1.0.0\n * @category supervision\n */\nexports.forkScoped = forkScoped;\nconst forkWithErrorHandler = fiberRuntime.forkWithErrorHandler;\n/**\n * Lifts an `Either<E, A>` into an `Effect<never, E, A>`.\n *\n * @since 1.0.0\n * @category conversions\n */\nexports.forkWithErrorHandler = forkWithErrorHandler;\nconst fromEither = core.fromEither;\n/**\n * Lifts an `Either<Cause<E>, A>` into an `Effect<never, E, A>`.\n *\n * @since 1.0.0\n * @category conversions\n */\nexports.fromEither = fromEither;\nconst fromEitherCause = effect.fromEitherCause;\n/**\n * Creates an `Effect` value that represents the exit value of the specified\n * fiber.\n *\n * @since 1.0.0\n * @category conversions\n */\nexports.fromEitherCause = fromEitherCause;\nconst fromFiber = circular.fromFiber;\n/**\n * Creates an `Effect` value that represents the exit value of the specified\n * fiber.\n *\n * @since 1.0.0\n * @category conversions\n */\nexports.fromFiber = fromFiber;\nconst fromFiberEffect = circular.fromFiberEffect;\n/**\n * Lifts an `Option` into an `Effect` but preserves the error as an option in\n * the error channel, making it easier to compose in some scenarios.\n *\n * @since 1.0.0\n * @category conversions\n */\nexports.fromFiberEffect = fromFiberEffect;\nconst fromOption = core.fromOption;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexports.fromOption = fromOption;\nconst gen = effect.gen;\n/**\n * Returns a collection of all `FiberRef` values for the fiber running this\n * effect.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.gen = gen;\nconst getFiberRefs = effect.getFiberRefs;\n/**\n * Lifts an `Option` into an `Effect`, if the option is not defined it fails\n * with `NoSuchElementException`.\n *\n * @since 1.0.0\n * @category conversions\n */\nexports.getFiberRefs = getFiberRefs;\nconst getOrFail = effect.getOrFail;\n/**\n * Lifts an `Option` into a `IO`, if the option is not defined it fails with\n * `void`.\n *\n * @since 1.0.0\n * @category conversions\n */\nexports.getOrFail = getOrFail;\nconst getOrFailDiscard = effect.getOrFailDiscard;\n/**\n * Lifts an `Maybe` into an `Effect`. If the option is not defined, fail with\n * the specified `e` value.\n *\n * @since 1.0.0\n * @category conversions\n */\nexports.getOrFailDiscard = getOrFailDiscard;\nconst getOrFailWith = effect.getOrFailWith;\n/**\n * Returns a successful effect with the head of the collection if the collection\n * is non-empty, or fails with the error `None` if the collection is empty.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.getOrFailWith = getOrFailWith;\nconst head = effect.head;\n/**\n * Runs `onTrue` if the result of `self` is `true` and `onFalse` otherwise.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.head = head;\nconst ifEffect = core.ifEffect;\n/**\n * Returns a new effect that ignores the success or failure of this effect.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.ifEffect = ifEffect;\nconst ignore = effect.ignore;\n/**\n * Returns a new effect that ignores the success or failure of this effect,\n * but which also logs failures at the Debug level, just in case the failure\n * turns out to be important.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.ignore = ignore;\nconst ignoreLogged = effect.ignoreLogged;\n/**\n * Inherits values from all `FiberRef` instances into current fiber.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.ignoreLogged = ignoreLogged;\nconst inheritFiberRefs = effect.inheritFiberRefs;\n/**\n * @since 1.0.0\n * @category interruption\n */\nexports.inheritFiberRefs = inheritFiberRefs;\nconst interrupt = core.interrupt;\n/**\n * @since 1.0.0\n * @category interruption\n */\nexports.interrupt = interrupt;\nconst interruptWith = core.interruptWith;\n/**\n * @since 1.0.0\n * @category interruption\n */\nexports.interruptWith = interruptWith;\nconst interruptible = core.interruptible;\n/**\n * @since 1.0.0\n * @category interruption\n */\nexports.interruptible = interruptible;\nconst interruptibleMask = core.interruptibleMask;\n/**\n * @since 1.0.0\n * @category utilities\n */\nexports.interruptibleMask = interruptibleMask;\nconst intoDeferred = core.intoDeferred;\n/**\n * Returns `true` if this effect is a failure, `false` otherwise.\n *\n * @since 1.0.0\n * @category getter\n */\nexports.intoDeferred = intoDeferred;\nconst isFailure = effect.isFailure;\n/**\n * Returns `true` if this effect is a success, `false` otherwise.\n *\n * @since 1.0.0\n * @category getter\n */\nexports.isFailure = isFailure;\nconst isSuccess = effect.isSuccess;\n/**\n * Iterates with the specified effectual function. The moral equivalent of:\n *\n * ```ts\n * let s = initial\n *\n * while (cont(s)) {\n *   s = body(s)\n * }\n *\n * return s\n * ```\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.isSuccess = isSuccess;\nconst iterate = effect.iterate;\n/**\n * \"Zooms in\" on the value in the `Left` side of an `Either`, moving the\n * possibility that the value is a `Right` to the error channel.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.iterate = iterate;\nconst left = effect.left;\n/**\n * Performs the specified operation while \"zoomed in\" on the `Left` case of an\n * `Either`.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.left = left;\nconst leftWith = effect.leftWith;\n/**\n * Logs the specified message at the current log level.\n *\n * @since 1.0.0\n * @category logging\n */\nexports.leftWith = leftWith;\nconst log = effect.log;\n/**\n * Logs the specified message at the debug log level.\n *\n * @since 1.0.0\n * @category logging\n */\nexports.log = log;\nconst logDebug = effect.logDebug;\n/**\n * Logs the specified cause at the debug log level.\n *\n * @since 1.0.0\n * @category logging\n */\nexports.logDebug = logDebug;\nconst logDebugCause = effect.logDebugCause;\n/**\n * Logs the specified message and cause at the debug log level.\n *\n * @since 1.0.0\n * @category logging\n */\nexports.logDebugCause = logDebugCause;\nconst logDebugCauseMessage = effect.logDebugCauseMessage;\n/**\n * Logs the specified message at the error log level.\n *\n * @since 1.0.0\n * @category logging\n */\nexports.logDebugCauseMessage = logDebugCauseMessage;\nconst logError = effect.logError;\n/**\n * Logs the specified cause at the error log level.\n *\n * @since 1.0.0\n * @category logging\n */\nexports.logError = logError;\nconst logErrorCause = effect.logErrorCause;\n/**\n * Logs the specified message and cause at the error log level.\n *\n * @since 1.0.0\n * @category logging\n */\nexports.logErrorCause = logErrorCause;\nconst logErrorCauseMessage = effect.logErrorCauseMessage;\n/**\n * Logs the specified message at the fatal log level.\n *\n * @since 1.0.0\n * @category logging\n */\nexports.logErrorCauseMessage = logErrorCauseMessage;\nconst logFatal = effect.logFatal;\n/**\n * Logs the specified cause at the fatal log level.\n *\n * @since 1.0.0\n * @category logging\n */\nexports.logFatal = logFatal;\nconst logFatalCause = effect.logFatalCause;\n/**\n * Logs the specified message and cause at the fatal log level.\n *\n * @since 1.0.0\n * @category logging\n */\nexports.logFatalCause = logFatalCause;\nconst logFatalCauseMessage = effect.logFatalCauseMessage;\n/**\n * Logs the specified message at the informational log level.\n *\n * @since 1.0.0\n * @category logging\n */\nexports.logFatalCauseMessage = logFatalCauseMessage;\nconst logInfo = effect.logInfo;\n/**\n * Logs the specified cause at the informational log level.\n *\n * @since 1.0.0\n * @category logging\n */\nexports.logInfo = logInfo;\nconst logInfoCause = effect.logInfoCause;\n/**\n * Logs the specified message and cause at the informational log level.\n *\n * @since 1.0.0\n * @category logging\n */\nexports.logInfoCause = logInfoCause;\nconst logInfoCauseMessage = effect.logInfoCauseMessage;\n/**\n * Logs the specified message at the warning log level.\n *\n * @since 1.0.0\n * @category logging\n */\nexports.logInfoCauseMessage = logInfoCauseMessage;\nconst logWarning = effect.logWarning;\n/**\n * Logs the specified cause at the warning log level.\n *\n * @since 1.0.0\n * @category logging\n */\nexports.logWarning = logWarning;\nconst logWarningCause = effect.logWarningCause;\n/**\n * Logs the specified message and cause at the warning log level.\n *\n * @since 1.0.0\n * @category logging\n */\nexports.logWarningCause = logWarningCause;\nconst logWarningCauseMessage = effect.logWarningCauseMessage;\n/**\n * Logs the specified message at the trace log level.\n *\n * @since 1.0.0\n * @category logging\n */\nexports.logWarningCauseMessage = logWarningCauseMessage;\nconst logTrace = effect.logTrace;\n/**\n * Logs the specified cause at the trace log level.\n *\n * @since 1.0.0\n * @category logging\n */\nexports.logTrace = logTrace;\nconst logTraceCause = effect.logTraceCause;\n/**\n * Logs the specified message and cause at the trace log level.\n *\n * @since 1.0.0\n * @category logging\n */\nexports.logTraceCause = logTraceCause;\nconst logTraceCauseMessage = effect.logTraceCauseMessage;\n/**\n * Adjusts the label for the current logging span.\n *\n * @since 1.0.0\n * @category logging\n */\nexports.logTraceCauseMessage = logTraceCauseMessage;\nconst logSpan = effect.logSpan;\n/**\n * Annotates each log in this effect with the specified log annotation.\n *\n * @since 1.0.0\n * @category logging\n */\nexports.logSpan = logSpan;\nconst logAnnotate = effect.logAnnotate;\n/**\n * Retrieves the log annotations associated with the current scope.\n *\n * @since 1.0.0\n * @category logging\n */\nexports.logAnnotate = logAnnotate;\nconst logAnnotations = effect.logAnnotations;\n/**\n * Loops with the specified effectual function, collecting the results into a\n * list. The moral equivalent of:\n *\n * ```ts\n * let s  = initial\n * let as = [] as readonly A[]\n *\n * while (cont(s)) {\n *   as = [body(s), ...as]\n *   s  = inc(s)\n * }\n *\n * A.reverse(as)\n * ```\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.logAnnotations = logAnnotations;\nconst loop = effect.loop;\n/**\n * Loops with the specified effectual function purely for its effects. The\n * moral equivalent of:\n *\n * ```ts\n * let s = initial\n *\n * while (cont(s)) {\n *   body(s)\n *   s = inc(s)\n * }\n * ```\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.loop = loop;\nconst loopDiscard = effect.loopDiscard;\n/**\n * @since 1.0.0\n * @category mapping\n */\nexports.loopDiscard = loopDiscard;\nconst map = core.map;\n/**\n * Statefully and effectfully maps over the elements of this chunk to produce\n * new elements.\n *\n * @since 1.0.0\n * @category mapping\n */\nexports.map = map;\nconst mapAccum = effect.mapAccum;\n/**\n * Returns an effect whose failure and success channels have been mapped by\n * the specified pair of functions, `f` and `g`.\n *\n * @since 1.0.0\n * @category mapping\n */\nexports.mapAccum = mapAccum;\nconst mapBoth = effect.mapBoth;\n/**\n * Returns an effect with its error channel mapped using the specified function.\n *\n * @since 1.0.0\n * @category mapping\n */\nexports.mapBoth = mapBoth;\nconst mapError = core.mapError;\n/**\n * Returns an effect with its full cause of failure mapped using the specified\n * function. This can be used to transform errors while preserving the\n * original structure of `Cause`.\n *\n * See `absorb`, `sandbox`, `catchAllCause` for other functions for dealing\n * with defects.\n *\n * @since 1.0.0\n * @category mapping\n */\nexports.mapError = mapError;\nconst mapErrorCause = effect.mapErrorCause;\n/**\n * Returns an effect whose success is mapped by the specified side effecting\n * `f` function, translating any thrown exceptions into typed failed effects.\n *\n * @since 1.0.0\n * @category mapping\n */\nexports.mapErrorCause = mapErrorCause;\nconst mapTryCatch = effect.mapTryCatch;\n/**\n * Folds over the failure value or the success value to yield an effect that\n * does not fail, but succeeds with the value returned by the left or right\n * function passed to `match`.\n *\n * @since 1.0.0\n * @category folding\n */\nexports.mapTryCatch = mapTryCatch;\nconst match = effect.match;\n/**\n * @since 1.0.0\n * @category error handling\n */\nexports.match = match;\nconst matchCause = core.matchCause;\n/**\n * @since 1.0.0\n * @category error handling\n */\nexports.matchCause = matchCause;\nconst matchCauseEffect = core.matchCauseEffect;\n/**\n * @since 1.0.0\n * @category error handling\n */\nexports.matchCauseEffect = matchCauseEffect;\nconst matchEffect = core.matchEffect;\n/**\n * Returns an effect that, if evaluated, will return the lazily computed\n * result of this effect.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.matchEffect = matchEffect;\nconst memoize = effect.memoize;\n/**\n * Returns a memoized version of the specified effectual function.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.memoize = memoize;\nconst memoizeFunction = circular.memoizeFunction;\n/**\n * Returns a new effect where the error channel has been merged into the\n * success channel to their common combined type.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.memoizeFunction = memoizeFunction;\nconst merge = effect.merge;\n/**\n * Merges an `Iterable<Effect<R, E, A>>` to a single effect, working\n * sequentially.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.merge = merge;\nconst mergeAll = effect.mergeAll;\n/**\n * Merges an `Iterable<Effect<R, E, A>>` to a single effect, working in\n * parallel.\n *\n * Due to the parallel nature of this combinator, `f` must be both:\n * - commutative: `f(a, b) == f(b, a)`\n * - associative: `f(a, f(b, c)) == f(f(a, b), c)`\n *\n * It's unsafe to execute side effects inside `f`, as `f` may be executed\n * more than once for some of `in` elements during effect execution.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.mergeAll = mergeAll;\nconst mergeAllPar = fiberRuntime.mergeAllPar;\n/**\n * Returns a new effect where boolean value of this effect is negated.\n *\n * @since 1.0.0\n * @category mapping\n */\nexports.mergeAllPar = mergeAllPar;\nconst negate = effect.negate;\n/**\n * Returns a effect that will never produce anything. The moral equivalent of\n * `while(true) {}`, only without the wasted CPU cycles.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.negate = negate;\nconst never = core.never;\n/**\n * Requires the option produced by this value to be `None`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.never = never;\nconst none = effect.none;\n/**\n * Lifts an `Option` into a `Effect`. If the option is empty it succeeds with\n * `void`. If the option is defined it fails with the content.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.none = none;\nconst noneOrFail = effect.noneOrFail;\n/**\n * Lifts an `Option` into a `Effect`. If the option is empty it succeeds with\n * `undefined`. If the option is defined it fails with an error computed by\n * the specified function.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.noneOrFail = noneOrFail;\nconst noneOrFailWith = effect.noneOrFailWith;\n/**\n * @since 1.0.0\n * @category mutations\n */\nexports.noneOrFailWith = noneOrFailWith;\nconst onDone = fiberRuntime.onDone;\n/**\n * @since 1.0.0\n * @category mutations\n */\nexports.onDone = onDone;\nconst onDoneCause = fiberRuntime.onDoneCause;\n/**\n * Runs the specified effect if this effect fails, providing the error to the\n * effect if it exists. The provided effect will not be interrupted.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.onDoneCause = onDoneCause;\nconst onError = core.onError;\n/**\n * Ensures that a cleanup functions runs, whether this effect succeeds, fails,\n * or is interrupted.\n *\n * @category finalization\n * @since 1.0.0\n */\nexports.onError = onError;\nconst onExit = core.onExit;\n/**\n * @since 1.0.0\n * @category finalization\n */\nexports.onExit = onExit;\nconst onInterrupt = core.onInterrupt;\n/**\n * Returns an effect that will be executed at most once, even if it is\n * evaluated multiple times.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.onInterrupt = onInterrupt;\nconst once = effect.once;\n/**\n * Executes this effect, skipping the error but returning optionally the\n * success.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.once = once;\nconst option = effect.option;\n/**\n * Translates effect failure into death of the fiber, making all failures\n * unchecked and not a part of the type of the effect.\n *\n * @since 1.0.0\n * @category alternatives\n */\nexports.option = option;\nconst orDie = core.orDie;\n/**\n * Keeps none of the errors, and terminates the fiber with them, using the\n * specified function to convert the `E` into a `Throwable`.\n *\n * @since 1.0.0\n * @category alternatives\n */\nexports.orDie = orDie;\nconst orDieWith = core.orDieWith;\n/**\n * Executes this effect and returns its value, if it succeeds, but otherwise\n * executes the specified effect.\n *\n * @since 1.0.0\n * @category alternatives\n */\nexports.orDieWith = orDieWith;\nconst orElse = core.orElse;\n/**\n * Returns an effect that will produce the value of this effect, unless it\n * fails, in which case, it will produce the value of the specified effect.\n *\n * @since 1.0.0\n * @category alternatives\n */\nexports.orElse = orElse;\nconst orElseEither = effect.orElseEither;\n/**\n * Executes this effect and returns its value, if it succeeds, but otherwise\n * fails with the specified error.\n *\n * @since 1.0.0\n * @category alternatives\n */\nexports.orElseEither = orElseEither;\nconst orElseFail = effect.orElseFail;\n/**\n * Returns an effect that will produce the value of this effect, unless it\n * fails with the `None` value, in which case it will produce the value of\n * the specified effect.\n *\n * @since 1.0.0\n * @category alternatives\n */\nexports.orElseFail = orElseFail;\nconst orElseOptional = effect.orElseOptional;\n/**\n * Executes this effect and returns its value, if it succeeds, but\n * otherwise succeeds with the specified value.\n *\n * @since 1.0.0\n * @category alternatives\n */\nexports.orElseOptional = orElseOptional;\nconst orElseSucceed = effect.orElseSucceed;\n/**\n * Exposes all parallel errors in a single call.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.orElseSucceed = orElseSucceed;\nconst parallelErrors = effect.parallelErrors;\n/**\n * @since 1.0.0\n * @category mutations\n */\nexports.parallelErrors = parallelErrors;\nconst parallelFinalizers = fiberRuntime.parallelFinalizers;\n/**\n * Feeds elements of type `A` to a function `f` that returns an effect.\n * Collects all successes and failures in a tupled fashion.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.parallelFinalizers = parallelFinalizers;\nconst partition = effect.partition;\n/**\n * Feeds elements of type `A` to a function `f` that returns an effect.\n * Collects all successes and failures in parallel and returns the result as a\n * tuple.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.partition = partition;\nconst partitionPar = fiberRuntime.partitionPar;\n/**\n * Applies the specified changes to the `FiberRef` values for the fiber\n * running this workflow.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.partitionPar = partitionPar;\nconst patchFiberRefs = effect.patchFiberRefs;\n/**\n * Like `attemptPromise` but produces a defect in case of errors.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.patchFiberRefs = patchFiberRefs;\nconst promise = effect.promise;\n/**\n * Like `promise` but allows for interruption via AbortSignal\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.promise = promise;\nconst promiseInterrupt = effect.promiseInterrupt;\n/**\n * Provides the effect with its required context, which eliminates its\n * dependency on `R`.\n *\n * @since 1.0.0\n * @category context\n */\nexports.promiseInterrupt = promiseInterrupt;\nconst provideContext = core.provideContext;\n/**\n * Provides a layer to the effect, which translates it to another level.\n *\n * @since 1.0.0\n * @category context\n */\nexports.provideContext = provideContext;\nconst provideLayer = layer.provideLayer;\n/**\n * Provides the effect with the single service it requires. If the effect\n * requires more than one service use `provideContext` instead.\n *\n * @since 1.0.0\n * @category context\n */\nexports.provideLayer = provideLayer;\nconst provideService = effect.provideService;\n/**\n * Provides the effect with the single service it requires. If the effect\n * requires more than one service use `provideContext` instead.\n *\n * @since 1.0.0\n * @category context\n */\nexports.provideService = provideService;\nconst provideServiceEffect = effect.provideServiceEffect;\n/**\n * Splits the context into two parts, providing one part using the\n * specified layer and leaving the remainder `R0`.\n *\n * @since 1.0.0\n * @category context\n */\nexports.provideServiceEffect = provideServiceEffect;\nconst provideSomeLayer = layer.provideSomeLayer;\n/**\n * Returns an effect that races this effect with the specified effect,\n * returning the first successful `A` from the faster side. If one effect\n * succeeds, the other will be interrupted. If neither succeeds, then the\n * effect will fail with some error.\n *\n * Note that both effects are disconnected before being raced. This means that\n * interruption of the loser will always be performed in the background. If this\n * behavior is not desired, you can use `Effect.raceWith`, which will not\n * disconnect or interrupt losers.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.provideSomeLayer = provideSomeLayer;\nconst race = circular.race;\n/**\n * Returns an effect that races this effect with all the specified effects,\n * yielding the value of the first effect to succeed with a value. Losers of\n * the race will be interrupted immediately\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.race = race;\nconst raceAll = fiberRuntime.raceAll;\n/**\n * Returns an effect that races this effect with the specified effect,\n * returning the first successful `A` from the faster side. If one effect\n * succeeds, the other will be interrupted. If neither succeeds, then the\n * effect will fail with some error.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.raceAll = raceAll;\nconst raceAwait = circular.raceAwait;\n/**\n * Returns an effect that races this effect with the specified effect,\n * yielding the first result to succeed. If neither effect succeeds, then the\n * composed effect will fail with some error.\n *\n * WARNING: The raced effect will safely interrupt the \"loser\", but will not\n * resume until the loser has been cleanly terminated.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.raceAwait = raceAwait;\nconst raceEither = circular.raceEither;\n/**\n * Forks this effect and the specified effect into their own fibers, and races\n * them, calling one of two specified callbacks depending on which fiber wins\n * the race. This method does not interrupt, join, or otherwise do anything\n * with the fibers. It can be considered a low-level building block for\n * higher-level operators like `race`.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.raceEither = raceEither;\nconst raceFibersWith = circular.raceFibersWith;\n/**\n * Returns an effect that races this effect with the specified effect,\n * yielding the first result to complete, whether by success or failure. If\n * neither effect completes, then the composed effect will not complete.\n *\n * WARNING: The raced effect will safely interrupt the \"loser\", but will not\n * resume until the loser has been cleanly terminated. If early return is\n * desired, then instead of performing `l raceFirst r`, perform\n * `l.disconnect raceFirst r.disconnect`, which disconnects left and right\n * interrupt signal, allowing a fast return, with interruption performed\n * in the background.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.raceFibersWith = raceFibersWith;\nconst raceFirst = circular.raceFirst;\n/**\n * Returns an effect that races this effect with the specified effect, calling\n * the specified finisher as soon as one result or the other has been computed.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.raceFirst = raceFirst;\nconst raceWith = circular.raceWith;\n/**\n * Retreives the `Random` service from the context.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.raceWith = raceWith;\nconst random = effect.random;\n/**\n * Retreives the `Random` service from the context and uses it to run the\n * specified workflow.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.random = random;\nconst randomWith = effect.randomWith;\n/**\n * Folds an `Iterable<A>` using an effectual function f, working sequentially\n * from left to right.\n *\n * @since 1.0.0\n * @category folding\n */\nexports.randomWith = randomWith;\nconst reduce = effect.reduce;\n/**\n * Reduces an `Iterable<Effect<R, E, A>>` to a single effect, working\n * sequentially.\n *\n * @since 1.0.0\n * @category folding\n */\nexports.reduce = reduce;\nconst reduceAll = effect.reduceAll;\n/**\n * Reduces an `Iterable<Effect<R, E, A>>` to a single effect, working in\n * parallel.\n *\n * @since 1.0.0\n * @category folding\n */\nexports.reduceAll = reduceAll;\nconst reduceAllPar = fiberRuntime.reduceAllPar;\n/**\n * Folds an `Iterable<A>` using an effectual function f, working sequentially from left to right.\n *\n * @since 1.0.0\n * @category folding\n */\nexports.reduceAllPar = reduceAllPar;\nconst reduceRight = effect.reduceRight;\n/**\n * Folds over the elements in this chunk from the left, stopping the fold early\n * when the predicate is not satisfied.\n *\n * @since 1.0.0\n * @category folding\n */\nexports.reduceRight = reduceRight;\nconst reduceWhile = effect.reduceWhile;\n/**\n * Keeps some of the errors, and terminates the fiber with the rest\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.reduceWhile = reduceWhile;\nconst refineOrDie = effect.refineOrDie;\n/**\n * Keeps some of the errors, and terminates the fiber with the rest, using\n * the specified function to convert the `E` into a defect.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.refineOrDie = refineOrDie;\nconst refineOrDieWith = effect.refineOrDieWith;\n/**\n * Keeps only the error matching the specified tag, and terminates the fiber\n * with the rest\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.refineOrDieWith = refineOrDieWith;\nconst refineTagOrDie = effect.refineTagOrDie;\n/**\n * Keeps only the error matching the specified tag, and terminates the fiber\n * with the rest, using the specified function to convert the `E` into a defect.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.refineTagOrDie = refineTagOrDie;\nconst refineTagOrDieWith = effect.refineTagOrDieWith;\n/**\n * Fail with the returned value if the `PartialFunction` matches, otherwise\n * continue with our held value.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.refineTagOrDieWith = refineTagOrDieWith;\nconst reject = effect.reject;\n/**\n * Continue with the returned computation if the `PartialFunction` matches,\n * translating the successful match into a failure, otherwise continue with\n * our held value.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.reject = reject;\nconst rejectEffect = effect.rejectEffect;\n/**\n * Returns a new effect that repeats this effect according to the specified\n * schedule or until the first failure. Scheduled recurrences are in addition\n * to the first execution, so that `io.repeat(Schedule.once)` yields an effect\n * that executes `io`, and then if that succeeds, executes `io` an additional\n * time.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.rejectEffect = rejectEffect;\nconst repeat = _schedule.repeat_Effect;\n/**\n * Returns a new effect that repeats this effect the specified number of times\n * or until the first failure. Repeats are in addition to the first execution,\n * so that `io.repeatN(1)` yields an effect that executes `io`, and then if\n * that succeeds, executes `io` an additional time.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.repeat = repeat;\nconst repeatN = effect.repeatN;\n/**\n * Returns a new effect that repeats this effect according to the specified\n * schedule or until the first failure, at which point, the failure value and\n * schedule output are passed to the specified handler.\n *\n * Scheduled recurrences are in addition to the first execution, so that\n * `pipe(effect, Effect.repeat(Schedule.once()))` yields an effect that executes\n * `effect`, and then if that succeeds, executes `effect` an additional time.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.repeatN = repeatN;\nconst repeatOrElse = _schedule.repeatOrElse_Effect;\n/**\n * Returns a new effect that repeats this effect according to the specified\n * schedule or until the first failure, at which point, the failure value and\n * schedule output are passed to the specified handler.\n *\n * Scheduled recurrences are in addition to the first execution, so that\n * `pipe(effect, Effect.repeat(Schedule.once()))` yields an effect that executes\n * `effect`, and then if that succeeds, executes `effect` an additional time.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.repeatOrElse = repeatOrElse;\nconst repeatOrElseEither = _schedule.repeatOrElseEither_Effect;\n/**\n * Repeats this effect until its value satisfies the specified predicate or\n * until the first failure.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.repeatOrElseEither = repeatOrElseEither;\nconst repeatUntil = _schedule.repeatUntil_Effect;\n/**\n * Repeats this effect until its value satisfies the specified effectful\n * predicate or until the first failure.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.repeatUntil = repeatUntil;\nconst repeatUntilEffect = _schedule.repeatUntilEffect_Effect;\n/**\n * Repeats this effect until its value is equal to the specified value or\n * until the first failure.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.repeatUntilEffect = repeatUntilEffect;\nconst repeatUntilEquals = _schedule.repeatUntilEquals_Effect;\n/**\n * Repeats this effect while its value satisfies the specified effectful\n * predicate or until the first failure.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.repeatUntilEquals = repeatUntilEquals;\nconst repeatWhile = _schedule.repeatWhile_Effect;\n/**\n * Repeats this effect while its value satisfies the specified effectful\n * predicate or until the first failure.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.repeatWhile = repeatWhile;\nconst repeatWhileEffect = _schedule.repeatWhileEffect_Effect;\n/**\n * Repeats this effect for as long as its value is equal to the specified\n * value or until the first failure.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.repeatWhileEffect = repeatWhileEffect;\nconst repeatWhileEquals = _schedule.repeatWhileEquals_Effect;\n/**\n * Retries with the specified retry policy. Retries are done following the\n * failure of the original `io` (up to a fixed maximum with `once` or `recurs`\n * for example), so that that `io.retry(Schedule.once)` means \"execute `io`\n * and in case of failure, try again once\".\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.repeatWhileEquals = repeatWhileEquals;\nconst retry = _schedule.retry_Effect;\n/**\n * Retries this effect the specified number of times.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.retry = retry;\nconst retryN = _schedule.retryN_Effect;\n/**\n * Retries with the specified schedule, until it fails, and then both the\n * value produced by the schedule together with the last error are passed to\n * the recovery function.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.retryN = retryN;\nconst retryOrElse = _schedule.retryOrElse_Effect;\n/**\n * Retries with the specified schedule, until it fails, and then both the\n * value produced by the schedule together with the last error are passed to\n * the recovery function.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.retryOrElse = retryOrElse;\nconst retryOrElseEither = _schedule.retryOrElseEither_Effect;\n/**\n * Retries this effect until its error satisfies the specified predicate.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.retryOrElseEither = retryOrElseEither;\nconst retryUntil = _schedule.retryUntil_Effect;\n/**\n * Retries this effect until its error satisfies the specified effectful\n * predicate.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.retryUntil = retryUntil;\nconst retryUntilEffect = _schedule.retryUntilEffect_Effect;\n/**\n * Retries this effect until its error is equal to the specified error.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.retryUntilEffect = retryUntilEffect;\nconst retryUntilEquals = _schedule.retryUntilEquals_Effect;\n/**\n * Retries this effect while its error satisfies the specified predicate.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.retryUntilEquals = retryUntilEquals;\nconst retryWhile = _schedule.retryWhile_Effect;\n/**\n * Retries this effect while its error satisfies the specified effectful\n * predicate.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.retryWhile = retryWhile;\nconst retryWhileEffect = _schedule.retryWhileEffect_Effect;\n/**\n * Retries this effect for as long as its error is equal to the specified\n * error.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.retryWhileEffect = retryWhileEffect;\nconst retryWhileEquals = _schedule.retryWhileEquals_Effect;\n/**\n * Replicates the given effect `n` times.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.retryWhileEquals = retryWhileEquals;\nconst replicate = effect.replicate;\n/**\n * Performs this effect the specified number of times and collects the\n * results.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.replicate = replicate;\nconst replicateEffect = effect.replicateEffect;\n/**\n * Performs this effect the specified number of times, discarding the results.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.replicateEffect = replicateEffect;\nconst replicateEffectDiscard = effect.replicateEffectDiscard;\n/**\n * Unearth the unchecked failure of the effect (opposite of `orDie`).\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.replicateEffectDiscard = replicateEffectDiscard;\nconst resurrect = effect.resurrect;\n/**\n * \"Zooms in\" on the value in the `Right` side of an `Either`, moving the\n * possibility that the value is a `Left` to the error channel.\n *\n * @since 1.0.0\n * @category getters\n */\nexports.resurrect = resurrect;\nconst right = effect.right;\n/**\n * Performs the specified operation while \"zoomed in\" on the `Right` case of an\n * `Either`.\n *\n * @since 1.0.0\n * @category getters\n */\nexports.right = right;\nconst rightWith = effect.rightWith;\n/**\n * Returns an effect that accesses the runtime, which can be used to\n * (unsafely) execute tasks. This is useful for integration with legacy code\n * that must call back into Effect code.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.rightWith = rightWith;\nconst runtime = _runtime.runtime;\n/**\n * Retrieves an effect that succeeds with the current runtime flags, which\n * govern behavior and features of the runtime system.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.runtime = runtime;\nconst runtimeFlags = core.runtimeFlags;\n/**\n * Exposes the full `Cause` of failure for the specified effect.\n *\n * @since 1.0.0\n * @category error handling\n */\nexports.runtimeFlags = runtimeFlags;\nconst sandbox = effect.sandbox;\n/**\n * Runs this effect according to the specified schedule.\n *\n * See `scheduleFrom` for a variant that allows the schedule's decision to\n * depend on the result of this effect.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.sandbox = sandbox;\nconst schedule = _schedule.schedule_Effect;\n/**\n * Runs this effect according to the specified schedule in a new fiber\n * attached to the current scope.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.schedule = schedule;\nconst scheduleForked = circular.scheduleForked;\n/**\n * Runs this effect according to the specified schedule starting from the\n * specified input value.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.scheduleForked = scheduleForked;\nconst scheduleFrom = _schedule.scheduleFrom_Effect;\n/**\n * @since 1.0.0\n * @category context\n */\nexports.scheduleFrom = scheduleFrom;\nconst scope = fiberRuntime.scope;\n/**\n * Accesses the current scope and uses it to perform the specified effect.\n *\n * @since 1.0.0\n * @category scoping\n */\nexports.scope = scope;\nconst scopeWith = fiberRuntime.scopeWith;\n/**\n * Scopes all resources uses in this workflow to the lifetime of the workflow,\n * ensuring that their finalizers are run as soon as this workflow completes\n * execution, whether by success, failure, or interruption.\n *\n * @since 1.0.0\n * @category context\n */\nexports.scopeWith = scopeWith;\nconst scoped = fiberRuntime.scopedEffect;\n/**\n * Returns a new scoped workflow that runs finalizers added to the scope of\n * this workflow sequentially in the reverse of the order in which they were\n * added. Note that finalizers are run sequentially by default so this only\n * has meaning if used within a scope where finalizers are being run in\n * parallel.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.scoped = scoped;\nconst sequentialFinalizers = fiberRuntime.sequentialFinalizers;\n/**\n * Extracts the specified service from the context of the effect.\n *\n * @since 1.0.0\n * @category context\n */\nexports.sequentialFinalizers = sequentialFinalizers;\nconst service = core.service;\n/**\n * Accesses the specified service in the context of the effect.\n *\n * @since 1.0.0\n * @category context\n */\nexports.service = service;\nconst serviceWith = core.serviceWith;\n/**\n * Effectfully accesses the specified service in the context of the effect.\n *\n * @since 1.0.0\n * @category context\n */\nexports.serviceWith = serviceWith;\nconst serviceWithEffect = core.serviceWithEffect;\n/**\n * Sets the current `ConfigProvider`.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.serviceWithEffect = serviceWithEffect;\nconst setConfigProvider = circularLayer.setConfigProvider;\n/**\n * Sets the `FiberRef` values for the fiber running this effect to the values\n * in the specified collection of `FiberRef` values.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.setConfigProvider = setConfigProvider;\nconst setFiberRefs = effect.setFiberRefs;\n/**\n * Returns an effect that suspends for the specified duration. This method is\n * asynchronous, and does not actually block the fiber executing the effect.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.setFiberRefs = setFiberRefs;\nconst sleep = effect.sleep;\n/**\n * Converts an option on values into an option on errors.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.sleep = sleep;\nconst some = fiberRuntime.some;\n/**\n * Extracts the optional value, or returns the given 'orElse'.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.some = some;\nconst someOrElse = effect.someOrElse;\n/**\n * Extracts the optional value, or executes the given 'orElse' effect.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.someOrElse = someOrElse;\nconst someOrElseEffect = effect.someOrElseEffect;\n/**\n * Extracts the optional value, or fails with the given error 'e'.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.someOrElseEffect = someOrElseEffect;\nconst someOrFail = effect.someOrFail;\n/**\n * Extracts the optional value, or fails with a `NoSuchElementException`.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.someOrFail = someOrFail;\nconst someOrFailException = effect.someOrFailException;\n/**\n * Perfoms the specified operation while \"zoomed in\" on the `Some` case of an\n * `Option`.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.someOrFailException = someOrFailException;\nconst someWith = fiberRuntime.someWith;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexports.someWith = someWith;\nconst succeed = core.succeed;\n/**\n * Returns an effect which succeeds with the value wrapped in a `Left`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.succeed = succeed;\nconst succeedLeft = effect.succeedLeft;\n/**\n * Returns an effect which succeeds with `None`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.succeedLeft = succeedLeft;\nconst succeedNone = effect.succeedNone;\n/**\n * Returns an effect which succeeds with the value wrapped in a `Right`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.succeedNone = succeedNone;\nconst succeedRight = effect.succeedRight;\n/**\n * Returns an effect which succeeds with the value wrapped in a `Some`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.succeedRight = succeedRight;\nconst succeedSome = effect.succeedSome;\n/**\n * Summarizes a effect by computing some value before and after execution, and\n * then combining the values to produce a summary, together with the result of\n * execution.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.succeedSome = succeedSome;\nconst summarized = effect.summarized;\n/**\n * Returns an effect with the behavior of this one, but where all child fibers\n * forked in the effect are reported to the specified supervisor.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.summarized = summarized;\nconst supervised = circular.supervised;\n/**\n * Returns a lazily constructed effect, whose construction may itself require\n * effects. When no context is required (i.e., when `R == unknown`) it is\n * conceptually equivalent to `flatten(succeed(io))`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.supervised = supervised;\nconst attemptSuspend = effect.attemptSuspend;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexports.attemptSuspend = attemptSuspend;\nconst suspend = core.suspend;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexports.suspend = suspend;\nconst sync = core.sync;\n/**\n * Takes all elements so long as the effectual predicate returns true.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.sync = sync;\nconst takeWhile = effect.takeWhile;\n/**\n * Tags each metric in this effect with the specific tag.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.takeWhile = takeWhile;\nconst tagged = effect.tagged;\n/**\n * Tags each metric in this effect with the specific tag.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.tagged = tagged;\nconst taggedWithLabels = effect.taggedWithLabels;\n/**\n * Tags each metric in this effect with the specific tag.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.taggedWithLabels = taggedWithLabels;\nconst taggedWithLabelSet = effect.taggedWithLabelSet;\n/**\n * Tags each metric in a scope with a the specific tag.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.taggedWithLabelSet = taggedWithLabelSet;\nconst taggedScoped = fiberRuntime.taggedScoped;\n/**\n * Tags each metric in a scope with a the specific tag.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.taggedScoped = taggedScoped;\nconst taggedScopedWithLabels = fiberRuntime.taggedScopedWithLabels;\n/**\n * Tags each metric in a scope with a the specific tag.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.taggedScopedWithLabels = taggedScopedWithLabels;\nconst taggedScopedWithLabelSet = fiberRuntime.taggedScopedWithLabelSet;\n/**\n * Retrieves the metric tags associated with the current scope.\n *\n * @since 1.0.0\n * @category getters\n */\nexports.taggedScopedWithLabelSet = taggedScopedWithLabelSet;\nconst tags = core.tags;\n/**\n * @since 1.0.0\n * @category sequencing\n */\nexports.tags = tags;\nconst tap = core.tap;\n/**\n * Returns an effect that effectfully \"peeks\" at the failure or success of\n * this effect.\n *\n * @since 1.0.0\n * @category sequencing\n */\nexports.tap = tap;\nconst tapBoth = effect.tapBoth;\n/**\n * Returns an effect that effectually \"peeks\" at the defect of this effect.\n *\n * @since 1.0.0\n * @category sequencing\n */\nexports.tapBoth = tapBoth;\nconst tapDefect = effect.tapDefect;\n/**\n * Returns an effect that effectfully \"peeks\" at the result of this effect.\n *\n * @since 1.0.0\n * @category sequencing\n */\nexports.tapDefect = tapDefect;\nconst tapEither = effect.tapEither;\n/**\n * Returns an effect that effectfully \"peeks\" at the failure of this effect.\n *\n * @since 1.0.0\n * @category sequencing\n */\nexports.tapEither = tapEither;\nconst tapError = effect.tapError;\n/**\n * Returns an effect that effectually \"peeks\" at the cause of the failure of\n * this effect.\n *\n * @since 1.0.0\n * @category sequencing\n */\nexports.tapError = tapError;\nconst tapErrorCause = effect.tapErrorCause;\n/**\n * Returns an effect that effectfully \"peeks\" at the success of this effect.\n * If the partial function isn't defined at the input, the result is\n * equivalent to the original effect.\n *\n * @since 1.0.0\n * @category sequencing\n */\nexports.tapErrorCause = tapErrorCause;\nconst tapSome = effect.tapSome;\n/**\n * Returns a new effect that executes this one and times the execution.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.tapSome = tapSome;\nconst timed = effect.timed;\n/**\n * A more powerful variation of `timed` that allows specifying the clock.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.timed = timed;\nconst timedWith = effect.timedWith;\n/**\n * Returns an effect that will timeout this effect, returning `None` if the\n * timeout elapses before the effect has produced a value; and returning\n * `Some` of the produced value otherwise.\n *\n * If the timeout elapses without producing a value, the running effect will\n * be safely interrupted.\n *\n * WARNING: The effect returned by this method will not itself return until\n * the underlying effect is actually interrupted. This leads to more\n * predictable resource utilization. If early return is desired, then instead\n * of using `effect.timeout(d)`, use `effect.disconnect.timeout(d)`, which\n * first disconnects the effect's interruption signal before performing the\n * timeout, resulting in earliest possible return, before an underlying effect\n * has been successfully interrupted.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.timedWith = timedWith;\nconst timeout = circular.timeout;\n/**\n * The same as `timeout`, but instead of producing a `None` in the event of\n * timeout, it will produce the specified error.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.timeout = timeout;\nconst timeoutFail = circular.timeoutFail;\n/**\n * The same as `timeout`, but instead of producing a `None` in the event of\n * timeout, it will produce the specified failure.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.timeoutFail = timeoutFail;\nconst timeoutFailCause = circular.timeoutFailCause;\n/**\n * Returns an effect that will timeout this effect, returning either the\n * default value if the timeout elapses before the effect has produced a\n * value or returning the result of applying the function `f` to the\n * success value of the effect.\n *\n * If the timeout elapses without producing a value, the running effect will\n * be safely interrupted.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.timeoutFailCause = timeoutFailCause;\nconst timeoutTo = circular.timeoutTo;\n/**\n * Constructs a layer from this effect.\n *\n * @since 1.0.0\n * @category conversions\n */\nexports.timeoutTo = timeoutTo;\nconst toLayer = layer.toLayer;\n/**\n * Constructs a layer from this effect.\n *\n * @since 1.0.0\n * @category conversions\n */\nexports.toLayer = toLayer;\nconst toLayerContext = layer.fromEffectContext;\n/**\n * Constructs a layer from this effect.\n *\n * @since 1.0.0\n * @category conversions\n */\nexports.toLayerContext = toLayerContext;\nconst toLayerDiscard = layer.fromEffectDiscard;\n/**\n * Constructs a layer from this effect.\n *\n * @since 1.0.0\n * @category conversions\n */\nexports.toLayerDiscard = toLayerDiscard;\nconst toLayerScopedDiscard = layer.scopedDiscard;\n/**\n * Constructs a layer from this effect.\n *\n * @since 1.0.0\n * @category conversions\n */\nexports.toLayerScopedDiscard = toLayerScopedDiscard;\nconst toLayerScoped = layer.toLayerScoped;\n/**\n * Transplants specified effects so that when those effects fork other\n * effects, the forked effects will be governed by the scope of the fiber that\n * executes this effect.\n *\n * This can be used to \"graft\" deep grandchildren onto a higher-level scope,\n * effectively extending their lifespans into the parent scope.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.toLayerScoped = toLayerScoped;\nconst transplant = core.transplant;\n/**\n * Imports a synchronous side-effect into a pure value, translating any\n * thrown exceptions into typed failed effects.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.transplant = transplant;\nconst attemptCatch = effect.attemptCatch;\n/**\n * Create an `Effect` that when executed will construct `promise` and wait for\n * its result, errors will be handled using `onReject`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.attemptCatch = attemptCatch;\nconst attemptCatchPromise = effect.attemptCatchPromise;\n/**\n * Like `tryCatchPromise` but allows for interruption via AbortSignal\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.attemptCatchPromise = attemptCatchPromise;\nconst attemptCatchPromiseInterrupt = effect.attemptCatchPromiseInterrupt;\n/**\n * Executed `that` in case `self` fails with a `Cause` that doesn't contain\n * defects, executes `success` in case of successes\n *\n * @since 1.0.0\n * @category alternatives\n */\nexports.attemptCatchPromiseInterrupt = attemptCatchPromiseInterrupt;\nconst attemptOrElse = core.attemptOrElse;\n/**\n * Create an `Effect` that when executed will construct `promise` and wait for\n * its result, errors will produce failure as `unknown`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.attemptOrElse = attemptOrElse;\nconst attemptPromise = effect.attemptPromise;\n/**\n * Like `tryPromise` but allows for interruption via AbortSignal\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.attemptPromise = attemptPromise;\nconst attemptPromiseInterrupt = effect.attemptPromiseInterrupt;\n/**\n * Runs all the provided effects in sequence respecting the structure provided in input.\n *\n * Supports multiple arguments, a single argument tuple / array or record / struct.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.attemptPromiseInterrupt = attemptPromiseInterrupt;\nconst all = effect.all;\n/**\n * Runs all the provided effects in parallel respecting the structure provided in input.\n *\n * Supports multiple arguments, a single argument tuple / array or record / struct.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.all = all;\nconst allPar = fiberRuntime.allPar;\n/**\n * Used to unify functions that would otherwise return `Effect<A, B, C> | Effect<D, E, F>`\n *\n * @category utilities\n * @since 1.0.0\n */\nexports.allPar = allPar;\nconst unified = core.unified;\n/**\n * When this effect succeeds with a cause, then this method returns a new\n * effect that either fails with the cause that this effect succeeded with, or\n * succeeds with unit, depending on whether the cause is empty.\n *\n * This operation is the opposite of `cause`.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.unified = unified;\nconst uncause = effect.uncause;\n/**\n * Constructs a `Chunk` by repeatedly applying the effectual function `f` as\n * long as it returns `Some`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.uncause = uncause;\nconst unfold = effect.unfold;\n/**\n * @since 1.0.0\n * @category interruption\n */\nexports.unfold = unfold;\nconst uninterruptible = core.uninterruptible;\n/**\n * @since 1.0.0\n * @category interruption\n */\nexports.uninterruptible = uninterruptible;\nconst uninterruptibleMask = core.uninterruptibleMask;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexports.uninterruptibleMask = uninterruptibleMask;\nconst unit = core.unit;\n/**\n * Converts a `Effect<R, Either<E, B>, A>` into a `Effect<R, E, Either<A, B>>`.\n * The inverse of `left`.\n *\n * @since 1.0.0\n * @category getters\n */\nexports.unit = unit;\nconst unleft = effect.unleft;\n/**\n * The moral equivalent of `if (!p) exp`.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.unleft = unleft;\nconst unless = effect.unless;\n/**\n * The moral equivalent of `if (!p) exp` when `p` has side-effects.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.unless = unless;\nconst unlessEffect = effect.unlessEffect;\n/**\n * Takes some fiber failures and converts them into errors.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.unlessEffect = unlessEffect;\nconst unrefine = effect.unrefine;\n/**\n * Takes some fiber failures and converts them into errors, using the specified\n * function to convert the `E` into an `E1 | E2`.\n *\n * @since 1.0.0\n * @category error handling\n */\nexports.unrefine = unrefine;\nconst unrefineWith = effect.unrefineWith;\n/**\n * Converts a `Effect<R, Either<B, E>, A>` into a `Effect<R, E, Either<B, A>>`.\n * The inverse of `right`.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.unrefineWith = unrefineWith;\nconst unright = effect.unright;\n/**\n * Unsafely creates a new Semaphore\n *\n * @since 1.0.0\n * @category locking\n */\nexports.unright = unright;\nconst unsafeMakeSemaphore = circular.unsafeMakeSemaphore;\n/**\n * Creates a new Semaphore\n *\n * @since 1.0.0\n * @category locking\n */\nexports.unsafeMakeSemaphore = unsafeMakeSemaphore;\nconst makeSemaphore = circular.makeSemaphore;\n/**\n * @since 1.0.0\n * @category execution\n */\nexports.makeSemaphore = makeSemaphore;\nconst runFork = _runtime.unsafeForkEffect;\n/**\n * @since 1.0.0\n * @category execution\n */\nexports.runFork = runFork;\nconst runCallback = _runtime.unsafeRunEffect;\n/**\n * @since 1.0.0\n * @category execution\n */\nexports.runCallback = runCallback;\nconst runPromiseEither = _runtime.unsafeRunPromiseEitherEffect;\n/**\n * Runs an `Effect` workflow, returning a `Promise` which resolves with the\n * result of the workflow or rejects with an error.\n *\n * @since 1.0.0\n * @category execution\n */\nexports.runPromiseEither = runPromiseEither;\nconst runPromise = _runtime.unsafeRunPromiseEffect;\n/**\n * Runs an `Effect` workflow, returning a `Promise` which resolves with the\n * `Exit` value of the workflow.\n *\n * @since 1.0.0\n * @category execution\n */\nexports.runPromise = runPromise;\nconst runPromiseExit = _runtime.unsafeRunPromiseExitEffect;\n/**\n * @since 1.0.0\n * @category execution\n */\nexports.runPromiseExit = runPromiseExit;\nconst runSync = _runtime.unsafeRunSyncEffect;\n/**\n * @since 1.0.0\n * @category execution\n */\nexports.runSync = runSync;\nconst runSyncExit = _runtime.unsafeRunSyncExitEffect;\n/**\n * @since 1.0.0\n * @category execution\n */\nexports.runSyncExit = runSyncExit;\nconst runSyncExitOrFiber = _runtime.unsafeRunSyncExitOrFiberEffect;\n/**\n * @since 1.0.0\n * @category execution\n */\nexports.runSyncExitOrFiber = runSyncExitOrFiber;\nconst runSyncEither = _runtime.unsafeRunSyncEitherEffect;\n/**\n * The inverse operation `sandbox(effect)`\n *\n * Terminates with exceptions on the `Left` side of the `Either` error, if it\n * exists. Otherwise extracts the contained `Effect< R, E, A>`\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.runSyncEither = runSyncEither;\nconst unsandbox = effect.unsandbox;\n/**\n * Scopes all resources acquired by `resource` to the lifetime of `use`\n * without effecting the scope of any resources acquired by `use`.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.unsandbox = unsandbox;\nconst using = fiberRuntime.using;\n/**\n * Converts an option on errors into an option on values.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.using = using;\nconst unsome = fiberRuntime.unsome;\n/**\n * Updates the `FiberRef` values for the fiber running this effect using the\n * specified function.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.unsome = unsome;\nconst updateFiberRefs = effect.updateFiberRefs;\n/**\n * @since 1.0.0\n * @category runtime\n */\nexports.updateFiberRefs = updateFiberRefs;\nconst updateRuntimeFlags = core.updateRuntimeFlags;\n/**\n * Updates the service with the required service entry.\n *\n * @since 1.0.0\n * @category context\n */\nexports.updateRuntimeFlags = updateRuntimeFlags;\nconst updateService = effect.updateService;\n/**\n * Sequentially zips the this result with the specified result. Combines both\n * `Cause`s when both effects fail.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.updateService = updateService;\nconst validate = effect.validate;\n/**\n * Returns an effect that executes both this effect and the specified effect,\n * in parallel. Combines both Cause<E1>` when both effects fail.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.validate = validate;\nconst validatePar = circular.validatePar;\n/**\n * Feeds elements of type `A` to `f` and accumulates all errors in error\n * channel or successes in success channel.\n *\n * This combinator is lossy meaning that if there are errors all successes\n * will be lost. To retain all information please use `partition`.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.validatePar = validatePar;\nconst validateAll = effect.validateAll;\n/**\n * Feeds elements of type `A` to `f `and accumulates, in parallel, all errors\n * in error channel or successes in success channel.\n *\n * This combinator is lossy meaning that if there are errors all successes\n * will be lost. To retain all information please use [[partitionPar]].\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.validateAll = validateAll;\nconst validateAllPar = fiberRuntime.validateAllPar;\n/**\n * Feeds elements of type `A` to `f` and accumulates all errors, discarding\n * the successes.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.validateAllPar = validateAllPar;\nconst validateAllDiscard = effect.validateAllDiscard;\n/**\n * Feeds elements of type `A` to `f` in parallel and accumulates all errors,\n * discarding the successes.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.validateAllDiscard = validateAllDiscard;\nconst validateAllParDiscard = fiberRuntime.validateAllParDiscard;\n/**\n * Feeds elements of type `A` to `f` until it succeeds. Returns first success\n * or the accumulation of all errors.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.validateAllParDiscard = validateAllParDiscard;\nconst validateFirst = effect.validateFirst;\n/**\n * Feeds elements of type `A` to `f` until it succeeds. Returns first success\n * or the accumulation of all errors.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.validateFirst = validateFirst;\nconst validateFirstPar = fiberRuntime.validateFirstPar;\n/**\n * Sequentially zips this effect with the specified effect using the specified\n * combiner function. Combines the causes in case both effect fail.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.validateFirstPar = validateFirstPar;\nconst validateWith = effect.validateWith;\n/**\n * Returns an effect that executes both this effect and the specified effect,\n * in parallel, combining their results with the specified `f` function. If\n * both sides fail, then the cause will be combined.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.validateWith = validateWith;\nconst validateWithPar = circular.validateWithPar;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexports.validateWithPar = validateWithPar;\nconst whileLoop = core.whileLoop;\n/**\n * The moral equivalent of `if (p) exp`.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.whileLoop = whileLoop;\nconst when = effect.when;\n/**\n * Runs an effect when the supplied partial function matches for the given\n * value, otherwise does nothing.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.when = when;\nconst whenCase = effect.whenCase;\n/**\n * Runs an effect when the supplied partial function matches for the given\n * value, otherwise does nothing.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.whenCase = whenCase;\nconst whenCaseEffect = effect.whenCaseEffect;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexports.whenCaseEffect = whenCaseEffect;\nconst whenEffect = core.whenEffect;\n/**\n * Executes this workflow when value of the specified `FiberRef` satisfies the\n * predicate.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.whenEffect = whenEffect;\nconst whenFiberRef = effect.whenFiberRef;\n/**\n * Executes this workflow when the value of the `Ref` satisfies the predicate.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.whenFiberRef = whenFiberRef;\nconst whenRef = effect.whenRef;\n/**\n * Executes the specified workflow with the specified implementation of the\n * clock service.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.whenRef = whenRef;\nconst withClock = defaultServices.withClock;\n/**\n * Sets the implementation of the clock service to the specified value and\n * restores it to its original value when the scope is closed.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.withClock = withClock;\nconst withClockScoped = fiberRuntime.withClockScoped;\n/**\n * Executes the specified workflow with the specified configuration provider.\n *\n * @since 1.0.0\n * @category config\n */\nexports.withClockScoped = withClockScoped;\nconst withConfigProvider = defaultServices.withConfigProvider;\n/**\n * Sets the configuration provider to the specified value and restores it to its original value\n * when the scope is closed.\n *\n * @since 1.0.0\n * @category config\n */\nexports.withConfigProvider = withConfigProvider;\nconst withConfigProviderScoped = fiberRuntime.withConfigProviderScoped;\n/**\n * Returns a new scoped workflow that returns the result of this workflow as\n * well as a finalizer that can be run to close the scope of this workflow.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.withConfigProviderScoped = withConfigProviderScoped;\nconst withEarlyRelease = fiberRuntime.withEarlyRelease;\n/**\n * @since 1.0.0\n * @category mutations\n */\nexports.withEarlyRelease = withEarlyRelease;\nconst withMetric = effect.withMetric;\n/**\n * @since 1.0.0\n * @category concurrency\n */\nexports.withMetric = withMetric;\nconst withParallelism = core.withParallelism;\n/**\n * Runs the specified effect with an unbounded maximum number of fibers for\n * parallel operations.\n *\n * @since 1.0.0\n * @category aspects\n */\nexports.withParallelism = withParallelism;\nconst withParallelismUnbounded = core.withParallelismUnbounded;\n/**\n * @since 1.0.0\n * @category runtime\n */\nexports.withParallelismUnbounded = withParallelismUnbounded;\nconst withRuntimeFlags = core.withRuntimeFlags;\n/**\n * @since 1.0.0\n * @category runtime\n */\nexports.withRuntimeFlags = withRuntimeFlags;\nconst withRuntimeFlagsScoped = fiberRuntime.withRuntimeFlagsScoped;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexports.withRuntimeFlagsScoped = withRuntimeFlagsScoped;\nconst yieldNow = core.yieldNow;\n/**\n * @since 1.0.0\n * @category products\n */\nexports.yieldNow = yieldNow;\nconst zip = core.zip;\n/**\n * @since 1.0.0\n * @category products\n */\nexports.zip = zip;\nconst zipLeft = core.zipLeft;\n/**\n * @since 1.0.0\n * @category products\n */\nexports.zipLeft = zipLeft;\nconst zipRight = core.zipRight;\n/**\n * @since 1.0.0\n * @category products\n */\nexports.zipRight = zipRight;\nconst zipWith = core.zipWith;\n/**\n * Zips this effect and that effect in parallel.\n *\n * @since 1.0.0\n * @category zipping\n */\nexports.zipWith = zipWith;\nconst zipPar = circular.zipPar;\n/**\n * Returns an effect that executes both this effect and the specified effect,\n * in parallel, returning result of that effect. If either side fails,\n * then the other side will be interrupted.\n *\n * @since 1.0.0\n * @category zipping\n */\nexports.zipPar = zipPar;\nconst zipParLeft = circular.zipParLeft;\n/**\n * Returns an effect that executes both this effect and the specified effect,\n * in parallel, returning result of the provided effect. If either side fails,\n * then the other side will be interrupted.\n *\n * @since 1.0.0\n * @category zipping\n */\nexports.zipParLeft = zipParLeft;\nconst zipParRight = circular.zipParRight;\n/**\n * Sequentially zips this effect with the specified effect using the\n * specified combiner function.\n *\n * @since 1.0.0\n * @category zipping\n */\nexports.zipParRight = zipParRight;\nconst zipWithPar = circular.zipWithPar;\nexports.zipWithPar = zipWithPar;\n//# sourceMappingURL=Effect.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.sequential = exports.parallelN = exports.parallel = exports.match = exports.isSequential = exports.isParallelN = exports.isParallel = void 0;\nvar internal = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/executionStrategy\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/**\n * Execute effects sequentially.\n *\n * @since 1.0.0\n * @category constructors\n */\nconst sequential = internal.sequential;\n/**\n * Execute effects in parallel.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.sequential = sequential;\nconst parallel = internal.parallel;\n/**\n * Execute effects in parallel, up to the specified number of concurrent fibers.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.parallel = parallel;\nconst parallelN = internal.parallelN;\n/**\n * Returns `true` if the specified `ExecutionStrategy` is an instance of\n * `Sequential`, `false` otherwise.\n *\n * @since 1.0.0\n * @category refinements\n */\nexports.parallelN = parallelN;\nconst isSequential = internal.isSequential;\n/**\n * Returns `true` if the specified `ExecutionStrategy` is an instance of\n * `Sequential`, `false` otherwise.\n *\n * @since 1.0.0\n * @category refinements\n */\nexports.isSequential = isSequential;\nconst isParallel = internal.isParallel;\n/**\n * Returns `true` if the specified `ExecutionStrategy` is an instance of\n * `Sequential`, `false` otherwise.\n *\n * @since 1.0.0\n * @category refinements\n */\nexports.isParallel = isParallel;\nconst isParallelN = internal.isParallelN;\n/**\n * Folds over the specified `ExecutionStrategy` using the provided case\n * functions.\n *\n * @since 1.0.0\n * @category folding\n */\nexports.isParallelN = isParallelN;\nconst match = internal.match;\nexports.match = match;\n//# sourceMappingURL=ExecutionStrategy.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.zipWith = exports.zipRight = exports.zipParRight = exports.zipParLeft = exports.zipPar = exports.zipLeft = exports.zip = exports.unit = exports.unannotate = exports.succeed = exports.matchEffect = exports.match = exports.mapErrorCause = exports.mapError = exports.mapBoth = exports.map = exports.isSuccess = exports.isInterrupted = exports.isFailure = exports.isExit = exports.interrupt = exports.getOrElse = exports.fromOption = exports.fromEither = exports.forEachEffect = exports.flatten = exports.flatMapEffect = exports.flatMap = exports.failCause = exports.fail = exports.exists = exports.die = exports.collectAllPar = exports.collectAll = exports.causeOption = exports.asUnit = exports.as = void 0;\nvar core = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/core\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/**\n * Returns `true` if the specified value is an `Exit`, `false` otherwise.\n *\n * @since 1.0.0\n * @category refinements\n */\nconst isExit = core.exitIsExit;\n/**\n * Returns `true` if the specified `Exit` is a `Failure`, `false` otherwise.\n *\n * @since 1.0.0\n * @category refinements\n */\nexports.isExit = isExit;\nconst isFailure = core.exitIsFailure;\n/**\n * Returns `true` if the specified `Exit` is a `Success`, `false` otherwise.\n *\n * @since 1.0.0\n * @category refinements\n */\nexports.isFailure = isFailure;\nconst isSuccess = core.exitIsSuccess;\n/**\n * Returns `true` if the specified exit is a `Failure` **and** the `Cause` of\n * the failure was due to interruption, `false` otherwise.\n *\n * @since 1.0.0\n * @category getters\n */\nexports.isSuccess = isSuccess;\nconst isInterrupted = core.exitIsInterrupted;\n/**\n * Maps the `Success` value of the specified exit to the provided constant\n * value.\n *\n * @since 1.0.0\n * @category mapping\n */\nexports.isInterrupted = isInterrupted;\nconst as = core.exitAs;\n/**\n * Maps the `Success` value of the specified exit to a void.\n *\n * @since 1.0.0\n * @category mapping\n */\nexports.as = as;\nconst asUnit = core.exitAsUnit;\n/**\n * Returns a `Some<Cause<E>>` if the specified exit is a `Failure`, `None`\n * otherwise.\n *\n * @since 1.0.0\n * @category getters\n */\nexports.asUnit = asUnit;\nconst causeOption = core.exitCauseOption;\n/**\n * Collects all of the specified exit values into a `Some<Exit<E, List<A>>>`. If\n * the provided iterable contains no elements, `None` will be returned.\n *\n * **Note**: `Exit.collectAll` combines `Cause` values sequentially.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.causeOption = causeOption;\nconst collectAll = core.exitCollectAll;\n/**\n * Collects all of the specified exit values into a `Some<Exit<E, List<A>>>`. If\n * the provided iterable contains no elements, `None` will be returned.\n *\n * **Note**: `Exit.collectAll` combines `Cause` values in parallel.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.collectAll = collectAll;\nconst collectAllPar = core.exitCollectAllPar;\n/**\n * Constructs a new `Exit.Failure` from the specified unrecoverable defect.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.collectAllPar = collectAllPar;\nconst die = core.exitDie;\n/**\n * Executes the predicate on the value of the specified exit if it is a\n * `Success`, otherwise returns `false`.\n *\n * @since 1.0.0\n * @category elements\n */\nexports.die = die;\nconst exists = core.exitExists;\n/**\n * Constructs a new `Exit.Failure` from the specified recoverable error of type\n * `E`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.exists = exists;\nconst fail = core.exitFail;\n/**\n * Constructs a new `Exit.Failure` from the specified `Cause` of type `E`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.fail = fail;\nconst failCause = core.exitFailCause;\n/**\n * @since 1.0.0\n * @category sequencing\n */\nexports.failCause = failCause;\nconst flatMap = core.exitFlatMap;\n/**\n * @since 1.0.0\n * @category sequencing\n */\nexports.flatMap = flatMap;\nconst flatMapEffect = core.exitFlatMapEffect;\n/**\n * @since 1.0.0\n * @category sequencing\n */\nexports.flatMapEffect = flatMapEffect;\nconst flatten = core.exitFlatten;\n/**\n * @since 1.0.0\n * @category traversing\n */\nexports.flatten = flatten;\nconst forEachEffect = core.exitForEachEffect;\n/**\n * Converts an `Either<E, A>` into an `Exit<E, A>`.\n *\n * @since 1.0.0\n * @category conversions\n */\nexports.forEachEffect = forEachEffect;\nconst fromEither = core.exitFromEither;\n/**\n * Converts an `Option<A>` into an `Exit<void, A>`.\n *\n * @since 1.0.0\n * @category conversions\n */\nexports.fromEither = fromEither;\nconst fromOption = core.exitFromOption;\n/**\n * Returns the `A` if specified exit is a `Success`, otherwise returns the\n * alternate `A` value computed from the specified function which receives the\n * `Cause<E>` of the exit `Failure`.\n *\n * @since 1.0.0\n * @category getters\n */\nexports.fromOption = fromOption;\nconst getOrElse = core.exitGetOrElse;\n/**\n * Constructs a new `Exit.Failure` from the specified `FiberId` indicating that\n * the `Fiber` running an `Effect` workflow was terminated due to interruption.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.getOrElse = getOrElse;\nconst interrupt = core.exitInterrupt;\n/**\n * Maps over the `Success` value of the specified exit using the provided\n * function.\n *\n * @since 1.0.0\n * @category mapping\n */\nexports.interrupt = interrupt;\nconst map = core.exitMap;\n/**\n * Maps over the `Success` and `Failure` cases of the specified exit using the\n * provided functions.\n *\n * @since 1.0.0\n * @category mapping\n */\nexports.map = map;\nconst mapBoth = core.exitMapBoth;\n/**\n * Maps over the error contained in the `Failure` of the specified exit using\n * the provided function.\n *\n * @since 1.0.0\n * @category mapping\n */\nexports.mapBoth = mapBoth;\nconst mapError = core.exitMapError;\n/**\n * Maps over the `Cause` contained in the `Failure` of the specified exit using\n * the provided function.\n *\n * @since 1.0.0\n * @category mapping\n */\nexports.mapError = mapError;\nconst mapErrorCause = core.exitMapErrorCause;\n/**\n * @since 1.0.0\n * @category folding\n */\nexports.mapErrorCause = mapErrorCause;\nconst match = core.exitMatch;\n/**\n * @since 1.0.0\n * @category folding\n */\nexports.match = match;\nconst matchEffect = core.exitMatchEffect;\n/**\n * Constructs a new `Exit.Success` containing the specified value of type `A`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.matchEffect = matchEffect;\nconst succeed = core.exitSucceed;\n/**\n * Removes any annotation from the failure cause\n *\n * @since 1.0.0\n * @category filtering\n */\nexports.succeed = succeed;\nconst unannotate = core.exitUnannotate;\n/**\n * Represents an `Exit` which succeeds with `undefined`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.unannotate = unannotate;\nconst unit = core.exitUnit;\n/**\n * Sequentially zips the this result with the specified result or else returns\n * the failed `Cause<E | E2>`.\n *\n * @since 1.0.0\n * @category zipping\n */\nexports.unit = unit;\nconst zip = core.exitZip;\n/**\n * Sequentially zips the this result with the specified result discarding the\n * second element of the tuple or else returns the failed `Cause<E | E2>`.\n *\n * @since 1.0.0\n * @category zipping\n */\nexports.zip = zip;\nconst zipLeft = core.exitZipLeft;\n/**\n * Sequentially zips the this result with the specified result discarding the\n * first element of the tuple or else returns the failed `Cause<E | E2>`.\n *\n * @since 1.0.0\n * @category zipping\n */\nexports.zipLeft = zipLeft;\nconst zipRight = core.exitZipRight;\n/**\n * Parallelly zips the this result with the specified result or else returns\n * the failed `Cause<E | E2>`.\n *\n * @since 1.0.0\n * @category zipping\n */\nexports.zipRight = zipRight;\nconst zipPar = core.exitZipPar;\n/**\n * Parallelly zips the this result with the specified result discarding the\n * second element of the tuple or else returns the failed `Cause<E | E2>`.\n *\n * @since 1.0.0\n * @category zipping\n */\nexports.zipPar = zipPar;\nconst zipParLeft = core.exitZipParLeft;\n/**\n * Parallelly zips the this result with the specified result discarding the\n * first element of the tuple or else returns the failed `Cause<E | E2>`.\n *\n * @since 1.0.0\n * @category zipping\n */\nexports.zipParLeft = zipParLeft;\nconst zipParRight = core.exitZipParRight;\n/**\n * Zips this exit together with that exit using the specified combination\n * functions.\n *\n * @since 1.0.0\n * @category zipping\n */\nexports.zipParRight = zipParRight;\nconst zipWith = core.exitZipWith;\nexports.zipWith = zipWith;\n//# sourceMappingURL=Exit.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.zipWith = exports.zipRight = exports.zipLeft = exports.zip = exports.unsafeRoots = exports.unit = exports.succeed = exports.status = exports.scoped = exports.roots = exports.pretty = exports.poll = exports.orElseEither = exports.orElse = exports.never = exports.match = exports.mapFiber = exports.mapEffect = exports.map = exports.joinAll = exports.join = exports.isRuntimeFiber = exports.isFiber = exports.interrupted = exports.interruptFork = exports.interruptAsFork = exports.interruptAs = exports.interruptAllAs = exports.interruptAll = exports.interrupt = exports.inheritAll = exports.id = exports.getCurrentFiber = exports.fromEffect = exports.failCause = exports.fail = exports.dumpAll = exports.dump = exports.done = exports.collectAll = exports.children = exports.awaitAll = exports.await = exports.RuntimeFiberTypeId = exports.Order = exports.FiberTypeId = void 0;\nvar core = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/core\"));\nvar circular = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/effect/circular\"));\nvar internal = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/fiber\"));\nvar fiberRuntime = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/fiberRuntime\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/**\n * @since 1.0.0\n * @category symbols\n */\nconst FiberTypeId = internal.FiberTypeId;\n/**\n * @since 1.0.0\n * @category symbols\n */\nexports.FiberTypeId = FiberTypeId;\nconst RuntimeFiberTypeId = internal.RuntimeFiberTypeId;\n/**\n * @since 1.0.0\n * @category instances\n */\nexports.RuntimeFiberTypeId = RuntimeFiberTypeId;\nconst Order = internal.Order;\n/**\n * Returns `true` if the specified value is a `Fiber`, `false` otherwise.\n *\n * @since 1.0.0\n * @category refinements\n */\nexports.Order = Order;\nconst isFiber = internal.isFiber;\n/**\n * Returns `true` if the specified `Fiber` is a `RuntimeFiber`, `false`\n * otherwise.\n *\n * @since 1.0.0\n * @category refinements\n */\nexports.isFiber = isFiber;\nconst isRuntimeFiber = internal.isRuntimeFiber;\n/**\n * The identity of the fiber.\n *\n * @since 1.0.0\n * @category getters\n */\nexports.isRuntimeFiber = isRuntimeFiber;\nconst id = internal.id;\nexports.id = id;\nconst _await = internal._await;\nexports.await = _await;\n/**\n * Awaits on all fibers to be completed, successfully or not.\n *\n * @since 1.0.0\n * @category destructors\n */\nconst awaitAll = fiberRuntime.fiberAwaitAll;\n/**\n * Retrieves the immediate children of the fiber.\n *\n * @since 1.0.0\n * @category getters\n */\nexports.awaitAll = awaitAll;\nconst children = internal.children;\n/**\n * Collects all fibers into a single fiber producing an in-order list of the\n * results.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.children = children;\nconst collectAll = fiberRuntime.fiberCollectAll;\n/**\n * A fiber that is done with the specified `Exit` value.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.collectAll = collectAll;\nconst done = internal.done;\n/**\n * @since 1.0.0\n * @category destructors\n */\nexports.done = done;\nconst dump = internal.dump;\n/**\n * @since 1.0.0\n * @category destructors\n */\nexports.dump = dump;\nconst dumpAll = internal.dumpAll;\n/**\n * A fiber that has already failed with the specified value.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.dumpAll = dumpAll;\nconst fail = internal.fail;\n/**\n * Creates a `Fiber` that has already failed with the specified cause.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.fail = fail;\nconst failCause = internal.failCause;\n/**\n * Lifts an `Effect` into a `Fiber`.\n *\n * @since 1.0.0\n * @category conversions\n */\nexports.failCause = failCause;\nconst fromEffect = internal.fromEffect;\n/**\n * Gets the current fiber if one is running.\n *\n * @since 1.0.0\n * @category utilities\n */\nexports.fromEffect = fromEffect;\nconst getCurrentFiber = internal.getCurrentFiber;\n/**\n * Inherits values from all `FiberRef` instances into current fiber. This\n * will resume immediately.\n *\n * @since 1.0.0\n * @category destructors\n */\nexports.getCurrentFiber = getCurrentFiber;\nconst inheritAll = internal.inheritAll;\n/**\n * Interrupts the fiber from whichever fiber is calling this method. If the\n * fiber has already exited, the returned effect will resume immediately.\n * Otherwise, the effect will resume when the fiber exits.\n *\n * @since 1.0.0\n * @category interruption\n */\nexports.inheritAll = inheritAll;\nconst interrupt = core.interruptFiber;\n/**\n * Constructrs a `Fiber` that is already interrupted.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.interrupt = interrupt;\nconst interrupted = internal.interrupted;\n/**\n * Interrupts the fiber as if interrupted from the specified fiber. If the\n * fiber has already exited, the returned effect will resume immediately.\n * Otherwise, the effect will resume when the fiber exits.\n *\n * @since 1.0.0\n * @category interruption\n */\nexports.interrupted = interrupted;\nconst interruptAs = core.interruptAsFiber;\n/**\n * Interrupts the fiber as if interrupted from the specified fiber. If the\n * fiber has already exited, the returned effect will resume immediately.\n * Otherwise, the effect will resume when the fiber exits.\n *\n * @since 1.0.0\n * @category interruption\n */\nexports.interruptAs = interruptAs;\nconst interruptAsFork = internal.interruptAsFork;\n/**\n * Interrupts all fibers, awaiting their interruption.\n *\n * @since 1.0.0\n * @category interruption\n */\nexports.interruptAsFork = interruptAsFork;\nconst interruptAll = internal.interruptAll;\n/**\n * Interrupts all fibers as by the specified fiber, awaiting their\n * interruption.\n *\n * @since 1.0.0\n * @category interruption\n */\nexports.interruptAll = interruptAll;\nconst interruptAllAs = internal.interruptAllAs;\n/**\n * Interrupts the fiber from whichever fiber is calling this method. The\n * interruption will happen in a separate daemon fiber, and the returned\n * effect will always resume immediately without waiting.\n *\n * @since 1.0.0\n * @category interruption\n */\nexports.interruptAllAs = interruptAllAs;\nconst interruptFork = fiberRuntime.fiberInterruptFork;\n/**\n * Joins the fiber, which suspends the joining fiber until the result of the\n * fiber has been determined. Attempting to join a fiber that has erred will\n * result in a catchable error. Joining an interrupted fiber will result in an\n * \"inner interruption\" of this fiber, unlike interruption triggered by\n * another fiber, \"inner interruption\" can be caught and recovered.\n *\n * @since 1.0.0\n * @category destructors\n */\nexports.interruptFork = interruptFork;\nconst join = internal.join;\n/**\n * Joins all fibers, awaiting their _successful_ completion. Attempting to\n * join a fiber that has erred will result in a catchable error, _if_ that\n * error does not result from interruption.\n *\n * @since 1.0.0\n * @category destructors\n */\nexports.join = join;\nconst joinAll = fiberRuntime.fiberJoinAll;\n/**\n * Maps over the value the Fiber computes.\n *\n * @since 1.0.0\n * @category mapping\n */\nexports.joinAll = joinAll;\nconst map = internal.map;\n/**\n * Effectually maps over the value the fiber computes.\n *\n * @since 1.0.0\n * @category mapping\n */\nexports.map = map;\nconst mapEffect = internal.mapEffect;\n/**\n * Passes the success of this fiber to the specified callback, and continues\n * with the fiber that it returns.\n *\n * @since 1.0.0\n * @category mapping\n */\nexports.mapEffect = mapEffect;\nconst mapFiber = internal.mapFiber;\n/**\n * Folds over the `Fiber` or `RuntimeFiber`.\n *\n * @since 1.0.0\n * @category folding\n */\nexports.mapFiber = mapFiber;\nconst match = internal.match;\n/**\n * A fiber that never fails or succeeds.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.match = match;\nconst never = internal.never;\n/**\n * Returns a fiber that prefers `this` fiber, but falls back to the `that` one\n * when `this` one fails. Interrupting the returned fiber will interrupt both\n * fibers, sequentially, from left to right.\n *\n * @since 1.0.0\n * @category alternatives\n */\nexports.never = never;\nconst orElse = internal.orElse;\n/**\n * Returns a fiber that prefers `this` fiber, but falls back to the `that` one\n * when `this` one fails. Interrupting the returned fiber will interrupt both\n * fibers, sequentially, from left to right.\n *\n * @since 1.0.0\n * @category alternatives\n */\nexports.orElse = orElse;\nconst orElseEither = internal.orElseEither;\n/**\n * Tentatively observes the fiber, but returns immediately if it is not\n * already done.\n *\n * @since 1.0.0\n * @category getters\n */\nexports.orElseEither = orElseEither;\nconst poll = internal.poll;\n/**\n * Pretty-prints a `RuntimeFiber`.\n *\n * @since 1.0.0\n * @category destructors\n */\nexports.poll = poll;\nconst pretty = internal.pretty;\n/**\n * Returns a chunk containing all root fibers.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.pretty = pretty;\nconst roots = internal.roots;\n/**\n * Returns a chunk containing all root fibers.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.roots = roots;\nconst unsafeRoots = internal.unsafeRoots;\n/**\n * Converts this fiber into a scoped effect. The fiber is interrupted when the\n * scope is closed.\n *\n * @since 1.0.0\n * @category destructors\n */\nexports.unsafeRoots = unsafeRoots;\nconst scoped = fiberRuntime.fiberScoped;\n/**\n * Returns the `FiberStatus` of a `RuntimeFiber`.\n *\n * @since 1.0.0\n * @category getters\n */\nexports.scoped = scoped;\nconst status = internal.status;\n/**\n * Returns a fiber that has already succeeded with the specified value.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.status = status;\nconst succeed = internal.succeed;\n/**\n * A fiber that has already succeeded with unit.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.succeed = succeed;\nconst unit = internal.unit;\n/**\n * Zips this fiber and the specified fiber together, producing a tuple of\n * their output.\n *\n * @since 1.0.0\n * @category zipping\n */\nexports.unit = unit;\nconst zip = circular.zipFiber;\n/**\n * Same as `zip` but discards the output of that `Fiber`.\n *\n * @since 1.0.0\n * @category zipping\n */\nexports.zip = zip;\nconst zipLeft = circular.zipLeftFiber;\n/**\n * Same as `zip` but discards the output of this `Fiber`.\n *\n * @since 1.0.0\n * @category zipping\n */\nexports.zipLeft = zipLeft;\nconst zipRight = circular.zipRightFiber;\n/**\n * Zips this fiber with the specified fiber, combining their results using the\n * specified combiner function. Both joins and interruptions are performed in\n * sequential order from left to right.\n *\n * @since 1.0.0\n * @category zipping\n */\nexports.zipRight = zipRight;\nconst zipWith = circular.zipWithFiber;\nexports.zipWith = zipWith;\n//# sourceMappingURL=Fiber.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.unsafeMake = exports.toSet = exports.toOption = exports.threadName = exports.runtime = exports.none = exports.make = exports.isRuntime = exports.isNone = exports.isFiberId = exports.isComposite = exports.ids = exports.getOrElse = exports.composite = exports.combineAll = exports.combine = exports.FiberIdTypeId = void 0;\nvar internal = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/fiberId\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/**\n * @since 1.0.0\n * @category symbols\n */\nconst FiberIdTypeId = internal.FiberIdTypeId;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexports.FiberIdTypeId = FiberIdTypeId;\nconst none = internal.none;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexports.none = none;\nconst runtime = internal.runtime;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexports.runtime = runtime;\nconst composite = internal.composite;\n/**\n * Returns `true` if the specified unknown value is a `FiberId`, `false`\n * otherwise.\n *\n * @since 1.0.0\n * @category refinements\n */\nexports.composite = composite;\nconst isFiberId = internal.isFiberId;\n/**\n * Returns `true` if the `FiberId` is a `None`, `false` otherwise.\n *\n * @since 1.0.0\n * @category refinements\n */\nexports.isFiberId = isFiberId;\nconst isNone = internal.isNone;\n/**\n * Returns `true` if the `FiberId` is a `Runtime`, `false` otherwise.\n *\n * @since 1.0.0\n * @category refinements\n */\nexports.isNone = isNone;\nconst isRuntime = internal.isRuntime;\n/**\n * Returns `true` if the `FiberId` is a `Composite`, `false` otherwise.\n *\n * @since 1.0.0\n * @category refinements\n */\nexports.isRuntime = isRuntime;\nconst isComposite = internal.isComposite;\n/**\n * Combine two `FiberId`s.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.isComposite = isComposite;\nconst combine = internal.combine;\n/**\n * Combines a set of `FiberId`s into a single `FiberId`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.combine = combine;\nconst combineAll = internal.combineAll;\n/**\n * Returns this `FiberId` if it is not `None`, otherwise returns that `FiberId`.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.combineAll = combineAll;\nconst getOrElse = internal.getOrElse;\n/**\n * Get the set of identifiers for this `FiberId`.\n *\n * @since 1.0.0\n * @category destructors\n */\nexports.getOrElse = getOrElse;\nconst ids = internal.ids;\n/**\n * Creates a new `FiberId`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.ids = ids;\nconst make = internal.make;\n/**\n * Creates a string representing the name of the current thread of execution\n * represented by the specified `FiberId`.\n *\n * @since 1.0.0\n * @category destructors\n */\nexports.make = make;\nconst threadName = internal.threadName;\n/**\n * Convert a `FiberId` into an `Option<FiberId>`.\n *\n * @since 1.0.0\n * @category destructors\n */\nexports.threadName = threadName;\nconst toOption = internal.toOption;\n/**\n * Convert a `FiberId` into a `HashSet<FiberId>`.\n *\n * @since 1.0.0\n * @category destructors\n */\nexports.toOption = toOption;\nconst toSet = internal.toSet;\n/**\n * Unsafely creates a new `FiberId`.\n *\n * @since 1.0.0\n * @category unsafe\n */\nexports.toSet = toSet;\nconst unsafeMake = internal.unsafeMake;\nexports.unsafeMake = unsafeMake;\n//# sourceMappingURL=Id.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.render = exports.make = exports.isEnabled = exports.isEmpty = exports.isDisabled = exports.isActive = exports.inverse = exports.includes = exports.exclude = exports.enabledSet = exports.enable = exports.empty = exports.either = exports.disabledSet = exports.disable = exports.both = exports.andThen = void 0;\nvar runtimeFlags = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/runtimeFlags\"));\nvar internal = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/runtimeFlagsPatch\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/**\n * The empty `RuntimeFlagsPatch`.\n *\n * @since 1.0.0\n * @category constructors\n */\nconst empty = internal.empty;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexports.empty = empty;\nconst make = internal.make;\n/**\n * Creates a `RuntimeFlagsPatch` describing enabling the provided `RuntimeFlag`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.make = make;\nconst enable = internal.enable;\n/**\n * Creates a `RuntimeFlagsPatch` describing disabling the provided `RuntimeFlag`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.enable = enable;\nconst disable = internal.disable;\n/**\n * Returns `true` if the specified `RuntimeFlagsPatch` is empty.\n *\n * @since 1.0.0\n * @category getters\n */\nexports.disable = disable;\nconst isEmpty = internal.isEmpty;\n/**\n * Returns `true` if the `RuntimeFlagsPatch` describes the specified\n * `RuntimeFlag` as active.\n *\n * @since 1.0.0\n * @category elements\n */\nexports.isEmpty = isEmpty;\nconst isActive = internal.isActive;\n/**\n * Returns `true` if the `RuntimeFlagsPatch` describes the specified\n * `RuntimeFlag` as enabled.\n *\n * @since 1.0.0\n * @category elements\n */\nexports.isActive = isActive;\nconst isEnabled = internal.isEnabled;\n/**\n * Returns `true` if the `RuntimeFlagsPatch` describes the specified\n * `RuntimeFlag` as disabled.\n *\n * @since 1.0.0\n * @category elements\n */\nexports.isEnabled = isEnabled;\nconst isDisabled = internal.isDisabled;\n/**\n * Returns `true` if the `RuntimeFlagsPatch` includes the specified\n * `RuntimeFlag`, `false` otherwise.\n *\n * @since 1.0.0\n * @category elements\n */\nexports.isDisabled = isDisabled;\nconst includes = internal.isActive;\n/**\n * Creates a `RuntimeFlagsPatch` describing the application of the `self` patch,\n * followed by `that` patch.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.includes = includes;\nconst andThen = internal.andThen;\n/**\n * Creates a `RuntimeFlagsPatch` describing application of both the `self` patch\n * and `that` patch.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.andThen = andThen;\nconst both = internal.both;\n/**\n * Creates a `RuntimeFlagsPatch` describing application of either the `self`\n * patch or `that` patch.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.both = both;\nconst either = internal.either;\n/**\n * Creates a `RuntimeFlagsPatch` which describes exclusion of the specified\n * `RuntimeFlag` from the set of `RuntimeFlags`.\n *\n * @category mutations\n * @since 1.0.0\n */\nexports.either = either;\nconst exclude = internal.exclude;\n/**\n * Creates a `RuntimeFlagsPatch` which describes the inverse of the patch\n * specified by the provided `RuntimeFlagsPatch`.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.exclude = exclude;\nconst inverse = internal.inverse;\n/**\n * Returns a `ReadonlySet<number>` containing the `RuntimeFlags` described as\n * enabled by the specified `RuntimeFlagsPatch`.\n *\n * @since 1.0.0\n * @category destructors\n */\nexports.inverse = inverse;\nconst enabledSet = runtimeFlags.enabledSet;\n/**\n * Returns a `ReadonlySet<number>` containing the `RuntimeFlags` described as\n * disabled by the specified `RuntimeFlagsPatch`.\n *\n * @since 1.0.0\n * @category destructors\n */\nexports.enabledSet = enabledSet;\nconst disabledSet = runtimeFlags.disabledSet;\n/**\n * Renders the provided `RuntimeFlagsPatch` to a string.\n *\n * @since 1.0.0\n * @category destructors\n */\nexports.disabledSet = disabledSet;\nconst render = runtimeFlags.renderPatch;\nexports.render = render;\n//# sourceMappingURL=Patch.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.suspended = exports.running = exports.isSuspended = exports.isRunning = exports.isFiberStatus = exports.isDone = exports.done = exports.FiberStatusTypeId = void 0;\nvar internal = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/fiberStatus\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/**\n * @since 1.0.0\n * @category symbols\n */\nconst FiberStatusTypeId = internal.FiberStatusTypeId;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexports.FiberStatusTypeId = FiberStatusTypeId;\nconst done = internal.done;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexports.done = done;\nconst running = internal.running;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexports.running = running;\nconst suspended = internal.suspended;\n/**\n * Returns `true` if the specified value is a `FiberStatus`, `false` otherwise.\n *\n * @since 1.0.0\n * @category refinements\n */\nexports.suspended = suspended;\nconst isFiberStatus = internal.isFiberStatus;\n/**\n * Returns `true` if the specified `FiberStatus` is `Done`, `false` otherwise.\n *\n * @since 1.0.0\n * @category refinements\n */\nexports.isFiberStatus = isFiberStatus;\nconst isDone = internal.isDone;\n/**\n * Returns `true` if the specified `FiberStatus` is `Running`, `false`\n * otherwise.\n *\n * @since 1.0.0\n * @category refinements\n */\nexports.isDone = isDone;\nconst isRunning = internal.isRunning;\n/**\n * Returns `true` if the specified `FiberStatus` is `Suspended`, `false`\n * otherwise.\n *\n * @since 1.0.0\n * @category refinements\n */\nexports.isRunning = isRunning;\nconst isSuspended = internal.isSuspended;\nexports.isSuspended = isSuspended;\n//# sourceMappingURL=Status.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.updatedAs = exports.unsafeMake = exports.setAll = exports.joinAs = exports.getOrDefault = exports.get = exports.forkAs = exports.fiberRefs = exports.delete = exports.FiberRefsSym = void 0;\nvar internal = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/fiberRefs\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/**\n * @since 1.0.0\n * @category symbols\n */\nconst FiberRefsSym = internal.FiberRefsSym;\nexports.FiberRefsSym = FiberRefsSym;\nconst delete_ = internal.delete_;\nexports.delete = delete_;\n/**\n * Returns a set of each `FiberRef` in this collection.\n *\n * @since 1.0.0\n * @category getters\n */\nconst fiberRefs = internal.fiberRefs;\n/**\n * Forks this collection of fiber refs as the specified child fiber id. This\n * will potentially modify the value of the fiber refs, as determined by the\n * individual fiber refs that make up the collection.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.fiberRefs = fiberRefs;\nconst forkAs = internal.forkAs;\n/**\n * Gets the value of the specified `FiberRef` in this collection of `FiberRef`\n * values if it exists or `None` otherwise.\n *\n * @since 1.0.0\n * @category getters\n */\nexports.forkAs = forkAs;\nconst get = internal.get;\n/**\n * Gets the value of the specified `FiberRef` in this collection of `FiberRef`\n * values if it exists or the `initial` value of the `FiberRef` otherwise.\n *\n * @since 1.0.0\n * @category getters\n */\nexports.get = get;\nconst getOrDefault = internal.getOrDefault;\n/**\n * Joins this collection of fiber refs to the specified collection, as the\n * specified fiber id. This will perform diffing and merging to ensure\n * preservation of maximum information from both child and parent refs.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.getOrDefault = getOrDefault;\nconst joinAs = internal.joinAs;\n/**\n * Set each ref to either its value or its default.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.joinAs = joinAs;\nconst setAll = internal.setAll;\n/**\n * Updates the value of the specified `FiberRef` using the provided `FiberId`\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.setAll = setAll;\nconst updatedAs = internal.updatedAs;\n/**\n * Note: it will not copy the provided Map, make sure to provide a fresh one.\n *\n * @since 1.0.0\n * @category unsafe\n */\nexports.updatedAs = updatedAs;\nconst unsafeMake = internal.unsafeMake;\nexports.unsafeMake = unsafeMake;\n//# sourceMappingURL=FiberRefs.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.unbounded = exports.subscribe = exports.sliding = exports.size = exports.shutdown = exports.publishAll = exports.publish = exports.isShutdown = exports.isFull = exports.isEmpty = exports.dropping = exports.capacity = exports.bounded = exports.awaitShutdown = void 0;\nvar internal = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/hub\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/**\n * Creates a bounded hub with the back pressure strategy. The hub will retain\n * messages until they have been taken by all subscribers, applying back\n * pressure to publishers if the hub is at capacity.\n *\n * For best performance use capacities that are powers of two.\n *\n * @since 1.0.0\n * @category constructors\n */\nconst bounded = internal.bounded;\n/**\n * Creates a bounded hub with the dropping strategy. The hub will drop new\n * messages if the hub is at capacity.\n *\n * For best performance use capacities that are powers of two.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.bounded = bounded;\nconst dropping = internal.dropping;\n/**\n * Creates a bounded hub with the sliding strategy. The hub will add new\n * messages and drop old messages if the hub is at capacity.\n *\n * For best performance use capacities that are powers of two.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.dropping = dropping;\nconst sliding = internal.sliding;\n/**\n * Creates an unbounded hub.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.sliding = sliding;\nconst unbounded = internal.unbounded;\n/**\n *  Returns the number of elements the queue can hold.\n *\n * @since 1.0.0\n * @category getters\n */\nexports.unbounded = unbounded;\nconst capacity = internal.capacity;\n/**\n * Retrieves the size of the queue, which is equal to the number of elements\n * in the queue. This may be negative if fibers are suspended waiting for\n * elements to be added to the queue.\n *\n * @since 1.0.0\n * @category getters\n */\nexports.capacity = capacity;\nconst size = internal.size;\n/**\n * Returns `true` if the `Queue` contains at least one element, `false`\n * otherwise.\n *\n * @since 1.0.0\n * @category getters\n */\nexports.size = size;\nconst isFull = internal.isFull;\n/**\n * Returns `true` if the `Queue` contains zero elements, `false` otherwise.\n *\n * @since 1.0.0\n * @category getters\n */\nexports.isFull = isFull;\nconst isEmpty = internal.isEmpty;\n/**\n * Interrupts any fibers that are suspended on `offer` or `take`. Future calls\n * to `offer*` and `take*` will be interrupted immediately.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.isEmpty = isEmpty;\nconst shutdown = internal.shutdown;\n/**\n * Returns `true` if `shutdown` has been called, otherwise returns `false`.\n *\n * @since 1.0.0\n * @category getters\n */\nexports.shutdown = shutdown;\nconst isShutdown = internal.isShutdown;\n/**\n * Waits until the queue is shutdown. The `Effect` returned by this method will\n * not resume until the queue has been shutdown. If the queue is already\n * shutdown, the `Effect` will resume right away.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.isShutdown = isShutdown;\nconst awaitShutdown = internal.awaitShutdown;\n/**\n * Publishes a message to the hub, returning whether the message was published\n * to the hub.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.awaitShutdown = awaitShutdown;\nconst publish = internal.publish;\n/**\n * Publishes all of the specified messages to the hub, returning whether they\n * were published to the hub.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.publish = publish;\nconst publishAll = internal.publishAll;\n/**\n * Subscribes to receive messages from the hub. The resulting subscription can\n * be evaluated multiple times within the scope to take a message from the hub\n * each time.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.publishAll = publishAll;\nconst subscribe = internal.subscribe;\nexports.subscribe = subscribe;\n//# sourceMappingURL=Hub.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.zipWithPar = exports.useMerge = exports.use = exports.toRuntime = exports.tapErrorCause = exports.tapError = exports.tap = exports.syncContext = exports.sync = exports.suspend = exports.succeedContext = exports.succeed = exports.service = exports.scopedDiscard = exports.scopedContext = exports.scoped = exports.scope = exports.retry = exports.provideMerge = exports.provide = exports.project = exports.passthrough = exports.orElse = exports.orDie = exports.mergeAll = exports.merge = exports.memoize = exports.matchLayer = exports.matchCauseLayer = exports.mapError = exports.map = exports.launch = exports.isLayer = exports.isFresh = exports.function = exports.fresh = exports.flatten = exports.flatMap = exports.failSync = exports.failCauseSync = exports.failCause = exports.fail = exports.extendScope = exports.effectDiscard = exports.effectContext = exports.effect = exports.discard = exports.dieSync = exports.die = exports.context = exports.catchAllCause = exports.catchAll = exports.buildWithScope = exports.build = exports.LayerTypeId = void 0;\nvar internal = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/layer\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/**\n * @since 1.0.0\n * @category symbols\n */\nconst LayerTypeId = internal.LayerTypeId;\n/**\n * Returns `true` if the specified value is a `Layer`, `false` otherwise.\n *\n * @since 1.0.0\n * @category getters\n */\nexports.LayerTypeId = LayerTypeId;\nconst isLayer = internal.isLayer;\n/**\n * Returns `true` if the specified `Layer` is a fresh version that will not be\n * shared, `false` otherwise.\n *\n * @since 1.0.0\n * @category getters\n */\nexports.isLayer = isLayer;\nconst isFresh = internal.isFresh;\n/**\n * Builds a layer into a scoped value.\n *\n * @since 1.0.0\n * @category destructors\n */\nexports.isFresh = isFresh;\nconst build = internal.build;\n/**\n * Builds a layer into an `Effect` value. Any resources associated with this\n * layer will be released when the specified scope is closed unless their scope\n * has been extended. This allows building layers where the lifetime of some of\n * the services output by the layer exceed the lifetime of the effect the\n * layer is provided to.\n *\n * @since 1.0.0\n * @category destructors\n */\nexports.build = build;\nconst buildWithScope = internal.buildWithScope;\n/**\n * Recovers from all errors.\n *\n * @since 1.0.0\n * @category error handling\n */\nexports.buildWithScope = buildWithScope;\nconst catchAll = internal.catchAll;\n/**\n * Recovers from all errors.\n *\n * @since 1.0.0\n * @category error handling\n */\nexports.catchAll = catchAll;\nconst catchAllCause = internal.catchAllCause;\n/**\n * Constructs a `Layer` that passes along the specified context as an\n * output.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.catchAllCause = catchAllCause;\nconst context = internal.context;\n/**\n * Constructs a layer that dies with the specified defect.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.context = context;\nconst die = internal.die;\n/**\n * Constructs a layer that dies with the specified defect.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.die = die;\nconst dieSync = internal.dieSync;\n/**\n * Replaces the layer's output with `void` and includes the layer only for its\n * side-effects.\n *\n * @since 1.0.0\n * @category mapping\n */\nexports.dieSync = dieSync;\nconst discard = internal.discard;\n/**\n * Constructs a layer from the specified effect.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.discard = discard;\nconst effect = internal.fromEffect;\n/**\n * Constructs a layer from the specified effect discarding it's output.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.effect = effect;\nconst effectDiscard = internal.fromEffectDiscard;\n/**\n * Constructs a layer from the specified effect, which must return one or more\n * services.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.effectDiscard = effectDiscard;\nconst effectContext = internal.fromEffectContext;\n/**\n * Extends the scope of this layer, returning a new layer that when provided\n * to an effect will not immediately release its associated resources when\n * that effect completes execution but instead when the scope the resulting\n * effect depends on is closed.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.effectContext = effectContext;\nconst extendScope = internal.extendScope;\n/**\n * Constructs a layer that fails with the specified error.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.extendScope = extendScope;\nconst fail = internal.fail;\n/**\n * Constructs a layer that fails with the specified error.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.fail = fail;\nconst failSync = internal.failSync;\n/**\n * Constructs a layer that fails with the specified cause.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.failSync = failSync;\nconst failCause = internal.failCause;\n/**\n * Constructs a layer that fails with the specified cause.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.failCause = failCause;\nconst failCauseSync = internal.failCauseSync;\n/**\n * Constructs a layer dynamically based on the output of this layer.\n *\n * @since 1.0.0\n * @category sequencing\n */\nexports.failCauseSync = failCauseSync;\nconst flatMap = internal.flatMap;\n/**\n * Flattens layers nested in the context of an effect.\n *\n * @since 1.0.0\n * @category sequencing\n */\nexports.flatMap = flatMap;\nconst flatten = internal.flatten;\n/**\n * Creates a fresh version of this layer that will not be shared.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.flatten = flatten;\nconst fresh = internal.fresh;\nexports.fresh = fresh;\nconst fromFunction = internal.fromFunction;\nexports.function = fromFunction;\n/**\n * Builds this layer and uses it until it is interrupted. This is useful when\n * your entire application is a layer, such as an HTTP server.\n *\n * @since 1.0.0\n * @category conversions\n */\nconst launch = internal.launch;\n/**\n * Returns a new layer whose output is mapped by the specified function.\n *\n * @since 1.0.0\n * @category mapping\n */\nexports.launch = launch;\nconst map = internal.map;\n/**\n * Returns a layer with its error channel mapped using the specified function.\n *\n * @since 1.0.0\n * @category mapping\n */\nexports.map = map;\nconst mapError = internal.mapError;\n/**\n * Feeds the error or output services of this layer into the input of either\n * the specified `failure` or `success` layers, resulting in a new layer with\n * the inputs of this layer, and the error or outputs of the specified layer.\n *\n * @since 1.0.0\n * @category folding\n */\nexports.mapError = mapError;\nconst matchLayer = internal.matchLayer;\n/**\n * Feeds the error or output services of this layer into the input of either\n * the specified `failure` or `success` layers, resulting in a new layer with\n * the inputs of this layer, and the error or outputs of the specified layer.\n *\n * @since 1.0.0\n * @category folding\n */\nexports.matchLayer = matchLayer;\nconst matchCauseLayer = internal.matchCauseLayer;\n/**\n * Returns a scoped effect that, if evaluated, will return the lazily computed\n * result of this layer.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.matchCauseLayer = matchCauseLayer;\nconst memoize = internal.memoize;\n/**\n * Combines this layer with the specified layer, producing a new layer that\n * has the inputs and outputs of both.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.memoize = memoize;\nconst merge = internal.merge;\n/**\n * Merges all the layers together in parallel.\n *\n * @since 1.0.0\n * @category zipping\n */\nexports.merge = merge;\nconst mergeAll = internal.mergeAll;\n/**\n * Translates effect failure into death of the fiber, making all failures\n * unchecked and not a part of the type of the layer.\n *\n * @since 1.0.0\n * @category error handling\n */\nexports.mergeAll = mergeAll;\nconst orDie = internal.orDie;\n/**\n * Executes this layer and returns its output, if it succeeds, but otherwise\n * executes the specified layer.\n *\n * @since 1.0.0\n * @category error handling\n */\nexports.orDie = orDie;\nconst orElse = internal.orElse;\n/**\n * Returns a new layer that produces the outputs of this layer but also\n * passes through the inputs.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.orElse = orElse;\nconst passthrough = internal.passthrough;\n/**\n * Projects out part of one of the services output by this layer using the\n * specified function.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.passthrough = passthrough;\nconst project = internal.project;\n/**\n * Feeds the output services of this builder into the input of the specified\n * builder, resulting in a new builder with the inputs of this builder as\n * well as any leftover inputs, and the outputs of the specified builder.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.project = project;\nconst provide = internal.provide;\n/**\n * Feeds the output services of this layer into the input of the specified\n * layer, resulting in a new layer with the inputs of this layer, and the\n * outputs of both layers.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.provide = provide;\nconst provideMerge = internal.provideMerge;\n/**\n * Retries constructing this layer according to the specified schedule.\n *\n * @since 1.0.0\n * @category retrying\n */\nexports.provideMerge = provideMerge;\nconst retry = internal.retry;\n/**\n * A layer that constructs a scope and closes it when the workflow the layer\n * is provided to completes execution, whether by success, failure, or\n * interruption. This can be used to close a scope when providing a layer to a\n * workflow.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.retry = retry;\nconst scope = internal.scope;\n/**\n * Constructs a layer from the specified scoped effect.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.scope = scope;\nconst scoped = internal.scoped;\n/**\n * Constructs a layer from the specified scoped effect.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.scoped = scoped;\nconst scopedDiscard = internal.scopedDiscard;\n/**\n * Constructs a layer from the specified scoped effect, which must return one\n * or more services.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.scopedDiscard = scopedDiscard;\nconst scopedContext = internal.scopedContext;\n/**\n * Constructs a layer that accesses and returns the specified service from the\n * context.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.scopedContext = scopedContext;\nconst service = internal.service;\n/**\n * Constructs a layer from the specified value.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.service = service;\nconst succeed = internal.succeed;\n/**\n * Constructs a layer from the specified value, which must return one or more\n * services.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.succeed = succeed;\nconst succeedContext = internal.succeedContext;\n/**\n * Lazily constructs a layer. This is useful to avoid infinite recursion when\n * creating layers that refer to themselves.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.succeedContext = succeedContext;\nconst suspend = internal.suspend;\n/**\n * Lazily constructs a layer from the specified value.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.suspend = suspend;\nconst sync = internal.sync;\n/**\n * Lazily constructs a layer from the specified value, which must return one or more\n * services.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.sync = sync;\nconst syncContext = internal.syncContext;\n/**\n * Performs the specified effect if this layer succeeds.\n *\n * @since 1.0.0\n * @category sequencing\n */\nexports.syncContext = syncContext;\nconst tap = internal.tap;\n/**\n * Performs the specified effect if this layer fails.\n *\n * @since 1.0.0\n * @category sequencing\n */\nexports.tap = tap;\nconst tapError = internal.tapError;\n/**\n * Performs the specified effect if this layer fails.\n *\n * @since 1.0.0\n * @category sequencing\n */\nexports.tapError = tapError;\nconst tapErrorCause = internal.tapErrorCause;\n/**\n * Converts a layer that requires no services into a scoped runtime, which can\n * be used to execute effects.\n *\n * @since 1.0.0\n * @category conversions\n */\nexports.tapErrorCause = tapErrorCause;\nconst toRuntime = internal.toRuntime;\n/**\n * Feeds the output services of this builder into the input of the specified\n * builder, resulting in a new builder with the inputs of this builder as\n * well as any leftover inputs, and the outputs of the specified builder.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.toRuntime = toRuntime;\nconst use = internal.use;\n/**\n * Feeds the output services of this layer into the input of the specified\n * layer, resulting in a new layer with the inputs of this layer, and the\n * outputs of both layers.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.use = use;\nconst useMerge = internal.useMerge;\n/**\n * Combines this layer the specified layer, producing a new layer that has the\n * inputs of both, and the outputs of both combined using the specified\n * function.\n *\n * @since 1.0.0\n * @category zipping\n */\nexports.useMerge = useMerge;\nconst zipWithPar = internal.zipWithPar;\nexports.zipWithPar = zipWithPar;\n//# sourceMappingURL=Layer.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.locally = exports.lessThanEqual = exports.lessThan = exports.greaterThanEqual = exports.greaterThan = exports.fromLiteral = exports.Warning = exports.Trace = exports.Order = exports.None = exports.Info = exports.Fatal = exports.Error = exports.Debug = exports.All = void 0;\nvar number = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Number\"));\nvar order = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/typeclass/Order\"));\nvar debug = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Debug\"));\nvar core = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/core\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/**\n * @since 1.0.0\n */\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nconst All = core.logLevelAll;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexports.All = All;\nconst Fatal = core.logLevelFatal;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexports.Fatal = Fatal;\nconst Error = core.logLevelError;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexports.Error = Error;\nconst Warning = core.logLevelWarning;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexports.Warning = Warning;\nconst Info = core.logLevelInfo;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexports.Info = Info;\nconst Debug = core.logLevelDebug;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexports.Debug = Debug;\nconst Trace = core.logLevelTrace;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexports.Trace = Trace;\nconst None = core.logLevelNone;\n/**\n * Locally applies the specified `LogLevel` to an `Effect` workflow, reverting\n * to the previous `LogLevel` after the `Effect` workflow completes.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.None = None;\nconst locally = /*#__PURE__*/debug.dualWithTrace(2, trace => (use, self) => core.fiberRefLocally(use, core.currentLogLevel, self).traced(trace));\n/**\n * @since 1.0.0\n * @category instances\n */\nexports.locally = locally;\nconst Order = /*#__PURE__*/order.contramap(level => level.ordinal)(number.Order);\n/**\n * @since 1.0.0\n * @category ordering\n */\nexports.Order = Order;\nconst lessThan = /*#__PURE__*/order.lessThan(Order);\n/**\n * @since 1.0.0\n * @category ordering\n */\nexports.lessThan = lessThan;\nconst lessThanEqual = /*#__PURE__*/order.lessThanOrEqualTo(Order);\n/**\n * @since 1.0.0\n * @category ordering\n */\nexports.lessThanEqual = lessThanEqual;\nconst greaterThan = /*#__PURE__*/order.greaterThan(Order);\n/**\n * @since 1.0.0\n * @category ordering\n */\nexports.greaterThan = greaterThan;\nconst greaterThanEqual = /*#__PURE__*/order.greaterThanOrEqualTo(Order);\n/**\n * @since 1.0.0\n * @category conversions\n */\nexports.greaterThanEqual = greaterThanEqual;\nconst fromLiteral = _ => {\n  switch (_) {\n    case \"All\":\n      {\n        return All;\n      }\n    case \"Debug\":\n      {\n        return Debug;\n      }\n    case \"Error\":\n      {\n        return Error;\n      }\n    case \"Fatal\":\n      {\n        return Fatal;\n      }\n    case \"Info\":\n      {\n        return Info;\n      }\n    case \"Trace\":\n      {\n        return Trace;\n      }\n    case \"None\":\n      {\n        return None;\n      }\n    case \"Warning\":\n      {\n        return Warning;\n      }\n  }\n};\nexports.fromLiteral = fromLiteral;\n//# sourceMappingURL=Level.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.render = exports.make = void 0;\nvar internal = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/logSpan\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/**\n * @since 1.0.0\n */\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nconst make = internal.make;\n/**\n * @since 1.0.0\n * @category destructors\n */\nexports.make = make;\nconst render = internal.render;\nexports.render = render;\n//# sourceMappingURL=Span.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.unbounded = exports.takeUpTo = exports.takeN = exports.takeBetween = exports.takeAll = exports.take = exports.slidingStrategy = exports.sliding = exports.size = exports.shutdown = exports.poll = exports.offerAll = exports.offer = exports.isShutdown = exports.isQueue = exports.isFull = exports.isEnqueue = exports.isEmpty = exports.isDequeue = exports.droppingStrategy = exports.dropping = exports.capacity = exports.bounded = exports.backPressureStrategy = exports.awaitShutdown = exports.QueueStrategyTypeId = exports.EnqueueTypeId = exports.DequeueTypeId = void 0;\nvar internal = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/queue\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/**\n * @since 1.0.0\n * @category symbols\n */\nconst EnqueueTypeId = internal.EnqueueTypeId;\n/**\n * @since 1.0.0\n * @category symbols\n */\nexports.EnqueueTypeId = EnqueueTypeId;\nconst DequeueTypeId = internal.DequeueTypeId;\n/**\n * @since 1.0.0\n * @category symbols\n */\nexports.DequeueTypeId = DequeueTypeId;\nconst QueueStrategyTypeId = internal.QueueStrategyTypeId;\n/**\n * Returns `true` if the specified value is a `Queue`, `false` otherwise.\n *\n * @since 1.0.0\n * @category refinements\n */\nexports.QueueStrategyTypeId = QueueStrategyTypeId;\nconst isQueue = internal.isQueue;\n/**\n * Returns `true` if the specified value is a `Dequeue`, `false` otherwise.\n *\n * @since 1.0.0\n * @category refinements\n */\nexports.isQueue = isQueue;\nconst isDequeue = internal.isDequeue;\n/**\n * Returns `true` if the specified value is a `Enqueue`, `false` otherwise.\n *\n * @since 1.0.0\n * @category refinements\n */\nexports.isDequeue = isDequeue;\nconst isEnqueue = internal.isEnqueue;\n/**\n * @since 1.0.0\n * @category strategies\n */\nexports.isEnqueue = isEnqueue;\nconst backPressureStrategy = internal.backPressureStrategy;\n/**\n * @since 1.0.0\n * @category strategies\n */\nexports.backPressureStrategy = backPressureStrategy;\nconst droppingStrategy = internal.droppingStrategy;\n/**\n * @since 1.0.0\n * @category strategies\n */\nexports.droppingStrategy = droppingStrategy;\nconst slidingStrategy = internal.slidingStrategy;\n/**\n * Makes a new bounded `Queue`. When the capacity of the queue is reached, any\n * additional calls to `offer` will be suspended until there is more room in\n * the queue.\n *\n * **Note**: When possible use only power of 2 capacities; this will provide\n * better performance by utilising an optimised version of the underlying\n * `RingBuffer`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.slidingStrategy = slidingStrategy;\nconst bounded = internal.bounded;\n/**\n * Makes a new bounded `Queue` with the dropping strategy.\n *\n * When the capacity of the queue is reached, new elements will be added and the\n * old elements will be dropped.\n *\n * **Note**: When possible use only power of 2 capacities; this will provide\n * better performance by utilising an optimised version of the underlying\n * `RingBuffer`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.bounded = bounded;\nconst dropping = internal.dropping;\n/**\n * Makes a new bounded `Queue` with the sliding strategy.\n *\n * When the capacity of the queue is reached, new elements will be added and the\n * old elements will be dropped.\n *\n * **Note**: When possible use only power of 2 capacities; this will provide\n * better performance by utilising an optimised version of the underlying\n * `RingBuffer`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.dropping = dropping;\nconst sliding = internal.sliding;\n/**\n * Creates a new unbounded `Queue`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.sliding = sliding;\nconst unbounded = internal.unbounded;\n/**\n * Returns the number of elements the queue can hold.\n *\n * @since 1.0.0\n * @category getters\n */\nexports.unbounded = unbounded;\nconst capacity = internal.capacity;\n/**\n * Retrieves the size of the queue, which is equal to the number of elements\n * in the queue. This may be negative if fibers are suspended waiting for\n * elements to be added to the queue.\n *\n * @since 1.0.0\n * @category getters\n */\nexports.capacity = capacity;\nconst size = internal.size;\n/**\n * Returns `true` if the `Queue` contains zero elements, `false` otherwise.\n *\n * @since 1.0.0\n * @category getters\n */\nexports.size = size;\nconst isEmpty = internal.isEmpty;\n/**\n * Returns `true` if the `Queue` contains at least one element, `false`\n * otherwise.\n *\n * @since 1.0.0\n * @category getters\n */\nexports.isEmpty = isEmpty;\nconst isFull = internal.isFull;\n/**\n * Returns `true` if `shutdown` has been called, otherwise returns `false`.\n *\n * @since 1.0.0\n * @category getters\n */\nexports.isFull = isFull;\nconst isShutdown = internal.isShutdown;\n/**\n * Waits until the queue is shutdown. The `Effect` returned by this method will\n * not resume until the queue has been shutdown. If the queue is already\n * shutdown, the `Effect` will resume right away.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.isShutdown = isShutdown;\nconst awaitShutdown = internal.awaitShutdown;\n/**\n * Interrupts any fibers that are suspended on `offer` or `take`. Future calls\n * to `offer*` and `take*` will be interrupted immediately.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.awaitShutdown = awaitShutdown;\nconst shutdown = internal.shutdown;\n/**\n * Places one value in the queue.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.shutdown = shutdown;\nconst offer = internal.offer;\n/**\n * For Bounded Queue: uses the `BackPressure` Strategy, places the values in\n * the queue and always returns true. If the queue has reached capacity, then\n * the fiber performing the `offerAll` will be suspended until there is room\n * in the queue.\n *\n * For Unbounded Queue: Places all values in the queue and returns true.\n *\n * For Sliding Queue: uses `Sliding` Strategy If there is room in the queue,\n * it places the values otherwise it removes the old elements and enqueues the\n * new ones. Always returns true.\n *\n * For Dropping Queue: uses `Dropping` Strategy, It places the values in the\n * queue but if there is no room it will not enqueue them and return false.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.offer = offer;\nconst offerAll = internal.offerAll;\n/**\n * Returns the first value in the `Queue` as a `Some<A>`, or `None` if the queue\n * is empty.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.offerAll = offerAll;\nconst poll = internal.poll;\n/**\n * Takes the oldest value in the queue. If the queue is empty, this will return\n * a computation that resumes when an item has been added to the queue.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.poll = poll;\nconst take = internal.take;\n/**\n * Takes all the values in the queue and returns the values. If the queue is\n * empty returns an empty collection.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.take = take;\nconst takeAll = internal.takeAll;\n/**\n * Takes up to max number of values from the queue.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.takeAll = takeAll;\nconst takeUpTo = internal.takeUpTo;\n/**\n * Takes a number of elements from the queue between the specified minimum and\n * maximum. If there are fewer than the minimum number of elements available,\n * suspends until at least the minimum number of elements have been collected.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.takeUpTo = takeUpTo;\nconst takeBetween = internal.takeBetween;\n/**\n * Takes the specified number of elements from the queue. If there are fewer\n * than the specified number of elements available, it suspends until they\n * become available.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.takeBetween = takeBetween;\nconst takeN = internal.takeN;\nexports.takeN = takeN;\n//# sourceMappingURL=Queue.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.shuffle = exports.randomWith = exports.nextRange = exports.nextIntBetween = exports.nextInt = exports.nextBoolean = exports.next = exports.RandomTypeId = void 0;\nvar defaultServices = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/defaultServices\"));\nvar internal = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/random\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/**\n * @since 1.0.0\n * @category symbols\n */\nconst RandomTypeId = internal.RandomTypeId;\n/**\n * Returns the next numeric value from the pseudo-random number generator.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.RandomTypeId = RandomTypeId;\nconst next = defaultServices.next;\n/**\n * Returns the next integer value from the pseudo-random number generator.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.next = next;\nconst nextInt = defaultServices.nextInt;\n/**\n * Returns the next boolean value from the pseudo-random number generator.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.nextInt = nextInt;\nconst nextBoolean = defaultServices.nextBoolean;\n/**\n * Returns the next numeric value in the specified range from the\n * pseudo-random number generator.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.nextBoolean = nextBoolean;\nconst nextRange = defaultServices.nextRange;\n/**\n * Returns the next integer value in the specified range from the\n * pseudo-random number generator.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.nextRange = nextRange;\nconst nextIntBetween = defaultServices.nextIntBetween;\n/**\n * Uses the pseudo-random number generator to shuffle the specified iterable.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.nextIntBetween = nextIntBetween;\nconst shuffle = defaultServices.shuffle;\n/**\n * Retreives the `Random` service from the context and uses it to run the\n * specified workflow.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.shuffle = shuffle;\nconst randomWith = defaultServices.randomWith;\nexports.randomWith = randomWith;\n//# sourceMappingURL=Random.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.updateSomeAndGet = exports.updateSome = exports.updateAndGet = exports.update = exports.unsafeMake = exports.setAndGet = exports.set = exports.modifySome = exports.modify = exports.make = exports.getAndUpdateSome = exports.getAndUpdate = exports.getAndSet = exports.get = exports.RefTypeId = void 0;\nvar internal = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/ref\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/**\n * @since 1.0.0\n * @category symbols\n */\nconst RefTypeId = internal.RefTypeId;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexports.RefTypeId = RefTypeId;\nconst make = internal.make;\n/**\n * @since 1.0.0\n * @category getters\n */\nexports.make = make;\nconst get = internal.get;\n/**\n * @since 1.0.0\n * @category mutations\n */\nexports.get = get;\nconst getAndSet = internal.getAndSet;\n/**\n * @since 1.0.0\n * @category mutations\n */\nexports.getAndSet = getAndSet;\nconst getAndUpdate = internal.getAndUpdate;\n/**\n * @since 1.0.0\n * @category mutations\n */\nexports.getAndUpdate = getAndUpdate;\nconst getAndUpdateSome = internal.getAndUpdateSome;\n/**\n * @since 1.0.0\n * @category mutations\n */\nexports.getAndUpdateSome = getAndUpdateSome;\nconst modify = internal.modify;\n/**\n * @since 1.0.0\n * @category mutations\n */\nexports.modify = modify;\nconst modifySome = internal.modifySome;\n/**\n * @since 1.0.0\n * @category mutations\n */\nexports.modifySome = modifySome;\nconst set = internal.set;\n/**\n * @since 1.0.0\n * @category mutations\n */\nexports.set = set;\nconst setAndGet = internal.setAndGet;\n/**\n * @since 1.0.0\n * @category mutations\n */\nexports.setAndGet = setAndGet;\nconst update = internal.update;\n/**\n * @since 1.0.0\n * @category mutations\n */\nexports.update = update;\nconst updateAndGet = internal.updateAndGet;\n/**\n * @since 1.0.0\n * @category mutations\n */\nexports.updateAndGet = updateAndGet;\nconst updateSome = internal.updateSome;\n/**\n * @since 1.0.0\n * @category mutations\n */\nexports.updateSome = updateSome;\nconst updateSomeAndGet = internal.updateSomeAndGet;\n/**\n * @since 1.0.0\n * @category unsafe\n */\nexports.updateSomeAndGet = updateSomeAndGet;\nconst unsafeMake = internal.unsafeMake;\nexports.unsafeMake = unsafeMake;\n//# sourceMappingURL=Ref.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.runSyncExitOrFiber = exports.runSyncExit = exports.runSyncEither = exports.runSync = exports.runPromiseExit = exports.runPromiseEither = exports.runPromise = exports.runFork = exports.runCallback = exports.make = exports.defaultRuntimeFlags = exports.defaultRuntime = void 0;\nvar internal = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/runtime\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/**\n * Executes the effect using the provided Scheduler or using the global\n * Scheduler if not provided\n *\n * @since 1.0.0\n * @category execution\n */\nconst runFork = internal.unsafeFork;\n/**\n * Executes the effect synchronously returning the exit.\n *\n * This method is effectful and should only be invoked at the edges of your\n * program.\n *\n * @since 1.0.0\n * @category execution\n */\nexports.runFork = runFork;\nconst runSyncExit = internal.unsafeRunSyncExit;\n/**\n * Executes the effect synchronously returning the exit or the fiber if async.\n *\n * This method is effectful and should only be invoked at the edges of your\n * program.\n *\n * @since 1.0.0\n * @category execution\n */\nexports.runSyncExit = runSyncExit;\nconst runSyncExitOrFiber = internal.unsafeRunSyncExitOrFiber;\n/**\n * Executes the effect synchronously throwing in case of errors or async boundaries.\n *\n * This method is effectful and should only be invoked at the edges of your\n * program.\n *\n * @since 1.0.0\n * @category execution\n */\nexports.runSyncExitOrFiber = runSyncExitOrFiber;\nconst runSync = internal.unsafeRunSync;\n/**\n * Executes the effect asynchronously, eventually passing the exit value to\n * the specified callback.\n *\n * This method is effectful and should only be invoked at the edges of your\n * program.\n *\n * @since 1.0.0\n * @category execution\n */\nexports.runSync = runSync;\nconst runCallback = internal.unsafeRunCallback;\n/**\n * Executes the effect synchronously returning either the result or a failure.\n *\n * Throwing in case of defects and interruptions.\n *\n * This method is effectful and should only be invoked at the edges of your\n * program.\n *\n * @since 1.0.0\n * @category execution\n */\nexports.runCallback = runCallback;\nconst runSyncEither = internal.unsafeRunSyncEither;\n/**\n * Runs the `Effect`, returning a JavaScript `Promise` that will be resolved\n * with the value of the effect once the effect has been executed, or will be\n * rejected with the first error or exception throw by the effect.\n *\n * This method is effectful and should only be used at the edges of your\n * program.\n *\n * @since 1.0.0\n * @category execution\n */\nexports.runSyncEither = runSyncEither;\nconst runPromise = internal.unsafeRunPromise;\n/**\n * Runs the `Effect`, returning a JavaScript `Promise` that will be resolved\n * with the `Exit` state of the effect once the effect has been executed.\n *\n * This method is effectful and should only be used at the edges of your\n * program.\n *\n * @since 1.0.0\n * @category execution\n */\nexports.runPromise = runPromise;\nconst runPromiseExit = internal.unsafeRunPromiseExit;\n/**\n * Runs the `Effect`, returning a JavaScript `Promise` that will be resolved\n * with the either a success or a failure. The promise will be rejected in case\n * of defects and interruption.\n *\n * This method is effectful and should only be used at the edges of your\n * program.\n *\n * @since 1.0.0\n * @category execution\n */\nexports.runPromiseExit = runPromiseExit;\nconst runPromiseEither = internal.unsafeRunPromiseEither;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexports.runPromiseEither = runPromiseEither;\nconst defaultRuntime = internal.defaultRuntime;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexports.defaultRuntime = defaultRuntime;\nconst defaultRuntimeFlags = internal.defaultRuntimeFlags;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexports.defaultRuntimeFlags = defaultRuntimeFlags;\nconst make = internal.make;\nexports.make = make;\n//# sourceMappingURL=Runtime.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.whileInputEffect = exports.whileInput = exports.upTo = exports.untilOutputEffect = exports.untilOutput = exports.untilInputEffect = exports.untilInput = exports.unionWith = exports.union = exports.unfold = exports.tapOutput = exports.tapInput = exports.sync = exports.succeed = exports.stop = exports.spaced = exports.secondOfMinute = exports.run = exports.right = exports.resetWhen = exports.resetAfter = exports.repetitions = exports.repeatForever = exports.reduceEffect = exports.reduce = exports.recurs = exports.recurWhileEquals = exports.recurWhileEffect = exports.recurWhile = exports.recurUpTo = exports.recurUntilOption = exports.recurUntilEquals = exports.recurUntilEffect = exports.recurUntil = exports.reconsiderEffect = exports.reconsider = exports.provideService = exports.provideContext = exports.passthrough = exports.once = exports.onDecision = exports.modifyDelayEffect = exports.modifyDelay = exports.minuteOfHour = exports.mapEffect = exports.map = exports.makeWithState = exports.linear = exports.left = exports.jitteredWith = exports.jittered = exports.intersectWith = exports.intersect = exports.identity = exports.hourOfDay = exports.fromFunction = exports.fromDelays = exports.fromDelay = exports.forever = exports.fixed = exports.fibonacci = exports.exponential = exports.ensuring = exports.elapsed = exports.eitherWith = exports.either = exports.duration = exports.driver = exports.dimapEffect = exports.dimap = exports.delays = exports.delayedSchedule = exports.delayedEffect = exports.delayed = exports.dayOfWeek = exports.dayOfMonth = exports.count = exports.contramapEffect = exports.contramapContext = exports.contramap = exports.compose = exports.collectWhileEffect = exports.collectWhile = exports.collectUntilEffect = exports.collectUntil = exports.collectAllOutputs = exports.collectAllInputs = exports.chooseMerge = exports.choose = exports.checkEffect = exports.check = exports.bothInOut = exports.asUnit = exports.as = exports.andThenEither = exports.andThen = exports.addDelayEffect = exports.addDelay = exports.ScheduleTypeId = exports.ScheduleDriverTypeId = void 0;\nexports.zipWith = exports.zipRight = exports.zipLeft = exports.windowed = exports.whileOutputEffect = exports.whileOutput = void 0;\nvar internal = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/schedule\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/**\n * @since 1.0.0\n * @category symbols\n */\nconst ScheduleTypeId = internal.ScheduleTypeId;\n/**\n * @since 1.0.0\n * @category symbols\n */\nexports.ScheduleTypeId = ScheduleTypeId;\nconst ScheduleDriverTypeId = internal.ScheduleDriverTypeId;\n/**\n * Constructs a new `Schedule` with the specified `initial` state and the\n * specified `step` function.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.ScheduleDriverTypeId = ScheduleDriverTypeId;\nconst makeWithState = internal.makeWithState;\n/**\n * Returns a new schedule with the given delay added to every interval defined\n * by this schedule.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.makeWithState = makeWithState;\nconst addDelay = internal.addDelay;\n/**\n * Returns a new schedule with the given effectfully computed delay added to\n * every interval defined by this schedule.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.addDelay = addDelay;\nconst addDelayEffect = internal.addDelayEffect;\n/**\n * The same as `andThenEither`, but merges the output.\n *\n * @since 1.0.0\n * @category sequencing\n */\nexports.addDelayEffect = addDelayEffect;\nconst andThen = internal.andThen;\n/**\n * Returns a new schedule that first executes this schedule to completion, and\n * then executes the specified schedule to completion.\n *\n * @since 1.0.0\n * @category sequencing\n */\nexports.andThen = andThen;\nconst andThenEither = internal.andThenEither;\n/**\n * Returns a new schedule that maps this schedule to a constant output.\n *\n * @since 1.0.0\n * @category mapping\n */\nexports.andThenEither = andThenEither;\nconst as = internal.as;\n/**\n * Returns a new schedule that maps the output of this schedule to unit.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.as = as;\nconst asUnit = internal.asUnit;\n/**\n * Returns a new schedule that has both the inputs and outputs of this and the\n * specified schedule.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.asUnit = asUnit;\nconst bothInOut = internal.bothInOut;\n/**\n * Returns a new schedule that passes each input and output of this schedule\n * to the specified function, and then determines whether or not to continue\n * based on the return value of the function.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.bothInOut = bothInOut;\nconst check = internal.check;\n/**\n * Returns a new schedule that passes each input and output of this schedule\n * to the specified function, and then determines whether or not to continue\n * based on the return value of the function.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.check = check;\nconst checkEffect = internal.checkEffect;\n/**\n * Returns a new schedule that allows choosing between feeding inputs to this\n * schedule, or feeding inputs to the specified schedule.\n *\n * @since 1.0.0\n * @category alternatives\n */\nexports.checkEffect = checkEffect;\nconst choose = internal.choose;\n/**\n * Returns a new schedule that chooses between two schedules with a common\n * output.\n *\n * @since 1.0.0\n * @category alternatives\n */\nexports.choose = choose;\nconst chooseMerge = internal.chooseMerge;\n/**\n * A schedule that recurs anywhere, collecting all inputs into a `Chunk`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.chooseMerge = chooseMerge;\nconst collectAllInputs = internal.collectAllInputs;\n/**\n * Returns a new schedule that collects the outputs of this one into a chunk.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.collectAllInputs = collectAllInputs;\nconst collectAllOutputs = internal.collectAllOutputs;\n/**\n * A schedule that recurs until the condition f fails, collecting all inputs\n * into a list.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.collectAllOutputs = collectAllOutputs;\nconst collectUntil = internal.collectUntil;\n/**\n * A schedule that recurs until the effectful condition f fails, collecting\n * all inputs into a list.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.collectUntil = collectUntil;\nconst collectUntilEffect = internal.collectUntilEffect;\n/**\n * A schedule that recurs as long as the condition f holds, collecting all\n * inputs into a list.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.collectUntilEffect = collectUntilEffect;\nconst collectWhile = internal.collectWhile;\n/**\n * A schedule that recurs as long as the effectful condition holds, collecting\n * all inputs into a list.\n *\n * @category mutations\n * @since 1.0.0\n */\nexports.collectWhile = collectWhile;\nconst collectWhileEffect = internal.collectWhileEffect;\n/**\n * Returns the composition of this schedule and the specified schedule, by\n * piping the output of this one into the input of the other. Effects\n * described by this schedule will always be executed before the effects\n * described by the second schedule.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.collectWhileEffect = collectWhileEffect;\nconst compose = internal.compose;\n/**\n * Returns a new schedule that deals with a narrower class of inputs than this\n * schedule.\n *\n * @since 1.0.0\n * @category mapping\n */\nexports.compose = compose;\nconst contramap = internal.contramap;\n/**\n * Transforms the context being provided to this schedule with the\n * specified function.\n *\n * @since 1.0.0\n * @category context\n */\nexports.contramap = contramap;\nconst contramapContext = internal.contramapContext;\n/**\n * Returns a new schedule that deals with a narrower class of inputs than this\n * schedule.\n *\n * @since 1.0.0\n * @category mapping\n */\nexports.contramapContext = contramapContext;\nconst contramapEffect = internal.contramapEffect;\n/**\n * A schedule that always recurs, which counts the number of recurrences.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.contramapEffect = contramapEffect;\nconst count = internal.count;\n/**\n * Cron-like schedule that recurs every specified `day` of month. Won't recur\n * on months containing less days than specified in `day` param.\n *\n * It triggers at zero hour of the day. Producing a count of repeats: 0, 1, 2.\n *\n * NOTE: `day` parameter is validated lazily. Must be in range 1...31.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.count = count;\nconst dayOfMonth = internal.dayOfMonth;\n/**\n * Cron-like schedule that recurs every specified `day` of each week. It\n * triggers at zero hour of the week. Producing a count of repeats: 0, 1, 2.\n *\n * NOTE: `day` parameter is validated lazily. Must be in range 1 (Monday)...7\n * (Sunday).\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.dayOfMonth = dayOfMonth;\nconst dayOfWeek = internal.dayOfWeek;\n/**\n * Returns a new schedule with the specified effectfully computed delay added\n * before the start of each interval produced by this schedule.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.dayOfWeek = dayOfWeek;\nconst delayed = internal.delayed;\n/**\n * Returns a new schedule with the specified effectfully computed delay added\n * before the start of each interval produced by this schedule.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.delayed = delayed;\nconst delayedEffect = internal.delayedEffect;\n/**\n * Takes a schedule that produces a delay, and returns a new schedule that\n * uses this delay to further delay intervals in the resulting schedule.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.delayedEffect = delayedEffect;\nconst delayedSchedule = internal.delayedSchedule;\n/**\n * Returns a new schedule that outputs the delay between each occurence.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.delayedSchedule = delayedSchedule;\nconst delays = internal.delays;\n/**\n * Returns a new schedule that contramaps the input and maps the output.\n *\n * @since 1.0.0\n * @category mapping\n */\nexports.delays = delays;\nconst dimap = internal.dimap;\n/**\n * Returns a new schedule that contramaps the input and maps the output.\n *\n * @since 1.0.0\n * @category mapping\n */\nexports.dimap = dimap;\nconst dimapEffect = internal.dimapEffect;\n/**\n * Returns a driver that can be used to step the schedule, appropriately\n * handling sleeping.\n *\n * @since 1.0.0\n * @category getter\n */\nexports.dimapEffect = dimapEffect;\nconst driver = internal.driver;\n/**\n * A schedule that can recur one time, the specified amount of time into the\n * future.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.driver = driver;\nconst duration = internal.duration;\n/**\n * Returns a new schedule that performs a geometric union on the intervals\n * defined by both schedules.\n *\n * @since 1.0.0\n * @category alternatives\n */\nexports.duration = duration;\nconst either = internal.either;\n/**\n * The same as `either` followed by `map`.\n *\n * @since 1.0.0\n * @category alternatives\n */\nexports.either = either;\nconst eitherWith = internal.eitherWith;\n/**\n * A schedule that occurs everywhere, which returns the total elapsed duration\n * since the first step.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.eitherWith = eitherWith;\nconst elapsed = internal.elapsed;\n/**\n * Returns a new schedule that will run the specified finalizer as soon as the\n * schedule is complete. Note that unlike `Effect.ensuring`, this method does not\n * guarantee the finalizer will be run. The `Schedule` may not initialize or\n * the driver of the schedule may not run to completion. However, if the\n * `Schedule` ever decides not to continue, then the finalizer will be run.\n *\n * @since 1.0.0\n * @category finalization\n */\nexports.elapsed = elapsed;\nconst ensuring = internal.ensuring;\n/**\n * A schedule that always recurs, but will wait a certain amount between\n * repetitions, given by `base * factor.pow(n)`, where `n` is the number of\n * repetitions so far. Returns the current duration between recurrences.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.ensuring = ensuring;\nconst exponential = internal.exponential;\n/**\n * A schedule that always recurs, increasing delays by summing the preceding\n * two delays (similar to the fibonacci sequence). Returns the current\n * duration between recurrences.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.exponential = exponential;\nconst fibonacci = internal.fibonacci;\n/**\n * A schedule that recurs on a fixed interval. Returns the number of\n * repetitions of the schedule so far.\n *\n * If the action run between updates takes longer than the interval, then the\n * action will be run immediately, but re-runs will not \"pile up\".\n *\n * ```\n * |-----interval-----|-----interval-----|-----interval-----|\n * |---------action--------||action|-----|action|-----------|\n * ```\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.fibonacci = fibonacci;\nconst fixed = internal.fixed;\n/**\n * A schedule that always recurs, producing a count of repeats: 0, 1, 2.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.fixed = fixed;\nconst forever = internal.forever;\n/**\n * A schedule that recurs once with the specified delay.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.forever = forever;\nconst fromDelay = internal.fromDelay;\n/**\n * A schedule that recurs once for each of the specified durations, delaying\n * each time for the length of the specified duration. Returns the length of\n * the current duration between recurrences.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.fromDelay = fromDelay;\nconst fromDelays = internal.fromDelays;\n/**\n * A schedule that always recurs, mapping input values through the specified\n * function.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.fromDelays = fromDelays;\nconst fromFunction = internal.fromFunction;\n/**\n * Cron-like schedule that recurs every specified `hour` of each day. It\n * triggers at zero minute of the hour. Producing a count of repeats: 0, 1, 2.\n *\n * NOTE: `hour` parameter is validated lazily. Must be in range 0...23.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.fromFunction = fromFunction;\nconst hourOfDay = internal.hourOfDay;\n/**\n * A schedule that always recurs, which returns inputs as outputs.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.hourOfDay = hourOfDay;\nconst identity = internal.identity;\n/**\n * Returns a new schedule that performs a geometric intersection on the\n * intervals defined by both schedules.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.identity = identity;\nconst intersect = internal.intersect;\n/**\n * Returns a new schedule that combines this schedule with the specified\n * schedule, continuing as long as both schedules want to continue and merging\n * the next intervals according to the specified merge function.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.intersect = intersect;\nconst intersectWith = internal.intersectWith;\n/**\n * Returns a new schedule that randomly modifies the size of the intervals of\n * this schedule.\n *\n * Defaults `min` to `0.8` and `max` to `1.2`.\n *\n * The new interval size is between `min * old interval size` and `max * old\n * interval size`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.intersectWith = intersectWith;\nconst jittered = internal.jittered;\n/**\n * Returns a new schedule that randomly modifies the size of the intervals of\n * this schedule.\n *\n * The new interval size is between `min * old interval size` and `max * old\n * interval size`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.jittered = jittered;\nconst jitteredWith = internal.jitteredWith;\n/**\n * Returns a new schedule that makes this schedule available on the `Left`\n * side of an `Either` input, allowing propagating some type `X` through this\n * channel on demand.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.jitteredWith = jitteredWith;\nconst left = internal.left;\n/**\n * A schedule that always recurs, but will repeat on a linear time interval,\n * given by `base * n` where `n` is the number of repetitions so far. Returns\n * the current duration between recurrences.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.left = left;\nconst linear = internal.linear;\n/**\n * Returns a new schedule that maps the output of this schedule through the\n * specified function.\n *\n * @since 1.0.0\n * @category mapping\n */\nexports.linear = linear;\nconst map = internal.map;\n/**\n * Returns a new schedule that maps the output of this schedule through the\n * specified effectful function.\n *\n * @since 1.0.0\n * @category mapping\n */\nexports.map = map;\nconst mapEffect = internal.mapEffect;\n/**\n * Cron-like schedule that recurs every specified `minute` of each hour. It\n * triggers at zero second of the minute. Producing a count of repeats: 0, 1,\n * 2.\n *\n * NOTE: `minute` parameter is validated lazily. Must be in range 0...59.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.mapEffect = mapEffect;\nconst minuteOfHour = internal.minuteOfHour;\n/**\n * Returns a new schedule that modifies the delay using the specified\n * function.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.minuteOfHour = minuteOfHour;\nconst modifyDelay = internal.modifyDelay;\n/**\n * Returns a new schedule that modifies the delay using the specified\n * effectual function.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.modifyDelay = modifyDelay;\nconst modifyDelayEffect = internal.modifyDelayEffect;\n/**\n * Returns a new schedule that applies the current one but runs the specified\n * effect for every decision of this schedule. This can be used to create\n * schedules that log failures, decisions, or computed values.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.modifyDelayEffect = modifyDelayEffect;\nconst onDecision = internal.onDecision;\n/**\n * A schedule that recurs one time.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.onDecision = onDecision;\nconst once = internal.once;\n/**\n * Returns a new schedule that passes through the inputs of this schedule.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.once = once;\nconst passthrough = internal.passthrough;\n/**\n * Returns a new schedule with its context provided to it, so the\n * resulting schedule does not require any context.\n *\n * @since 1.0.0\n * @category context\n */\nexports.passthrough = passthrough;\nconst provideContext = internal.provideContext;\n/**\n * Returns a new schedule with the single service it requires provided to it.\n * If the schedule requires multiple services use `provideContext`\n * instead.\n *\n * @since 1.0.0\n * @category context\n */\nexports.provideContext = provideContext;\nconst provideService = internal.provideService;\n/**\n * Returns a new schedule that reconsiders every decision made by this\n * schedule, possibly modifying the next interval and the output type in the\n * process.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.provideService = provideService;\nconst reconsider = internal.reconsider;\n/**\n * Returns a new schedule that effectfully reconsiders every decision made by\n * this schedule, possibly modifying the next interval and the output type in\n * the process.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.reconsider = reconsider;\nconst reconsiderEffect = internal.reconsiderEffect;\n/**\n * A schedule that recurs for until the predicate evaluates to true.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.reconsiderEffect = reconsiderEffect;\nconst recurUntil = internal.recurUntil;\n/**\n * A schedule that recurs for until the predicate evaluates to true.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.recurUntil = recurUntil;\nconst recurUntilEffect = internal.recurUntilEffect;\n/**\n * A schedule that recurs for until the predicate is equal.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.recurUntilEffect = recurUntilEffect;\nconst recurUntilEquals = internal.recurUntilEquals;\n/**\n * A schedule that recurs for until the input value becomes applicable to\n * partial function and then map that value with given function.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.recurUntilEquals = recurUntilEquals;\nconst recurUntilOption = internal.recurUntilOption;\n/**\n * A schedule that recurs during the given duration.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.recurUntilOption = recurUntilOption;\nconst recurUpTo = internal.recurUpTo;\n/**\n * A schedule that recurs for as long as the predicate evaluates to true.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.recurUpTo = recurUpTo;\nconst recurWhile = internal.recurWhile;\n/**\n * A schedule that recurs for as long as the effectful predicate evaluates to\n * true.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.recurWhile = recurWhile;\nconst recurWhileEffect = internal.recurWhileEffect;\n/**\n * A schedule that recurs for as long as the predicate is equal to the\n * specified value.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.recurWhileEffect = recurWhileEffect;\nconst recurWhileEquals = internal.recurWhileEquals;\n/**\n * A schedule spanning all time, which can be stepped only the specified\n * number of times before it terminates.\n *\n * @category constructors\n * @since 1.0.0\n */\nexports.recurWhileEquals = recurWhileEquals;\nconst recurs = internal.recurs;\n/**\n * Returns a new schedule that folds over the outputs of this one.\n *\n * @since 1.0.0\n * @category folding\n */\nexports.recurs = recurs;\nconst reduce = internal.reduce;\n/**\n * Returns a new schedule that effectfully folds over the outputs of this one.\n *\n * @since 1.0.0\n * @category folding\n */\nexports.reduce = reduce;\nconst reduceEffect = internal.reduceEffect;\n/**\n * Returns a new schedule that loops this one continuously, resetting the\n * state when this schedule is done.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.reduceEffect = reduceEffect;\nconst repeatForever = internal.forever;\n/**\n * Returns a new schedule that outputs the number of repetitions of this one.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.repeatForever = repeatForever;\nconst repetitions = internal.repetitions;\n/**\n * Return a new schedule that automatically resets the schedule to its initial\n * state after some time of inactivity defined by `duration`.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.repetitions = repetitions;\nconst resetAfter = internal.resetAfter;\n/**\n * Resets the schedule when the specified predicate on the schedule output\n * evaluates to true.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.resetAfter = resetAfter;\nconst resetWhen = internal.resetWhen;\n/**\n * Returns a new schedule that makes this schedule available on the `Right`\n * side of an `Either` input, allowing propagating some type `X` through this\n * channel on demand.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.resetWhen = resetWhen;\nconst right = internal.right;\n/**\n * Runs a schedule using the provided inputs, and collects all outputs.\n *\n * @since 1.0.0\n * @category destructors\n */\nexports.right = right;\nconst run = internal.run;\n/**\n * Cron-like schedule that recurs every specified `second` of each minute. It\n * triggers at zero nanosecond of the second. Producing a count of repeats: 0,\n * 1, 2.\n *\n * NOTE: `second` parameter is validated lazily. Must be in range 0...59.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.run = run;\nconst secondOfMinute = internal.secondOfMinute;\n/**\n * Returns a schedule that recurs continuously, each repetition spaced the\n * specified duration from the last run.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.secondOfMinute = secondOfMinute;\nconst spaced = internal.spaced;\n/**\n * A schedule that does not recur, it just stops.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.spaced = spaced;\nconst stop = internal.stop;\n/**\n * Returns a schedule that repeats one time, producing the specified constant\n * value.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.stop = stop;\nconst succeed = internal.succeed;\n/**\n * Returns a schedule that repeats one time, producing the specified constant\n * value.\n *\n * @category constructors\n * @since 1.0.0\n */\nexports.succeed = succeed;\nconst sync = internal.sync;\n/**\n * Returns a new schedule that effectfully processes every input to this\n * schedule.\n *\n * @since 1.0.0\n * @category sequencing\n */\nexports.sync = sync;\nconst tapInput = internal.tapInput;\n/**\n * Returns a new schedule that effectfully processes every output from this\n * schedule.\n *\n * @since 1.0.0\n * @category sequencing\n */\nexports.tapInput = tapInput;\nconst tapOutput = internal.tapOutput;\n/**\n * Unfolds a schedule that repeats one time from the specified state and\n * iterator.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.tapOutput = tapOutput;\nconst unfold = internal.unfold;\n/**\n * Returns a new schedule that performs a geometric union on the intervals\n * defined by both schedules.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.unfold = unfold;\nconst union = internal.union;\n/**\n * Returns a new schedule that combines this schedule with the specified\n * schedule, continuing as long as either schedule wants to continue and\n * merging the next intervals according to the specified merge function.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.union = union;\nconst unionWith = internal.unionWith;\n/**\n * Returns a new schedule that continues until the specified predicate on the\n * input evaluates to true.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.unionWith = unionWith;\nconst untilInput = internal.untilInput;\n/**\n * Returns a new schedule that continues until the specified effectful\n * predicate on the input evaluates to true.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.untilInput = untilInput;\nconst untilInputEffect = internal.untilInputEffect;\n/**\n * Returns a new schedule that continues until the specified predicate on the\n * output evaluates to true.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.untilInputEffect = untilInputEffect;\nconst untilOutput = internal.untilOutput;\n/**\n * Returns a new schedule that continues until the specified effectful\n * predicate on the output evaluates to true.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.untilOutput = untilOutput;\nconst untilOutputEffect = internal.untilOutputEffect;\n/**\n * A schedule that recurs during the given duration.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.untilOutputEffect = untilOutputEffect;\nconst upTo = internal.upTo;\n/**\n * Returns a new schedule that continues for as long the specified predicate\n * on the input evaluates to true.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.upTo = upTo;\nconst whileInput = internal.whileInput;\n/**\n * Returns a new schedule that continues for as long the specified effectful\n * predicate on the input evaluates to true.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.whileInput = whileInput;\nconst whileInputEffect = internal.whileInputEffect;\n/**\n * Returns a new schedule that continues for as long the specified predicate\n * on the output evaluates to true.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.whileInputEffect = whileInputEffect;\nconst whileOutput = internal.whileOutput;\n/**\n * Returns a new schedule that continues for as long the specified effectful\n * predicate on the output evaluates to true.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.whileOutput = whileOutput;\nconst whileOutputEffect = internal.whileOutputEffect;\n/**\n * A schedule that divides the timeline to `interval`-long windows, and sleeps\n * until the nearest window boundary every time it recurs.\n *\n * For example, `windowed(Duration.seconds(10))` would produce a schedule as\n * follows:\n *\n * ```\n *      10s        10s        10s       10s\n * |----------|----------|----------|----------|\n * |action------|sleep---|act|-sleep|action----|\n * ```\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.whileOutputEffect = whileOutputEffect;\nconst windowed = internal.windowed;\n/**\n * The same as `intersect` but ignores the right output.\n *\n * @since 1.0.0\n * @category zipping\n */\nexports.windowed = windowed;\nconst zipLeft = internal.zipLeft;\n/**\n * The same as `intersect` but ignores the left output.\n *\n * @since 1.0.0\n * @category zipping\n */\nexports.zipLeft = zipLeft;\nconst zipRight = internal.zipRight;\n/**\n * Equivalent to `intersect` followed by `map`.\n *\n * @since 1.0.0\n * @category zipping\n */\nexports.zipRight = zipRight;\nconst zipWith = internal.zipWith;\nexports.zipWith = zipWith;\n//# sourceMappingURL=Schedule.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isDone = exports.isContinue = exports.done = exports.continueWith = exports.continue = void 0;\nvar internal = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/schedule/decision\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/**\n * @since 1.0.0\n */\n\nconst _continue = internal._continue;\nexports.continue = _continue;\n/**\n * @since 1.0.0\n * @category constructors\n */\nconst continueWith = internal.continueWith;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexports.continueWith = continueWith;\nconst done = internal.done;\n/**\n * @since 1.0.0\n * @category refinements\n */\nexports.done = done;\nconst isContinue = internal.isContinue;\n/**\n * @since 1.0.0\n * @category refinements\n */\nexports.isContinue = isContinue;\nconst isDone = internal.isDone;\nexports.isDone = isDone;\n//# sourceMappingURL=Decision.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.union = exports.size = exports.min = exports.max = exports.make = exports.lessThan = exports.isNonEmpty = exports.isEmpty = exports.intersect = exports.empty = exports.before = exports.after = exports.IntervalTypeId = void 0;\nvar internal = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/schedule/interval\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/**\n * @since 1.0.0\n * @category symbols\n */\nconst IntervalTypeId = internal.IntervalTypeId;\n/**\n * Constructs a new interval from the two specified endpoints. If the start\n * endpoint greater than the end endpoint, then a zero size interval will be\n * returned.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.IntervalTypeId = IntervalTypeId;\nconst make = internal.make;\n/**\n * An `Interval` of zero-width.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.make = make;\nconst empty = internal.empty;\n/**\n * Returns `true` if this `Interval` is less than `that` interval, `false`\n * otherwise.\n *\n * @since 1.0.0\n * @category ordering\n */\nexports.empty = empty;\nconst lessThan = internal.lessThan;\n/**\n * Returns the minimum of two `Interval`s.\n *\n * @since 1.0.0\n * @category ordering\n */\nexports.lessThan = lessThan;\nconst min = internal.min;\n/**\n * Returns the maximum of two `Interval`s.\n *\n * @since 1.0.0\n * @category ordering\n */\nexports.min = min;\nconst max = internal.max;\n/**\n * Returns `true` if the specified `Interval` is empty, `false` otherwise.\n *\n * @since 1.0.0\n * @category ordering\n */\nexports.max = max;\nconst isEmpty = internal.isEmpty;\n/**\n * Returns `true` if the specified `Interval` is non-empty, `false` otherwise.\n *\n * @since 1.0.0\n * @category ordering\n */\nexports.isEmpty = isEmpty;\nconst isNonEmpty = internal.isNonEmpty;\n/**\n * Computes a new `Interval` which is the intersection of this `Interval` and\n * that `Interval`.\n *\n * @since 1.0.0\n * @category ordering\n */\nexports.isNonEmpty = isNonEmpty;\nconst intersect = internal.intersect;\n/**\n * Calculates the size of the `Interval` as the `Duration` from the start of the\n * interval to the end of the interval.\n *\n * @since 1.0.0\n * @category getters\n */\nexports.intersect = intersect;\nconst size = internal.size;\n/**\n * Computes a new `Interval` which is the union of this `Interval` and that\n * `Interval` as a `Some`, otherwise returns `None` if the two intervals cannot\n * form a union.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.size = size;\nconst union = internal.union;\n/**\n * Construct an `Interval` that includes all time equal to and after the\n * specified start time.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.union = union;\nconst after = internal.after;\n/**\n * Construct an `Interval` that includes all time equal to and before the\n * specified end time.\n *\n * @category constructors\n * @since 1.0.0\n */\nexports.after = after;\nconst before = internal.before;\nexports.before = before;\n//# sourceMappingURL=Interval.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.union = exports.start = exports.max = exports.make = exports.lessThan = exports.isNonEmpty = exports.intersect = exports.fromIterable = exports.end = exports.empty = exports.IntervalsTypeId = void 0;\nvar internal = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/schedule/intervals\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/**\n * @since 1.0.0\n * @category symbols\n */\nconst IntervalsTypeId = internal.IntervalsTypeId;\n/**\n * Creates a new `Intervals` from a `List` of `Interval`s.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.IntervalsTypeId = IntervalsTypeId;\nconst make = internal.make;\n/**\n * Constructs an empty list of `Interval`s.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.make = make;\nconst empty = internal.empty;\n/**\n * Constructs `Intervals` from the specified `Iterable<Interval>`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.empty = empty;\nconst fromIterable = internal.fromIterable;\n/**\n * Computes the union of this `Intervals` and  that `Intervals`\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.fromIterable = fromIterable;\nconst union = internal.union;\n/**\n * Produces the intersection of this `Intervals` and that `Intervals`.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.union = union;\nconst intersect = internal.intersect;\n/**\n * The start of the earliest interval in the specified `Intervals`.\n *\n * @since 1.0.0\n * @category getters\n */\nexports.intersect = intersect;\nconst start = internal.start;\n/**\n * The end of the latest interval in the specified `Intervals`.\n *\n * @since 1.0.0\n * @category getters\n */\nexports.start = start;\nconst end = internal.end;\n/**\n * Returns `true` if the start of this `Intervals` is before the start of that\n * `Intervals`, `false` otherwise.\n *\n * @since 1.0.0\n * @category ordering\n */\nexports.end = end;\nconst lessThan = internal.lessThan;\n/**\n * Returns `true` if this `Intervals` is non-empty, `false` otherwise.\n *\n * @since 1.0.0\n * @category getters\n */\nexports.lessThan = lessThan;\nconst isNonEmpty = internal.isNonEmpty;\n/**\n * Returns the maximum of the two `Intervals` (i.e. which has the latest start).\n *\n * @since 1.0.0\n * @category ordering\n */\nexports.isNonEmpty = isNonEmpty;\nconst max = internal.max;\nexports.max = max;\n//# sourceMappingURL=Intervals.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.defaultScheduler = exports.SyncScheduler = exports.ControlledScheduler = void 0;\nvar _Global = /*#__PURE__*/require(\"@effect/data/Global\");\n/**\n * @since 1.0.0\n */\n\nclass DefaultScheduler {\n  constructor() {\n    this.running = false;\n    this.tasks = [];\n  }\n  get executionMode() {\n    return \"PreferAsync\";\n  }\n  starveInternal(depth) {\n    const toRun = this.tasks;\n    this.tasks = [];\n    for (let i = 0; i < toRun.length; i++) {\n      toRun[i]();\n    }\n    if (this.tasks.length === 0) {\n      this.running = false;\n    } else {\n      this.starve(depth);\n    }\n  }\n  starve(depth = 0) {\n    if (depth >= 2048) {\n      setTimeout(() => this.starveInternal(0), 0);\n    } else {\n      Promise.resolve(void 0).then(() => this.starveInternal(depth + 1));\n    }\n  }\n  scheduleTask(task) {\n    this.tasks.push(task);\n    if (!this.running) {\n      this.running = true;\n      this.starve();\n    }\n  }\n}\n/**\n * @since 1.0.0\n * @category schedulers\n */\nconst defaultScheduler = /*#__PURE__*/(0, _Global.globalValue)( /*#__PURE__*/Symbol.for(\"@effect/io/Scheduler/defaultScheduler\"), () => new DefaultScheduler());\n/**\n * @since 1.0.0\n * @category schedulers\n */\nexports.defaultScheduler = defaultScheduler;\nclass SyncScheduler {\n  constructor(\n  /**\n   * @since 1.0.0\n   */\n  initialMode) {\n    this.initialMode = initialMode;\n    /**\n     * @since 1.0.0\n     */\n    this.tasks = [];\n    /**\n     * @since 1.0.0\n     */\n    this.deferred = false;\n  }\n  /**\n   * @since 1.0.0\n   */\n  scheduleTask(task) {\n    if (this.deferred) {\n      defaultScheduler.scheduleTask(task);\n    } else {\n      this.tasks.push(task);\n    }\n  }\n  /**\n   * @since 1.0.0\n   */\n  get executionMode() {\n    if (this.deferred) {\n      return defaultScheduler.executionMode;\n    }\n    return this.initialMode;\n  }\n  /**\n   * @since 1.0.0\n   */\n  flush() {\n    while (this.tasks.length > 0) {\n      const toRun = this.tasks;\n      this.tasks = [];\n      for (let i = 0; i < toRun.length; i++) {\n        toRun[i]();\n      }\n    }\n    this.deferred = true;\n  }\n}\n/**\n * @since 1.0.0\n * @category schedulers\n */\nexports.SyncScheduler = SyncScheduler;\nclass ControlledScheduler {\n  constructor(\n  /**\n   * @since 1.0.0\n   */\n  currentMode) {\n    this.currentMode = currentMode;\n    /**\n     * @since 1.0.0\n     */\n    this.tasks = [];\n    /**\n     * @since 1.0.0\n     */\n    this.deferred = false;\n  }\n  /**\n   * @since 1.0.0\n   */\n  scheduleTask(task) {\n    if (this.deferred) {\n      defaultScheduler.scheduleTask(task);\n    } else {\n      this.tasks.push(task);\n    }\n  }\n  /**\n   * @since 1.0.0\n   */\n  get executionMode() {\n    return this.currentMode();\n  }\n  /**\n   * @since 1.0.0\n   */\n  step() {\n    const toRun = this.tasks;\n    this.tasks = [];\n    for (let i = 0; i < toRun.length; i++) {\n      toRun[i]();\n    }\n  }\n}\nexports.ControlledScheduler = ControlledScheduler;\n//# sourceMappingURL=Scheduler.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.use = exports.make = exports.fork = exports.extend = exports.close = exports.addFinalizerExit = exports.addFinalizer = exports.Tag = exports.ScopeTypeId = exports.CloseableScopeTypeId = void 0;\nvar core = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/core\"));\nvar fiberRuntime = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/fiberRuntime\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/**\n * @since 1.0.0\n */\n\n/**\n * @since 1.0.0\n * @category symbols\n */\nconst ScopeTypeId = core.ScopeTypeId;\n/**\n * @since 1.0.0\n * @category symbols\n */\nexports.ScopeTypeId = ScopeTypeId;\nconst CloseableScopeTypeId = core.CloseableScopeTypeId;\n/**\n * @since 1.0.0\n * @category context\n */\nexports.CloseableScopeTypeId = CloseableScopeTypeId;\nconst Tag = fiberRuntime.scopeTag;\n/**\n * Adds a finalizer to this scope. The finalizer is guaranteed to be run when\n * the scope is closed.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.Tag = Tag;\nconst addFinalizer = core.scopeAddFinalizer;\n/**\n * A simplified version of `addFinalizerWith` when the `finalizer` does not\n * depend on the `Exit` value that the scope is closed with.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.addFinalizer = addFinalizer;\nconst addFinalizerExit = core.scopeAddFinalizerExit;\n/**\n * Closes a scope with the specified exit value, running all finalizers that\n * have been added to the scope.\n *\n * @since 1.0.0\n * @category destructors\n */\nexports.addFinalizerExit = addFinalizerExit;\nconst close = core.scopeClose;\n/**\n * Extends the scope of an `Effect` workflow that needs a scope into this\n * scope by providing it to the workflow but not closing the scope when the\n * workflow completes execution. This allows extending a scoped value into a\n * larger scope.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.close = close;\nconst extend = fiberRuntime.scopeExtend;\n/**\n * Forks a new scope that is a child of this scope. The child scope will\n * automatically be closed when this scope is closed.\n *\n * @since 1.0.0\n * @category mutations\n */\nexports.extend = extend;\nconst fork = core.scopeFork;\n/**\n * Uses the scope by providing it to an `Effect` workflow that needs a scope,\n * guaranteeing that the scope is closed with the result of that workflow as\n * soon as the workflow completes execution, whether by success, failure, or\n * interruption.\n *\n * @since 1.0.0\n * @category destructors\n */\nexports.fork = fork;\nconst use = fiberRuntime.scopeUse;\n/**\n * Creates a Scope where Finalizers will run according to the `ExecutionStrategy`.\n *\n * If an ExecutionStrategy is not provided `sequential` will be used.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.use = use;\nconst make = fiberRuntime.scopeMake;\nexports.make = make;\n//# sourceMappingURL=Scope.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.prettyErrors = exports.pretty = void 0;\nvar Chunk = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Chunk\"));\nvar Option = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Option\"));\nvar Debug = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Debug\"));\nvar internal = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/cause\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n// -----------------------------------------------------------------------------\n// Pretty Printing\n// -----------------------------------------------------------------------------\n/** @internal */\nconst renderToString = u => {\n  if (typeof u === \"object\" && u != null && \"toString\" in u && typeof u[\"toString\"] === \"function\" && u[\"toString\"] !== Object.prototype.toString) {\n    return u[\"toString\"]();\n  }\n  if (typeof u === \"string\") {\n    return `Error: ${u}`;\n  }\n  if (typeof u === \"object\" && u !== null) {\n    if (\"message\" in u && typeof u[\"message\"] === \"string\") {\n      const raw = JSON.parse(JSON.stringify(u));\n      const keys = new Set(Object.keys(raw));\n      keys.delete(\"name\");\n      keys.delete(\"message\");\n      keys.delete(\"_tag\");\n      if (keys.size === 0) {\n        return `${\"name\" in u && typeof u.name === \"string\" ? u.name : \"Error\"}${\"_tag\" in u && typeof u[\"_tag\"] === \"string\" ? `(${u._tag})` : ``}: ${u.message}`;\n      }\n    }\n  }\n  return `Error: ${JSON.stringify(u)}`;\n};\nconst renderTraces = chunk => {\n  const ret = [];\n  for (const s of chunk) {\n    const r = s?.toFrame();\n    if (r) {\n      if (Debug.runtimeDebug.filterStackFrame(r)) {\n        ret.push(renderFrame(r));\n      }\n    }\n  }\n  return ret;\n};\n/** @internal */\nconst renderStack = span => {\n  if (Option.isNone(span)) {\n    return [];\n  }\n  if (span.value.stack.length > 0) {\n    return renderTraces(span.value.stack);\n  }\n  return [];\n};\n/** @internal */\nconst renderFail = (error, errorStack, stack) => {\n  return [new RenderError(stack._tag === \"Some\" ? stack.value.seq : 0, error, errorStack ? errorStack + \"\\r\\n\" + renderStack(stack).join(\"\\r\\n\") : renderStack(stack).join(\"\\r\\n\"))];\n};\n/** @internal */\nconst renderError = error => {\n  if (error.stack) {\n    const stack = Debug.runtimeDebug.parseStack(error);\n    const traces = [];\n    for (const frame of stack) {\n      if (frame) {\n        if (Debug.runtimeDebug.filterStackFrame(frame)) {\n          traces.push(renderFrame(frame));\n        } else {\n          break;\n        }\n      }\n    }\n    return [renderToString(error), traces.join(\"\\r\\n\")];\n  }\n  return [String(error), void 0];\n};\n/** @internal */\nconst defaultErrorToLines = error => {\n  if (error instanceof Error) {\n    return renderError(error);\n  }\n  return [renderToString(error), void 0];\n};\nclass RenderError {\n  constructor(seq, message, stack) {\n    this.seq = seq;\n    this.message = message;\n    this.stack = stack;\n  }\n}\nclass RenderErrorTmp {\n  constructor(message, errorSack, fiberStack) {\n    this.message = message;\n    this.errorSack = errorSack;\n    this.fiberStack = fiberStack;\n  }\n}\n/** @internal */\nconst pretty = cause => {\n  if (internal.isInterruptedOnly(cause)) {\n    return \"All fibers interrupted without errors.\";\n  }\n  const errors = prettyErrors(cause);\n  const final = Array.from(errors).sort((a, b) => a.seq === b.seq ? 0 : a.seq > b.seq ? 1 : -1).map(e => {\n    let message = e.message;\n    if (e.stack && e.stack.length > 0) {\n      message += `\\r\\n${e.stack}`;\n    }\n    return message;\n  }).join(\"\\r\\n\\r\\n\");\n  if (!final.includes(\"\\r\\n\")) {\n    return final;\n  }\n  return `\\r\\n${final}\\r\\n`;\n};\n/** @internal */\nexports.pretty = pretty;\nconst prettyErrors = cause => internal.reduceWithContext(cause, void 0, {\n  emptyCase: () => [],\n  dieCase: (_, err) => {\n    const rendered = defaultErrorToLines(err);\n    return [{\n      message: rendered[0],\n      errorSack: rendered[1],\n      fiberStack: Option.none()\n    }];\n  },\n  failCase: (_, err) => {\n    const rendered = defaultErrorToLines(err);\n    return [{\n      message: rendered[0],\n      errorSack: rendered[1],\n      fiberStack: Option.none()\n    }];\n  },\n  interruptCase: () => [],\n  parallelCase: (_, l, r) => [...l, ...r],\n  sequentialCase: (_, l, r) => [...l, ...r],\n  annotatedCase: (_, v, parent) => internal.isStackAnnotation(parent) ? v.map(r => ({\n    message: r.message,\n    errorSack: r.errorSack,\n    fiberStack: Option.orElse(() => Option.some(parent))(Option.map(r.fiberStack, annotation => new internal.StackAnnotation(annotation.stack.length < Debug.runtimeDebug.traceStackLimit && parent.stack.length > 0 && (annotation.stack.length > 0 && Chunk.unsafeLast(parent.stack) !== Chunk.unsafeLast(annotation.stack) || annotation.stack.length === 0) ? Chunk.take(Debug.runtimeDebug.traceStackLimit)(Chunk.dedupeAdjacent(Chunk.concat(parent.stack)(annotation.stack))) : annotation.stack, annotation.seq)))\n  })) : v\n}).flatMap(r => renderFail(r.message, r.errorSack, r.fiberStack));\nexports.prettyErrors = prettyErrors;\nfunction renderFrame(r) {\n  if (r) {\n    if (r.name) {\n      return `    at ${r.name} (${r.fileName}:${r.line}:${r.column})`;\n    }\n    return `    at ${r.fileName}:${r.line}:${r.column}`;\n  }\n  return `    at <unknown>`;\n}\n//# sourceMappingURL=cause-pretty.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.unannotate = exports.stripSomeDefects = exports.stripFailures = exports.squashWith = exports.squash = exports.size = exports.sequential = exports.reduceWithContext = exports.reduce = exports.parallel = exports.match = exports.map = exports.linearize = exports.keepDefectsAndElectFailures = exports.keepDefects = exports.isStackAnnotation = exports.isSequentialType = exports.isRuntimeException = exports.isParallelType = exports.isNoSuchElementException = exports.isInvalidCapacityError = exports.isInterruptedOnly = exports.isInterruptedException = exports.isInterrupted = exports.isInterruptType = exports.isIllegalArgumentException = exports.isFailure = exports.isFailType = exports.isEmptyType = exports.isEmpty = exports.isDieType = exports.isDie = exports.isCause = exports.isAnnotatedType = exports.interruptors = exports.interruptOption = exports.interrupt = exports.globalErrorSeq = exports.flipCauseOption = exports.flatten = exports.flatMap = exports.find = exports.filter = exports.failures = exports.failureOrCause = exports.failureOption = exports.fail = exports.empty = exports.electFailures = exports.dieOption = exports.die = exports.defects = exports.contains = exports.as = exports.annotated = exports.StackAnnotationTypeId = exports.StackAnnotation = exports.RuntimeExceptionTypeId = exports.RuntimeException = exports.NoSuchElementExceptionTypeId = exports.NoSuchElementException = exports.InvalidHubCapacityExceptionTypeId = exports.InvalidHubCapacityException = exports.InterruptedExceptionTypeId = exports.InterruptedException = exports.IllegalArgumentExceptionTypeId = exports.IllegalArgumentException = exports.CauseTypeId = void 0;\nvar Chunk = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Chunk\"));\nvar Either = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Either\"));\nvar Equal = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Equal\"));\nvar _Function = /*#__PURE__*/require(\"@effect/data/Function\");\nvar Hash = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Hash\"));\nvar HashSet = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/HashSet\"));\nvar Option = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Option\"));\nvar FiberId = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Fiber/Id\"));\nvar OpCodes = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/opCodes/cause\"));\nvar MRef = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/MutableRef\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\nvar _a;\n// -----------------------------------------------------------------------------\n// Models\n// -----------------------------------------------------------------------------\n/** @internal */\nconst CauseSymbolKey = \"@effect/io/Cause\";\n/** @internal */\nconst CauseTypeId = /*#__PURE__*/Symbol.for(CauseSymbolKey);\n/** @internal */\nexports.CauseTypeId = CauseTypeId;\nconst variance = {\n  _E: _ => _\n};\n/** @internal */\nconst proto = {\n  [CauseTypeId]: variance,\n  [Hash.symbol]() {\n    return Hash.combine(Hash.hash(flattenCause(this)))(Hash.hash(CauseSymbolKey));\n  },\n  [Equal.symbol](that) {\n    return isCause(that) && causeEquals(this, that);\n  }\n};\n// -----------------------------------------------------------------------------\n// Constructors\n// -----------------------------------------------------------------------------\n/** @internal */\nconst empty = /*#__PURE__*/(() => {\n  const o = /*#__PURE__*/Object.create(proto);\n  o._tag = OpCodes.OP_EMPTY;\n  return o;\n})();\n/** @internal */\nexports.empty = empty;\nconst fail = error => {\n  const o = Object.create(proto);\n  o._tag = OpCodes.OP_FAIL;\n  o.error = error;\n  return o;\n};\n/** @internal */\nexports.fail = fail;\nconst die = defect => {\n  const o = Object.create(proto);\n  o._tag = OpCodes.OP_DIE;\n  o.defect = defect;\n  return o;\n};\n/** @internal */\nexports.die = die;\nconst interrupt = fiberId => {\n  const o = Object.create(proto);\n  o._tag = OpCodes.OP_INTERRUPT;\n  o.fiberId = fiberId;\n  return o;\n};\n/** @internal */\nexports.interrupt = interrupt;\nconst annotated = (cause, annotation) => {\n  const o = Object.create(proto);\n  o._tag = OpCodes.OP_ANNOTATED;\n  o.cause = cause;\n  o.annotation = annotation;\n  return o;\n};\n/** @internal */\nexports.annotated = annotated;\nconst parallel = (left, right) => {\n  const o = Object.create(proto);\n  o._tag = OpCodes.OP_PARALLEL;\n  o.left = left;\n  o.right = right;\n  return o;\n};\n/** @internal */\nexports.parallel = parallel;\nconst sequential = (left, right) => {\n  const o = Object.create(proto);\n  o._tag = OpCodes.OP_SEQUENTIAL;\n  o.left = left;\n  o.right = right;\n  return o;\n};\n// -----------------------------------------------------------------------------\n// Refinements\n// -----------------------------------------------------------------------------\n/** @internal */\nexports.sequential = sequential;\nconst isCause = u => typeof u === \"object\" && u != null && CauseTypeId in u;\n/** @internal */\nexports.isCause = isCause;\nconst isEmptyType = self => self._tag === OpCodes.OP_EMPTY;\n/** @internal */\nexports.isEmptyType = isEmptyType;\nconst isFailType = self => self._tag === OpCodes.OP_FAIL;\n/** @internal */\nexports.isFailType = isFailType;\nconst isDieType = self => self._tag === OpCodes.OP_DIE;\n/** @internal */\nexports.isDieType = isDieType;\nconst isInterruptType = self => self._tag === OpCodes.OP_INTERRUPT;\n/** @internal */\nexports.isInterruptType = isInterruptType;\nconst isAnnotatedType = self => self._tag === OpCodes.OP_ANNOTATED;\n/** @internal */\nexports.isAnnotatedType = isAnnotatedType;\nconst isSequentialType = self => self._tag === OpCodes.OP_SEQUENTIAL;\n/** @internal */\nexports.isSequentialType = isSequentialType;\nconst isParallelType = self => self._tag === OpCodes.OP_PARALLEL;\n// -----------------------------------------------------------------------------\n// Getters\n// -----------------------------------------------------------------------------\n/** @internal */\nexports.isParallelType = isParallelType;\nconst size = self => reduceWithContext(self, void 0, SizeCauseReducer);\n/** @internal */\nexports.size = size;\nconst isEmpty = self => {\n  if (self._tag === OpCodes.OP_EMPTY) {\n    return true;\n  }\n  return reduce(self, true, (acc, cause) => {\n    switch (cause._tag) {\n      case OpCodes.OP_EMPTY:\n        {\n          return Option.some(acc);\n        }\n      case OpCodes.OP_DIE:\n      case OpCodes.OP_FAIL:\n      case OpCodes.OP_INTERRUPT:\n        {\n          return Option.some(false);\n        }\n      default:\n        {\n          return Option.none();\n        }\n    }\n  });\n};\n/** @internal */\nexports.isEmpty = isEmpty;\nconst isFailure = self => Option.isSome(failureOption(self));\n/** @internal */\nexports.isFailure = isFailure;\nconst isDie = self => Option.isSome(dieOption(self));\n/** @internal */\nexports.isDie = isDie;\nconst isInterrupted = self => Option.isSome(interruptOption(self));\n/** @internal */\nexports.isInterrupted = isInterrupted;\nconst isInterruptedOnly = self => reduceWithContext(undefined, IsInterruptedOnlyCauseReducer)(self);\n/** @internal */\nexports.isInterruptedOnly = isInterruptedOnly;\nconst failures = self => Chunk.reverse(reduce(self, Chunk.empty(), (list, cause) => cause._tag === OpCodes.OP_FAIL ? Option.some(Chunk.prepend(cause.error)(list)) : Option.none()));\n/** @internal */\nexports.failures = failures;\nconst defects = self => Chunk.reverse(reduce(self, Chunk.empty(), (list, cause) => cause._tag === OpCodes.OP_DIE ? Option.some(Chunk.prepend(cause.defect)(list)) : Option.none()));\n/** @internal */\nexports.defects = defects;\nconst interruptors = self => reduce(self, HashSet.empty(), (set, cause) => cause._tag === OpCodes.OP_INTERRUPT ? Option.some(HashSet.add(cause.fiberId)(set)) : Option.none());\n/** @internal */\nexports.interruptors = interruptors;\nconst failureOption = self => find(self, cause => cause._tag === OpCodes.OP_FAIL ? Option.some(cause.error) : Option.none());\n/** @internal */\nexports.failureOption = failureOption;\nconst failureOrCause = self => {\n  const option = failureOption(self);\n  switch (option._tag) {\n    case \"None\":\n      {\n        // no `E` inside this `Cause`, so it can be safely cast to `never`\n        return Either.right(self);\n      }\n    case \"Some\":\n      {\n        return Either.left(option.value);\n      }\n  }\n};\n/** @internal */\nexports.failureOrCause = failureOrCause;\nconst dieOption = self => find(self, cause => cause._tag === OpCodes.OP_DIE ? Option.some(cause.defect) : Option.none());\n/** @internal */\nexports.dieOption = dieOption;\nconst flipCauseOption = self => match(self, Option.some(empty), failureOption => Option.map(fail)(failureOption), defect => Option.some(die(defect)), fiberId => Option.some(interrupt(fiberId)), (causeOption, annotation) => Option.map(cause => annotated(cause, annotation))(causeOption), (left, right) => {\n  if (Option.isSome(left) && Option.isSome(right)) {\n    return Option.some(sequential(left.value, right.value));\n  }\n  if (Option.isNone(left) && Option.isSome(right)) {\n    return Option.some(right.value);\n  }\n  if (Option.isSome(left) && Option.isNone(right)) {\n    return Option.some(left.value);\n  }\n  return Option.none();\n}, (left, right) => {\n  if (Option.isSome(left) && Option.isSome(right)) {\n    return Option.some(parallel(left.value, right.value));\n  }\n  if (Option.isNone(left) && Option.isSome(right)) {\n    return Option.some(right.value);\n  }\n  if (Option.isSome(left) && Option.isNone(right)) {\n    return Option.some(left.value);\n  }\n  return Option.none();\n});\n/** @internal */\nexports.flipCauseOption = flipCauseOption;\nconst interruptOption = self => find(self, cause => cause._tag === OpCodes.OP_INTERRUPT ? Option.some(cause.fiberId) : Option.none());\n/** @internal */\nexports.interruptOption = interruptOption;\nconst keepDefects = self => match(self, Option.none(), () => Option.none(), defect => Option.some(die(defect)), () => Option.none(), (option, annotation) => Option.map(cause => annotated(cause, annotation))(option), (left, right) => {\n  if (Option.isSome(left) && Option.isSome(right)) {\n    return Option.some(sequential(left.value, right.value));\n  }\n  if (Option.isSome(left) && Option.isNone(right)) {\n    return Option.some(left.value);\n  }\n  if (Option.isNone(left) && Option.isSome(right)) {\n    return Option.some(right.value);\n  }\n  return Option.none();\n}, (left, right) => {\n  if (Option.isSome(left) && Option.isSome(right)) {\n    return Option.some(parallel(left.value, right.value));\n  }\n  if (Option.isSome(left) && Option.isNone(right)) {\n    return Option.some(left.value);\n  }\n  if (Option.isNone(left) && Option.isSome(right)) {\n    return Option.some(right.value);\n  }\n  return Option.none();\n});\n/** @internal */\nexports.keepDefects = keepDefects;\nconst keepDefectsAndElectFailures = self => match(self, Option.none(), failure => Option.some(die(failure)), defect => Option.some(die(defect)), () => Option.none(), (option, annotation) => Option.map(cause => annotated(cause, annotation))(option), (left, right) => {\n  if (Option.isSome(left) && Option.isSome(right)) {\n    return Option.some(sequential(left.value, right.value));\n  }\n  if (Option.isSome(left) && Option.isNone(right)) {\n    return Option.some(left.value);\n  }\n  if (Option.isNone(left) && Option.isSome(right)) {\n    return Option.some(right.value);\n  }\n  return Option.none();\n}, (left, right) => {\n  if (Option.isSome(left) && Option.isSome(right)) {\n    return Option.some(parallel(left.value, right.value));\n  }\n  if (Option.isSome(left) && Option.isNone(right)) {\n    return Option.some(left.value);\n  }\n  if (Option.isNone(left) && Option.isSome(right)) {\n    return Option.some(right.value);\n  }\n  return Option.none();\n});\n/** @internal */\nexports.keepDefectsAndElectFailures = keepDefectsAndElectFailures;\nconst linearize = self => match(self, HashSet.empty(), error => HashSet.make(fail(error)), defect => HashSet.make(die(defect)), fiberId => HashSet.make(interrupt(fiberId)), (set, annotation) => HashSet.map(cause => annotated(cause, annotation))(set), (leftSet, rightSet) => HashSet.flatMap(leftCause => HashSet.map(rightCause => sequential(leftCause, rightCause))(rightSet))(leftSet), (leftSet, rightSet) => HashSet.flatMap(leftCause => HashSet.map(rightCause => parallel(leftCause, rightCause))(rightSet))(leftSet));\n/** @internal */\nexports.linearize = linearize;\nconst stripFailures = self => match(self, empty, () => empty, defect => die(defect), fiberId => interrupt(fiberId), (cause, annotation) => isEmptyType(cause) ? cause : annotated(cause, annotation), (left, right) => sequential(left, right), (left, right) => parallel(left, right));\n/** @internal */\nexports.stripFailures = stripFailures;\nconst electFailures = self => match(self, empty, failure => die(failure), defect => die(defect), fiberId => interrupt(fiberId), (cause, annotation) => isEmptyType(cause) ? cause : annotated(cause, annotation), (left, right) => sequential(left, right), (left, right) => parallel(left, right));\n/** @internal */\nexports.electFailures = electFailures;\nconst stripSomeDefects = /*#__PURE__*/(0, _Function.dual)(2, (self, pf) => {\n  return match(self, Option.some(empty), error => Option.some(fail(error)), defect => {\n    const option = pf(defect);\n    return Option.isSome(option) ? Option.none() : Option.some(die(defect));\n  }, fiberId => Option.some(interrupt(fiberId)), (option, annotation) => Option.map(cause => annotated(cause, annotation))(option), (left, right) => {\n    if (Option.isSome(left) && Option.isSome(right)) {\n      return Option.some(sequential(left.value, right.value));\n    }\n    if (Option.isSome(left) && Option.isNone(right)) {\n      return Option.some(left.value);\n    }\n    if (Option.isNone(left) && Option.isSome(right)) {\n      return Option.some(right.value);\n    }\n    return Option.none();\n  }, (left, right) => {\n    if (Option.isSome(left) && Option.isSome(right)) {\n      return Option.some(parallel(left.value, right.value));\n    }\n    if (Option.isSome(left) && Option.isNone(right)) {\n      return Option.some(left.value);\n    }\n    if (Option.isNone(left) && Option.isSome(right)) {\n      return Option.some(right.value);\n    }\n    return Option.none();\n  });\n});\n// -----------------------------------------------------------------------------\n// Mapping\n// -----------------------------------------------------------------------------\n/** @internal */\nexports.stripSomeDefects = stripSomeDefects;\nconst as = /*#__PURE__*/(0, _Function.dual)(2, (self, error) => map(self, () => error));\n/** @internal */\nexports.as = as;\nconst map = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => flatMap(self, e => fail(f(e))));\n// -----------------------------------------------------------------------------\n// Sequencing\n// -----------------------------------------------------------------------------\n/** @internal */\nexports.map = map;\nconst flatMap = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => match(self, empty, error => f(error), defect => die(defect), fiberId => interrupt(fiberId), (cause, annotation) => annotated(cause, annotation), (left, right) => sequential(left, right), (left, right) => parallel(left, right)));\n/** @internal */\nexports.flatMap = flatMap;\nconst flatten = self => flatMap(self, _Function.identity);\n// -----------------------------------------------------------------------------\n// Equality\n// -----------------------------------------------------------------------------\n/** @internal */\nexports.flatten = flatten;\nconst contains = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => {\n  if (that._tag === OpCodes.OP_EMPTY || self === that) {\n    return true;\n  }\n  return reduce(self, false, (accumulator, cause) => {\n    return Option.some(accumulator || causeEquals(cause, that));\n  });\n});\n/** @internal */\nexports.contains = contains;\nconst causeEquals = (left, right) => {\n  let leftStack = Chunk.of(left);\n  let rightStack = Chunk.of(right);\n  while (Chunk.isNonEmpty(leftStack) && Chunk.isNonEmpty(rightStack)) {\n    const [leftParallel, leftSequential] = reduce([HashSet.empty(), Chunk.empty()], ([parallel, sequential], cause) => {\n      const [par, seq] = evaluateCause(cause);\n      return Option.some([HashSet.union(par)(parallel), Chunk.concat(seq)(sequential)]);\n    })(Chunk.headNonEmpty(leftStack));\n    const [rightParallel, rightSequential] = reduce([HashSet.empty(), Chunk.empty()], ([parallel, sequential], cause) => {\n      const [par, seq] = evaluateCause(cause);\n      return Option.some([HashSet.union(par)(parallel), Chunk.concat(seq)(sequential)]);\n    })(Chunk.headNonEmpty(rightStack));\n    if (!Equal.equals(leftParallel, rightParallel)) {\n      return false;\n    }\n    leftStack = leftSequential;\n    rightStack = rightSequential;\n  }\n  return true;\n};\n// -----------------------------------------------------------------------------\n// Flattening\n// -----------------------------------------------------------------------------\n/**\n * Flattens a cause to a sequence of sets of causes, where each set represents\n * causes that fail in parallel and sequential sets represent causes that fail\n * after each other.\n *\n * @internal\n */\nconst flattenCause = cause => {\n  return flattenCauseLoop(Chunk.of(cause), Chunk.empty());\n};\n/** @internal */\nconst flattenCauseLoop = (causes, flattened) => {\n  // eslint-disable-next-line no-constant-condition\n  while (1) {\n    const [parallel, sequential] = Chunk.reduce([HashSet.empty(), Chunk.empty()], ([parallel, sequential], cause) => {\n      const [par, seq] = evaluateCause(cause);\n      return [HashSet.union(par)(parallel), Chunk.concat(seq)(sequential)];\n    })(causes);\n    const updated = HashSet.size(parallel) > 0 ? Chunk.prepend(parallel)(flattened) : flattened;\n    if (Chunk.isEmpty(sequential)) {\n      return Chunk.reverse(updated);\n    }\n    causes = sequential;\n    flattened = updated;\n  }\n  throw new Error(\"BUG: Cause.flattenCauseLoop - please report an issue at https://github.com/Effect-TS/io/issues\");\n};\n// -----------------------------------------------------------------------------\n// Squashing\n// -----------------------------------------------------------------------------\n/** @internal */\nconst squash = self => {\n  return squashWith(_Function.identity)(self);\n};\n/** @internal */\nexports.squash = squash;\nconst squashWith = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => {\n  const option = Option.map(f)(failureOption(self));\n  switch (option._tag) {\n    case \"None\":\n      {\n        return Option.match(() => {\n          const interrupts = Array.from(interruptors(self)).flatMap(fiberId => Array.from(FiberId.ids(fiberId)).map(id => `#${id}`));\n          return InterruptedException(interrupts ? `Interrupted by fibers: ${interrupts.join(\", \")}` : void 0);\n        }, _Function.identity)(Chunk.head(defects(self)));\n      }\n    case \"Some\":\n      {\n        return option.value;\n      }\n  }\n});\n// -----------------------------------------------------------------------------\n// Finding\n// -----------------------------------------------------------------------------\n/** @internal */\nexports.squashWith = squashWith;\nconst find = /*#__PURE__*/(0, _Function.dual)(2, (self, pf) => {\n  const stack = [self];\n  while (stack.length > 0) {\n    const item = stack.pop();\n    const option = pf(item);\n    switch (option._tag) {\n      case \"None\":\n        {\n          switch (item._tag) {\n            case OpCodes.OP_SEQUENTIAL:\n            case OpCodes.OP_PARALLEL:\n              {\n                stack.push(item.right);\n                stack.push(item.left);\n                break;\n              }\n            case OpCodes.OP_ANNOTATED:\n              {\n                stack.push(item.cause);\n                break;\n              }\n          }\n          break;\n        }\n      case \"Some\":\n        {\n          return option;\n        }\n    }\n  }\n  return Option.none();\n});\n// -----------------------------------------------------------------------------\n// Filtering\n// -----------------------------------------------------------------------------\n/** @internal */\nexports.find = find;\nconst filter = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => reduceWithContext(self, void 0, FilterCauseReducer(predicate)));\n// -----------------------------------------------------------------------------\n// Evaluation\n// -----------------------------------------------------------------------------\n/**\n * Takes one step in evaluating a cause, returning a set of causes that fail\n * in parallel and a list of causes that fail sequentially after those causes.\n *\n * @internal\n */\nexports.filter = filter;\nconst evaluateCause = self => {\n  let cause = self;\n  const stack = [];\n  let _parallel = HashSet.empty();\n  let _sequential = Chunk.empty();\n  while (cause !== undefined) {\n    switch (cause._tag) {\n      case OpCodes.OP_EMPTY:\n        {\n          if (stack.length === 0) {\n            return [_parallel, _sequential];\n          }\n          cause = stack.pop();\n          break;\n        }\n      case OpCodes.OP_FAIL:\n        {\n          if (stack.length === 0) {\n            return [HashSet.add(cause.error)(_parallel), _sequential];\n          }\n          _parallel = HashSet.add(cause.error)(_parallel);\n          cause = stack.pop();\n          break;\n        }\n      case OpCodes.OP_DIE:\n        {\n          if (stack.length === 0) {\n            return [HashSet.add(cause.defect)(_parallel), _sequential];\n          }\n          _parallel = HashSet.add(cause.defect)(_parallel);\n          cause = stack.pop();\n          break;\n        }\n      case OpCodes.OP_INTERRUPT:\n        {\n          if (stack.length === 0) {\n            return [HashSet.add(cause.fiberId)(_parallel), _sequential];\n          }\n          _parallel = HashSet.add(cause.fiberId)(_parallel);\n          cause = stack.pop();\n          break;\n        }\n      case OpCodes.OP_ANNOTATED:\n        {\n          cause = cause.cause;\n          break;\n        }\n      case OpCodes.OP_SEQUENTIAL:\n        {\n          switch (cause.left._tag) {\n            case OpCodes.OP_EMPTY:\n              {\n                cause = cause.right;\n                break;\n              }\n            case OpCodes.OP_SEQUENTIAL:\n              {\n                cause = sequential(cause.left.left, sequential(cause.left.right, cause.right));\n                break;\n              }\n            case OpCodes.OP_PARALLEL:\n              {\n                cause = parallel(sequential(cause.left.left, cause.right), sequential(cause.left.right, cause.right));\n                break;\n              }\n            case OpCodes.OP_ANNOTATED:\n              {\n                cause = sequential(cause.left.cause, cause.right);\n                break;\n              }\n            default:\n              {\n                _sequential = Chunk.prepend(cause.right)(_sequential);\n                cause = cause.left;\n                break;\n              }\n          }\n          break;\n        }\n      case OpCodes.OP_PARALLEL:\n        {\n          stack.push(cause.right);\n          cause = cause.left;\n          break;\n        }\n    }\n  }\n  throw new Error(\"BUG: Cause.evaluateCauseLoop - please report an issue at https://github.com/Effect-TS/io/issues\");\n};\n// -----------------------------------------------------------------------------\n// Reducing\n// -----------------------------------------------------------------------------\n/** @internal */\nconst SizeCauseReducer = {\n  emptyCase: () => 0,\n  failCase: () => 1,\n  dieCase: () => 1,\n  interruptCase: () => 1,\n  annotatedCase: (_, value) => value,\n  sequentialCase: (_, left, right) => left + right,\n  parallelCase: (_, left, right) => left + right\n};\n/** @internal */\nconst IsInterruptedOnlyCauseReducer = {\n  emptyCase: _Function.constTrue,\n  failCase: _Function.constFalse,\n  dieCase: _Function.constFalse,\n  interruptCase: _Function.constTrue,\n  annotatedCase: (_, value) => value,\n  sequentialCase: (_, left, right) => left && right,\n  parallelCase: (_, left, right) => left && right\n};\n/** @internal */\nconst FilterCauseReducer = predicate => ({\n  emptyCase: () => empty,\n  failCase: (_, error) => fail(error),\n  dieCase: (_, defect) => die(defect),\n  interruptCase: (_, fiberId) => interrupt(fiberId),\n  annotatedCase: (_, cause, annotation) => annotated(cause, annotation),\n  sequentialCase: (_, left, right) => {\n    if (predicate(left)) {\n      if (predicate(right)) {\n        return sequential(left, right);\n      }\n      return left;\n    }\n    if (predicate(right)) {\n      return right;\n    }\n    return empty;\n  },\n  parallelCase: (_, left, right) => {\n    if (predicate(left)) {\n      if (predicate(right)) {\n        return parallel(left, right);\n      }\n      return left;\n    }\n    if (predicate(right)) {\n      return right;\n    }\n    return empty;\n  }\n});\nconst OP_SEQUENTIAL_CASE = \"SequentialCase\";\nconst OP_PARALLEL_CASE = \"ParallelCase\";\nconst OP_ANNOTATED_CASE = \"AnnotatedCase\";\n/** @internal */\nconst match = /*#__PURE__*/(0, _Function.dual)(8, (self, emptyCase, failCase, dieCase, interruptCase, annotatedCase, sequentialCase, parallelCase) => {\n  return reduceWithContext(self, void 0, {\n    emptyCase: () => emptyCase,\n    failCase: (_, error) => failCase(error),\n    dieCase: (_, defect) => dieCase(defect),\n    interruptCase: (_, fiberId) => interruptCase(fiberId),\n    annotatedCase: (_, value, annotation) => annotatedCase(value, annotation),\n    sequentialCase: (_, left, right) => sequentialCase(left, right),\n    parallelCase: (_, left, right) => parallelCase(left, right)\n  });\n});\n/** @internal */\nexports.match = match;\nconst reduce = /*#__PURE__*/(0, _Function.dual)(3, (self, zero, pf) => {\n  let accumulator = zero;\n  let cause = self;\n  const causes = [];\n  while (cause !== undefined) {\n    const option = pf(accumulator, cause);\n    accumulator = Option.isSome(option) ? option.value : accumulator;\n    switch (cause._tag) {\n      case OpCodes.OP_SEQUENTIAL:\n        {\n          causes.push(cause.right);\n          cause = cause.left;\n          break;\n        }\n      case OpCodes.OP_PARALLEL:\n        {\n          causes.push(cause.right);\n          cause = cause.left;\n          break;\n        }\n      case OpCodes.OP_ANNOTATED:\n        {\n          cause = cause.cause;\n          break;\n        }\n      default:\n        {\n          cause = undefined;\n          break;\n        }\n    }\n    if (cause === undefined && causes.length > 0) {\n      cause = causes.pop();\n    }\n  }\n  return accumulator;\n});\n/** @internal */\nexports.reduce = reduce;\nconst reduceWithContext = /*#__PURE__*/(0, _Function.dual)(3, (self, context, reducer) => {\n  const input = [self];\n  const output = [];\n  while (input.length > 0) {\n    const cause = input.pop();\n    switch (cause._tag) {\n      case OpCodes.OP_EMPTY:\n        {\n          output.push(Either.right(reducer.emptyCase(context)));\n          break;\n        }\n      case OpCodes.OP_FAIL:\n        {\n          output.push(Either.right(reducer.failCase(context, cause.error)));\n          break;\n        }\n      case OpCodes.OP_DIE:\n        {\n          output.push(Either.right(reducer.dieCase(context, cause.defect)));\n          break;\n        }\n      case OpCodes.OP_INTERRUPT:\n        {\n          output.push(Either.right(reducer.interruptCase(context, cause.fiberId)));\n          break;\n        }\n      case OpCodes.OP_ANNOTATED:\n        {\n          input.push(cause.cause);\n          output.push(Either.left({\n            _tag: OP_ANNOTATED_CASE,\n            annotation: cause.annotation\n          }));\n          break;\n        }\n      case OpCodes.OP_SEQUENTIAL:\n        {\n          input.push(cause.right);\n          input.push(cause.left);\n          output.push(Either.left({\n            _tag: OP_SEQUENTIAL_CASE\n          }));\n          break;\n        }\n      case OpCodes.OP_PARALLEL:\n        {\n          input.push(cause.right);\n          input.push(cause.left);\n          output.push(Either.left({\n            _tag: OP_PARALLEL_CASE\n          }));\n          break;\n        }\n    }\n  }\n  const accumulator = [];\n  while (output.length > 0) {\n    const either = output.pop();\n    switch (either._tag) {\n      case \"Left\":\n        {\n          switch (either.left._tag) {\n            case OP_SEQUENTIAL_CASE:\n              {\n                const left = accumulator.pop();\n                const right = accumulator.pop();\n                const value = reducer.sequentialCase(context, left, right);\n                accumulator.push(value);\n                break;\n              }\n            case OP_PARALLEL_CASE:\n              {\n                const left = accumulator.pop();\n                const right = accumulator.pop();\n                const value = reducer.parallelCase(context, left, right);\n                accumulator.push(value);\n                break;\n              }\n            case OP_ANNOTATED_CASE:\n              {\n                const cause = accumulator.pop();\n                const value = reducer.annotatedCase(context, cause, either.left.annotation);\n                accumulator.push(value);\n                break;\n              }\n          }\n          break;\n        }\n      case \"Right\":\n        {\n          accumulator.push(either.right);\n          break;\n        }\n    }\n  }\n  if (accumulator.length === 0) {\n    throw new Error(\"BUG: Cause.reduceWithContext - please report an issue at https://github.com/Effect-TS/io/issues\");\n  }\n  return accumulator.pop();\n});\n// -----------------------------------------------------------------------------\n// Errors\n// -----------------------------------------------------------------------------\nexports.reduceWithContext = reduceWithContext;\nconst makeException = (proto, tag) => {\n  const _tag = {\n    value: tag,\n    enumerable: true\n  };\n  const protoWithToString = {\n    ...proto,\n    toString() {\n      return `${this._tag}: ${this.message}`;\n    }\n  };\n  return message => Object.create(protoWithToString, {\n    _tag,\n    message: {\n      value: message,\n      enumerable: true\n    }\n  });\n};\n/** @internal */\nconst RuntimeExceptionTypeId = /*#__PURE__*/Symbol.for(\"@effect/io/Cause/errors/RuntimeException\");\n/** @internal */\nexports.RuntimeExceptionTypeId = RuntimeExceptionTypeId;\nconst RuntimeException = /*#__PURE__*/makeException({\n  [RuntimeExceptionTypeId]: RuntimeExceptionTypeId\n}, \"RuntimeException\");\n/** @internal */\nexports.RuntimeException = RuntimeException;\nconst isRuntimeException = u => {\n  return typeof u === \"object\" && u != null && RuntimeExceptionTypeId in u;\n};\n/** @internal */\nexports.isRuntimeException = isRuntimeException;\nconst InterruptedExceptionTypeId = /*#__PURE__*/Symbol.for(\"@effect/io/Cause/errors/InterruptedException\");\n/** @internal */\nexports.InterruptedExceptionTypeId = InterruptedExceptionTypeId;\nconst InterruptedException = /*#__PURE__*/makeException({\n  [InterruptedExceptionTypeId]: InterruptedExceptionTypeId\n}, \"InterruptedException\");\n/** @internal */\nexports.InterruptedException = InterruptedException;\nconst isInterruptedException = u => {\n  return typeof u === \"object\" && u != null && InterruptedExceptionTypeId in u;\n};\n/** @internal */\nexports.isInterruptedException = isInterruptedException;\nconst IllegalArgumentExceptionTypeId = /*#__PURE__*/Symbol.for(\"@effect/io/Cause/errors/IllegalArgument\");\n/** @internal */\nexports.IllegalArgumentExceptionTypeId = IllegalArgumentExceptionTypeId;\nconst IllegalArgumentException = /*#__PURE__*/makeException({\n  [IllegalArgumentExceptionTypeId]: IllegalArgumentExceptionTypeId\n}, \"IllegalArgumentException\");\n/** @internal */\nexports.IllegalArgumentException = IllegalArgumentException;\nconst isIllegalArgumentException = u => {\n  return typeof u === \"object\" && u != null && IllegalArgumentExceptionTypeId in u;\n};\n/** @internal */\nexports.isIllegalArgumentException = isIllegalArgumentException;\nconst NoSuchElementExceptionTypeId = /*#__PURE__*/Symbol.for(\"@effect/io/Cause/errors/NoSuchElement\");\n/** @internal */\nexports.NoSuchElementExceptionTypeId = NoSuchElementExceptionTypeId;\nconst NoSuchElementException = /*#__PURE__*/makeException({\n  [NoSuchElementExceptionTypeId]: NoSuchElementExceptionTypeId\n}, \"NoSuchElementException\");\n/** @internal */\nexports.NoSuchElementException = NoSuchElementException;\nconst isNoSuchElementException = u => {\n  return typeof u === \"object\" && u != null && NoSuchElementExceptionTypeId in u;\n};\n/** @internal */\nexports.isNoSuchElementException = isNoSuchElementException;\nconst InvalidHubCapacityExceptionTypeId = /*#__PURE__*/Symbol.for(\"@effect/io/Cause/errors/InvalidHubCapacityException\");\n/** @internal */\nexports.InvalidHubCapacityExceptionTypeId = InvalidHubCapacityExceptionTypeId;\nconst InvalidHubCapacityException = /*#__PURE__*/makeException({\n  [InvalidHubCapacityExceptionTypeId]: InvalidHubCapacityExceptionTypeId\n}, \"InvalidHubCapacityException\");\n/** @internal */\nexports.InvalidHubCapacityException = InvalidHubCapacityException;\nconst isInvalidCapacityError = u => {\n  return typeof u === \"object\" && u != null && InvalidHubCapacityExceptionTypeId in u;\n};\n// -----------------------------------------------------------------------------\n// Stack Annotations\n// -----------------------------------------------------------------------------\n/** @internal */\nexports.isInvalidCapacityError = isInvalidCapacityError;\nconst StackAnnotationTypeId = /*#__PURE__*/Symbol.for(\"@effect/io/Cause/StackAnnotation\");\n/** @internal */\nexports.StackAnnotationTypeId = StackAnnotationTypeId;\nclass StackAnnotation {\n  constructor(stack, seq) {\n    this.stack = stack;\n    this.seq = seq;\n    this[_a] = StackAnnotationTypeId;\n  }\n}\nexports.StackAnnotation = StackAnnotation;\n_a = StackAnnotationTypeId;\n/** @internal */\nconst globalErrorSeq = /*#__PURE__*/MRef.make(0);\n/** @internal */\nexports.globalErrorSeq = globalErrorSeq;\nconst isStackAnnotation = u => {\n  return typeof u === \"object\" && u != null && StackAnnotationTypeId in u;\n};\n/** @internal */\nexports.isStackAnnotation = isStackAnnotation;\nconst UnAnnotateCauseReducer = () => ({\n  emptyCase: () => empty,\n  failCase: (_, error) => fail(error),\n  dieCase: (_, defect) => die(defect),\n  interruptCase: (_, fiberId) => interrupt(fiberId),\n  annotatedCase: (_, cause, __) => cause,\n  sequentialCase: (_, left, right) => sequential(left, right),\n  parallelCase: (_, left, right) => parallel(left, right)\n});\n/** @internal */\nconst unannotate = self => reduceWithContext(self, void 0, UnAnnotateCauseReducer());\nexports.unannotate = unannotate;\n//# sourceMappingURL=cause.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.make = exports.globalClockScheduler = exports.dieOnSync = exports.dieMessage = exports.clockTag = exports.MAX_TIMER_MILLIS = exports.ClockTypeId = void 0;\nvar Context = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Context\"));\nvar Either = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Either\"));\nvar _Function = /*#__PURE__*/require(\"@effect/data/Function\");\nvar Debug = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Debug\"));\nvar internalCause = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/cause\"));\nvar core = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/core\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\nvar _a;\n/** @internal */\nconst ClockSymbolKey = \"@effect/io/Clock\";\n/** @internal */\nconst ClockTypeId = /*#__PURE__*/Symbol.for(ClockSymbolKey);\n/** @internal */\nexports.ClockTypeId = ClockTypeId;\nconst clockTag = /*#__PURE__*/Context.Tag(ClockTypeId);\n/** @internal */\nexports.clockTag = clockTag;\nconst MAX_TIMER_MILLIS = 2 ** 31 - 1;\n/** @internal */\nexports.MAX_TIMER_MILLIS = MAX_TIMER_MILLIS;\nconst globalClockScheduler = {\n  unsafeSchedule(task, duration) {\n    // If the duration is greater than the value allowable by the JS timer\n    // functions, treat the value as an infinite duration\n    if (duration.millis > MAX_TIMER_MILLIS) {\n      return _Function.constFalse;\n    }\n    let completed = false;\n    const handle = setTimeout(() => {\n      completed = true;\n      task();\n    }, duration.millis);\n    return () => {\n      clearTimeout(handle);\n      return !completed;\n    };\n  }\n};\n/** @internal */\nexports.globalClockScheduler = globalClockScheduler;\nclass ClockImpl {\n  constructor() {\n    this[_a] = ClockTypeId;\n  }\n  unsafeCurrentTimeMillis() {\n    return new Date().getTime();\n  }\n  currentTimeMillis() {\n    return Debug.bodyWithTrace(trace => core.sync(() => this.unsafeCurrentTimeMillis()).traced(trace));\n  }\n  scheduler() {\n    return Debug.bodyWithTrace(trace => core.succeed(globalClockScheduler).traced(trace));\n  }\n  sleep(duration) {\n    return Debug.bodyWithTrace(trace => dieOnSync(core.asyncInterruptEither(cb => {\n      const canceler = globalClockScheduler.unsafeSchedule(() => cb(core.unit()), duration);\n      return Either.left(core.asUnit(core.sync(canceler)));\n    })).traced(trace));\n  }\n}\n_a = ClockTypeId;\n/** @internal */\nconst make = () => new ClockImpl();\n//\n// Circular with effect\n//\n/* @internal */\nexports.make = make;\nconst dieMessage = /*#__PURE__*/Debug.methodWithTrace(trace => message => core.failCauseSync(() => internalCause.die(internalCause.RuntimeException(message))).traced(trace));\n/* @internal */\nexports.dieMessage = dieMessage;\nconst dieOnSync = /*#__PURE__*/Debug.methodWithTrace(trace => self => core.withFiberRuntime(runtime => {\n  const scheduler = runtime.getFiberRef(core.currentScheduler);\n  if (scheduler.executionMode === \"Sync\") {\n    return dieMessage(\"effect is forbidden to run in Sync mode\");\n  }\n  return self;\n}).traced(trace));\nexports.dieOnSync = dieOnSync;\n//# sourceMappingURL=clock.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.zipWith = exports.zip = exports.withDescription = exports.withDefault = exports.validate = exports.unwrap = exports.table = exports.sync = exports.succeed = exports.string = exports.setOf = exports.secret = exports.repeat = exports.primitive = exports.orElseIf = exports.orElse = exports.optional = exports.nested = exports.missingError = exports.mapOrFail = exports.mapAttempt = exports.map = exports.isConfig = exports.integer = exports.float = exports.fail = exports.defer = exports.date = exports.chunkOf = exports.bool = exports.arrayOf = exports.all = exports.ConfigTypeId = void 0;\nvar Chunk = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Chunk\"));\nvar Either = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Either\"));\nvar _Function = /*#__PURE__*/require(\"@effect/data/Function\");\nvar HashSet = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/HashSet\"));\nvar Option = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Option\"));\nvar ConfigError = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Config/Error\"));\nvar configError = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/configError\"));\nvar configSecret = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/configSecret\"));\nvar OpCodes = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/opCodes/config\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/** @internal */\nconst ConfigSymbolKey = \"@effect/io/Config\";\n/** @internal */\nconst ConfigTypeId = /*#__PURE__*/Symbol.for(ConfigSymbolKey);\n/** @internal */\nexports.ConfigTypeId = ConfigTypeId;\nconst configVariance = {\n  _A: _ => _\n};\n/** @internal */\nconst proto = {\n  [ConfigTypeId]: configVariance\n};\n/** @internal */\nconst bool = name => {\n  const config = primitive(\"a boolean property\", text => {\n    switch (text) {\n      case \"true\":\n      case \"yes\":\n      case \"on\":\n      case \"1\":\n        {\n          return Either.right(true);\n        }\n      case \"false\":\n      case \"no\":\n      case \"off\":\n      case \"0\":\n        {\n          return Either.right(false);\n        }\n      default:\n        {\n          const error = configError.InvalidData(Chunk.empty(), `Expected a boolean value, but received ${text}`);\n          return Either.left(error);\n        }\n    }\n  });\n  return name === undefined ? config : nested(name)(config);\n};\n/** @internal */\nexports.bool = bool;\nconst arrayOf = (config, name) => {\n  return map(Chunk.toReadonlyArray)(chunkOf(config, name));\n};\n/** @internal */\nexports.arrayOf = arrayOf;\nconst chunkOf = (config, name) => {\n  return name === undefined ? repeat(config) : nested(name)(repeat(config));\n};\n/** @internal */\nexports.chunkOf = chunkOf;\nconst date = name => {\n  const config = primitive(\"a date property\", text => {\n    const result = Date.parse(text);\n    if (Number.isNaN(result)) {\n      return Either.left(configError.InvalidData(Chunk.empty(), `Expected a date value but received ${text}`));\n    }\n    return Either.right(new Date(result));\n  });\n  return name === undefined ? config : nested(name)(config);\n};\n/** @internal */\nexports.date = date;\nconst defer = config => {\n  const lazy = Object.create(proto);\n  lazy._tag = OpCodes.OP_LAZY;\n  lazy.config = config;\n  return lazy;\n};\n/** @internal */\nexports.defer = defer;\nconst fail = message => {\n  const fail = Object.create(proto);\n  fail._tag = OpCodes.OP_FAIL;\n  fail.message = message;\n  fail.parse = () => Either.left(configError.Unsupported(Chunk.empty(), message));\n  return fail;\n};\n/** @internal */\nexports.fail = fail;\nconst float = name => {\n  const config = primitive(\"a float property\", text => {\n    const result = Number.parseFloat(text);\n    if (Number.isNaN(result)) {\n      return Either.left(configError.InvalidData(Chunk.empty(), `Expected an float value but received ${text}`));\n    }\n    return Either.right(result);\n  });\n  return name === undefined ? config : nested(name)(config);\n};\n/** @internal */\nexports.float = float;\nconst integer = name => {\n  const config = primitive(\"an integer property\", text => {\n    const result = Number.parseInt(text, 10);\n    if (Number.isNaN(result)) {\n      return Either.left(configError.InvalidData(Chunk.empty(), `Expected an integer value but received ${text}`));\n    }\n    return Either.right(result);\n  });\n  return name === undefined ? config : nested(name)(config);\n};\n/** @internal */\nexports.integer = integer;\nconst map = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => mapOrFail(self, a => Either.right(f(a))));\n/** @internal */\nexports.map = map;\nconst mapAttempt = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => mapOrFail(self, a => {\n  try {\n    return Either.right(f(a));\n  } catch (error) {\n    return Either.left(configError.InvalidData(Chunk.empty(), error instanceof Error ? error.message : `${error}`));\n  }\n}));\n/** @internal */\nexports.mapAttempt = mapAttempt;\nconst mapOrFail = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => {\n  const mapOrFail = Object.create(proto);\n  mapOrFail._tag = OpCodes.OP_MAP_OR_FAIL;\n  mapOrFail.original = self;\n  mapOrFail.mapOrFail = f;\n  return mapOrFail;\n});\n/** @internal */\nexports.mapOrFail = mapOrFail;\nconst missingError = name => {\n  return self => {\n    return configError.MissingData(Chunk.empty(), `Expected ${self.description} with name ${name}`);\n  };\n};\n/** @internal */\nexports.missingError = missingError;\nconst nested = /*#__PURE__*/(0, _Function.dual)(2, (self, name) => {\n  const nested = Object.create(proto);\n  nested._tag = OpCodes.OP_NESTED;\n  nested.name = name;\n  nested.config = self;\n  return nested;\n});\n/** @internal */\nexports.nested = nested;\nconst orElse = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => {\n  const fallback = Object.create(proto);\n  fallback._tag = OpCodes.OP_FALLBACK;\n  fallback.first = self;\n  fallback.second = defer(that);\n  fallback.condition = _Function.constTrue;\n  return fallback;\n});\n/** @internal */\nexports.orElse = orElse;\nconst orElseIf = /*#__PURE__*/(0, _Function.dual)(3, (self, that, condition) => {\n  const fallback = Object.create(proto);\n  fallback._tag = OpCodes.OP_FALLBACK;\n  fallback.first = self;\n  fallback.second = defer(that);\n  fallback.condition = condition;\n  return fallback;\n});\n/** @internal */\nexports.orElseIf = orElseIf;\nconst optional = self => {\n  return orElseIf(() => succeed(Option.none()), ConfigError.isMissingDataOnly)(map(Option.some)(self));\n};\n/** @internal */\nexports.optional = optional;\nconst primitive = (description, parse) => {\n  const primitive = Object.create(proto);\n  primitive._tag = OpCodes.OP_PRIMITIVE;\n  primitive.description = description;\n  primitive.parse = parse;\n  return primitive;\n};\n/** @internal */\nexports.primitive = primitive;\nconst repeat = self => {\n  const repeat = Object.create(proto);\n  repeat._tag = OpCodes.OP_SEQUENCE;\n  repeat.config = self;\n  return repeat;\n};\n/** @internal */\nexports.repeat = repeat;\nconst secret = name => {\n  const config = primitive(\"a secret property\", text => Either.right(configSecret.fromString(text)));\n  return name === undefined ? config : nested(name)(config);\n};\n/** @internal */\nexports.secret = secret;\nconst setOf = (config, name) => {\n  const newConfig = map(chunkOf(config), HashSet.fromIterable);\n  return name === undefined ? newConfig : nested(name)(newConfig);\n};\n/** @internal */\nexports.setOf = setOf;\nconst string = name => {\n  const config = primitive(\"a text property\", Either.right);\n  return name === undefined ? config : nested(name)(config);\n};\nexports.string = string;\nconst all = function () {\n  if (arguments.length === 1) {\n    if (typeof arguments[0] === \"object\" && arguments[0] !== null && isConfig(arguments[0])) {\n      return map(arguments[0], x => [x]);\n    } else if (Array.isArray(arguments[0])) {\n      return tuple(arguments);\n    } else {\n      return struct(arguments[0]);\n    }\n  }\n  return tuple(arguments);\n};\nexports.all = all;\nconst struct = r => {\n  const entries = Object.entries(r);\n  let result = map(value => ({\n    [entries[0][0]]: value\n  }))(entries[0][1]);\n  if (entries.length === 1) {\n    return result;\n  }\n  const rest = entries.slice(1);\n  for (const [key, config] of rest) {\n    result = zipWith(config, (record, value) => ({\n      ...record,\n      [key]: value\n    }))(result);\n  }\n  return result;\n};\n/** @internal */\nconst succeed = value => {\n  const constant = Object.create(proto);\n  constant._tag = OpCodes.OP_CONSTANT;\n  constant.value = value;\n  constant.parse = () => Either.right(value);\n  return constant;\n};\n/** @internal */\nexports.succeed = succeed;\nconst sync = value => {\n  return defer(() => succeed(value()));\n};\n/** @internal */\nexports.sync = sync;\nconst table = (config, name) => {\n  const table = Object.create(proto);\n  table._tag = OpCodes.OP_TABLE;\n  table.valueConfig = config;\n  return name === undefined ? table : nested(name)(table);\n};\n/** @internal */\nexports.table = table;\nconst isConfig = u => typeof u === \"object\" && u != null && ConfigTypeId in u;\n/** @internal */\nexports.isConfig = isConfig;\nconst tuple = tuple => {\n  if (tuple.length === 0) {\n    return succeed([]);\n  }\n  if (tuple.length === 1) {\n    return map(tuple[0], x => [x]);\n  }\n  let result = map(tuple[0], x => [x]);\n  for (let i = 1; i < tuple.length; i++) {\n    const config = tuple[i];\n    result = zipWith(config, (tuple, value) => [...tuple, value])(result);\n  }\n  return result;\n};\n/**\n * @internal\n */\nconst unwrap = wrapped => {\n  if (isConfig(wrapped)) {\n    return wrapped;\n  }\n  return struct(Object.fromEntries(Object.entries(wrapped).map(([k, a]) => [k, unwrap(a)])));\n};\n/** @internal */\nexports.unwrap = unwrap;\nconst validate = /*#__PURE__*/(0, _Function.dual)(3, (self, message, f) => mapOrFail(self, a => {\n  if (f(a)) {\n    return Either.right(a);\n  }\n  return Either.left(configError.InvalidData(Chunk.empty(), message));\n}));\n/** @internal */\nexports.validate = validate;\nconst withDefault = /*#__PURE__*/(0, _Function.dual)(2, (self, def) => orElseIf(self, () => succeed(def), ConfigError.isMissingDataOnly));\n/** @internal */\nexports.withDefault = withDefault;\nconst withDescription = /*#__PURE__*/(0, _Function.dual)(2, (self, description) => {\n  const described = Object.create(proto);\n  described._tag = OpCodes.OP_DESCRIBED;\n  described.config = self;\n  described.description = description;\n  return described;\n});\n/** @internal */\nexports.withDescription = withDescription;\nconst zip = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => zipWith(self, that, (a, b) => [a, b]));\n/** @internal */\nexports.zip = zip;\nconst zipWith = /*#__PURE__*/(0, _Function.dual)(3, (self, that, f) => {\n  const zipWith = Object.create(proto);\n  zipWith._tag = OpCodes.OP_ZIP_WITH;\n  zipWith.left = self;\n  zipWith.right = that;\n  zipWith.zip = f;\n  return zipWith;\n});\nexports.zipWith = zipWith;\n//# sourceMappingURL=config.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.reduceWithContext = exports.proto = exports.prefixed = exports.isUnsupported = exports.isSourceUnavailable = exports.isOr = exports.isMissingDataOnly = exports.isMissingData = exports.isInvalidData = exports.isConfigError = exports.isAnd = exports.Unsupported = exports.SourceUnavailable = exports.Or = exports.MissingData = exports.InvalidData = exports.ConfigErrorTypeId = exports.And = void 0;\nvar Chunk = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Chunk\"));\nvar Either = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Either\"));\nvar _Function = /*#__PURE__*/require(\"@effect/data/Function\");\nvar OpCodes = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/opCodes/configError\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/** @internal */\nconst ConfigErrorSymbolKey = \"@effect/io/Config/Error\";\n/** @internal */\nconst ConfigErrorTypeId = /*#__PURE__*/Symbol.for(ConfigErrorSymbolKey);\n/** @internal */\nexports.ConfigErrorTypeId = ConfigErrorTypeId;\nconst proto = {\n  [ConfigErrorTypeId]: ConfigErrorTypeId\n};\n/** @internal */\nexports.proto = proto;\nconst And = (self, that) => {\n  const error = Object.create(proto);\n  error._tag = OpCodes.OP_AND;\n  error.left = self;\n  error.right = that;\n  Object.defineProperty(error, \"toString\", {\n    enumerable: false,\n    value() {\n      return `${this.left} and ${this.right}`;\n    }\n  });\n  return error;\n};\n/** @internal */\nexports.And = And;\nconst Or = (self, that) => {\n  const error = Object.create(proto);\n  error._tag = OpCodes.OP_OR;\n  error.left = self;\n  error.right = that;\n  Object.defineProperty(error, \"toString\", {\n    enumerable: false,\n    value() {\n      return `${this.left} or ${this.right}`;\n    }\n  });\n  return error;\n};\n/** @internal */\nexports.Or = Or;\nconst InvalidData = (path, message) => {\n  const error = Object.create(proto);\n  error._tag = OpCodes.OP_INVALID_DATA;\n  error.path = path;\n  error.message = message;\n  Object.defineProperty(error, \"toString\", {\n    enumerable: false,\n    value() {\n      const path = Chunk.join(\".\")(this.path);\n      return `(Invalid data at ${path}: \"${this.message}\")`;\n    }\n  });\n  return error;\n};\n/** @internal */\nexports.InvalidData = InvalidData;\nconst MissingData = (path, message) => {\n  const error = Object.create(proto);\n  error._tag = OpCodes.OP_MISSING_DATA;\n  error.path = path;\n  error.message = message;\n  Object.defineProperty(error, \"toString\", {\n    enumerable: false,\n    value() {\n      const path = Chunk.join(\".\")(this.path);\n      return `(Missing data at ${path}: \"${this.message}\")`;\n    }\n  });\n  return error;\n};\n/** @internal */\nexports.MissingData = MissingData;\nconst SourceUnavailable = (path, message, cause) => {\n  const error = Object.create(proto);\n  error._tag = OpCodes.OP_SOURCE_UNAVAILABLE;\n  error.path = path;\n  error.message = message;\n  error.cause = cause;\n  Object.defineProperty(error, \"toString\", {\n    enumerable: false,\n    value() {\n      const path = Chunk.join(\".\")(this.path);\n      return `(Source unavailable at ${path}: \"${this.message}\")`;\n    }\n  });\n  return error;\n};\n/** @internal */\nexports.SourceUnavailable = SourceUnavailable;\nconst Unsupported = (path, message) => {\n  const error = Object.create(proto);\n  error._tag = OpCodes.OP_UNSUPPORTED;\n  error.path = path;\n  error.message = message;\n  Object.defineProperty(error, \"toString\", {\n    enumerable: false,\n    value() {\n      const path = Chunk.join(\".\")(this.path);\n      return `(Unsupported operation at ${path}: \"${this.message}\")`;\n    }\n  });\n  return error;\n};\n/** @internal */\nexports.Unsupported = Unsupported;\nconst isConfigError = u => typeof u === \"object\" && u != null && ConfigErrorTypeId in u;\n/** @internal */\nexports.isConfigError = isConfigError;\nconst isAnd = self => self._tag === OpCodes.OP_AND;\n/** @internal */\nexports.isAnd = isAnd;\nconst isOr = self => self._tag === OpCodes.OP_OR;\n/** @internal */\nexports.isOr = isOr;\nconst isInvalidData = self => self._tag === OpCodes.OP_INVALID_DATA;\n/** @internal */\nexports.isInvalidData = isInvalidData;\nconst isMissingData = self => self._tag === OpCodes.OP_MISSING_DATA;\n/** @internal */\nexports.isMissingData = isMissingData;\nconst isSourceUnavailable = self => self._tag === OpCodes.OP_SOURCE_UNAVAILABLE;\n/** @internal */\nexports.isSourceUnavailable = isSourceUnavailable;\nconst isUnsupported = self => self._tag === OpCodes.OP_UNSUPPORTED;\n/** @internal */\nexports.isUnsupported = isUnsupported;\nconst prefixed = /*#__PURE__*/(0, _Function.dual)(2, (self, prefix) => {\n  switch (self._tag) {\n    case OpCodes.OP_AND:\n      {\n        return And(prefixed(prefix)(self.left), prefixed(prefix)(self.right));\n      }\n    case OpCodes.OP_OR:\n      {\n        return Or(prefixed(prefix)(self.left), prefixed(prefix)(self.right));\n      }\n    case OpCodes.OP_INVALID_DATA:\n      {\n        return InvalidData(Chunk.concat(self.path)(prefix), self.message);\n      }\n    case OpCodes.OP_MISSING_DATA:\n      {\n        return MissingData(Chunk.concat(self.path)(prefix), self.message);\n      }\n    case OpCodes.OP_SOURCE_UNAVAILABLE:\n      {\n        return SourceUnavailable(Chunk.concat(self.path)(prefix), self.message, self.cause);\n      }\n    case OpCodes.OP_UNSUPPORTED:\n      {\n        return Unsupported(Chunk.concat(self.path)(prefix), self.message);\n      }\n  }\n});\n/** @internal */\nexports.prefixed = prefixed;\nconst IsMissingDataOnlyReducer = {\n  andCase: (_, left, right) => left && right,\n  orCase: (_, left, right) => left || right,\n  invalidDataCase: _Function.constFalse,\n  missingDataCase: _Function.constTrue,\n  sourceUnavailableCase: _Function.constFalse,\n  unsupportedCase: _Function.constFalse\n};\n/** @internal */\nconst reduceWithContext = /*#__PURE__*/(0, _Function.dual)(3, (self, context, reducer) => {\n  const input = [self];\n  const output = [];\n  while (input.length > 0) {\n    const error = input.pop();\n    switch (error._tag) {\n      case OpCodes.OP_AND:\n        {\n          input.push(error.right);\n          input.push(error.left);\n          output.push(Either.left({\n            _tag: \"AndCase\"\n          }));\n          break;\n        }\n      case OpCodes.OP_OR:\n        {\n          input.push(error.right);\n          input.push(error.left);\n          output.push(Either.left({\n            _tag: \"OrCase\"\n          }));\n          break;\n        }\n      case OpCodes.OP_INVALID_DATA:\n        {\n          output.push(Either.right(reducer.invalidDataCase(context, error.path, error.message)));\n          break;\n        }\n      case OpCodes.OP_MISSING_DATA:\n        {\n          output.push(Either.right(reducer.missingDataCase(context, error.path, error.message)));\n          break;\n        }\n      case OpCodes.OP_SOURCE_UNAVAILABLE:\n        {\n          output.push(Either.right(reducer.sourceUnavailableCase(context, error.path, error.message, error.cause)));\n          break;\n        }\n      case OpCodes.OP_UNSUPPORTED:\n        {\n          output.push(Either.right(reducer.unsupportedCase(context, error.path, error.message)));\n          break;\n        }\n    }\n  }\n  const accumulator = [];\n  while (output.length > 0) {\n    const either = output.pop();\n    switch (either._tag) {\n      case \"Left\":\n        {\n          switch (either.left._tag) {\n            case \"AndCase\":\n              {\n                const left = accumulator.pop();\n                const right = accumulator.pop();\n                const value = reducer.andCase(context, left, right);\n                accumulator.push(value);\n                break;\n              }\n            case \"OrCase\":\n              {\n                const left = accumulator.pop();\n                const right = accumulator.pop();\n                const value = reducer.orCase(context, left, right);\n                accumulator.push(value);\n                break;\n              }\n          }\n          break;\n        }\n      case \"Right\":\n        {\n          accumulator.push(either.right);\n          break;\n        }\n    }\n  }\n  if (accumulator.length === 0) {\n    throw new Error(\"BUG: ConfigError.reduceWithContext - please report an issue at https://github.com/Effect-TS/io/issues\");\n  }\n  return accumulator.pop();\n});\n/** @internal */\nexports.reduceWithContext = reduceWithContext;\nconst isMissingDataOnly = self => reduceWithContext(self, void 0, IsMissingDataOnlyReducer);\nexports.isMissingDataOnly = isMissingDataOnly;\n//# sourceMappingURL=configError.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.within = exports.upperCase = exports.unnested = exports.snakeCase = exports.orElse = exports.nested = exports.makeFlat = exports.make = exports.lowerCase = exports.kebabCase = exports.fromMap = exports.fromFlat = exports.fromEnv = exports.contramapPath = exports.constantCase = exports.configProviderTag = exports.FlatConfigProviderTypeId = exports.ConfigProviderTypeId = void 0;\nvar Chunk = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Chunk\"));\nvar Context = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Context\"));\nvar Either = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Either\"));\nvar HashMap = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/HashMap\"));\nvar HashSet = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/HashSet\"));\nvar Option = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Option\"));\nvar Debug = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Debug\"));\nvar _config = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/config\"));\nvar configError = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/configError\"));\nvar pathPatch = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/configProvider/pathPatch\"));\nvar core = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/core\"));\nvar OpCodes = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/opCodes/config\"));\nvar StringUtils = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/string-utils\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/** @internal */\nconst ConfigProviderSymbolKey = \"@effect/io/Config/Provider\";\n/** @internal */\nconst ConfigProviderTypeId = /*#__PURE__*/Symbol.for(ConfigProviderSymbolKey);\n/** @internal */\nexports.ConfigProviderTypeId = ConfigProviderTypeId;\nconst configProviderTag = /*#__PURE__*/Context.Tag(ConfigProviderTypeId);\n/** @internal */\nexports.configProviderTag = configProviderTag;\nconst FlatConfigProviderSymbolKey = \"@effect/io/Config/Provider/Flat\";\n/** @internal */\nconst FlatConfigProviderTypeId = /*#__PURE__*/Symbol.for(FlatConfigProviderSymbolKey);\n/** @internal */\nexports.FlatConfigProviderTypeId = FlatConfigProviderTypeId;\nconst make = /*#__PURE__*/Debug.untracedMethod(restore => (load, flattened) => ({\n  [ConfigProviderTypeId]: ConfigProviderTypeId,\n  load: Debug.methodWithTrace(trace => config => restore(load)(config).traced(trace)),\n  flattened\n}));\n/** @internal */\nexports.make = make;\nconst makeFlat = /*#__PURE__*/Debug.untracedMethod(restore => (load, enumerateChildren, patch) => ({\n  [FlatConfigProviderTypeId]: FlatConfigProviderTypeId,\n  patch,\n  load: Debug.methodWithTrace(trace => (path, config, split = true) => restore(load)(path, config, split).traced(trace)),\n  enumerateChildren: Debug.methodWithTrace(trace => path => restore(enumerateChildren)(path).traced(trace))\n}));\n/** @internal */\nexports.makeFlat = makeFlat;\nconst fromFlat = /*#__PURE__*/Debug.untracedMethod(() => flat => make(config => core.flatMap(fromFlatLoop(flat, Chunk.empty(), config, false), chunk => Option.match(() => core.fail(configError.MissingData(Chunk.empty(), `Expected a single value having structure: ${config}`)), core.succeed)(Chunk.head(chunk))), flat));\n/** @internal */\nexports.fromFlat = fromFlat;\nconst fromEnv = /*#__PURE__*/Debug.untracedMethod(() => (config = {}) => {\n  const {\n    pathDelim,\n    seqDelim\n  } = Object.assign({}, {\n    pathDelim: \"_\",\n    seqDelim: \",\"\n  }, config);\n  const makePathString = path => Chunk.join(pathDelim)(path);\n  const unmakePathString = pathString => pathString.split(pathDelim);\n  const getEnv = () => typeof process !== \"undefined\" && \"env\" in process && typeof process.env === \"object\" ? process.env : {};\n  const load = (path, primitive, split = true) => {\n    const pathString = makePathString(path);\n    const current = getEnv();\n    const valueOpt = pathString in current ? Option.some(current[pathString]) : Option.none();\n    return core.flatMap(value => parsePrimitive(value, path, primitive, seqDelim, split))(core.mapError(() => configError.MissingData(path, `Expected ${pathString} to exist in the process context`))(core.fromOption(valueOpt)));\n  };\n  const enumerateChildren = path => core.sync(() => {\n    const current = getEnv();\n    const keys = Object.keys(current);\n    const keyPaths = Array.from(keys).map(value => unmakePathString(value.toUpperCase()));\n    const filteredKeyPaths = keyPaths.filter(keyPath => {\n      for (let i = 0; i < path.length; i++) {\n        const pathComponent = Chunk.unsafeGet(i)(path);\n        const currentElement = keyPath[i];\n        if (currentElement === undefined || pathComponent !== currentElement) {\n          return false;\n        }\n      }\n      return true;\n    }).flatMap(keyPath => keyPath.slice(path.length, path.length + 1));\n    return HashSet.fromIterable(filteredKeyPaths);\n  });\n  return fromFlat(makeFlat(load, enumerateChildren, pathPatch.empty));\n});\n/** @internal */\nexports.fromEnv = fromEnv;\nconst fromMap = /*#__PURE__*/Debug.untracedMethod(() => (map, config = {}) => {\n  const {\n    pathDelim,\n    seqDelim\n  } = Object.assign({}, {\n    seqDelim: \",\",\n    pathDelim: \".\"\n  }, config);\n  const makePathString = path => Chunk.join(pathDelim)(path);\n  const unmakePathString = pathString => pathString.split(pathDelim);\n  const load = (path, primitive, split = true) => {\n    const pathString = makePathString(path);\n    const valueOpt = map.has(pathString) ? Option.some(map.get(pathString)) : Option.none();\n    return core.flatMap(value => parsePrimitive(value, path, primitive, seqDelim, split))(core.mapError(() => configError.MissingData(path, `Expected ${pathString} to exist in the provided map`))(core.fromOption(valueOpt)));\n  };\n  const enumerateChildren = path => core.sync(() => {\n    const keyPaths = Array.from(map.keys()).map(unmakePathString);\n    const filteredKeyPaths = keyPaths.filter(keyPath => {\n      for (let i = 0; i < path.length; i++) {\n        const pathComponent = Chunk.unsafeGet(i)(path);\n        const currentElement = keyPath[i];\n        if (currentElement === undefined || pathComponent !== currentElement) {\n          return false;\n        }\n      }\n      return true;\n    }).flatMap(keyPath => keyPath.slice(path.length, path.length + 1));\n    return HashSet.fromIterable(filteredKeyPaths);\n  });\n  return fromFlat(makeFlat(load, enumerateChildren, pathPatch.empty));\n});\nexports.fromMap = fromMap;\nconst extend = (leftDef, rightDef, left, right) => {\n  const leftPad = Chunk.unfold(left.length, index => index >= right.length ? Option.none() : Option.some([leftDef(index), index + 1]));\n  const rightPad = Chunk.unfold(right.length, index => index >= left.length ? Option.none() : Option.some([rightDef(index), index + 1]));\n  const leftExtension = Chunk.concat(leftPad)(left);\n  const rightExtension = Chunk.concat(rightPad)(right);\n  return [leftExtension, rightExtension];\n};\nconst fromFlatLoop = (flat, prefix, config, split) => {\n  const op = config;\n  switch (op._tag) {\n    case OpCodes.OP_CONSTANT:\n      {\n        return core.succeed(Chunk.of(op.value));\n      }\n    case OpCodes.OP_DESCRIBED:\n      {\n        return core.suspend(() => fromFlatLoop(flat, prefix, op.config, split));\n      }\n    case OpCodes.OP_FAIL:\n      {\n        return core.fail(configError.MissingData(prefix, op.message));\n      }\n    case OpCodes.OP_FALLBACK:\n      {\n        return core.catchAll(error1 => {\n          if (op.condition(error1)) {\n            return core.catchAll(error2 => core.fail(configError.Or(error1, error2)))(fromFlatLoop(flat, prefix, op.second, split));\n          }\n          return core.fail(error1);\n        })(core.suspend(() => fromFlatLoop(flat, prefix, op.first, split)));\n      }\n    case OpCodes.OP_LAZY:\n      {\n        return core.suspend(() => fromFlatLoop(flat, prefix, op.config(), split));\n      }\n    case OpCodes.OP_MAP_OR_FAIL:\n      {\n        return core.suspend(() => core.flatMap(core.forEach(a => core.mapError(configError.prefixed(prefix))(core.fromEither(op.mapOrFail(a)))))(fromFlatLoop(flat, prefix, op.original, split)));\n      }\n    case OpCodes.OP_NESTED:\n      {\n        return core.suspend(() => fromFlatLoop(flat, Chunk.concat(Chunk.of(op.name))(prefix), op.config, split));\n      }\n    case OpCodes.OP_PRIMITIVE:\n      {\n        return core.flatMap(prefix => core.flatMap(values => {\n          if (Chunk.isEmpty(values)) {\n            const name = Option.getOrElse(() => \"<n/a>\")(Chunk.last(prefix));\n            return core.fail(_config.missingError(name));\n          }\n          return core.succeed(values);\n        })(flat.load(prefix, op, split)))(core.fromEither(pathPatch.patch(prefix, flat.patch)));\n      }\n    case OpCodes.OP_SEQUENCE:\n      {\n        return core.suspend(() => core.map(Chunk.of)(fromFlatLoop(flat, prefix, op.config, true)));\n      }\n    case OpCodes.OP_TABLE:\n      {\n        return core.suspend(() => core.flatMap(prefix => core.flatMap(keys => {\n          return core.map(values => {\n            if (values.length === 0) {\n              return Chunk.of(HashMap.empty());\n            }\n            const matrix = Chunk.toReadonlyArray(values).map(Chunk.toReadonlyArray);\n            return Chunk.map(values => HashMap.fromIterable(Chunk.zip(Chunk.fromIterable(keys), values)))(Chunk.unsafeFromArray(transpose(matrix).map(Chunk.unsafeFromArray)));\n          })(core.forEach(key => fromFlatLoop(flat, Chunk.concat(Chunk.of(key))(prefix), op.valueConfig, split))(keys));\n        })(flat.enumerateChildren(prefix)))(core.fromEither(pathPatch.patch(prefix, flat.patch))));\n      }\n    case OpCodes.OP_ZIP_WITH:\n      {\n        return core.suspend(() => core.flatMap(left => core.flatMap(right => {\n          if (Either.isLeft(left) && Either.isLeft(right)) {\n            return core.fail(configError.And(left.left, right.left));\n          }\n          if (Either.isLeft(left) && Either.isRight(right)) {\n            return core.fail(left.left);\n          }\n          if (Either.isRight(left) && Either.isLeft(right)) {\n            return core.fail(right.left);\n          }\n          if (Either.isRight(left) && Either.isRight(right)) {\n            const path = Chunk.join(\".\")(prefix);\n            const fail = fromFlatLoopFail(prefix, path);\n            const [lefts, rights] = extend(fail, fail, Chunk.map(Either.right)(left.right), Chunk.map(Either.right)(right.right));\n            return core.forEach(([left, right]) => core.map(([left, right]) => op.zip(left, right))(core.zip(core.fromEither(right))(core.fromEither(left))))(Chunk.zip(rights)(lefts));\n          }\n          throw new Error(\"BUG: ConfigProvider.fromFlatLoop - please report an issue at https://github.com/Effect-TS/io/issues\");\n        })(core.either(fromFlatLoop(flat, prefix, op.right, split))))(core.either(fromFlatLoop(flat, prefix, op.left, split))));\n      }\n  }\n};\nconst fromFlatLoopFail = (prefix, path) => index => Either.left(configError.MissingData(prefix, `The element at index ${index} in a sequence at path \"${path}\" was missing`));\n/** @internal */\nconst contramapPath = /*#__PURE__*/Debug.untracedDual(2, restore => (self, f) => fromFlat(contramapPathFlat(self.flattened, restore(f))));\nexports.contramapPath = contramapPath;\nconst contramapPathFlat = (self, f) => makeFlat((path, config, split = true) => self.load(path, config, split), path => self.enumerateChildren(path), pathPatch.mapName(self.patch, f));\n/** @internal */\nconst nested = /*#__PURE__*/Debug.untracedDual(2, () => (self, name) => fromFlat(makeFlat((path, config) => self.flattened.load(path, config, true), path => self.flattened.enumerateChildren(Chunk.prepend(name)(path)), pathPatch.nested(self.flattened.patch, name))));\n/** @internal */\nexports.nested = nested;\nconst unnested = /*#__PURE__*/Debug.untracedDual(2, () => (self, name) => fromFlat(makeFlat((path, config) => self.flattened.load(path, config, true), path => self.flattened.enumerateChildren(path), pathPatch.unnested(self.flattened.patch, name))));\n/** @internal */\nexports.unnested = unnested;\nconst orElse = /*#__PURE__*/Debug.untracedDual(2, restore => (self, that) => fromFlat(orElseFlat(self.flattened, () => restore(that)().flattened)));\nexports.orElse = orElse;\nconst orElseFlat = (self, that) => makeFlat((path, config, split) => core.catchAll(error1 => core.flatMap(that => core.catchAll(error2 => core.fail(configError.Or(error1, error2)))(core.flatMap(patch => that.load(patch, config, split))(core.fromEither(pathPatch.patch(path, that.patch)))))(core.sync(that)))(core.flatMap(patch => self.load(patch, config, split))(core.fromEither(pathPatch.patch(path, self.patch)))), path => core.flatMap(left => core.flatMap(that => core.flatMap(right => {\n  if (Either.isLeft(left) && Either.isLeft(right)) {\n    return core.fail(configError.And(left.left, right.left));\n  }\n  if (Either.isLeft(left) && Either.isRight(right)) {\n    return core.fail(left.left);\n  }\n  if (Either.isRight(left) && Either.isLeft(right)) {\n    return core.fail(right.left);\n  }\n  if (Either.isRight(left) && Either.isRight(right)) {\n    return core.succeed(HashSet.union(right.right)(left.right));\n  }\n  throw new Error(\"BUG: ConfigProvider.orElseFlat - please report an issue at https://github.com/Effect-TS/io/issues\");\n})(core.either(core.flatMap(patch => that.enumerateChildren(patch))(core.fromEither(pathPatch.patch(path, that.patch))))))(core.sync(that)))(core.either(core.flatMap(patch => self.enumerateChildren(patch))(core.fromEither(pathPatch.patch(path, self.patch))))), pathPatch.empty);\n/** @internal */\nconst constantCase = self => contramapPath(self, StringUtils.constantCase);\n/** @internal */\nexports.constantCase = constantCase;\nconst kebabCase = self => contramapPath(self, StringUtils.kebabCase);\n/** @internal */\nexports.kebabCase = kebabCase;\nconst lowerCase = self => contramapPath(self, StringUtils.lowerCase);\n/** @internal */\nexports.lowerCase = lowerCase;\nconst snakeCase = self => contramapPath(self, StringUtils.snakeCase);\n/** @internal */\nexports.snakeCase = snakeCase;\nconst upperCase = self => contramapPath(self, StringUtils.upperCase);\n/** @internal */\nexports.upperCase = upperCase;\nconst within = /*#__PURE__*/Debug.untracedDual(3, () => (self, path, f) => {\n  const unnest = Chunk.reduce(path, self, (provider, name) => unnested(provider, name));\n  const nest = Chunk.reduceRight(path, f(unnest), (provider, name) => nested(provider, name));\n  return orElse(nest, () => self);\n});\nexports.within = within;\nconst splitPathString = (text, delim) => {\n  const split = text.split(new RegExp(`\\\\s*${escapeRegex(delim)}\\\\s*`));\n  return Chunk.unsafeFromArray(split);\n};\nconst parsePrimitive = (text, path, primitive, delimiter, split) => {\n  if (!split) {\n    return core.mapError(configError.prefixed(path))(core.map(Chunk.of)(core.fromEither(primitive.parse(text))));\n  }\n  return core.mapError(configError.prefixed(path))(core.forEach(char => core.fromEither(primitive.parse(char.trim())))(splitPathString(text, delimiter)));\n};\nconst transpose = array => {\n  return Object.keys(array[0]).map(column => array.map(row => row[column]));\n};\nconst escapeRegex = string => {\n  return string.replace(/[/\\-\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\");\n};\n//# sourceMappingURL=configProvider.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.unnested = exports.patch = exports.nested = exports.mapName = exports.empty = exports.andThen = void 0;\nvar Chunk = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Chunk\"));\nvar Either = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Either\"));\nvar _Function = /*#__PURE__*/require(\"@effect/data/Function\");\nvar List = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/List\"));\nvar Option = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Option\"));\nvar String = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/String\"));\nvar configError = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/configError\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/** @internal */\nconst empty = {\n  _tag: \"Empty\"\n};\n/** @internal */\nexports.empty = empty;\nconst andThen = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => ({\n  _tag: \"AndThen\",\n  first: self,\n  second: that\n}));\n/** @internal */\nexports.andThen = andThen;\nconst mapName = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => andThen(self, {\n  _tag: \"MapName\",\n  f\n}));\n/** @internal */\nexports.mapName = mapName;\nconst nested = /*#__PURE__*/(0, _Function.dual)(2, (self, name) => andThen(self, {\n  _tag: \"Nested\",\n  name\n}));\n/** @internal */\nexports.nested = nested;\nconst unnested = /*#__PURE__*/(0, _Function.dual)(2, (self, name) => andThen(self, {\n  _tag: \"Unnested\",\n  name\n}));\n/** @internal */\nexports.unnested = unnested;\nconst patch = /*#__PURE__*/(0, _Function.dual)(2, (path, patch) => {\n  let input = List.of(patch);\n  let output = path;\n  while (List.isCons(input)) {\n    const patch = input.head;\n    switch (patch._tag) {\n      case \"Empty\":\n        {\n          input = input.tail;\n          break;\n        }\n      case \"AndThen\":\n        {\n          input = List.cons(patch.first, List.cons(patch.second, input.tail));\n          break;\n        }\n      case \"MapName\":\n        {\n          output = Chunk.map(output, patch.f);\n          input = input.tail;\n          break;\n        }\n      case \"Nested\":\n        {\n          output = Chunk.prepend(output, patch.name);\n          input = input.tail;\n          break;\n        }\n      case \"Unnested\":\n        {\n          const containsName = Option.contains(String.Equivalence)(patch.name)(Chunk.head(output));\n          if (containsName) {\n            output = Chunk.tailNonEmpty(output);\n            input = input.tail;\n          } else {\n            return Either.left(configError.MissingData(output, `Expected ${patch.name} to be in path in ConfigProvider#unnested`));\n          }\n          break;\n        }\n    }\n  }\n  return Either.right(output);\n});\nexports.patch = patch;\n//# sourceMappingURL=pathPatch.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.value = exports.unsafeWipe = exports.proto = exports.make = exports.isConfigSecret = exports.fromString = exports.fromChunk = exports.ConfigSecretTypeId = void 0;\nvar Chunk = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Chunk\"));\nvar Equal = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Equal\"));\nvar Hash = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Hash\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/** @internal */\nconst ConfigSecretSymbolKey = \"@effect/io/Config/Secret\";\n/** @internal */\nconst ConfigSecretTypeId = /*#__PURE__*/Symbol.for(ConfigSecretSymbolKey);\n/** @internal */\nexports.ConfigSecretTypeId = ConfigSecretTypeId;\nconst proto = {\n  [ConfigSecretTypeId]: ConfigSecretTypeId,\n  [Hash.symbol]() {\n    return Hash.combine(Hash.array(this.raw))(Hash.hash(ConfigSecretSymbolKey));\n  },\n  [Equal.symbol](that) {\n    return isConfigSecret(that) && this.raw.length === that.raw.length && this.raw.every((v, i) => Equal.equals(v, that.raw[i]));\n  }\n};\n/** @internal */\nexports.proto = proto;\nconst isConfigSecret = u => {\n  return typeof u === \"object\" && u != null && ConfigSecretTypeId in u;\n};\n/** @internal */\nexports.isConfigSecret = isConfigSecret;\nconst make = bytes => {\n  const secret = Object.create(proto);\n  Object.defineProperty(secret, \"toString\", {\n    enumerable: false,\n    value() {\n      return \"ConfigSecret(<redacted>)\";\n    }\n  });\n  Object.defineProperty(secret, \"raw\", {\n    enumerable: false,\n    value: bytes\n  });\n  return secret;\n};\n/** @internal */\nexports.make = make;\nconst fromChunk = chunk => {\n  return make(Chunk.toReadonlyArray(chunk).map(char => char.charCodeAt(0)));\n};\n/** @internal */\nexports.fromChunk = fromChunk;\nconst fromString = text => {\n  return make(text.split(\"\").map(char => char.charCodeAt(0)));\n};\n/** @internal */\nexports.fromString = fromString;\nconst value = self => {\n  return self.raw.map(byte => String.fromCharCode(byte)).join(\"\");\n};\n/** @internal */\nexports.value = value;\nconst unsafeWipe = self => {\n  for (let i = 0; i < self.raw.length; i++) {\n    self.raw[i] = 0;\n  }\n};\nexports.unsafeWipe = unsafeWipe;\n//# sourceMappingURL=configSecret.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.fiberRefGetAndUpdateSome = exports.fiberRefGetAndUpdate = exports.fiberRefGetAndSet = exports.fiberRefGet = exports.fiberRefDelete = exports.fiberIdWith = exports.fiberId = exports.failSync = exports.failCauseSync = exports.failCause = exports.fail = exports.exitZipWith = exports.exitZipRight = exports.exitZipParRight = exports.exitZipParLeft = exports.exitZipPar = exports.exitZipLeft = exports.exitZip = exports.exitUnit = exports.exitUnannotate = exports.exitSucceed = exports.exitMatchEffect = exports.exitMatch = exports.exitMapErrorCause = exports.exitMapError = exports.exitMapBoth = exports.exitMap = exports.exitIsSuccess = exports.exitIsInterrupted = exports.exitIsFailure = exports.exitIsExit = exports.exitInterrupt = exports.exitGetOrElse = exports.exitFromOption = exports.exitFromEither = exports.exitForEachEffect = exports.exitFlatten = exports.exitFlatMapEffect = exports.exitFlatMap = exports.exitFailCause = exports.exitFail = exports.exitExists = exports.exitDie = exports.exitCollectAllPar = exports.exitCollectAll = exports.exitCauseOption = exports.exitAsUnit = exports.exitAs = exports.exit = exports.either = exports.done = exports.dieSync = exports.die = exports.deferredUnsafeMake = exports.deferredUnsafeDone = exports.deferredSync = exports.deferredSucceed = exports.deferredPoll = exports.deferredMakeAs = exports.deferredMake = exports.deferredIsDone = exports.deferredInterruptWith = exports.deferredInterrupt = exports.deferredFailSync = exports.deferredFailCauseSync = exports.deferredFailCause = exports.deferredFail = exports.deferredDone = exports.deferredDieSync = exports.deferredDie = exports.deferredCompleteWith = exports.deferredComplete = exports.deferredAwait = exports.currentTags = exports.currentScheduler = exports.currentParallelism = exports.currentLogSpan = exports.currentLogLevel = exports.currentLogAnnotations = exports.currentContext = exports.contramapContext = exports.contextWithEffect = exports.context = exports.checkInterruptible = exports.catchSome = exports.catchAllCause = exports.catchAll = exports.attemptOrElse = exports.asyncInterruptEither = exports.asyncInterrupt = exports.async = exports.asUnit = exports.as = exports.acquireUseRelease = exports.ScopeTypeId = exports.RevertFlags = exports.FiberRefTypeId = exports.EffectTypeId = exports.EffectErrorTypeId = exports.CloseableScopeTypeId = void 0;\nexports.zipWith = exports.zipRight = exports.zipLeft = exports.zipFlatten = exports.zip = exports.yieldNow = exports.withRuntimeFlags = exports.withParallelismUnbounded = exports.withParallelism = exports.withFiberRuntime = exports.whileLoop = exports.whenEffect = exports.updateRuntimeFlags = exports.unit = exports.uninterruptibleMask = exports.uninterruptible = exports.unified = exports.transplant = exports.tap = exports.tags = exports.sync = exports.suspend = exports.succeed = exports.serviceWithEffect = exports.serviceWith = exports.service = exports.scopeFork = exports.scopeClose = exports.scopeAddFinalizerExit = exports.scopeAddFinalizer = exports.runtimeFlags = exports.releaseMapReplace = exports.releaseMapRemove = exports.releaseMapRelease = exports.releaseMapMake = exports.releaseMapGet = exports.releaseMapAddIfOpen = exports.releaseMapAdd = exports.provideContext = exports.partitionMap = exports.orElse = exports.orDieWith = exports.orDie = exports.onInterrupt = exports.onExit = exports.onError = exports.never = exports.matchEffect = exports.matchCauseEffect = exports.matchCause = exports.mapError = exports.map = exports.makeEffectError = exports.logLevelWarning = exports.logLevelTrace = exports.logLevelNone = exports.logLevelInfo = exports.logLevelFatal = exports.logLevelError = exports.logLevelDebug = exports.logLevelAll = exports.isEffectError = exports.isEffect = exports.intoDeferred = exports.interruptibleMask = exports.interruptible = exports.interruptedCause = exports.interruptWith = exports.interruptFiber = exports.interruptAsFiber = exports.interrupt = exports.ifEffect = exports.fromOption = exports.fromEither = exports.forkScopeOverride = exports.forEachDiscard = exports.forEach = exports.flip = exports.flatten = exports.flatMap = exports.fiberRefUpdateSomeAndGet = exports.fiberRefUpdateSome = exports.fiberRefUpdateAndGet = exports.fiberRefUpdate = exports.fiberRefUnsafeMakeRuntimeFlags = exports.fiberRefUnsafeMakePatch = exports.fiberRefUnsafeMakeHashSet = exports.fiberRefUnsafeMakeContext = exports.fiberRefUnsafeMake = exports.fiberRefSet = exports.fiberRefReset = exports.fiberRefModifySome = exports.fiberRefModify = exports.fiberRefLocallyWith = exports.fiberRefLocally = exports.fiberRefGetWith = void 0;\nvar Chunk = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Chunk\"));\nvar Context = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Context\"));\nvar Differ = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Differ\"));\nvar ContextPatch = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Differ/ContextPatch\"));\nvar HashSetPatch = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Differ/HashSetPatch\"));\nvar Either = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Either\"));\nvar Equal = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Equal\"));\nvar _Function = /*#__PURE__*/require(\"@effect/data/Function\");\nvar Hash = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Hash\"));\nvar HashMap = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/HashMap\"));\nvar HashSet = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/HashSet\"));\nvar MutableRef = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/MutableRef\"));\nvar Option = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Option\"));\nvar Debug = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Debug\"));\nvar FiberId = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Fiber/Id\"));\nvar RuntimeFlagsPatch = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Fiber/Runtime/Flags/Patch\"));\nvar internalCause = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/cause\"));\nvar deferred = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/deferred\"));\nvar DeferredOpCodes = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/opCodes/deferred\"));\nvar OpCodes = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/opCodes/effect\"));\nvar _runtimeFlags = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/runtimeFlags\"));\nvar scheduler = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Scheduler\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\nvar _a, _b, _c;\n// -----------------------------------------------------------------------------\n// Effect\n// -----------------------------------------------------------------------------\n/** @internal */\nconst EffectErrorSymbolKey = \"@effect/io/Effect/Error\";\n/** @internal */\nconst EffectErrorTypeId = /*#__PURE__*/Symbol.for(EffectErrorSymbolKey);\n/** @internal */\nexports.EffectErrorTypeId = EffectErrorTypeId;\nconst isEffectError = u => typeof u === \"object\" && u != null && EffectErrorTypeId in u;\n/** @internal */\nexports.isEffectError = isEffectError;\nconst makeEffectError = cause => ({\n  [EffectErrorTypeId]: EffectErrorTypeId,\n  _tag: \"EffectError\",\n  cause\n});\n/** @internal */\nexports.makeEffectError = makeEffectError;\nconst EffectTypeId = /*#__PURE__*/Symbol.for(\"@effect/io/Effect\");\n/** @internal */\nexports.EffectTypeId = EffectTypeId;\nclass RevertFlags {\n  constructor(patch) {\n    this.patch = patch;\n    this._tag = OpCodes.OP_REVERT_FLAGS;\n  }\n}\n/** @internal */\nexports.RevertFlags = RevertFlags;\nclass EffectPrimitive {\n  constructor(_tag) {\n    this._tag = _tag;\n    this.i0 = undefined;\n    this.i1 = undefined;\n    this.i2 = undefined;\n    this.trace = undefined;\n    this[_a] = effectVariance;\n  }\n  [(_a = EffectTypeId, Equal.symbol)](that) {\n    return this === that;\n  }\n  [Hash.symbol]() {\n    return Hash.random(this);\n  }\n  traced(trace) {\n    if (trace) {\n      const effect = new EffectPrimitive(OpCodes.OP_TRACED);\n      effect.i0 = this;\n      effect.trace = trace;\n      return effect;\n    }\n    return this;\n  }\n}\n/** @internal */\nclass EffectPrimitiveFailure {\n  constructor(_tag) {\n    this._tag = _tag;\n    this.i0 = undefined;\n    this.i1 = undefined;\n    this.i2 = undefined;\n    this.trace = undefined;\n    this[_b] = effectVariance;\n  }\n  [(_b = EffectTypeId, Equal.symbol)](that) {\n    return this === that;\n  }\n  [Hash.symbol]() {\n    return Hash.random(this);\n  }\n  get cause() {\n    return this.i0;\n  }\n  traced(trace) {\n    if (trace) {\n      const effect = new EffectPrimitive(OpCodes.OP_TRACED);\n      effect.i0 = this;\n      effect.trace = trace;\n      return effect;\n    }\n    return this;\n  }\n}\n/** @internal */\nclass EffectPrimitiveSuccess {\n  constructor(_tag) {\n    this._tag = _tag;\n    this.i0 = undefined;\n    this.i1 = undefined;\n    this.i2 = undefined;\n    this.trace = undefined;\n    this[_c] = effectVariance;\n  }\n  [(_c = EffectTypeId, Equal.symbol)](that) {\n    return this === that;\n  }\n  [Hash.symbol]() {\n    return Hash.random(this);\n  }\n  get value() {\n    return this.i0;\n  }\n  traced(trace) {\n    if (trace) {\n      const effect = new EffectPrimitive(OpCodes.OP_TRACED);\n      effect.i0 = this;\n      effect.trace = trace;\n      return effect;\n    }\n    return this;\n  }\n}\n/** @internal */\nconst effectVariance = {\n  _R: _ => _,\n  _E: _ => _,\n  _A: _ => _\n};\n/** @internal */\nconst isEffect = u => typeof u === \"object\" && u != null && EffectTypeId in u;\n/* @internal */\nexports.isEffect = isEffect;\nconst acquireUseRelease = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restoreTracing) => (acquire, use, release) => uninterruptibleMask(restore => flatMap(a => flatMap(exit => matchCauseEffect(cause => {\n  switch (exit._tag) {\n    case OpCodes.OP_FAILURE:\n      {\n        return failCause(internalCause.parallel(exit.i0, cause));\n      }\n    case OpCodes.OP_SUCCESS:\n      {\n        return failCause(cause);\n      }\n  }\n}, () => exit)(suspend(() => restoreTracing(release)(a, exit))))(exit(suspend(() => restore(restoreTracing(use)(a))))))(acquire)).traced(trace));\n/* @internal */\nexports.acquireUseRelease = acquireUseRelease;\nconst as = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, value) => flatMap(() => succeed(value))(self).traced(trace));\n/* @internal */\nexports.as = as;\nconst asUnit = /*#__PURE__*/Debug.methodWithTrace(trace => self => as(void 0)(self).traced(trace));\n/* @internal */\nexports.asUnit = asUnit;\nconst async = /*#__PURE__*/Debug.methodWithTrace(trace => (register, blockingOn = FiberId.none) => {\n  const effect = new EffectPrimitive(OpCodes.OP_ASYNC);\n  effect.i0 = register;\n  effect.i1 = blockingOn;\n  if (trace) {\n    return effect.traced(trace);\n  }\n  return effect;\n});\n/* @internal */\nexports.async = async;\nconst asyncInterruptEither = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => (register, blockingOn = FiberId.none) => suspend(() => {\n  let cancelerRef = unit();\n  return onInterrupt(() => cancelerRef)(async(resume => {\n    const result = restore(register)(resume);\n    if (Either.isRight(result)) {\n      resume(result.right);\n    } else {\n      cancelerRef = result.left;\n    }\n  }, blockingOn));\n}).traced(trace));\n/* @internal */\nexports.asyncInterruptEither = asyncInterruptEither;\nconst asyncInterrupt = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => (register, blockingOn = FiberId.none) => suspend(() => {\n  let cancelerRef = unit();\n  return onInterrupt(() => cancelerRef)(async(resume => {\n    cancelerRef = restore(register)(resume);\n  }, blockingOn));\n}).traced(trace));\n/* @internal */\nexports.asyncInterrupt = asyncInterrupt;\nconst catchAllCause = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => {\n  const effect = new EffectPrimitive(OpCodes.OP_ON_FAILURE);\n  effect.i0 = self;\n  effect.i1 = restore(f);\n  if (trace) {\n    return effect.traced(trace);\n  }\n  return effect;\n});\n/* @internal */\nexports.catchAllCause = catchAllCause;\nconst catchAll = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => matchEffect(restore(f), succeed)(self).traced(trace));\n/**\n * @macro identity\n * @internal\n */\nexports.catchAll = catchAll;\nconst unified = f => (...args) => f(...args);\n/* @internal */\nexports.unified = unified;\nconst catchSome = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, pf) => matchCauseEffect(unified(cause => {\n  const either = internalCause.failureOrCause(cause);\n  switch (either._tag) {\n    case \"Left\":\n      {\n        return Option.getOrElse(() => failCause(cause))(restore(pf)(either.left));\n      }\n    case \"Right\":\n      {\n        return failCause(either.right);\n      }\n  }\n}), succeed)(self).traced(trace));\n/* @internal */\nexports.catchSome = catchSome;\nconst checkInterruptible = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => f => withFiberRuntime((_, status) => restore(f)(_runtimeFlags.interruption(status.runtimeFlags))).traced(trace));\n/* @internal */\nexports.checkInterruptible = checkInterruptible;\nconst die = /*#__PURE__*/Debug.methodWithTrace(trace => defect => failCause(internalCause.die(defect)).traced(trace));\n/* @internal */\nexports.die = die;\nconst dieSync = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => evaluate => failCauseSync(() => internalCause.die(restore(evaluate)())).traced(trace));\n/* @internal */\nexports.dieSync = dieSync;\nconst done = /*#__PURE__*/Debug.methodWithTrace(trace => exit => suspend(() => exit).traced(trace));\n/* @internal */\nexports.done = done;\nconst either = /*#__PURE__*/Debug.methodWithTrace(trace => self => matchEffect(e => succeed(Either.left(e)), a => succeed(Either.right(a)))(self).traced(trace));\n/* @internal */\nexports.either = either;\nconst context = /*#__PURE__*/Debug.methodWithTrace(trace => () => suspend(() => fiberRefGet(currentContext)).traced(trace));\n/* @internal */\nexports.context = context;\nconst contextWithEffect = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => f => flatMap(restore(f))(context()).traced(trace));\n/* @internal */\nexports.contextWithEffect = contextWithEffect;\nconst exit = /*#__PURE__*/Debug.methodWithTrace(trace => self => matchCause(failCause, succeed)(self).traced(trace));\n/* @internal */\nexports.exit = exit;\nconst fail = /*#__PURE__*/Debug.methodWithTrace(trace => error => failCause(internalCause.fail(error)).traced(trace));\n/* @internal */\nexports.fail = fail;\nconst failSync = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => evaluate => failCauseSync(() => internalCause.fail(restore(evaluate)())).traced(trace));\n/* @internal */\nexports.failSync = failSync;\nconst failCause = /*#__PURE__*/Debug.methodWithTrace(trace => cause => {\n  const effect = new EffectPrimitiveFailure(OpCodes.OP_FAILURE);\n  effect.i0 = cause;\n  if (trace) {\n    return effect.traced(trace);\n  }\n  return effect;\n});\n/* @internal */\nexports.failCause = failCause;\nconst failCauseSync = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => evaluate => flatMap(sync(restore(evaluate)), failCause).traced(trace));\n/* @internal */\nexports.failCauseSync = failCauseSync;\nconst fiberId = /*#__PURE__*/Debug.methodWithTrace(trace => () => withFiberRuntime(state => succeed(state.id())).traced(trace));\n/* @internal */\nexports.fiberId = fiberId;\nconst fiberIdWith = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => f => withFiberRuntime(state => restore(f)(state.id())).traced(trace));\n/* @internal */\nexports.fiberIdWith = fiberIdWith;\nconst flatMap = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => {\n  const effect = new EffectPrimitive(OpCodes.OP_ON_SUCCESS);\n  effect.i0 = self;\n  effect.i1 = restore(f);\n  if (trace) {\n    return effect.traced(trace);\n  }\n  return effect;\n});\n/* @internal */\nexports.flatMap = flatMap;\nconst flatten = /*#__PURE__*/Debug.methodWithTrace(trace => self => flatMap(self, _Function.identity).traced(trace));\n/* @internal */\nexports.flatten = flatten;\nconst flip = /*#__PURE__*/Debug.methodWithTrace(trace => self => matchEffect(succeed, fail)(self).traced(trace));\n/* @internal */\nexports.flip = flip;\nconst matchCause = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (self, onFailure, onSuccess) => matchCauseEffect(cause => succeed(restore(onFailure)(cause)), a => succeed(restore(onSuccess)(a)))(self).traced(trace));\n/* @internal */\nexports.matchCause = matchCause;\nconst matchCauseEffect = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (self, onFailure, onSuccess) => {\n  const effect = new EffectPrimitive(OpCodes.OP_ON_SUCCESS_AND_FAILURE);\n  effect.i0 = self;\n  effect.i1 = restore(onFailure);\n  effect.i2 = restore(onSuccess);\n  if (trace) {\n    return effect.traced(trace);\n  }\n  return effect;\n});\n/* @internal */\nexports.matchCauseEffect = matchCauseEffect;\nconst matchEffect = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (self, onFailure, onSuccess) => matchCauseEffect(self, cause => {\n  const failures = internalCause.failures(cause);\n  const defects = internalCause.defects(cause);\n  if (defects.length > 0) {\n    return failCause(internalCause.electFailures(cause));\n  }\n  if (failures.length > 0) {\n    return restore(onFailure)(Chunk.unsafeHead(failures));\n  }\n  return failCause(cause);\n}, onSuccess).traced(trace));\n/* @internal */\nexports.matchEffect = matchEffect;\nconst forEach = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => suspend(() => {\n  const arr = Array.from(self);\n  const ret = new Array(arr.length);\n  let i = 0;\n  return as(Chunk.unsafeFromArray(ret))(whileLoop(() => i < arr.length, () => restore(f)(arr[i]), b => {\n    ret[i++] = b;\n  }));\n}).traced(trace));\n/* @internal */\nexports.forEach = forEach;\nconst forEachDiscard = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => suspend(() => {\n  const arr = Array.from(self);\n  let i = 0;\n  return whileLoop(() => i < arr.length, () => restore(f)(arr[i++]), () => {\n    //\n  });\n}).traced(trace));\n/* @internal */\nexports.forEachDiscard = forEachDiscard;\nconst fromOption = /*#__PURE__*/Debug.methodWithTrace(trace => option => {\n  switch (option._tag) {\n    case \"None\":\n      {\n        return fail(Option.none()).traced(trace);\n      }\n    case \"Some\":\n      {\n        return succeed(option.value).traced(trace);\n      }\n  }\n});\n/* @internal */\nexports.fromOption = fromOption;\nconst fromEither = /*#__PURE__*/Debug.methodWithTrace(trace => either => {\n  switch (either._tag) {\n    case \"Left\":\n      {\n        return fail(either.left).traced(trace);\n      }\n    case \"Right\":\n      {\n        return succeed(either.right).traced(trace);\n      }\n  }\n});\n/* @internal */\nexports.fromEither = fromEither;\nconst ifEffect = /*#__PURE__*/Debug.dualWithTrace(3, trace => (self, onTrue, onFalse) => flatMap(unified(b => b ? onTrue : onFalse))(self).traced(trace));\n/* @internal */\nexports.ifEffect = ifEffect;\nconst interrupt = /*#__PURE__*/Debug.methodWithTrace(trace => () => flatMap(fiberId => interruptWith(fiberId))(fiberId()).traced(trace));\n/* @internal */\nexports.interrupt = interrupt;\nconst interruptWith = /*#__PURE__*/Debug.methodWithTrace(trace => fiberId => failCause(internalCause.interrupt(fiberId)).traced(trace));\n/* @internal */\nexports.interruptWith = interruptWith;\nconst interruptible = /*#__PURE__*/Debug.methodWithTrace(trace => self => {\n  const effect = new EffectPrimitive(OpCodes.OP_UPDATE_RUNTIME_FLAGS);\n  effect.i0 = RuntimeFlagsPatch.enable(_runtimeFlags.Interruption);\n  effect.i1 = () => self;\n  if (trace) {\n    return effect.traced(trace);\n  }\n  return effect;\n});\n/* @internal */\nexports.interruptible = interruptible;\nconst interruptibleMask = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => f => {\n  const effect = new EffectPrimitive(OpCodes.OP_UPDATE_RUNTIME_FLAGS);\n  effect.i0 = RuntimeFlagsPatch.enable(_runtimeFlags.Interruption);\n  effect.i1 = oldFlags => _runtimeFlags.interruption(oldFlags) ? restore(f)(interruptible) : restore(f)(uninterruptible);\n  if (trace) {\n    return effect.traced(trace);\n  }\n  return effect;\n});\n/* @internal */\nexports.interruptibleMask = interruptibleMask;\nconst intoDeferred = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, deferred) => uninterruptibleMask(restore => flatMap(exit => deferredDone(deferred, exit))(exit(restore(self)))).traced(trace));\n/* @internal */\nexports.intoDeferred = intoDeferred;\nconst map = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => flatMap(a => sync(() => restore(f)(a)))(self).traced(trace));\n/* @internal */\nexports.map = map;\nconst mapError = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => matchCauseEffect(self, cause => {\n  const either = internalCause.failureOrCause(cause);\n  switch (either._tag) {\n    case \"Left\":\n      {\n        return failSync(() => restore(f)(either.left));\n      }\n    case \"Right\":\n      {\n        return failCause(either.right);\n      }\n  }\n}, succeed).traced(trace));\n/* @internal */\nexports.mapError = mapError;\nconst never = /*#__PURE__*/Debug.methodWithTrace(trace => () => asyncInterruptEither(() => {\n  const interval = setInterval(() => {\n    //\n  }, 2 ** 31 - 1);\n  return Either.left(sync(() => clearInterval(interval)));\n}).traced(trace));\n/* @internal */\nexports.never = never;\nconst onError = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, cleanup) => onExit(self, unified(exit => exitIsSuccess(exit) ? unit() : restore(cleanup)(exit.i0))).traced(trace));\n/* @internal */\nexports.onError = onError;\nconst onExit = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restoreTrace) => (self, cleanup) => uninterruptibleMask(restore => matchCauseEffect(restore(self), cause1 => {\n  const result = exitFailCause(cause1);\n  return matchCauseEffect(cause2 => exitFailCause(internalCause.sequential(cause1, cause2)), () => result)(restoreTrace(cleanup)(result));\n}, success => {\n  const result = exitSucceed(success);\n  return zipRight(result)(restoreTrace(cleanup)(result));\n})).traced(trace));\n/* @internal */\nexports.onExit = onExit;\nconst onInterrupt = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, cleanup) => onExit(self, exitMatch(cause => internalCause.isInterruptedOnly(cause) ? asUnit(restore(cleanup)(internalCause.interruptors(cause))) : unit(), () => unit())).traced(trace));\n/* @internal */\nexports.onInterrupt = onInterrupt;\nconst orElse = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, that) => attemptOrElse(restore(that), succeed)(self).traced(trace));\n/* @internal */\nexports.orElse = orElse;\nconst orDie = /*#__PURE__*/Debug.methodWithTrace(trace => self => orDieWith(self, _Function.identity).traced(trace));\n/* @internal */\nexports.orDie = orDie;\nconst orDieWith = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => matchEffect(e => die(restore(f)(e)), succeed)(self).traced(trace));\n/* @internal */\nexports.orDieWith = orDieWith;\nconst partitionMap = (elements, f) => Array.from(elements).reduceRight(([lefts, rights], current) => {\n  const either = f(current);\n  switch (either._tag) {\n    case \"Left\":\n      {\n        return [Chunk.prepend(either.left)(lefts), rights];\n      }\n    case \"Right\":\n      {\n        return [lefts, Chunk.prepend(either.right)(rights)];\n      }\n  }\n}, [Chunk.empty(), Chunk.empty()]);\n/* @internal */\nexports.partitionMap = partitionMap;\nconst provideContext = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, context) => fiberRefLocally(currentContext, context)(self).traced(trace));\n/* @internal */\nexports.provideContext = provideContext;\nconst contramapContext = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => contextWithEffect(context => provideContext(restore(f)(context))(self)).traced(trace));\n/* @internal */\nexports.contramapContext = contramapContext;\nconst runtimeFlags = /*#__PURE__*/Debug.methodWithTrace(trace => () => withFiberRuntime((_, status) => succeed(status.runtimeFlags)).traced(trace));\n/* @internal */\nexports.runtimeFlags = runtimeFlags;\nconst service = /*#__PURE__*/Debug.methodWithTrace(trace => tag => serviceWithEffect(tag, succeed).traced(trace));\n/* @internal */\nexports.service = service;\nconst serviceWith = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => (tag, f) => serviceWithEffect(tag, a => sync(() => restore(f)(a))).traced(trace));\n/* @internal */\nexports.serviceWith = serviceWith;\nconst serviceWithEffect = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => (tag, f) => suspend(() => flatMap(env => restore(f)(Context.unsafeGet(tag)(env)))(fiberRefGet(currentContext))).traced(trace));\n/* @internal */\nexports.serviceWithEffect = serviceWithEffect;\nconst succeed = /*#__PURE__*/Debug.methodWithTrace(trace => value => {\n  const effect = new EffectPrimitiveSuccess(OpCodes.OP_SUCCESS);\n  effect.i0 = value;\n  if (trace) {\n    return effect.traced(trace);\n  }\n  return effect;\n});\n/* @internal */\nexports.succeed = succeed;\nconst suspend = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => effect => flatMap(_Function.identity)(sync(restore(effect))).traced(trace));\n/* @internal */\nexports.suspend = suspend;\nconst sync = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => evaluate => {\n  const effect = new EffectPrimitive(OpCodes.OP_SYNC);\n  effect.i0 = restore(evaluate);\n  if (trace) {\n    return effect.traced(trace);\n  }\n  return effect;\n});\n/* @internal */\nexports.sync = sync;\nconst tags = /*#__PURE__*/Debug.methodWithTrace(trace => () => fiberRefGet(currentTags).traced(trace));\n/* @internal */\nexports.tags = tags;\nconst tap = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => flatMap(a => as(a)(restore(f)(a)))(self).traced(trace));\n/* @internal */\nexports.tap = tap;\nconst transplant = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => f => withFiberRuntime(state => {\n  const scopeOverride = state.getFiberRef(forkScopeOverride);\n  const scope = Option.getOrElse(() => state.scope())(scopeOverride);\n  return restore(f)(fiberRefLocally(forkScopeOverride, Option.some(scope)));\n}).traced(trace));\n/* @internal */\nexports.transplant = transplant;\nconst attemptOrElse = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (self, that, onSuccess) => matchCauseEffect(self, cause => {\n  const defects = internalCause.defects(cause);\n  if (defects.length > 0) {\n    return failCause(Option.getOrThrow(internalCause.keepDefectsAndElectFailures(cause)));\n  }\n  return restore(that)();\n}, restore(onSuccess)).traced(trace));\n/* @internal */\nexports.attemptOrElse = attemptOrElse;\nconst uninterruptible = /*#__PURE__*/Debug.methodWithTrace(trace => self => {\n  const effect = new EffectPrimitive(OpCodes.OP_UPDATE_RUNTIME_FLAGS);\n  effect.i0 = RuntimeFlagsPatch.disable(_runtimeFlags.Interruption);\n  effect.i1 = () => self;\n  if (trace) {\n    return effect.traced(trace);\n  }\n  return effect;\n});\n/* @internal */\nexports.uninterruptible = uninterruptible;\nconst uninterruptibleMask = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => f => {\n  const effect = new EffectPrimitive(OpCodes.OP_UPDATE_RUNTIME_FLAGS);\n  effect.i0 = RuntimeFlagsPatch.disable(_runtimeFlags.Interruption);\n  effect.i1 = oldFlags => _runtimeFlags.interruption(oldFlags) ? restore(f)(interruptible) : restore(f)(uninterruptible);\n  if (trace) {\n    return effect.traced(trace);\n  }\n  return effect;\n});\n/* @internal */\nexports.uninterruptibleMask = uninterruptibleMask;\nconst unit = /*#__PURE__*/Debug.methodWithTrace(trace => _ => succeed(void 0).traced(trace));\n/* @internal */\nexports.unit = unit;\nconst updateRuntimeFlags = /*#__PURE__*/Debug.methodWithTrace(trace => patch => {\n  const effect = new EffectPrimitive(OpCodes.OP_UPDATE_RUNTIME_FLAGS);\n  effect.i0 = patch;\n  effect.i1 = void 0;\n  if (trace) {\n    return effect.traced(trace);\n  }\n  return effect;\n});\n/* @internal */\nexports.updateRuntimeFlags = updateRuntimeFlags;\nconst whenEffect = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, predicate) => flatMap(b => {\n  if (b) {\n    return map(Option.some)(self);\n  }\n  return succeed(Option.none());\n})(predicate).traced(trace));\n/* @internal */\nexports.whenEffect = whenEffect;\nconst whileLoop = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => (check, body, process) => {\n  const effect = new EffectPrimitive(OpCodes.OP_WHILE);\n  effect.i0 = restore(check);\n  effect.i1 = restore(body);\n  effect.i2 = restore(process);\n  if (trace) {\n    return effect.traced(trace);\n  }\n  return effect;\n});\n/* @internal */\nexports.whileLoop = whileLoop;\nconst withFiberRuntime = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => withRuntime => {\n  const effect = new EffectPrimitive(OpCodes.OP_WITH_RUNTIME);\n  effect.i0 = restore(withRuntime);\n  if (trace) {\n    return effect.traced(trace);\n  }\n  return effect;\n});\n/* @internal */\nexports.withFiberRuntime = withFiberRuntime;\nconst withParallelism = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, parallelism) => suspend(() => fiberRefLocally(currentParallelism, Option.some(parallelism))(self)).traced(trace));\n/* @internal */\nexports.withParallelism = withParallelism;\nconst withParallelismUnbounded = /*#__PURE__*/Debug.methodWithTrace(trace => self => suspend(() => fiberRefLocally(currentParallelism, Option.none())(self)).traced(trace));\n/* @internal */\nexports.withParallelismUnbounded = withParallelismUnbounded;\nconst withRuntimeFlags = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, update) => {\n  const effect = new EffectPrimitive(OpCodes.OP_UPDATE_RUNTIME_FLAGS);\n  effect.i0 = update;\n  effect.i1 = () => self;\n  if (trace) {\n    return effect.traced(trace);\n  }\n  return effect;\n});\n/* @internal */\nexports.withRuntimeFlags = withRuntimeFlags;\nconst yieldNow = /*#__PURE__*/Debug.methodWithTrace(trace => () => {\n  const effect = new EffectPrimitive(OpCodes.OP_YIELD);\n  if (trace) {\n    return effect.traced(trace);\n  }\n  return effect;\n});\n/* @internal */\nexports.yieldNow = yieldNow;\nconst zip = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, that) => flatMap(self, a => map(that, b => [a, b])).traced(trace));\n/* @internal */\nexports.zip = zip;\nconst zipFlatten = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, that) => flatMap(self, a => map(that, b => [...a, b])).traced(trace));\n/* @internal */\nexports.zipFlatten = zipFlatten;\nconst zipLeft = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, that) => flatMap(self, a => as(that, a)).traced(trace));\n/* @internal */\nexports.zipLeft = zipLeft;\nconst zipRight = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, that) => flatMap(self, () => that).traced(trace));\n/* @internal */\nexports.zipRight = zipRight;\nconst zipWith = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (self, that, f) => flatMap(self, a => map(that, b => restore(f)(a, b))).traced(trace));\n// -----------------------------------------------------------------------------\n// Fiber\n// -----------------------------------------------------------------------------\n/* @internal */\nexports.zipWith = zipWith;\nconst interruptFiber = /*#__PURE__*/Debug.methodWithTrace(trace => self => flatMap(fiberId => interruptAsFiber(fiberId)(self))(fiberId()).traced(trace));\n/* @internal */\nexports.interruptFiber = interruptFiber;\nconst interruptAsFiber = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, fiberId) => flatMap(() => self.await())(self.interruptAsFork(fiberId)).traced(trace));\n// -----------------------------------------------------------------------------\n// LogLevel\n// -----------------------------------------------------------------------------\n/** @internal */\nexports.interruptAsFiber = interruptAsFiber;\nconst logLevelAll = {\n  _tag: \"All\",\n  syslog: 0,\n  label: \"ALL\",\n  ordinal: Number.MIN_SAFE_INTEGER\n};\n/** @internal */\nexports.logLevelAll = logLevelAll;\nconst logLevelFatal = {\n  _tag: \"Fatal\",\n  syslog: 2,\n  label: \"FATAL\",\n  ordinal: 50000\n};\n/** @internal */\nexports.logLevelFatal = logLevelFatal;\nconst logLevelError = {\n  _tag: \"Error\",\n  syslog: 3,\n  label: \"ERROR\",\n  ordinal: 40000\n};\n/** @internal */\nexports.logLevelError = logLevelError;\nconst logLevelWarning = {\n  _tag: \"Warning\",\n  syslog: 4,\n  label: \"WARN\",\n  ordinal: 30000\n};\n/** @internal */\nexports.logLevelWarning = logLevelWarning;\nconst logLevelInfo = {\n  _tag: \"Info\",\n  syslog: 6,\n  label: \"INFO\",\n  ordinal: 20000\n};\n/** @internal */\nexports.logLevelInfo = logLevelInfo;\nconst logLevelDebug = {\n  _tag: \"Debug\",\n  syslog: 7,\n  label: \"DEBUG\",\n  ordinal: 10000\n};\n/** @internal */\nexports.logLevelDebug = logLevelDebug;\nconst logLevelTrace = {\n  _tag: \"Trace\",\n  syslog: 7,\n  label: \"TRACE\",\n  ordinal: 0\n};\n/** @internal */\nexports.logLevelTrace = logLevelTrace;\nconst logLevelNone = {\n  _tag: \"None\",\n  syslog: 7,\n  label: \"OFF\",\n  ordinal: Number.MAX_SAFE_INTEGER\n};\n// -----------------------------------------------------------------------------\n// FiberRef\n// -----------------------------------------------------------------------------\n/** @internal */\nexports.logLevelNone = logLevelNone;\nconst FiberRefSymbolKey = \"@effect/io/FiberRef\";\n/** @internal */\nconst FiberRefTypeId = /*#__PURE__*/Symbol.for(FiberRefSymbolKey);\n/** @internal */\nexports.FiberRefTypeId = FiberRefTypeId;\nconst fiberRefVariance = {\n  _A: _ => _\n};\n/* @internal */\nconst fiberRefGet = /*#__PURE__*/Debug.methodWithTrace(trace => self => fiberRefModify(self, a => [a, a]).traced(trace));\n/* @internal */\nexports.fiberRefGet = fiberRefGet;\nconst fiberRefGetAndSet = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, value) => fiberRefModify(self, v => [v, value]).traced(trace));\n/* @internal */\nexports.fiberRefGetAndSet = fiberRefGetAndSet;\nconst fiberRefGetAndUpdate = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => fiberRefModify(self, v => [v, restore(f)(v)]).traced(trace));\n/* @internal */\nexports.fiberRefGetAndUpdate = fiberRefGetAndUpdate;\nconst fiberRefGetAndUpdateSome = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, pf) => fiberRefModify(self, v => [v, Option.getOrElse(restore(pf)(v), () => v)]).traced(trace));\n/* @internal */\nexports.fiberRefGetAndUpdateSome = fiberRefGetAndUpdateSome;\nconst fiberRefGetWith = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => flatMap(fiberRefGet(self), restore(f)).traced(trace));\n/* @internal */\nexports.fiberRefGetWith = fiberRefGetWith;\nconst fiberRefSet = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, value) => fiberRefModify(self, () => [void 0, value]).traced(trace));\n/* @internal */\nexports.fiberRefSet = fiberRefSet;\nconst fiberRefDelete = /*#__PURE__*/Debug.methodWithTrace(trace => self => withFiberRuntime(state => {\n  state.unsafeDeleteFiberRef(self);\n  return unit();\n}).traced(trace));\n/* @internal */\nexports.fiberRefDelete = fiberRefDelete;\nconst fiberRefReset = /*#__PURE__*/Debug.methodWithTrace(trace => self => fiberRefSet(self, self.initial).traced(trace));\n/* @internal */\nexports.fiberRefReset = fiberRefReset;\nconst fiberRefModify = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => withFiberRuntime(state => {\n  const [b, a] = restore(f)(state.getFiberRef(self));\n  state.setFiberRef(self, a);\n  return succeed(b);\n}).traced(trace));\n/* @internal */\nexports.fiberRefModify = fiberRefModify;\nconst fiberRefModifySome = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => (self, def, f) => fiberRefModify(self, v => Option.getOrElse(restore(f)(v), () => [def, v])).traced(trace));\n/* @internal */\nexports.fiberRefModifySome = fiberRefModifySome;\nconst fiberRefUpdate = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => fiberRefModify(self, v => [void 0, restore(f)(v)]).traced(trace));\n/* @internal */\nexports.fiberRefUpdate = fiberRefUpdate;\nconst fiberRefUpdateSome = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, pf) => fiberRefModify(self, v => [void 0, Option.getOrElse(restore(pf)(v), () => v)]).traced(trace));\n/* @internal */\nexports.fiberRefUpdateSome = fiberRefUpdateSome;\nconst fiberRefUpdateAndGet = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => fiberRefModify(self, v => {\n  const result = restore(f)(v);\n  return [result, result];\n}).traced(trace));\n/* @internal */\nexports.fiberRefUpdateAndGet = fiberRefUpdateAndGet;\nconst fiberRefUpdateSomeAndGet = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, pf) => fiberRefModify(self, v => {\n  const result = Option.getOrElse(() => v)(restore(pf)(v));\n  return [result, result];\n}).traced(trace));\n/* @internal */\nexports.fiberRefUpdateSomeAndGet = fiberRefUpdateSomeAndGet;\nconst fiberRefLocally = /*#__PURE__*/Debug.dualWithTrace(3, trace => (use, self, value) => acquireUseRelease(zipLeft(fiberRefGet(self), fiberRefSet(self, value)), () => use, oldValue => fiberRefSet(self, oldValue)).traced(trace));\n/* @internal */\nexports.fiberRefLocally = fiberRefLocally;\nconst fiberRefLocallyWith = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (use, self, f) => fiberRefGetWith(self, a => fiberRefLocally(self, restore(f)(a))(use)).traced(trace));\n/** @internal */\nexports.fiberRefLocallyWith = fiberRefLocallyWith;\nconst fiberRefUnsafeMake = (initial, fork = _Function.identity, join = (_, a) => a) => fiberRefUnsafeMakePatch(initial, Differ.update(), fork, join);\n/** @internal */\nexports.fiberRefUnsafeMake = fiberRefUnsafeMake;\nconst fiberRefUnsafeMakeHashSet = initial => fiberRefUnsafeMakePatch(initial, Differ.hashSet(), HashSetPatch.empty());\n/** @internal */\nexports.fiberRefUnsafeMakeHashSet = fiberRefUnsafeMakeHashSet;\nconst fiberRefUnsafeMakeContext = initial => fiberRefUnsafeMakePatch(initial, Differ.environment(), ContextPatch.empty());\n/** @internal */\nexports.fiberRefUnsafeMakeContext = fiberRefUnsafeMakeContext;\nconst fiberRefUnsafeMakePatch = (initial, differ, fork, join = (_, n) => n) => ({\n  [FiberRefTypeId]: fiberRefVariance,\n  initial,\n  diff: (oldValue, newValue) => Differ.diff(oldValue, newValue)(differ),\n  combine: (first, second) => Differ.combine(first, second)(differ),\n  patch: patch => oldValue => Differ.patch(patch, oldValue)(differ),\n  fork,\n  join\n});\n/** @internal */\nexports.fiberRefUnsafeMakePatch = fiberRefUnsafeMakePatch;\nconst fiberRefUnsafeMakeRuntimeFlags = initial => fiberRefUnsafeMakePatch(initial, _runtimeFlags.differ(), RuntimeFlagsPatch.empty);\n/** @internal */\nexports.fiberRefUnsafeMakeRuntimeFlags = fiberRefUnsafeMakeRuntimeFlags;\nconst currentContext = /*#__PURE__*/fiberRefUnsafeMakeContext( /*#__PURE__*/Context.empty());\n/** @internal */\nexports.currentContext = currentContext;\nconst currentLogAnnotations = /*#__PURE__*/fiberRefUnsafeMake( /*#__PURE__*/HashMap.empty());\n/** @internal */\nexports.currentLogAnnotations = currentLogAnnotations;\nconst currentLogLevel = /*#__PURE__*/fiberRefUnsafeMake(logLevelInfo);\n/** @internal */\nexports.currentLogLevel = currentLogLevel;\nconst currentLogSpan = /*#__PURE__*/fiberRefUnsafeMake( /*#__PURE__*/Chunk.empty());\n/** @internal */\nexports.currentLogSpan = currentLogSpan;\nconst currentScheduler = /*#__PURE__*/fiberRefUnsafeMake(scheduler.defaultScheduler);\n/** @internal */\nexports.currentScheduler = currentScheduler;\nconst currentParallelism = /*#__PURE__*/fiberRefUnsafeMake( /*#__PURE__*/Option.none());\n/** @internal */\nexports.currentParallelism = currentParallelism;\nconst currentTags = /*#__PURE__*/fiberRefUnsafeMakeHashSet( /*#__PURE__*/HashSet.empty());\n/** @internal */\nexports.currentTags = currentTags;\nconst forkScopeOverride = /*#__PURE__*/fiberRefUnsafeMake( /*#__PURE__*/Option.none(), () => Option.none(), (parent, _) => parent);\n/** @internal */\nexports.forkScopeOverride = forkScopeOverride;\nconst interruptedCause = /*#__PURE__*/fiberRefUnsafeMake(internalCause.empty, () => internalCause.empty, (parent, _) => parent);\n// -----------------------------------------------------------------------------\n// Scope\n// -----------------------------------------------------------------------------\n/** @internal */\nexports.interruptedCause = interruptedCause;\nconst ScopeTypeId = /*#__PURE__*/Symbol.for(\"@effect/io/Scope\");\n/** @internal */\nexports.ScopeTypeId = ScopeTypeId;\nconst CloseableScopeTypeId = /*#__PURE__*/Symbol.for(\"@effect/io/CloseableScope\");\n/* @internal */\nexports.CloseableScopeTypeId = CloseableScopeTypeId;\nconst scopeAddFinalizer = /*#__PURE__*/Debug.methodWithTrace(trace => (self, finalizer) => self.addFinalizer(() => asUnit(finalizer)).traced(trace));\n/* @internal */\nexports.scopeAddFinalizer = scopeAddFinalizer;\nconst scopeAddFinalizerExit = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => (self, finalizer) => self.addFinalizer(restore(finalizer)).traced(trace));\n/* @internal */\nexports.scopeAddFinalizerExit = scopeAddFinalizerExit;\nconst scopeClose = /*#__PURE__*/Debug.methodWithTrace(trace => (self, exit) => self.close(exit).traced(trace));\n/* @internal */\nexports.scopeClose = scopeClose;\nconst scopeFork = /*#__PURE__*/Debug.methodWithTrace(trace => (self, strategy) => self.fork(strategy).traced(trace));\n/* @internal */\nexports.scopeFork = scopeFork;\nconst releaseMapAdd = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, finalizer) => map(Option.match(() => () => unit(), key => exit => releaseMapRelease(key, exit)(self)))(releaseMapAddIfOpen(restore(finalizer))(self)).traced(trace));\n/* @internal */\nexports.releaseMapAdd = releaseMapAdd;\nconst releaseMapRelease = /*#__PURE__*/Debug.dualWithTrace(3, trace => (self, key, exit) => suspend(() => {\n  switch (self.state._tag) {\n    case \"Exited\":\n      {\n        return unit();\n      }\n    case \"Running\":\n      {\n        const finalizer = self.state.finalizers.get(key);\n        self.state.finalizers.delete(key);\n        if (finalizer != null) {\n          return self.state.update(finalizer)(exit);\n        }\n        return unit();\n      }\n  }\n}).traced(trace));\n/* @internal */\nexports.releaseMapRelease = releaseMapRelease;\nconst releaseMapAddIfOpen = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, finalizer) => suspend(() => {\n  switch (self.state._tag) {\n    case \"Exited\":\n      {\n        self.state.nextKey += 1;\n        return as(Option.none())(restore(finalizer)(self.state.exit));\n      }\n    case \"Running\":\n      {\n        const key = self.state.nextKey;\n        self.state.finalizers.set(key, finalizer);\n        self.state.nextKey += 1;\n        return succeed(Option.some(key));\n      }\n  }\n}).traced(trace));\n/* @internal */\nexports.releaseMapAddIfOpen = releaseMapAddIfOpen;\nconst releaseMapGet = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, key) => sync(() => self.state._tag === \"Running\" ? Option.fromNullable(self.state.finalizers.get(key)) : Option.none()).traced(trace));\n/* @internal */\nexports.releaseMapGet = releaseMapGet;\nconst releaseMapReplace = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (self, key, finalizer) => suspend(() => {\n  switch (self.state._tag) {\n    case \"Exited\":\n      {\n        return as(Option.none())(restore(finalizer)(self.state.exit));\n      }\n    case \"Running\":\n      {\n        const fin = Option.fromNullable(self.state.finalizers.get(key));\n        self.state.finalizers.set(key, restore(finalizer));\n        return succeed(fin);\n      }\n  }\n}).traced(trace));\n/* @internal */\nexports.releaseMapReplace = releaseMapReplace;\nconst releaseMapRemove = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, key) => sync(() => {\n  if (self.state._tag === \"Exited\") {\n    return Option.none();\n  }\n  const fin = Option.fromNullable(self.state.finalizers.get(key));\n  self.state.finalizers.delete(key);\n  return fin;\n}).traced(trace));\n/* @internal */\nexports.releaseMapRemove = releaseMapRemove;\nconst releaseMapMake = /*#__PURE__*/Debug.methodWithTrace(trace => () => sync(() => ({\n  state: {\n    _tag: \"Running\",\n    nextKey: 0,\n    finalizers: new Map(),\n    update: _Function.identity\n  }\n})).traced(trace));\n// -----------------------------------------------------------------------------\n// Exit\n// -----------------------------------------------------------------------------\n/** @internal */\nexports.releaseMapMake = releaseMapMake;\nconst exitIsExit = u => isEffect(u) && \"_tag\" in u && (u._tag === \"Success\" || u._tag === \"Failure\");\n/** @internal */\nexports.exitIsExit = exitIsExit;\nconst exitIsFailure = self => self._tag === \"Failure\";\n/** @internal */\nexports.exitIsFailure = exitIsFailure;\nconst exitIsSuccess = self => self._tag === \"Success\";\n/** @internal */\nexports.exitIsSuccess = exitIsSuccess;\nconst exitIsInterrupted = self => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      {\n        return internalCause.isInterrupted(self.i0);\n      }\n    case OpCodes.OP_SUCCESS:\n      {\n        return false;\n      }\n  }\n};\n/** @internal */\nexports.exitIsInterrupted = exitIsInterrupted;\nconst exitAs = /*#__PURE__*/(0, _Function.dual)(2, (self, value) => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      {\n        return self;\n      }\n    case OpCodes.OP_SUCCESS:\n      {\n        return exitSucceed(value);\n      }\n  }\n});\n/** @internal */\nexports.exitAs = exitAs;\nconst exitAsUnit = self => exitAs(self, void 0);\n/** @internal */\nexports.exitAsUnit = exitAsUnit;\nconst exitCauseOption = self => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      {\n        return Option.some(self.i0);\n      }\n    case OpCodes.OP_SUCCESS:\n      {\n        return Option.none();\n      }\n  }\n};\n/** @internal */\nexports.exitCauseOption = exitCauseOption;\nconst exitCollectAll = exits => exitCollectAllInternal(exits, internalCause.sequential);\n/** @internal */\nexports.exitCollectAll = exitCollectAll;\nconst exitCollectAllPar = exits => exitCollectAllInternal(exits, internalCause.parallel);\n/** @internal */\nexports.exitCollectAllPar = exitCollectAllPar;\nconst exitDie = defect => exitFailCause(internalCause.die(defect));\n/** @internal */\nexports.exitDie = exitDie;\nconst exitExists = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      {\n        return false;\n      }\n    case OpCodes.OP_SUCCESS:\n      {\n        return predicate(self.i0);\n      }\n  }\n});\n/** @internal */\nexports.exitExists = exitExists;\nconst exitFail = error => exitFailCause(internalCause.fail(error));\n/** @internal */\nexports.exitFail = exitFail;\nconst exitFailCause = cause => {\n  const effect = new EffectPrimitiveFailure(OpCodes.OP_FAILURE);\n  effect.i0 = cause;\n  return effect;\n};\n/** @internal */\nexports.exitFailCause = exitFailCause;\nconst exitFlatMap = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      {\n        return self;\n      }\n    case OpCodes.OP_SUCCESS:\n      {\n        return f(self.i0);\n      }\n  }\n});\n/** @internal */\nexports.exitFlatMap = exitFlatMap;\nconst exitFlatMapEffect = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      {\n        return succeed(self).traced(trace);\n      }\n    case OpCodes.OP_SUCCESS:\n      {\n        return restore(f)(self.i0).traced(trace);\n      }\n  }\n});\n/** @internal */\nexports.exitFlatMapEffect = exitFlatMapEffect;\nconst exitFlatten = self => exitFlatMap(_Function.identity)(self);\n/** @internal */\nexports.exitFlatten = exitFlatten;\nconst exitForEachEffect = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      {\n        return succeed(exitFailCause(self.i0)).traced(trace);\n      }\n    case OpCodes.OP_SUCCESS:\n      {\n        return exit(restore(f)(self.i0)).traced(trace);\n      }\n  }\n});\n/** @internal */\nexports.exitForEachEffect = exitForEachEffect;\nconst exitFromEither = either => {\n  switch (either._tag) {\n    case \"Left\":\n      {\n        return exitFail(either.left);\n      }\n    case \"Right\":\n      {\n        return exitSucceed(either.right);\n      }\n  }\n};\n/** @internal */\nexports.exitFromEither = exitFromEither;\nconst exitFromOption = option => {\n  switch (option._tag) {\n    case \"None\":\n      {\n        return exitFail(void 0);\n      }\n    case \"Some\":\n      {\n        return exitSucceed(option.value);\n      }\n  }\n};\n/** @internal */\nexports.exitFromOption = exitFromOption;\nconst exitGetOrElse = /*#__PURE__*/(0, _Function.dual)(2, (self, orElse) => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      {\n        return orElse(self.i0);\n      }\n    case OpCodes.OP_SUCCESS:\n      {\n        return self.i0;\n      }\n  }\n});\n/** @internal */\nexports.exitGetOrElse = exitGetOrElse;\nconst exitInterrupt = fiberId => exitFailCause(internalCause.interrupt(fiberId));\n/** @internal */\nexports.exitInterrupt = exitInterrupt;\nconst exitMap = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      {\n        return self;\n      }\n    case OpCodes.OP_SUCCESS:\n      {\n        return exitSucceed(f(self.i0));\n      }\n  }\n});\n/** @internal */\nexports.exitMap = exitMap;\nconst exitMapBoth = /*#__PURE__*/(0, _Function.dual)(3, (self, onFailure, onSuccess) => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      {\n        return exitFailCause(internalCause.map(onFailure)(self.i0));\n      }\n    case OpCodes.OP_SUCCESS:\n      {\n        return exitSucceed(onSuccess(self.i0));\n      }\n  }\n});\n/** @internal */\nexports.exitMapBoth = exitMapBoth;\nconst exitMapError = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      {\n        return exitFailCause(internalCause.map(f)(self.i0));\n      }\n    case OpCodes.OP_SUCCESS:\n      {\n        return self;\n      }\n  }\n});\n/** @internal */\nexports.exitMapError = exitMapError;\nconst exitMapErrorCause = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      {\n        return exitFailCause(f(self.i0));\n      }\n    case OpCodes.OP_SUCCESS:\n      {\n        return self;\n      }\n  }\n});\n/** @internal */\nexports.exitMapErrorCause = exitMapErrorCause;\nconst exitMatch = /*#__PURE__*/(0, _Function.dual)(3, (self, onFailure, onSuccess) => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      {\n        return onFailure(self.i0);\n      }\n    case OpCodes.OP_SUCCESS:\n      {\n        return onSuccess(self.i0);\n      }\n  }\n});\n/** @internal */\nexports.exitMatch = exitMatch;\nconst exitMatchEffect = /*#__PURE__*/(0, _Function.dual)(3, (self, onFailure, onSuccess) => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      {\n        return onFailure(self.i0);\n      }\n    case OpCodes.OP_SUCCESS:\n      {\n        return onSuccess(self.i0);\n      }\n  }\n});\n/** @internal */\nexports.exitMatchEffect = exitMatchEffect;\nconst exitSucceed = value => {\n  const effect = new EffectPrimitiveSuccess(OpCodes.OP_SUCCESS);\n  effect.i0 = value;\n  return effect;\n};\n/** @internal */\nexports.exitSucceed = exitSucceed;\nconst exitUnannotate = exit => exitIsSuccess(exit) ? exit : exitFailCause(internalCause.unannotate(exit.i0));\n/** @internal */\nexports.exitUnannotate = exitUnannotate;\nconst exitUnit = () => exitSucceed(void 0);\n/** @internal */\nexports.exitUnit = exitUnit;\nconst exitZip = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => exitZipWith(self, that, (a, a2) => [a, a2], internalCause.sequential));\n/** @internal */\nexports.exitZip = exitZip;\nconst exitZipLeft = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => exitZipWith(self, that, (a, _) => a, internalCause.sequential));\n/** @internal */\nexports.exitZipLeft = exitZipLeft;\nconst exitZipRight = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => exitZipWith(self, that, (_, a2) => a2, internalCause.sequential));\n/** @internal */\nexports.exitZipRight = exitZipRight;\nconst exitZipPar = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => exitZipWith(self, that, (a, a2) => [a, a2], internalCause.parallel));\n/** @internal */\nexports.exitZipPar = exitZipPar;\nconst exitZipParLeft = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => exitZipWith(self, that, (a, _) => a, internalCause.parallel));\n/** @internal */\nexports.exitZipParLeft = exitZipParLeft;\nconst exitZipParRight = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => exitZipWith(self, that, (_, a2) => a2, internalCause.parallel));\n/** @internal */\nexports.exitZipParRight = exitZipParRight;\nconst exitZipWith = /*#__PURE__*/(0, _Function.dual)(4, (self, that, f, g) => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      {\n        switch (that._tag) {\n          case OpCodes.OP_SUCCESS:\n            {\n              return self;\n            }\n          case OpCodes.OP_FAILURE:\n            {\n              return exitFailCause(g(self.i0, that.i0));\n            }\n        }\n      }\n    case OpCodes.OP_SUCCESS:\n      {\n        switch (that._tag) {\n          case OpCodes.OP_SUCCESS:\n            {\n              return exitSucceed(f(self.i0, that.i0));\n            }\n          case OpCodes.OP_FAILURE:\n            {\n              return that;\n            }\n        }\n      }\n  }\n});\nexports.exitZipWith = exitZipWith;\nconst exitCollectAllInternal = (exits, combineCauses) => {\n  const list = Chunk.fromIterable(exits);\n  if (!Chunk.isNonEmpty(list)) {\n    return Option.none();\n  }\n  return Option.some(exitMap(Chunk.reverse)(Chunk.reduce(exitMap(Chunk.of)(Chunk.headNonEmpty(list)), (accumulator, current) => exitZipWith(current, (list, value) => Chunk.prepend(value)(list), combineCauses)(accumulator))(Chunk.tailNonEmpty(list))));\n};\n// -----------------------------------------------------------------------------\n// Deferred\n// -----------------------------------------------------------------------------\n/** @internal */\nconst deferredUnsafeMake = fiberId => ({\n  [deferred.DeferredTypeId]: deferred.deferredVariance,\n  state: MutableRef.make(deferred.pending([])),\n  blockingOn: fiberId\n});\n/* @internal */\nexports.deferredUnsafeMake = deferredUnsafeMake;\nconst deferredMake = /*#__PURE__*/Debug.methodWithTrace(trace => () => flatMap(id => deferredMakeAs(id))(fiberId()).traced(trace));\n/* @internal */\nexports.deferredMake = deferredMake;\nconst deferredMakeAs = /*#__PURE__*/Debug.methodWithTrace(trace => fiberId => sync(() => deferredUnsafeMake(fiberId)).traced(trace));\n/* @internal */\nexports.deferredMakeAs = deferredMakeAs;\nconst deferredAwait = /*#__PURE__*/Debug.methodWithTrace(trace => self => asyncInterruptEither(k => {\n  const state = MutableRef.get(self.state);\n  switch (state._tag) {\n    case DeferredOpCodes.OP_STATE_DONE:\n      {\n        return Either.right(state.effect);\n      }\n    case DeferredOpCodes.OP_STATE_PENDING:\n      {\n        MutableRef.set(deferred.pending([k, ...state.joiners]))(self.state);\n        return Either.left(deferredInterruptJoiner(self, k));\n      }\n  }\n}, self.blockingOn).traced(trace));\n/* @internal */\nexports.deferredAwait = deferredAwait;\nconst deferredComplete = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, effect) => intoDeferred(effect, self).traced(trace));\n/* @internal */\nexports.deferredComplete = deferredComplete;\nconst deferredCompleteWith = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, effect) => sync(() => {\n  const state = MutableRef.get(self.state);\n  switch (state._tag) {\n    case DeferredOpCodes.OP_STATE_DONE:\n      {\n        return false;\n      }\n    case DeferredOpCodes.OP_STATE_PENDING:\n      {\n        MutableRef.set(deferred.done(effect))(self.state);\n        for (let i = 0; i < state.joiners.length; i++) {\n          state.joiners[i](effect);\n        }\n        return true;\n      }\n  }\n}).traced(trace));\n/* @internal */\nexports.deferredCompleteWith = deferredCompleteWith;\nconst deferredDone = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, exit) => deferredCompleteWith(self, done(exit)).traced(trace));\n/* @internal */\nexports.deferredDone = deferredDone;\nconst deferredFail = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, error) => deferredCompleteWith(self, fail(error)).traced(trace));\n/* @internal */\nexports.deferredFail = deferredFail;\nconst deferredFailSync = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, evaluate) => deferredCompleteWith(self, failSync(restore(evaluate))).traced(trace));\n/* @internal */\nexports.deferredFailSync = deferredFailSync;\nconst deferredFailCause = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, cause) => deferredCompleteWith(self, failCause(cause)).traced(trace));\n/* @internal */\nexports.deferredFailCause = deferredFailCause;\nconst deferredFailCauseSync = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, evaluate) => deferredCompleteWith(self, failCauseSync(restore(evaluate))).traced(trace));\n/* @internal */\nexports.deferredFailCauseSync = deferredFailCauseSync;\nconst deferredDie = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, defect) => deferredCompleteWith(self, die(defect)).traced(trace));\n/* @internal */\nexports.deferredDie = deferredDie;\nconst deferredDieSync = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, evaluate) => deferredCompleteWith(self, dieSync(restore(evaluate))).traced(trace));\n/* @internal */\nexports.deferredDieSync = deferredDieSync;\nconst deferredInterrupt = /*#__PURE__*/Debug.methodWithTrace(trace => self => flatMap(fiberId => deferredCompleteWith(self, interruptWith(fiberId)))(fiberId()).traced(trace));\n/* @internal */\nexports.deferredInterrupt = deferredInterrupt;\nconst deferredInterruptWith = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, fiberId) => deferredCompleteWith(self, interruptWith(fiberId)).traced(trace));\n/* @internal */\nexports.deferredInterruptWith = deferredInterruptWith;\nconst deferredIsDone = /*#__PURE__*/Debug.methodWithTrace(trace => self => sync(() => MutableRef.get(self.state)._tag === DeferredOpCodes.OP_STATE_DONE).traced(trace));\n/* @internal */\nexports.deferredIsDone = deferredIsDone;\nconst deferredPoll = /*#__PURE__*/Debug.methodWithTrace(trace => self => sync(() => {\n  const state = MutableRef.get(self.state);\n  switch (state._tag) {\n    case DeferredOpCodes.OP_STATE_DONE:\n      {\n        return Option.some(state.effect);\n      }\n    case DeferredOpCodes.OP_STATE_PENDING:\n      {\n        return Option.none();\n      }\n  }\n}).traced(trace));\n/* @internal */\nexports.deferredPoll = deferredPoll;\nconst deferredSucceed = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, value) => deferredCompleteWith(self, succeed(value)).traced(trace));\n/* @internal */\nexports.deferredSucceed = deferredSucceed;\nconst deferredSync = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, evaluate) => deferredCompleteWith(self, sync(restore(evaluate))).traced(trace));\n/** @internal */\nexports.deferredSync = deferredSync;\nconst deferredUnsafeDone = (self, effect) => {\n  const state = MutableRef.get(self.state);\n  if (state._tag === DeferredOpCodes.OP_STATE_PENDING) {\n    MutableRef.set(deferred.done(effect))(self.state);\n    for (let i = state.joiners.length - 1; i >= 0; i--) {\n      state.joiners[i](effect);\n    }\n  }\n};\nexports.deferredUnsafeDone = deferredUnsafeDone;\nconst deferredInterruptJoiner = (self, joiner) => sync(() => {\n  const state = MutableRef.get(self.state);\n  if (state._tag === DeferredOpCodes.OP_STATE_PENDING) {\n    MutableRef.set(deferred.pending(state.joiners.filter(j => j !== joiner)))(self.state);\n  }\n});\n//# sourceMappingURL=core.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.runtimeDebug = exports.restoreOn = exports.restoreOff = void 0;\nvar _Global = /*#__PURE__*/require(\"@effect/data/Global\");\n/** @internal */\nconst restoreOn = body => function () {\n  if (runtimeDebug.tracingEnabled) {\n    // @ts-expect-error\n    return body.apply(this, arguments);\n  }\n  runtimeDebug.tracingEnabled = true;\n  try {\n    // @ts-expect-error\n    return body.apply(this, arguments);\n  } finally {\n    runtimeDebug.tracingEnabled = false;\n  }\n};\n/** @internal */\nexports.restoreOn = restoreOn;\nconst restoreOff = body => function () {\n  if (!runtimeDebug.tracingEnabled) {\n    // @ts-expect-error\n    return body.apply(this, arguments);\n  }\n  runtimeDebug.tracingEnabled = false;\n  try {\n    // @ts-expect-error\n    return body.apply(this, arguments);\n  } finally {\n    runtimeDebug.tracingEnabled = true;\n  }\n};\n/** @internal */\nexports.restoreOff = restoreOff;\nconst runtimeDebug = /*#__PURE__*/(0, _Global.globalValue)( /*#__PURE__*/Symbol.for(\"@effect/io/Debug/runtimeDebug\"), () => ({\n  minumumLogLevel: \"Info\",\n  traceStackLimit: 5,\n  tracingEnabled: true,\n  parseStack: error => {\n    const stack = error.stack;\n    if (stack) {\n      const lines = stack.split(\"\\n\");\n      let starts = 0;\n      for (let i = 0; i < lines.length; i++) {\n        if (lines[i].startsWith(\"Error\")) {\n          starts = i;\n        }\n      }\n      const frames = [];\n      for (let i = starts + 1; i < lines.length; i++) {\n        if (lines[i].includes(\"at\")) {\n          const blocks = lines[i].split(\" \").filter(i => i.length > 0 && i !== \"at\");\n          const name = blocks.length === 2 && !blocks[0].includes(\"<anonymous>\") ? blocks[0] : undefined;\n          const file = blocks.length === 2 ? blocks[1] : blocks[0];\n          const matchFrame = file?.match(/\\(?(.*):(\\d+):(\\d+)/);\n          if (matchFrame) {\n            frames.push({\n              name,\n              fileName: matchFrame[1],\n              line: Number.parseInt(matchFrame[2]),\n              column: Number.parseInt(matchFrame[3])\n            });\n          } else {\n            frames.push(undefined);\n          }\n        } else {\n          frames.push(undefined);\n        }\n      }\n      return frames;\n    }\n    return [];\n  },\n  filterStackFrame: _ => _ != null && !_.fileName.match(/\\/internal_effect_untraced/)\n}));\nexports.runtimeDebug = runtimeDebug;\n//# sourceMappingURL=debug.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.withConfigProvider = exports.withClock = exports.sleep = exports.shuffle = exports.randomWith = exports.nextRange = exports.nextIntBetween = exports.nextInt = exports.nextBoolean = exports.next = exports.liveServices = exports.currentTimeMillis = exports.currentServices = exports.configProviderWith = exports.configOrDie = exports.config = exports.clockWith = void 0;\nvar Context = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Context\"));\nvar Debug = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Debug\"));\nvar clock = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/clock\"));\nvar configProvider = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/configProvider\"));\nvar core = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/core\"));\nvar random = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/random\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/** @internal */\nconst liveServices = /*#__PURE__*/Context.add(configProvider.configProviderTag, configProvider.fromEnv())( /*#__PURE__*/Context.add(random.randomTag, random.make(Math.random() * 4294967296 >>> 0))( /*#__PURE__*/Context.add(clock.clockTag, clock.make())( /*#__PURE__*/Context.empty())));\n/**\n * The `FiberRef` holding the default `Effect` services.\n *\n * @since 1.0.0\n * @category fiberRefs\n */\nexports.liveServices = liveServices;\nconst currentServices = /*#__PURE__*/core.fiberRefUnsafeMakeContext(liveServices);\n// circular with Clock\n/** @internal */\nexports.currentServices = currentServices;\nconst currentTimeMillis = /*#__PURE__*/Debug.methodWithTrace(trace => () => clockWith(clock => clock.currentTimeMillis()).traced(trace));\n/** @internal */\nexports.currentTimeMillis = currentTimeMillis;\nconst sleep = /*#__PURE__*/Debug.methodWithTrace(trace => duration => clockWith(clock => clock.sleep(duration)).traced(trace));\n/** @internal */\nexports.sleep = sleep;\nconst clockWith = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => f => core.fiberRefGetWith(currentServices, services => restore(f)(Context.get(clock.clockTag)(services))).traced(trace));\n/** @internal */\nexports.clockWith = clockWith;\nconst withClock = /*#__PURE__*/Debug.dualWithTrace(2, trace => (effect, value) => core.fiberRefLocallyWith(currentServices, Context.add(clock.clockTag, value))(effect).traced(trace));\n// circular with ConfigProvider\n/** @internal */\nexports.withClock = withClock;\nconst withConfigProvider = /*#__PURE__*/Debug.dualWithTrace(2, trace => (effect, value) => core.fiberRefLocallyWith(currentServices, Context.add(configProvider.configProviderTag, value))(effect).traced(trace));\n/** @internal */\nexports.withConfigProvider = withConfigProvider;\nconst configProviderWith = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => f => core.fiberRefGetWith(currentServices, services => restore(f)(Context.get(configProvider.configProviderTag)(services))).traced(trace));\n/** @internal */\nexports.configProviderWith = configProviderWith;\nconst config = /*#__PURE__*/Debug.methodWithTrace(trace => config => configProviderWith(_ => _.load(config)).traced(trace));\n/** @internal */\nexports.config = config;\nconst configOrDie = /*#__PURE__*/Debug.methodWithTrace(trace => config => core.orDie(configProviderWith(_ => _.load(config))).traced(trace));\n// circular with Random\n/** @internal */\nexports.configOrDie = configOrDie;\nconst randomWith = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => f => core.fiberRefGetWith(currentServices, services => restore(f)(Context.get(random.randomTag)(services))).traced(trace));\n/** @internal */\nexports.randomWith = randomWith;\nconst next = /*#__PURE__*/Debug.methodWithTrace(trace => () => randomWith(random => random.next()).traced(trace));\n/** @internal */\nexports.next = next;\nconst nextInt = /*#__PURE__*/Debug.methodWithTrace(trace => () => randomWith(random => random.nextInt()).traced(trace));\n/** @internal */\nexports.nextInt = nextInt;\nconst nextBoolean = /*#__PURE__*/Debug.methodWithTrace(trace => () => randomWith(random => random.nextBoolean()).traced(trace));\n/** @internal */\nexports.nextBoolean = nextBoolean;\nconst nextRange = /*#__PURE__*/Debug.methodWithTrace(trace => (min, max) => randomWith(random => random.nextRange(min, max)).traced(trace));\n/** @internal */\nexports.nextRange = nextRange;\nconst nextIntBetween = /*#__PURE__*/Debug.methodWithTrace(trace => (min, max) => randomWith(random => random.nextIntBetween(min, max)).traced(trace));\n/** @internal */\nexports.nextIntBetween = nextIntBetween;\nconst shuffle = /*#__PURE__*/Debug.methodWithTrace(trace => elements => randomWith(random => random.shuffle(elements)).traced(trace));\nexports.shuffle = shuffle;\n//# sourceMappingURL=defaultServices.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.pending = exports.done = exports.deferredVariance = exports.DeferredTypeId = void 0;\nvar OpCodes = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/opCodes/deferred\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/** @internal */\nconst DeferredSymbolKey = \"@effect/io/Deferred\";\n/** @internal */\nconst DeferredTypeId = /*#__PURE__*/Symbol.for(DeferredSymbolKey);\n/** @internal */\nexports.DeferredTypeId = DeferredTypeId;\nconst deferredVariance = {\n  _E: _ => _,\n  _A: _ => _\n};\n/** @internal */\nexports.deferredVariance = deferredVariance;\nconst pending = joiners => {\n  return {\n    _tag: OpCodes.OP_STATE_PENDING,\n    joiners\n  };\n};\n/** @internal */\nexports.pending = pending;\nconst done = effect => {\n  return {\n    _tag: OpCodes.OP_STATE_DONE,\n    effect\n  };\n};\nexports.done = done;\n//# sourceMappingURL=deferred.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.descriptorWith = exports.descriptor = exports.delay = exports.continueOrFailEffect = exports.continueOrFail = exports.contextWith = exports.cond = exports.collectWhile = exports.collectFirst = exports.collectAllWithEffect = exports.collectAllWith = exports.collectAllSuccesses = exports.collectAllDiscard = exports.collectAll = exports.clockWith = exports.clock = exports.cause = exports.catchTags = exports.catchTag = exports.catchSomeDefect = exports.catchSomeCause = exports.catchAllDefect = exports.bindValue = exports.bind = exports.attemptSuspend = exports.attemptPromiseInterrupt = exports.attemptPromise = exports.attemptCatchPromiseInterrupt = exports.attemptCatchPromise = exports.attemptCatch = exports.attempt = exports.asyncOption = exports.asSomeError = exports.asSome = exports.asRightError = exports.asRight = exports.asLeftError = exports.asLeft = exports.allowInterrupt = exports.all = exports.absorbWith = exports.absorb = exports.absolveWith = exports.absolve = exports._catch = exports.Do = void 0;\nObject.defineProperty(exports, \"dieMessage\", {\n  enumerable: true,\n  get: function () {\n    return _clock.dieMessage;\n  }\n});\nObject.defineProperty(exports, \"dieOnSync\", {\n  enumerable: true,\n  get: function () {\n    return _clock.dieOnSync;\n  }\n});\nexports.logSpan = exports.logInfoCauseMessage = exports.logInfoCause = exports.logInfo = exports.logFatalCauseMessage = exports.logFatalCause = exports.logFatal = exports.logErrorCauseMessage = exports.logErrorCause = exports.logError = exports.logDebugCauseMessage = exports.logDebugCause = exports.logDebug = exports.logAnnotations = exports.logAnnotate = exports.log = exports.leftWith = exports.left = exports.iterate = exports.isSuccess = exports.isFailure = exports.inheritFiberRefs = exports.ignoreLogged = exports.ignore = exports.head = exports.getOrFailWith = exports.getOrFailDiscard = exports.getOrFail = exports.getFiberRefs = exports.gen = exports.fromEitherCause = exports.forever = exports.forEachWithIndex = exports.forEachOption = exports.forEachEffect = exports.forAll = exports.flipWith = exports.flattenErrorOption = exports.firstSuccessOf = exports.find = exports.filterOrFail = exports.filterOrElseWith = exports.filterOrElse = exports.filterOrDieMessage = exports.filterOrDie = exports.filterNot = exports.filter = exports.exists = exports.eventually = exports.dropWhile = exports.dropUntil = exports.diffFiberRefs = void 0;\nexports.withMetric = exports.whenRef = exports.whenFiberRef = exports.whenCaseEffect = exports.whenCase = exports.when = exports.validateWith = exports.validateFirst = exports.validateAllDiscard = exports.validateAll = exports.validate = exports.updateService = exports.updateFiberRefs = exports.unsandbox = exports.unright = exports.unrefineWith = exports.unrefine = exports.unlessEffect = exports.unless = exports.unleft = exports.unfold = exports.uncause = exports.timedWith = exports.timed = exports.tapSome = exports.tapErrorCause = exports.tapError = exports.tapEither = exports.tapDefect = exports.tapBoth = exports.takeWhile = exports.taggedWithLabels = exports.taggedWithLabelSet = exports.tagged = exports.summarized = exports.succeedSome = exports.succeedRight = exports.succeedNone = exports.succeedLeft = exports.someOrFailException = exports.someOrFail = exports.someOrElseEffect = exports.someOrElse = exports.sleep = exports.setFiberRefs = exports.sandbox = exports.rightWith = exports.right = exports.resurrect = exports.replicateEffectDiscard = exports.replicateEffect = exports.replicate = exports.repeatN = exports.rejectEffect = exports.reject = exports.refineTagOrDieWith = exports.refineTagOrDie = exports.refineOrDieWith = exports.refineOrDie = exports.reduceWhile = exports.reduceRight = exports.reduceAll = exports.reduce = exports.randomWith = exports.random = exports.provideServiceEffect = exports.provideService = exports.promiseInterrupt = exports.promise = exports.patchFiberRefs = exports.partition = exports.parallelErrors = exports.orElseSucceed = exports.orElseOptional = exports.orElseFail = exports.orElseEither = exports.option = exports.once = exports.noneOrFailWith = exports.noneOrFail = exports.none = exports.negate = exports.mergeAll = exports.merge = exports.memoize = exports.match = exports.mapTryCatch = exports.mapErrorCause = exports.mapBoth = exports.mapAccum = exports.loopDiscard = exports.loop = exports.logWarningCauseMessage = exports.logWarningCause = exports.logWarning = exports.logTraceCauseMessage = exports.logTraceCause = exports.logTrace = void 0;\nvar Chunk = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Chunk\"));\nvar Context = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Context\"));\nvar Duration = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Duration\"));\nvar Either = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Either\"));\nvar _Function = /*#__PURE__*/require(\"@effect/data/Function\");\nvar HashMap = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/HashMap\"));\nvar HashSet = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/HashSet\"));\nvar Option = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Option\"));\nvar Clock = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Clock\"));\nvar Debug = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Debug\"));\nvar Exit = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Exit\"));\nvar FiberId = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Fiber/Id\"));\nvar FiberRefs = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/FiberRefs\"));\nvar internalCause = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/cause\"));\nvar _clock = /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/clock\");\nvar core = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/core\"));\nvar fiberRefsPatch = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/fiberRefs/patch\"));\nvar metricLabel = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/metric/label\"));\nvar SingleShotGen = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/singleShotGen\"));\nvar LogLevel = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Logger/Level\"));\nvar LogSpan = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Logger/Span\"));\nvar Random = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Random\"));\nvar Ref = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Ref\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/* @internal */\n\n/* @internal */\nconst absolve = /*#__PURE__*/Debug.methodWithTrace(trace => self => absolveWith(self, _Function.identity).traced(trace));\n/* @internal */\nexports.absolve = absolve;\nconst absolveWith = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => core.flatMap(value => core.fromEither(restore(f)(value)))(self).traced(trace));\n/* @internal */\nexports.absolveWith = absolveWith;\nconst absorb = /*#__PURE__*/Debug.methodWithTrace(trace => self => absorbWith(self, _Function.identity).traced(trace));\n/* @internal */\nexports.absorb = absorb;\nconst absorbWith = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => core.matchEffect(sandbox(self), cause => core.fail(internalCause.squashWith(restore(f))(cause)), core.succeed).traced(trace));\n/* @internal */\nexports.absorbWith = absorbWith;\nconst allowInterrupt = /*#__PURE__*/Debug.methodWithTrace(trace => () => descriptorWith(descriptor => HashSet.size(descriptor.interruptors) > 0 ? core.interrupt() : core.unit()).traced(trace));\n/* @internal */\nexports.allowInterrupt = allowInterrupt;\nconst asLeft = /*#__PURE__*/Debug.methodWithTrace(trace => self => core.map(Either.left)(self).traced(trace));\n/* @internal */\nexports.asLeft = asLeft;\nconst asLeftError = /*#__PURE__*/Debug.methodWithTrace(trace => self => core.mapError(Either.left)(self).traced(trace));\n/* @internal */\nexports.asLeftError = asLeftError;\nconst asRight = /*#__PURE__*/Debug.methodWithTrace(trace => self => core.map(Either.right)(self).traced(trace));\n/* @internal */\nexports.asRight = asRight;\nconst asRightError = /*#__PURE__*/Debug.methodWithTrace(trace => self => core.mapError(Either.right)(self).traced(trace));\n/* @internal */\nexports.asRightError = asRightError;\nconst asSome = /*#__PURE__*/Debug.methodWithTrace(trace => self => core.map(Option.some)(self).traced(trace));\n/* @internal */\nexports.asSome = asSome;\nconst asSomeError = /*#__PURE__*/Debug.methodWithTrace(trace => self => core.mapError(Option.some)(self).traced(trace));\n/* @internal */\nexports.asSomeError = asSomeError;\nconst asyncOption = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => (register, blockingOn = FiberId.none) => core.asyncInterruptEither(cb => {\n  const option = restore(register)(cb);\n  switch (option._tag) {\n    case \"None\":\n      {\n        return Either.left(core.unit());\n      }\n    case \"Some\":\n      {\n        return Either.right(option.value);\n      }\n  }\n}, blockingOn).traced(trace));\n/* @internal */\nexports.asyncOption = asyncOption;\nconst attempt = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => evaluate => core.sync(() => {\n  try {\n    return restore(evaluate)();\n  } catch (error) {\n    throw core.makeEffectError(internalCause.fail(error));\n  }\n}).traced(trace));\n/* @internal */\nexports.attempt = attempt;\nconst _catch = /*#__PURE__*/Debug.dualWithTrace(\n// @ts-expect-error - probably a TS bug - infers to never because \"DF does not extend (...args: any[]) => any)\" but, of course, it does)\n4, (trace, restore) => (self, tag, k, f) => core.catchAll(self, e => {\n  if (typeof e === \"object\" && e != null && tag in e && e[tag] === k) {\n    return restore(f)(e);\n  }\n  return core.fail(e);\n}).traced(trace));\n/* @internal */\nexports._catch = _catch;\nconst catchAllDefect = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => catchSomeDefect(self, defect => Option.some(restore(f)(defect))).traced(trace));\n/* @internal */\nexports.catchAllDefect = catchAllDefect;\nconst catchSomeCause = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => core.matchCauseEffect(self, cause => {\n  const option = restore(f)(cause);\n  switch (option._tag) {\n    case \"None\":\n      {\n        return core.failCause(cause);\n      }\n    case \"Some\":\n      {\n        return option.value;\n      }\n  }\n}, core.succeed).traced(trace));\n/* @internal */\nexports.catchSomeCause = catchSomeCause;\nconst catchSomeDefect = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, pf) => core.catchAll(s => s)(unrefineWith(self, restore(pf), core.fail)).traced(trace));\n/* @internal */\nexports.catchSomeDefect = catchSomeDefect;\nconst catchTag = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (self, k, f) => core.catchAll(self, e => {\n  if (\"_tag\" in e && e[\"_tag\"] === k) {\n    return restore(f)(e);\n  }\n  return core.fail(e);\n}).traced(trace));\n/** @internal */\nexports.catchTag = catchTag;\nconst catchTags = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, cases) => core.catchAll(self, e => {\n  const keys = Object.keys(cases);\n  if (\"_tag\" in e && keys.includes(e[\"_tag\"])) {\n    return restore(cases[e[\"_tag\"]])(e);\n  }\n  return core.fail(e);\n}).traced(trace));\n/* @internal */\nexports.catchTags = catchTags;\nconst cause = /*#__PURE__*/Debug.methodWithTrace(trace => self => core.matchCause(_Function.identity, () => internalCause.empty)(self).traced(trace));\n/* @internal */\nexports.cause = cause;\nconst clock = /*#__PURE__*/Debug.methodWithTrace(trace => () => clockWith(core.succeed).traced(trace));\n/* @internal */\nexports.clock = clock;\nconst clockWith = Clock.clockWith;\n/* @internal */\nexports.clockWith = clockWith;\nconst collectAll = /*#__PURE__*/Debug.methodWithTrace(trace => effects => core.forEach(effects, _Function.identity).traced(trace));\n/* @internal */\nexports.collectAll = collectAll;\nconst collectAllDiscard = /*#__PURE__*/Debug.methodWithTrace(trace => effects => core.forEachDiscard(effects, _Function.identity).traced(trace));\n/* @internal */\nexports.collectAllDiscard = collectAllDiscard;\nconst collectAllWith = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (elements, pf) => core.map(collectAll(elements), Chunk.filterMap(restore(pf))).traced(trace));\n/* @internal */\nexports.collectAllWith = collectAllWith;\nconst collectAllWithEffect = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (elements, f) => {\n  const array = Array.from(elements);\n  // Break out early if there are no elements\n  if (array.length === 0) {\n    return core.succeed(Chunk.empty()).traced(trace);\n  }\n  // Break out early if there is only one element\n  if (array.length === 1) {\n    const option = restore(f)(array[0]);\n    switch (option._tag) {\n      case \"None\":\n        {\n          return core.succeed(Chunk.empty()).traced(trace);\n        }\n      case \"Some\":\n        {\n          return core.map(option.value, Chunk.of).traced(trace);\n        }\n    }\n  }\n  // Otherwise create the intermediate result structure\n  let result = core.succeed(Chunk.empty());\n  for (let i = array.length - 1; i >= 0; i--) {\n    const option = restore(f)(array[i]);\n    if (option._tag === \"Some\") {\n      result = core.zipWith(result, option.value, (list, b) => Chunk.prepend(b)(list));\n    }\n  }\n  return core.map(result, Chunk.fromIterable).traced(trace);\n});\n/* @internal */\nexports.collectAllWithEffect = collectAllWithEffect;\nconst collectAllSuccesses = /*#__PURE__*/Debug.methodWithTrace(trace => as => collectAllWith(exit => Exit.isSuccess(exit) ? Option.some(exit.i0) : Option.none())(Array.from(as).map(core.exit)).traced(trace));\n/* @internal */\nexports.collectAllSuccesses = collectAllSuccesses;\nconst collectFirst = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (elements, f) => core.suspend(() => collectFirstLoop(restore, elements[Symbol.iterator](), restore(f))).traced(trace));\nexports.collectFirst = collectFirst;\nconst collectFirstLoop = (restore, iterator, f) => {\n  const next = restore(() => iterator.next())();\n  return next.done ? core.succeed(Option.none()) : core.flatMap(option => {\n    switch (option._tag) {\n      case \"None\":\n        {\n          return collectFirstLoop(restore, iterator, f);\n        }\n      case \"Some\":\n        {\n          return core.succeed(option);\n        }\n    }\n  })(f(next.value));\n};\n/* @internal */\nconst collectWhile = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (elements, f) => {\n  const array = Array.from(elements);\n  // Break out early if the input is empty\n  if (array.length === 0) {\n    return core.succeed(Chunk.empty()).traced(trace);\n  }\n  // Break out early if there is only one element in the list\n  if (array.length === 1) {\n    const option = restore(f)(array[0]);\n    switch (option._tag) {\n      case \"None\":\n        {\n          return core.succeed(Chunk.empty()).traced(trace);\n        }\n      case \"Some\":\n        {\n          return core.map(option.value, Chunk.of).traced(trace);\n        }\n    }\n  }\n  // Otherwise setup our intermediate result\n  let result = core.succeed(Chunk.empty());\n  for (let i = array.length - 1; i >= 0; i--) {\n    const option = restore(f)(array[i]);\n    switch (option._tag) {\n      case \"None\":\n        {\n          return core.map(result, Chunk.fromIterable).traced(trace);\n        }\n      case \"Some\":\n        {\n          result = core.zipWith(result, option.value, (bs, b) => Chunk.prepend(b)(bs));\n        }\n    }\n  }\n  return core.map(result, Chunk.fromIterable).traced(trace);\n});\n/* @internal */\nexports.collectWhile = collectWhile;\nconst cond = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => (predicate, result, error) => core.suspend(() => restore(predicate)() ? core.sync(restore(result)) : core.failSync(restore(error))).traced(trace));\n/* @internal */\nexports.cond = cond;\nconst continueOrFail = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (self, error, pf) => continueOrFailEffect(self, error, a => Option.map(restore(pf)(a), core.succeed)).traced(trace));\n/* @internal */\nexports.continueOrFail = continueOrFail;\nconst continueOrFailEffect = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (self, error, pf) => core.flatMap(self, value => Option.getOrElse(restore(pf)(value), () => core.failSync(error))).traced(trace));\n/* @internal */\nexports.continueOrFailEffect = continueOrFailEffect;\nconst delay = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, duration) => core.zipRight(Clock.sleep(duration), self).traced(trace));\n/* @internal */\nexports.delay = delay;\nconst descriptor = /*#__PURE__*/Debug.methodWithTrace(trace => () => descriptorWith(core.succeed).traced(trace));\n/* @internal */\nexports.descriptor = descriptor;\nconst descriptorWith = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => f => core.withFiberRuntime((state, status) => restore(f)({\n  id: state.id(),\n  status,\n  interruptors: internalCause.interruptors(state.getFiberRef(core.interruptedCause))\n})).traced(trace));\n/* @internal */\nexports.descriptorWith = descriptorWith;\nconst diffFiberRefs = /*#__PURE__*/Debug.methodWithTrace(trace => self => summarized(getFiberRefs(), fiberRefsPatch.diff)(self).traced(trace));\n/* @internal */\nexports.diffFiberRefs = diffFiberRefs;\nconst Do = /*#__PURE__*/Debug.methodWithTrace(trace => () => core.succeed({}).traced(trace));\n/* @internal */\nexports.Do = Do;\nconst bind = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (self, tag, f) => core.flatMap(self, k => core.map(restore(f)(k), a => ({\n  ...k,\n  [tag]: a\n}))).traced(trace));\n/* @internal */\nexports.bind = bind;\nconst bindValue = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (self, tag, f) => core.map(self, k => ({\n  ...k,\n  [tag]: restore(f)(k)\n})).traced(trace));\n/* @internal */\nexports.bindValue = bindValue;\nconst dropUntil = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (elements, predicate) => core.suspend(() => {\n  const iterator = elements[Symbol.iterator]();\n  const builder = [];\n  let next;\n  let dropping = core.succeed(false);\n  while ((next = iterator.next()) && !next.done) {\n    const a = next.value;\n    dropping = core.flatMap(dropping, bool => {\n      if (bool) {\n        builder.push(a);\n        return core.succeed(true);\n      }\n      return restore(predicate)(a);\n    });\n  }\n  return core.map(dropping, () => Chunk.unsafeFromArray(builder));\n}).traced(trace));\n/* @internal */\nexports.dropUntil = dropUntil;\nconst dropWhile = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (elements, f) => core.suspend(() => {\n  const iterator = elements[Symbol.iterator]();\n  const builder = [];\n  let next;\n  let dropping = core.succeed(true);\n  while ((next = iterator.next()) && !next.done) {\n    const a = next.value;\n    dropping = core.flatMap(dropping, d => core.map(d ? restore(f)(a) : core.succeed(false), b => {\n      if (!b) {\n        builder.push(a);\n      }\n      return b;\n    }));\n  }\n  return core.map(dropping, () => Chunk.unsafeFromArray(builder));\n}).traced(trace));\n/* @internal */\nexports.dropWhile = dropWhile;\nconst contextWith = /*#__PURE__*/Debug.methodWithTrace(trace => f => core.map(core.context(), f).traced(trace));\n/* @internal */\nexports.contextWith = contextWith;\nconst exists = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (elements, f) => core.suspend(() => existsLoop(restore, elements[Symbol.iterator](), restore(f))).traced(trace));\nexports.exists = exists;\nconst existsLoop = (restore, iterator, f) => {\n  const next = restore(() => iterator.next())();\n  if (next.done) {\n    return core.succeed(false);\n  }\n  return core.flatMap(b => b ? core.succeed(b) : existsLoop(restore, iterator, f))(f(next.value));\n};\n/* @internal */\nconst eventually = /*#__PURE__*/Debug.methodWithTrace(trace => self => core.orElse(self, () => core.flatMap(() => eventually(self))(core.yieldNow())).traced(trace));\n/* @internal */\nexports.eventually = eventually;\nconst filter = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (elements, f) => core.suspend(() => Array.from(elements).reduceRight((effect, a) => core.zipWith(effect, core.suspend(() => restore(f)(a)), (list, b) => b ? Chunk.prepend(a)(list) : list), core.sync(() => Chunk.empty()))).traced(trace));\n/* @internal */\nexports.filter = filter;\nconst filterNot = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (elements, f) => filter(elements, a => core.map(restore(f)(a), b => !b)).traced(trace));\n/* @internal */\nexports.filterNot = filterNot;\nconst filterOrDie = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (self, f, defect) => filterOrElse(self, restore(f), () => core.dieSync(restore(defect))).traced(trace));\n/* @internal */\nexports.filterOrDie = filterOrDie;\nconst filterOrDieMessage = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (self, f, message) => filterOrElse(self, restore(f), () => (0, _clock.dieMessage)(message)).traced(trace));\n/* @internal */\nexports.filterOrDieMessage = filterOrDieMessage;\nconst filterOrElse = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (self, f, orElse) => filterOrElseWith(self, restore(f), orElse).traced(trace));\n/* @internal */\nexports.filterOrElse = filterOrElse;\nconst filterOrElseWith = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (self, f, orElse) => core.flatMap(self, a => restore(f)(a) ? core.succeed(a) : restore(orElse)(a)).traced(trace));\n/* @internal */\nexports.filterOrElseWith = filterOrElseWith;\nconst filterOrFail = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (self, f, error) => filterOrElse(self, restore(f), () => core.failSync(restore(error))).traced(trace));\n/* @internal */\nexports.filterOrFail = filterOrFail;\nconst find = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (elements, f) => core.suspend(() => {\n  const array = Array.from(elements);\n  const iterator = array[Symbol.iterator]();\n  const next = restore(() => iterator.next())();\n  if (!next.done) {\n    return findLoop(restore, iterator, restore(f), next.value);\n  }\n  return core.succeed(Option.none());\n}).traced(trace));\nexports.find = find;\nconst findLoop = (restore, iterator, f, value) => core.flatMap(f(value), result => {\n  if (result) {\n    return core.succeed(Option.some(value));\n  }\n  const next = restore(() => iterator.next())();\n  if (!next.done) {\n    return findLoop(restore, iterator, f, next.value);\n  }\n  return core.succeed(Option.none());\n});\n/* @internal */\nconst firstSuccessOf = /*#__PURE__*/Debug.methodWithTrace(trace => effects => core.suspend(() => {\n  const list = Chunk.fromIterable(effects);\n  if (!Chunk.isNonEmpty(list)) {\n    return core.dieSync(() => internalCause.IllegalArgumentException(`Received an empty collection of effects`));\n  }\n  return Chunk.reduce(Chunk.headNonEmpty(list), (left, right) => core.orElse(left, () => right))(Chunk.tailNonEmpty(list));\n}).traced(trace));\n/* @internal */\nexports.firstSuccessOf = firstSuccessOf;\nconst flattenErrorOption = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, fallback) => core.mapError(self, Option.getOrElse(() => fallback)).traced(trace));\n/* @internal */\nexports.flattenErrorOption = flattenErrorOption;\nconst flipWith = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => core.flip(restore(f)(core.flip(self))).traced(trace));\n/* @internal */\nexports.flipWith = flipWith;\nconst match = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (self, onFailure, onSuccess) => core.matchEffect(self, e => core.succeed(restore(onFailure)(e)), a => core.succeed(restore(onSuccess)(a))).traced(trace));\n/* @internal */\nexports.match = match;\nconst forAll = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (elements, f) => core.suspend(() => forAllLoop(restore, elements[Symbol.iterator](), restore(f))).traced(trace));\nexports.forAll = forAll;\nconst forAllLoop = (restore, iterator, f) => {\n  const next = restore(() => iterator.next())();\n  return next.done ? core.succeed(true) : core.flatMap(b => b ? forAllLoop(restore, iterator, f) : core.succeed(b))(f(next.value));\n};\n/* @internal */\nconst forEachEffect = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => core.matchCauseEffect(self, () => core.succeed(Option.none()), a => core.map(restore(f)(a), Option.some)).traced(trace));\n/* @internal */\nexports.forEachEffect = forEachEffect;\nconst forEachOption = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (option, f) => {\n  switch (option._tag) {\n    case \"None\":\n      {\n        return core.succeed(Option.none()).traced(trace);\n      }\n    case \"Some\":\n      {\n        return core.map(restore(f)(option.value), Option.some).traced(trace);\n      }\n  }\n});\n/* @internal */\nexports.forEachOption = forEachOption;\nconst forEachWithIndex = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (elements, f) => core.suspend(() => {\n  let index = 0;\n  const acc = [];\n  return core.map(() => Chunk.unsafeFromArray(acc))(core.forEachDiscard(elements, a => core.map(restore(f)(a, index), b => {\n    acc.push(b);\n    index++;\n  })));\n}).traced(trace));\n/* @internal */\nexports.forEachWithIndex = forEachWithIndex;\nconst forever = /*#__PURE__*/Debug.methodWithTrace(trace => self => {\n  const loop = core.flatMap(() => loop)(core.flatMap(self, () => core.yieldNow()));\n  return loop.traced(trace);\n});\n/* @internal */\nexports.forever = forever;\nconst fromEitherCause = /*#__PURE__*/Debug.methodWithTrace(trace => either => {\n  switch (either._tag) {\n    case \"Left\":\n      {\n        return core.failCause(either.left).traced(trace);\n      }\n    case \"Right\":\n      {\n        return core.succeed(either.right).traced(trace);\n      }\n  }\n});\n/** @internal */\nexports.fromEitherCause = fromEitherCause;\nclass EffectGen {\n  constructor(value) {\n    this.value = value;\n  }\n  [Symbol.iterator]() {\n    return new SingleShotGen.SingleShotGen(this);\n  }\n}\n/**\n * Inspired by https://github.com/tusharmath/qio/pull/22 (revised)\n  @internal */\nconst gen = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => f => core.suspend(() => {\n  const iterator = restore(() => f(self => new EffectGen(self)))();\n  const state = restore(() => iterator.next())();\n  const run = state => state.done ? core.succeed(state.value) : core.flatMap(val => run(restore(() => iterator.next(val))()))(state.value.value);\n  return run(state);\n}).traced(trace));\n/* @internal */\nexports.gen = gen;\nconst getFiberRefs = /*#__PURE__*/Debug.methodWithTrace(trace => () => core.withFiberRuntime(state => core.succeed(state.unsafeGetFiberRefs())).traced(trace));\n/* @internal */\nexports.getFiberRefs = getFiberRefs;\nconst getOrFail = /*#__PURE__*/Debug.methodWithTrace(trace => option => getOrFailWith(() => internalCause.NoSuchElementException())(option).traced(trace));\n/* @internal */\nexports.getOrFail = getOrFail;\nconst getOrFailDiscard = /*#__PURE__*/Debug.methodWithTrace(trace => option => getOrFailWith(option, _Function.constVoid).traced(trace));\n/* @internal */\nexports.getOrFailDiscard = getOrFailDiscard;\nconst getOrFailWith = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (option, error) => {\n  switch (option._tag) {\n    case \"None\":\n      {\n        return core.failSync(restore(error)).traced(trace);\n      }\n    case \"Some\":\n      {\n        return core.succeed(option.value).traced(trace);\n      }\n  }\n});\n/* @internal */\nexports.getOrFailWith = getOrFailWith;\nconst head = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => self => core.matchEffect(e => core.fail(Option.some(e)), as => {\n  const iterator = restore(() => as[Symbol.iterator]())();\n  const next = restore(() => iterator.next())();\n  if (next.done) {\n    return core.fail(Option.none());\n  }\n  return core.succeed(next.value);\n})(self).traced(trace));\n/* @internal */\nexports.head = head;\nconst ignore = /*#__PURE__*/Debug.methodWithTrace(trace => self => match(self, _Function.constVoid, _Function.constVoid).traced(trace));\n/* @internal */\nexports.ignore = ignore;\nconst ignoreLogged = /*#__PURE__*/Debug.methodWithTrace(trace => self => core.matchCauseEffect(self, cause => logDebugCauseMessage(\"An error was silently ignored because it is not anticipated to be useful\", cause), () => core.unit()).traced(trace));\n/* @internal */\nexports.ignoreLogged = ignoreLogged;\nconst inheritFiberRefs = /*#__PURE__*/Debug.methodWithTrace(trace => childFiberRefs => updateFiberRefs((parentFiberId, parentFiberRefs) => FiberRefs.joinAs(parentFiberRefs, parentFiberId, childFiberRefs)).traced(trace));\n/* @internal */\nexports.inheritFiberRefs = inheritFiberRefs;\nconst isFailure = /*#__PURE__*/Debug.methodWithTrace(trace => self => match(self, _Function.constTrue, _Function.constFalse).traced(trace));\n/* @internal */\nexports.isFailure = isFailure;\nconst isSuccess = /*#__PURE__*/Debug.methodWithTrace(trace => self => match(self, _Function.constFalse, _Function.constTrue).traced(trace));\n/* @internal */\nexports.isSuccess = isSuccess;\nconst iterate = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => (initial, cont, body) => core.suspend(() => {\n  if (restore(cont)(initial)) {\n    return core.flatMap(restore(body)(initial), z2 => iterate(z2, restore(cont), restore(body)));\n  }\n  return core.succeed(initial);\n}).traced(trace));\n/* @internal */\nexports.iterate = iterate;\nconst left = /*#__PURE__*/Debug.methodWithTrace(trace => self => core.matchEffect(self, e => core.fail(Either.left(e)), either => {\n  switch (either._tag) {\n    case \"Left\":\n      {\n        return core.succeed(either.left);\n      }\n    case \"Right\":\n      {\n        return core.fail(Either.right(either.right));\n      }\n  }\n}).traced(trace));\n/* @internal */\nexports.left = left;\nconst leftWith = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => core.suspend(() => unleft(restore(f)(left(self)))).traced(trace));\n/** @internal */\nexports.leftWith = leftWith;\nconst someFatal = /*#__PURE__*/Option.some(LogLevel.Fatal);\n/** @internal */\nconst someError = /*#__PURE__*/Option.some(LogLevel.Error);\n/** @internal */\nconst someWarning = /*#__PURE__*/Option.some(LogLevel.Warning);\n/** @internal */\nconst someTrace = /*#__PURE__*/Option.some(LogLevel.Trace);\n/** @internal */\nconst someInfo = /*#__PURE__*/Option.some(LogLevel.Info);\n/** @internal */\nconst someDebug = /*#__PURE__*/Option.some(LogLevel.Debug);\n/* @internal */\nconst log = /*#__PURE__*/Debug.methodWithTrace(trace => message => core.withFiberRuntime(fiberState => {\n  fiberState.log(message, internalCause.empty, Option.none());\n  return core.unit();\n}).traced(trace));\n/* @internal */\nexports.log = log;\nconst logDebug = /*#__PURE__*/Debug.methodWithTrace(trace => message => core.withFiberRuntime(fiberState => {\n  fiberState.log(message, internalCause.empty, someDebug);\n  return core.unit();\n}).traced(trace));\n/* @internal */\nexports.logDebug = logDebug;\nconst logDebugCause = /*#__PURE__*/Debug.methodWithTrace(trace => cause => core.withFiberRuntime(fiberState => {\n  fiberState.log(\"\", cause, someDebug);\n  return core.unit();\n}).traced(trace));\n/* @internal */\nexports.logDebugCause = logDebugCause;\nconst logDebugCauseMessage = /*#__PURE__*/Debug.methodWithTrace(trace => (message, cause) => core.withFiberRuntime(fiberState => {\n  fiberState.log(message, cause, someDebug);\n  return core.unit();\n}).traced(trace));\n/* @internal */\nexports.logDebugCauseMessage = logDebugCauseMessage;\nconst logError = /*#__PURE__*/Debug.methodWithTrace(trace => message => core.withFiberRuntime(fiberState => {\n  fiberState.log(message, internalCause.empty, someError);\n  return core.unit();\n}).traced(trace));\n/* @internal */\nexports.logError = logError;\nconst logErrorCause = /*#__PURE__*/Debug.methodWithTrace(trace => cause => core.withFiberRuntime(fiberState => {\n  fiberState.log(\"\", cause, someError);\n  return core.unit();\n}).traced(trace));\n/* @internal */\nexports.logErrorCause = logErrorCause;\nconst logErrorCauseMessage = /*#__PURE__*/Debug.methodWithTrace(trace => (message, cause) => core.withFiberRuntime(fiberState => {\n  fiberState.log(message, cause, someError);\n  return core.unit();\n}).traced(trace));\n/* @internal */\nexports.logErrorCauseMessage = logErrorCauseMessage;\nconst logFatal = /*#__PURE__*/Debug.methodWithTrace(trace => message => core.withFiberRuntime(fiberState => {\n  fiberState.log(message, internalCause.empty, someFatal);\n  return core.unit();\n}).traced(trace));\n/* @internal */\nexports.logFatal = logFatal;\nconst logFatalCause = /*#__PURE__*/Debug.methodWithTrace(trace => cause => core.withFiberRuntime(fiberState => {\n  fiberState.log(\"\", cause, someFatal);\n  return core.unit();\n}).traced(trace));\n/* @internal */\nexports.logFatalCause = logFatalCause;\nconst logFatalCauseMessage = /*#__PURE__*/Debug.methodWithTrace(trace => (message, cause) => core.withFiberRuntime(fiberState => {\n  fiberState.log(message, cause, someFatal);\n  return core.unit();\n}).traced(trace));\n/* @internal */\nexports.logFatalCauseMessage = logFatalCauseMessage;\nconst logInfo = /*#__PURE__*/Debug.methodWithTrace(trace => message => core.withFiberRuntime(fiberState => {\n  fiberState.log(message, internalCause.empty, someInfo);\n  return core.unit();\n}).traced(trace));\n/* @internal */\nexports.logInfo = logInfo;\nconst logInfoCause = /*#__PURE__*/Debug.methodWithTrace(trace => cause => core.withFiberRuntime(fiberState => {\n  fiberState.log(\"\", cause, someInfo);\n  return core.unit();\n}).traced(trace));\n/* @internal */\nexports.logInfoCause = logInfoCause;\nconst logInfoCauseMessage = /*#__PURE__*/Debug.methodWithTrace(trace => (message, cause) => core.withFiberRuntime(fiberState => {\n  fiberState.log(message, cause, someInfo);\n  return core.unit();\n}).traced(trace));\n/* @internal */\nexports.logInfoCauseMessage = logInfoCauseMessage;\nconst logWarning = /*#__PURE__*/Debug.methodWithTrace(trace => message => core.withFiberRuntime(fiberState => {\n  fiberState.log(message, internalCause.empty, someWarning);\n  return core.unit();\n}).traced(trace));\n/* @internal */\nexports.logWarning = logWarning;\nconst logWarningCause = /*#__PURE__*/Debug.methodWithTrace(trace => cause => core.withFiberRuntime(fiberState => {\n  fiberState.log(\"\", cause, someWarning);\n  return core.unit();\n}).traced(trace));\n/* @internal */\nexports.logWarningCause = logWarningCause;\nconst logWarningCauseMessage = /*#__PURE__*/Debug.methodWithTrace(trace => (message, cause) => core.withFiberRuntime(fiberState => {\n  fiberState.log(message, cause, someWarning);\n  return core.unit();\n}).traced(trace));\n/* @internal */\nexports.logWarningCauseMessage = logWarningCauseMessage;\nconst logTrace = /*#__PURE__*/Debug.methodWithTrace(trace => message => core.withFiberRuntime(fiberState => {\n  fiberState.log(message, internalCause.empty, someTrace);\n  return core.unit();\n}).traced(trace));\n/* @internal */\nexports.logTrace = logTrace;\nconst logTraceCause = /*#__PURE__*/Debug.methodWithTrace(trace => cause => core.withFiberRuntime(fiberState => {\n  fiberState.log(\"\", cause, someTrace);\n  return core.unit();\n}).traced(trace));\n/* @internal */\nexports.logTraceCause = logTraceCause;\nconst logTraceCauseMessage = /*#__PURE__*/Debug.methodWithTrace(trace => (message, cause) => core.withFiberRuntime(fiberState => {\n  fiberState.log(message, cause, someTrace);\n  return core.unit();\n}).traced(trace));\n/* @internal */\nexports.logTraceCauseMessage = logTraceCauseMessage;\nconst logSpan = /*#__PURE__*/Debug.dualWithTrace(2, trace => (effect, label) => core.flatMap(core.fiberRefGet(core.currentLogSpan), stack => core.flatMap(Clock.currentTimeMillis(), now => core.suspend(() => {\n  const logSpan = LogSpan.make(label, now);\n  return core.fiberRefLocally(core.currentLogSpan, Chunk.prepend(logSpan)(stack))(effect);\n}))).traced(trace));\n/* @internal */\nexports.logSpan = logSpan;\nconst logAnnotate = /*#__PURE__*/Debug.dualWithTrace(3, trace => (effect, key, value) => core.flatMap(core.fiberRefGet(core.currentLogAnnotations), annotations => core.suspend(() => core.fiberRefLocally(core.currentLogAnnotations, HashMap.set(key, value)(annotations))(effect))).traced(trace));\n/* @internal */\nexports.logAnnotate = logAnnotate;\nconst logAnnotations = /*#__PURE__*/Debug.methodWithTrace(trace => () => core.fiberRefGet(core.currentLogAnnotations).traced(trace));\n/* @internal */\nexports.logAnnotations = logAnnotations;\nconst loop = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => (initial, cont, inc, body) => loopInternal(initial, restore(cont), restore(inc), restore(body)).traced(trace));\nexports.loop = loop;\nconst loopInternal = (initial, cont, inc, body) => {\n  return core.suspend(() => {\n    return cont(initial) ? core.flatMap(body(initial), a => core.map(loopInternal(inc(initial), cont, inc, body), Chunk.prepend(a))) : core.sync(() => Chunk.empty());\n  });\n};\n/* @internal */\nconst loopDiscard = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => (initial, cont, inc, body) => core.suspend(() => restore(cont)(initial) ? core.flatMap(restore(body)(initial), () => loopDiscard(restore(inc)(initial), restore(cont), restore(inc), restore(body))) : core.unit()).traced(trace));\n/* @internal */\nexports.loopDiscard = loopDiscard;\nconst mapAccum = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (elements, zero, f) => core.suspend(() => {\n  const iterator = restore(() => elements[Symbol.iterator]())();\n  const builder = [];\n  let result = core.succeed(zero);\n  let next;\n  while (!(next = iterator.next()).done) {\n    result = core.flatMap(state => core.map(([z, b]) => {\n      builder.push(b);\n      return z;\n    })(restore(f)(state, next.value)))(result);\n  }\n  return core.map(result, z => [z, Chunk.unsafeFromArray(builder)]);\n}).traced(trace));\n/* @internal */\nexports.mapAccum = mapAccum;\nconst mapBoth = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (self, f, g) => core.matchEffect(self, e => core.failSync(() => restore(f)(e)), a => core.sync(() => restore(g)(a))).traced(trace));\n/* @internal */\nexports.mapBoth = mapBoth;\nconst mapErrorCause = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => core.matchCauseEffect(self, c => core.failCauseSync(() => restore(f)(c)), core.succeed).traced(trace));\n/* @internal */\nexports.mapErrorCause = mapErrorCause;\nconst mapTryCatch = /*#__PURE__*/Debug.dualWithTrace(3, trace => (self, f, onThrow) => core.flatMap(self, a => attemptCatch(() => f(a), onThrow)).traced(trace));\n/* @internal */\nexports.mapTryCatch = mapTryCatch;\nconst memoize = /*#__PURE__*/Debug.methodWithTrace(trace => self => core.flatMap(deferred => core.map(complete => core.zipRight(core.flatMap(([patch, a]) => core.as(a)(patchFiberRefs(patch)))(core.deferredAwait(deferred)))(complete))(once(core.intoDeferred(deferred)(diffFiberRefs(self)))))(core.deferredMake()).traced(trace));\n/* @internal */\nexports.memoize = memoize;\nconst merge = /*#__PURE__*/Debug.methodWithTrace(trace => self => core.matchEffect(e => core.succeed(e), core.succeed)(self).traced(trace));\n/* @internal */\nexports.merge = merge;\nconst mergeAll = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (elements, zero, f) => Array.from(elements).reduce((acc, a) => core.zipWith(acc, a, restore(f)), core.succeed(zero)).traced(trace));\n/* @internal */\nexports.mergeAll = mergeAll;\nconst negate = /*#__PURE__*/Debug.methodWithTrace(trace => self => core.map(b => !b)(self).traced(trace));\n/* @internal */\nexports.negate = negate;\nconst none = /*#__PURE__*/Debug.methodWithTrace(trace => self => core.matchEffect(e => core.fail(Option.some(e)), option => {\n  switch (option._tag) {\n    case \"None\":\n      {\n        return core.unit();\n      }\n    case \"Some\":\n      {\n        return core.fail(Option.none());\n      }\n  }\n})(self).traced(trace));\n/* @internal */\nexports.none = none;\nconst noneOrFail = /*#__PURE__*/Debug.methodWithTrace(trace => option => core.flip(getOrFailDiscard(option)).traced(trace));\n/* @internal */\nexports.noneOrFail = noneOrFail;\nconst noneOrFailWith = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => (option, f) => core.mapError(restore(f))(core.flip(getOrFailDiscard(option))).traced(trace));\n/* @internal */\nexports.noneOrFailWith = noneOrFailWith;\nconst once = /*#__PURE__*/Debug.methodWithTrace(trace => self => core.map(ref => core.asUnit(core.whenEffect(Ref.getAndSet(ref, false))(self)))(Ref.make(true)).traced(trace));\n/* @internal */\nexports.once = once;\nconst option = /*#__PURE__*/Debug.methodWithTrace(trace => self => core.matchEffect(() => core.succeed(Option.none()), a => core.succeed(Option.some(a)))(self).traced(trace));\n/* @internal */\nexports.option = option;\nconst orElseEither = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, that) => core.attemptOrElse(self, () => core.map(restore(that)(), Either.right), a => core.succeed(Either.left(a))).traced(trace));\n/* @internal */\nexports.orElseEither = orElseEither;\nconst orElseFail = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, evaluate) => core.orElse(self, () => core.failSync(restore(evaluate))).traced(trace));\n/* @internal */\nexports.orElseFail = orElseFail;\nconst orElseOptional = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, that) => core.catchAll(self, option => {\n  switch (option._tag) {\n    case \"None\":\n      {\n        return restore(that)();\n      }\n    case \"Some\":\n      {\n        return core.fail(Option.some(option.value));\n      }\n  }\n}).traced(trace));\n/* @internal */\nexports.orElseOptional = orElseOptional;\nconst orElseSucceed = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, evaluate) => core.orElse(self, () => core.sync(restore(evaluate))).traced(trace));\n/* @internal */\nexports.orElseSucceed = orElseSucceed;\nconst parallelErrors = /*#__PURE__*/Debug.methodWithTrace(trace => self => core.matchCauseEffect(self, cause => {\n  const errors = Chunk.fromIterable(internalCause.failures(cause));\n  return errors.length === 0 ? core.failCause(cause) : core.fail(errors);\n}, core.succeed).traced(trace));\n/* @internal */\nexports.parallelErrors = parallelErrors;\nconst partition = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (elements, f) => core.map(chunk => core.partitionMap(chunk, _Function.identity))(core.forEach(elements, a => core.either(restore(f)(a)))).traced(trace));\n/* @internal */\nexports.partition = partition;\nconst patchFiberRefs = /*#__PURE__*/Debug.methodWithTrace(trace => patch => updateFiberRefs((fiberId, fiberRefs) => fiberRefsPatch.patch(fiberId, fiberRefs)(patch)).traced(trace));\n/* @internal */\nexports.patchFiberRefs = patchFiberRefs;\nconst promise = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => evaluate => (0, _clock.dieOnSync)(core.async(resolve => {\n  restore(evaluate)().then(a => resolve(core.exitSucceed(a))).catch(e => resolve(core.exitDie(e)));\n})).traced(trace));\n/* @internal */\nexports.promise = promise;\nconst promiseInterrupt = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => evaluate => (0, _clock.dieOnSync)(core.asyncInterruptEither(resolve => {\n  const controller = new AbortController();\n  restore(evaluate)(controller.signal).then(a => resolve(core.exitSucceed(a))).catch(e => resolve(core.exitDie(e)));\n  return Either.left(core.sync(() => controller.abort()));\n})).traced(trace));\n/* @internal */\nexports.promiseInterrupt = promiseInterrupt;\nconst provideService = /*#__PURE__*/Debug.dualWithTrace(3, trace => (self, tag, service) => provideServiceEffect(self, tag, core.succeed(service)).traced(trace));\n/* @internal */\nexports.provideService = provideService;\nconst provideServiceEffect = /*#__PURE__*/Debug.dualWithTrace(3, trace => (self, tag, effect) => core.contextWithEffect(env => core.flatMap(effect, service => core.provideContext(self, Context.add(tag, service)(env)))).traced(trace));\n/* @internal */\nexports.provideServiceEffect = provideServiceEffect;\nconst random = /*#__PURE__*/Debug.methodWithTrace(trace => () => randomWith(core.succeed).traced(trace));\n/* @internal */\nexports.random = random;\nconst randomWith = Random.randomWith;\n/* @internal */\nexports.randomWith = randomWith;\nconst reduce = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (elements, zero, f) => Array.from(elements).reduce((acc, el) => core.flatMap(acc, a => restore(f)(a, el)), core.succeed(zero)).traced(trace));\n/* @internal */\nexports.reduce = reduce;\nconst reduceAll = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (elements, zero, f) => Array.from(elements).reduce((acc, a) => core.zipWith(acc, a, restore(f)), zero).traced(trace));\n/* @internal */\nexports.reduceAll = reduceAll;\nconst reduceRight = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (elements, zero, f) => Array.from(elements).reduceRight((acc, el) => core.flatMap(acc, a => restore(f)(el, a)), core.succeed(zero)).traced(trace));\n/* @internal */\nexports.reduceRight = reduceRight;\nconst reduceWhile = /*#__PURE__*/Debug.dualWithTrace(4, (trace, restore) => (elements, zero, predicate, f) => core.flatMap(core.sync(restore(() => elements[Symbol.iterator]())), iterator => reduceWhileLoop(restore, iterator, zero, restore(predicate), restore(f))).traced(trace));\nexports.reduceWhile = reduceWhile;\nconst reduceWhileLoop = (restore, iterator, state, predicate, f) => {\n  const next = restore(() => iterator.next())();\n  if (!next.done && predicate(state)) {\n    return core.flatMap(f(state, next.value), nextState => reduceWhileLoop(restore, iterator, nextState, predicate, f));\n  }\n  return core.succeed(state);\n};\n/* @internal */\nconst refineOrDie = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, pf) => refineOrDieWith(self, pf, _Function.identity).traced(trace));\n/* @internal */\nexports.refineOrDie = refineOrDie;\nconst refineOrDieWith = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (self, pf, f) => core.catchAll(self, e => {\n  const option = restore(pf)(e);\n  switch (option._tag) {\n    case \"None\":\n      {\n        return core.die(restore(f)(e));\n      }\n    case \"Some\":\n      {\n        return core.fail(option.value);\n      }\n  }\n}).traced(trace));\n/* @internal */\nexports.refineOrDieWith = refineOrDieWith;\nconst refineTagOrDie = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, k) => refineTagOrDieWith(self, k, _Function.identity).traced(trace));\n/* @internal */\nexports.refineTagOrDie = refineTagOrDie;\nconst refineTagOrDieWith = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (self, k, f) => core.catchAll(self, e => {\n  if (\"_tag\" in e && e[\"_tag\"] === k) {\n    return core.fail(e);\n  }\n  return core.die(restore(f)(e));\n}).traced(trace));\n/* @internal */\nexports.refineTagOrDieWith = refineTagOrDieWith;\nconst reject = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, pf) => rejectEffect(self, a => Option.map(core.fail)(restore(pf)(a))).traced(trace));\n/* @internal */\nexports.reject = reject;\nconst rejectEffect = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, pf) => core.flatMap(self, a => {\n  const option = restore(pf)(a);\n  switch (option._tag) {\n    case \"None\":\n      {\n        return core.succeed(a);\n      }\n    case \"Some\":\n      {\n        return core.flatMap(core.fail)(option.value);\n      }\n  }\n}).traced(trace));\n/* @internal */\nexports.rejectEffect = rejectEffect;\nconst repeatN = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, n) => core.suspend(() => repeatNLoop(self, n)).traced(trace));\n/* @internal */\nexports.repeatN = repeatN;\nconst repeatNLoop = /*#__PURE__*/Debug.methodWithTrace(trace => (self, n) => core.flatMap(self, a => n <= 0 ? core.succeed(a) : core.zipRight(core.yieldNow(), repeatNLoop(self, n - 1))).traced(trace));\n/* @internal */\nconst replicate = n => {\n  return self => {\n    return Chunk.unsafeFromArray(Array.from({\n      length: n\n    }, () => self));\n  };\n};\n/* @internal */\nexports.replicate = replicate;\nconst replicateEffect = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, n) => collectAll(replicate(n)(self)).traced(trace));\n/* @internal */\nexports.replicateEffect = replicateEffect;\nconst replicateEffectDiscard = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, n) => collectAllDiscard(replicate(n)(self)).traced(trace));\n/* @internal */\nexports.replicateEffectDiscard = replicateEffectDiscard;\nconst resurrect = /*#__PURE__*/Debug.methodWithTrace(trace => self => unrefineWith(self, Option.some, _Function.identity).traced(trace));\n/* @internal */\nexports.resurrect = resurrect;\nconst right = /*#__PURE__*/Debug.methodWithTrace(trace => self => core.matchEffect(self, e => core.fail(Either.right(e)), either => {\n  switch (either._tag) {\n    case \"Left\":\n      {\n        return core.fail(Either.left(either.left));\n      }\n    case \"Right\":\n      {\n        return core.succeed(either.right);\n      }\n  }\n}).traced(trace));\n/* @internal */\nexports.right = right;\nconst rightWith = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => core.suspend(() => unright(restore(f)(right(self)))).traced(trace));\n/* @internal */\nexports.rightWith = rightWith;\nconst sandbox = /*#__PURE__*/Debug.methodWithTrace(trace => self => core.matchCauseEffect(self, core.fail, core.succeed).traced(trace));\n/* @internal */\nexports.sandbox = sandbox;\nconst setFiberRefs = /*#__PURE__*/Debug.methodWithTrace(trace => fiberRefs => core.suspend(() => FiberRefs.setAll(fiberRefs)).traced(trace));\n/* @internal */\nexports.setFiberRefs = setFiberRefs;\nconst sleep = Clock.sleep;\n/* @internal */\nexports.sleep = sleep;\nconst someOrElse = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, orElse) => core.map(self, option => {\n  switch (option._tag) {\n    case \"None\":\n      {\n        return restore(orElse)();\n      }\n    case \"Some\":\n      {\n        return option.value;\n      }\n  }\n}).traced(trace));\n/* @internal */\nexports.someOrElse = someOrElse;\nconst someOrElseEffect = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, orElse) => core.flatMap(self, option => Option.getOrElse(() => restore(orElse)())(Option.map(core.succeed)(option))).traced(trace));\n/* @internal */\nexports.someOrElseEffect = someOrElseEffect;\nconst someOrFail = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, orFail) => core.flatMap(self, option => {\n  switch (option._tag) {\n    case \"None\":\n      {\n        return core.flatMap(core.sync(restore(orFail)), core.fail);\n      }\n    case \"Some\":\n      {\n        return core.succeed(option.value);\n      }\n  }\n}).traced(trace));\n/* @internal */\nexports.someOrFail = someOrFail;\nconst someOrFailException = /*#__PURE__*/Debug.methodWithTrace(trace => self => someOrFail(self, () => internalCause.NoSuchElementException()).traced(trace));\n/* @internal */\nexports.someOrFailException = someOrFailException;\nconst succeedLeft = /*#__PURE__*/Debug.methodWithTrace(trace => value => core.succeed(Either.left(value)).traced(trace));\n/* @internal */\nexports.succeedLeft = succeedLeft;\nconst succeedNone = /*#__PURE__*/Debug.methodWithTrace(trace => () => core.succeed(Option.none()).traced(trace));\n/* @internal */\nexports.succeedNone = succeedNone;\nconst succeedRight = /*#__PURE__*/Debug.methodWithTrace(trace => value => core.succeed(Either.right(value)).traced(trace));\n/* @internal */\nexports.succeedRight = succeedRight;\nconst succeedSome = /*#__PURE__*/Debug.methodWithTrace(trace => value => core.succeed(Option.some(value)).traced(trace));\n/* @internal */\nexports.succeedSome = succeedSome;\nconst summarized = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (self, summary, f) => core.flatMap(summary, start => core.flatMap(self, value => core.map(summary, end => [restore(f)(start, end), value]))).traced(trace));\n/* @internal */\nexports.summarized = summarized;\nconst attemptSuspend = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => evaluate => core.flatMap(attempt(restore(evaluate)), _Function.identity).traced(trace));\n/* @internal */\nexports.attemptSuspend = attemptSuspend;\nconst tagged = /*#__PURE__*/Debug.dualWithTrace(3, trace => (self, key, value) => taggedWithLabels(self, [metricLabel.make(key, value)]).traced(trace));\n/* @internal */\nexports.tagged = tagged;\nconst taggedWithLabels = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, labels) => taggedWithLabelSet(self, HashSet.fromIterable(labels)).traced(trace));\n/* @internal */\nexports.taggedWithLabels = taggedWithLabels;\nconst taggedWithLabelSet = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, labels) => core.fiberRefLocallyWith(core.currentTags, set => HashSet.union(labels)(set))(self).traced(trace));\n/* @internal */\nexports.taggedWithLabelSet = taggedWithLabelSet;\nconst takeWhile = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (elements, predicate) => core.suspend(() => {\n  const iterator = elements[Symbol.iterator]();\n  const builder = [];\n  let next;\n  let taking = core.succeed(true);\n  while ((next = iterator.next()) && !next.done) {\n    const a = next.value;\n    taking = core.flatMap(taking, taking => core.map(bool => {\n      if (bool) {\n        builder.push(a);\n      }\n      return bool;\n    })(taking ? restore(predicate)(a) : core.succeed(false)));\n  }\n  return core.map(taking, () => Chunk.unsafeFromArray(builder));\n}).traced(trace));\n/* @internal */\nexports.takeWhile = takeWhile;\nconst tapBoth = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (self, f, g) => core.matchCauseEffect(self, cause => {\n  const either = internalCause.failureOrCause(cause);\n  switch (either._tag) {\n    case \"Left\":\n      {\n        return core.zipRight(restore(f)(either.left), core.failCause(cause));\n      }\n    case \"Right\":\n      {\n        return core.failCause(cause);\n      }\n  }\n}, a => core.as(restore(g)(a), a)).traced(trace));\n/* @internal */\nexports.tapBoth = tapBoth;\nconst tapDefect = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => core.catchAllCause(self, cause => Option.match(() => core.failCause(cause), a => core.zipRight(restore(f)(a), core.failCause(cause)))(internalCause.keepDefects(cause))).traced(trace));\n/* @internal */\nexports.tapDefect = tapDefect;\nconst tapEither = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => core.matchCauseEffect(self, cause => {\n  const either = internalCause.failureOrCause(cause);\n  switch (either._tag) {\n    case \"Left\":\n      {\n        return core.zipRight(restore(f)(either), core.failCause(cause));\n      }\n    case \"Right\":\n      {\n        return core.failCause(cause);\n      }\n  }\n}, a => core.as(restore(f)(Either.right(a)), a)).traced(trace));\n/* @internal */\nexports.tapEither = tapEither;\nconst tapError = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => core.matchCauseEffect(self, cause => {\n  const either = internalCause.failureOrCause(cause);\n  switch (either._tag) {\n    case \"Left\":\n      {\n        return core.zipRight(restore(f)(either.left), core.failCause(cause));\n      }\n    case \"Right\":\n      {\n        return core.failCause(cause);\n      }\n  }\n}, core.succeed).traced(trace));\n/* @internal */\nexports.tapError = tapError;\nconst tapErrorCause = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => core.matchCauseEffect(self, cause => core.zipRight(restore(f)(cause), core.failCause(cause)), core.succeed).traced(trace));\n/* @internal */\nexports.tapErrorCause = tapErrorCause;\nconst tapSome = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, pf) => core.tap(self, a => Option.getOrElse(() => core.unit())(Option.map(core.asUnit)(restore(pf)(a)))).traced(trace));\n/* @internal */\nexports.tapSome = tapSome;\nconst timed = /*#__PURE__*/Debug.methodWithTrace(trace => self => timedWith(self, Clock.currentTimeMillis()).traced(trace));\n/* @internal */\nexports.timed = timed;\nconst timedWith = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, milliseconds) => summarized(self, milliseconds, (start, end) => Duration.millis(end - start)).traced(trace));\n/* @internal */\nexports.timedWith = timedWith;\nconst attemptCatch = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => (attempt, onThrow) => core.sync(() => {\n  try {\n    return restore(attempt)();\n  } catch (error) {\n    throw core.makeEffectError(internalCause.fail(restore(onThrow)(error)));\n  }\n}).traced(trace));\n/* @internal */\nexports.attemptCatch = attemptCatch;\nconst attemptCatchPromise = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => (evaluate, onReject) => (0, _clock.dieOnSync)(core.flatMap(attemptCatch(restore(evaluate), restore(onReject)), promise => core.async(resolve => {\n  promise.then(a => resolve(core.exitSucceed(a))).catch(e => resolve(core.exitFail(restore(onReject)(e))));\n}))).traced(trace));\n/* @internal */\nexports.attemptCatchPromise = attemptCatchPromise;\nconst attemptCatchPromiseInterrupt = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => (evaluate, onReject) => (0, _clock.dieOnSync)(core.suspend(() => {\n  const controller = new AbortController();\n  return core.flatMap(promise => core.async(resolve => {\n    promise.then(a => resolve(core.exitSucceed(a))).catch(e => resolve(core.exitFail(restore(onReject)(e))));\n  }))(attemptCatch(() => restore(evaluate)(controller.signal), restore(onReject)));\n})).traced(trace));\n/* @internal */\nexports.attemptCatchPromiseInterrupt = attemptCatchPromiseInterrupt;\nconst attemptPromise = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => evaluate => (0, _clock.dieOnSync)(core.flatMap(restore(attempt)(evaluate), promise => core.async(resolve => {\n  promise.then(a => resolve(core.exitSucceed(a))).catch(e => resolve(core.exitFail(e)));\n}))).traced(trace));\n/* @internal */\nexports.attemptPromise = attemptPromise;\nconst attemptPromiseInterrupt = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => evaluate => (0, _clock.dieOnSync)(core.flatMap(attempt(() => {\n  const controller = new AbortController();\n  return [controller, restore(evaluate)(controller.signal)];\n}), ([controller, promise]) => core.asyncInterruptEither(resolve => {\n  promise.then(a => resolve(core.exitSucceed(a))).catch(e => resolve(core.exitFail(e)));\n  return Either.left(core.sync(() => controller.abort()));\n}))).traced(trace));\n/* @internal */\nexports.attemptPromiseInterrupt = attemptPromiseInterrupt;\nconst all = /*#__PURE__*/Debug.methodWithTrace(trace => function () {\n  if (arguments.length === 1) {\n    if (core.isEffect(arguments[0])) {\n      return core.map(arguments[0], x => [x]);\n    } else if (Array.isArray(arguments[0])) {\n      return core.map(collectAll(arguments[0]), Chunk.toReadonlyArray).traced(trace);\n    } else {\n      return core.map(values => {\n        const res = {};\n        for (const [k, v] of values) {\n          ;\n          res[k] = v;\n        }\n        return res;\n      })(core.forEach(Object.entries(arguments[0]), ([_, e]) => core.map(e, a => [_, a]))).traced(trace);\n    }\n  }\n  return core.map(collectAll(arguments), Chunk.toReadonlyArray).traced(trace);\n});\n/* @internal */\nexports.all = all;\nconst uncause = /*#__PURE__*/Debug.methodWithTrace(trace => self => core.flatMap(self, cause => internalCause.isEmpty(cause) ? core.unit() : core.failCause(cause)).traced(trace));\n/* @internal */\nexports.uncause = uncause;\nconst unfold = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => (s, f) => core.map(unfoldLoop(s, restore(f), Chunk.empty()), Chunk.reverse).traced(trace));\n/* @internal */\nexports.unfold = unfold;\nconst unfoldLoop = (s, f, builder) => core.flatMap(f(s), option => {\n  if (Option.isSome(option)) {\n    return unfoldLoop(option.value[1], f, Chunk.prepend(option.value[0])(builder));\n  } else {\n    return core.succeed(builder);\n  }\n});\n/* @internal */\nconst unleft = /*#__PURE__*/Debug.methodWithTrace(trace => self => core.matchEffect(self, either => {\n  switch (either._tag) {\n    case \"Left\":\n      {\n        return core.fail(either.left);\n      }\n    case \"Right\":\n      {\n        return core.succeed(either);\n      }\n  }\n}, a => core.succeed(Either.left(a))).traced(trace));\n/* @internal */\nexports.unleft = unleft;\nconst unless = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, predicate) => core.suspend(() => restore(predicate)() ? succeedNone() : asSome(self)).traced(trace));\n/* @internal */\nexports.unless = unless;\nconst unlessEffect = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, predicate) => core.flatMap(predicate, b => b ? succeedNone() : asSome(self)).traced(trace));\n/* @internal */\nexports.unlessEffect = unlessEffect;\nconst unrefine = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, pf) => unrefineWith(self, restore(pf), _Function.identity).traced(trace));\n/* @internal */\nexports.unrefine = unrefine;\nconst unrefineWith = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (self, pf, f) => core.catchAllCause(self, cause => {\n  const option = internalCause.find(cause => internalCause.isDieType(cause) ? restore(pf)(cause.defect) : Option.none())(cause);\n  switch (option._tag) {\n    case \"None\":\n      {\n        return core.failCause(internalCause.map(restore(f))(cause));\n      }\n    case \"Some\":\n      {\n        return core.fail(option.value);\n      }\n  }\n}).traced(trace));\n/* @internal */\nexports.unrefineWith = unrefineWith;\nconst unright = /*#__PURE__*/Debug.methodWithTrace(trace => self => core.matchEffect(self, either => {\n  switch (either._tag) {\n    case \"Left\":\n      {\n        return core.succeed(Either.left(either.left));\n      }\n    case \"Right\":\n      {\n        return core.fail(either.right);\n      }\n  }\n}, a => core.succeed(Either.right(a))).traced(trace));\n/* @internal */\nexports.unright = unright;\nconst unsandbox = /*#__PURE__*/Debug.methodWithTrace(trace => self => mapErrorCause(self, internalCause.flatten).traced(trace));\n/* @internal */\nexports.unsandbox = unsandbox;\nconst updateFiberRefs = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => f => core.withFiberRuntime(state => {\n  state.setFiberRefs(restore(f)(state.id(), state.unsafeGetFiberRefs()));\n  return core.unit();\n}).traced(trace));\n/* @internal */\nexports.updateFiberRefs = updateFiberRefs;\nconst updateService = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (self, tag, f) => core.contramapContext(self, context => Context.add(tag, restore(f)(Context.unsafeGet(context, tag)))(context)).traced(trace));\n/* @internal */\nexports.updateService = updateService;\nconst validate = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, that) => validateWith(self, that, (a, b) => [a, b]).traced(trace));\n/* @internal */\nexports.validate = validate;\nconst validateAll = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (elements, f) => core.flatMap(partition(elements, restore(f)), ([es, bs]) => Chunk.isEmpty(es) ? core.succeed(bs) : core.fail(es)).traced(trace));\n/* @internal */\nexports.validateAll = validateAll;\nconst validateAllDiscard = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (elements, f) => core.flatMap(partition(elements, restore(f)), ([es, _]) => Chunk.isEmpty(es) ? core.unit() : core.fail(es)).traced(trace));\n/* @internal */\nexports.validateAllDiscard = validateAllDiscard;\nconst validateFirst = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (elements, f) => core.flip(core.forEach(elements, a => core.flip(restore(f)(a)))).traced(trace));\n/* @internal */\nexports.validateFirst = validateFirst;\nconst validateWith = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (self, that, f) => core.flatten(core.zipWith(core.exit(self), core.exit(that), (ea, eb) => core.exitZipWith(eb, restore(f), (ca, cb) => internalCause.sequential(ca, cb))(ea))).traced(trace));\n/* @internal */\nexports.validateWith = validateWith;\nconst when = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, predicate) => core.suspend(() => restore(predicate)() ? core.map(self, Option.some) : core.succeed(Option.none())).traced(trace));\n/* @internal */\nexports.when = when;\nconst whenCase = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => (evaluate, pf) => core.flatMap(core.sync(restore(evaluate)), a => Option.getOrElse(() => succeedNone())(Option.map(asSome)(restore(pf)(a)))).traced(trace));\n/* @internal */\nexports.whenCase = whenCase;\nconst whenCaseEffect = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, pf) => core.flatMap(self, a => whenCase(() => a, restore(pf))).traced(trace));\n/* @internal */\nexports.whenCaseEffect = whenCaseEffect;\nconst whenFiberRef = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (self, fiberRef, predicate) => core.flatMap(core.fiberRefGet(fiberRef), s => restore(predicate)(s) ? core.map(self, a => [s, Option.some(a)]) : core.succeed([s, Option.none()])).traced(trace));\n/* @internal */\nexports.whenFiberRef = whenFiberRef;\nconst whenRef = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (self, ref, predicate) => core.flatMap(Ref.get(ref), s => restore(predicate)(s) ? core.map(self, a => [s, Option.some(a)]) : core.succeed([s, Option.none()])).traced(trace));\n/* @internal */\nexports.whenRef = whenRef;\nconst withMetric = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, metric) => metric(self).traced(trace));\nexports.withMetric = withMetric;\n//# sourceMappingURL=effect.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.zipWithPar = exports.zipWithFiber = exports.zipRightFiber = exports.zipParRight = exports.zipParLeft = exports.zipPar = exports.zipLeftFiber = exports.zipFiber = exports.validateWithPar = exports.validatePar = exports.updateSomeAndGetEffectSynchronized = exports.unsafeMakeSynchronized = exports.unsafeMakeSemaphore = exports.timeoutTo = exports.timeoutFailCause = exports.timeoutFail = exports.timeout = exports.synchronizedVariance = exports.supervised = exports.scheduleForked = exports.raceWith = exports.raceFirst = exports.raceFibersWith = exports.raceEither = exports.raceAwait = exports.race = exports.memoizeFunction = exports.makeSynchronized = exports.makeSemaphore = exports.fromFiberEffect = exports.fromFiber = exports.forkScoped = exports.forkIn = exports.forkAll = exports.ensuringChildren = exports.ensuringChild = exports.ensuring = exports.disconnect = exports.cachedInvalidate = exports.cached = exports.awaitAllChildren = exports.acquireReleaseInterruptible = exports.SynchronizedTypeId = void 0;\nvar Either = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Either\"));\nvar Equal = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Equal\"));\nvar Hash = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Hash\"));\nvar MutableHashMap = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/MutableHashMap\"));\nvar MutableRef = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/MutableRef\"));\nvar Option = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Option\"));\nvar Debug = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Debug\"));\nvar ExecutionStrategy = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/ExecutionStrategy\"));\nvar Exit = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Exit\"));\nvar FiberId = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Fiber/Id\"));\nvar internalCause = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/cause\"));\nvar core = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/core\"));\nvar effect = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/effect\"));\nvar internalFiber = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/fiber\"));\nvar fiberRuntime = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/fiberRuntime\"));\nvar OpCodes = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/opCodes/effect\"));\nvar internalRef = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/ref\"));\nvar _schedule = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/schedule\"));\nvar supervisor = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/supervisor\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\nvar _a, _b, _c;\n/** @internal */\nclass Semaphore {\n  constructor(permits) {\n    this.permits = permits;\n    this.waiters = new Array();\n    this.taken = 0;\n    this.take = n => Debug.bodyWithTrace(trace => core.asyncInterruptEither(resume => {\n      if (this.free < n) {\n        const observer = () => {\n          if (this.free >= n) {\n            const observerIndex = this.waiters.findIndex(cb => cb === observer);\n            if (observerIndex !== -1) {\n              this.waiters.splice(observerIndex, 1);\n            }\n            this.taken += n;\n            resume(core.succeed(n));\n          }\n        };\n        this.waiters.push(observer);\n        return Either.left(core.sync(() => {\n          const observerIndex = this.waiters.findIndex(cb => cb === observer);\n          if (observerIndex !== -1) {\n            this.waiters.splice(observerIndex, 1);\n          }\n        }));\n      }\n      this.taken += n;\n      return Either.right(core.succeed(n));\n    }).traced(trace));\n    this.release = n => Debug.bodyWithTrace(trace => core.withFiberRuntime(fiber => {\n      this.taken -= n;\n      fiber.getFiberRef(core.currentScheduler).scheduleTask(() => {\n        this.waiters.forEach(wake => wake());\n      });\n      return core.unit();\n    }).traced(trace));\n    this.withPermits = n => Debug.bodyWithTrace(trace => self => Debug.untraced(() => core.uninterruptibleMask(restore => core.flatMap(restore(this.take(n)), permits => ensuring(restore(self), this.release(permits))))).traced(trace));\n  }\n  get free() {\n    return this.permits - this.taken;\n  }\n}\n/** @internal */\nconst unsafeMakeSemaphore = leases => {\n  return new Semaphore(leases);\n};\n/** @internal */\nexports.unsafeMakeSemaphore = unsafeMakeSemaphore;\nconst makeSemaphore = /*#__PURE__*/Debug.methodWithTrace(trace => permits => core.sync(() => unsafeMakeSemaphore(permits)).traced(trace));\n/** @internal */\nexports.makeSemaphore = makeSemaphore;\nconst acquireReleaseInterruptible = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => (acquire, release) => ensuring(acquire, fiberRuntime.addFinalizer(restore(release))).traced(trace));\n/** @internal */\nexports.acquireReleaseInterruptible = acquireReleaseInterruptible;\nconst awaitAllChildren = /*#__PURE__*/Debug.methodWithTrace(trace => self => ensuringChildren(self, fiberRuntime.fiberAwaitAll).traced(trace));\n/** @internal */\nexports.awaitAllChildren = awaitAllChildren;\nconst cached = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, timeToLive) => core.map(cachedInvalidate(self, timeToLive), tuple => tuple[0]).traced(trace));\n/** @internal */\nexports.cached = cached;\nconst cachedInvalidate = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, timeToLive) => core.flatMap(core.context(), env => core.map(makeSynchronized(Option.none()), cache => [core.provideContext(getCachedValue(self, timeToLive, cache), env), invalidateCache(cache)])).traced(trace));\n/** @internal */\nexports.cachedInvalidate = cachedInvalidate;\nconst computeCachedValue = (self, timeToLive, start) => core.map(deferred => Option.some([start + timeToLive.millis, deferred]))(core.tap(deferred => core.intoDeferred(self, deferred))(core.deferredMake()));\n/** @internal */\nconst getCachedValue = (self, timeToLive, cache) => core.uninterruptibleMask(restore => core.flatMap(option => Option.isNone(option) ? effect.dieMessage(\"BUG: Effect.cachedInvalidate - please report an issue at https://github.com/Effect-TS/io/issues\") : restore(core.deferredAwait(option.value[1])))(core.flatMap(time => updateSomeAndGetEffectSynchronized(cache, option => {\n  switch (option._tag) {\n    case \"None\":\n      {\n        return Option.some(computeCachedValue(self, timeToLive, time));\n      }\n    case \"Some\":\n      {\n        const [end] = option.value;\n        return end - time <= 0 ? Option.some(computeCachedValue(self, timeToLive, time)) : Option.none();\n      }\n  }\n}))(effect.clockWith(clock => clock.currentTimeMillis()))));\n/** @internal */\nconst invalidateCache = cache => internalRef.set(cache, Option.none());\n/** @internal */\nconst disconnect = /*#__PURE__*/Debug.methodWithTrace(trace => self => core.uninterruptibleMask(restore => core.fiberIdWith(fiberId => core.flatMap(fiberRuntime.forkDaemon(restore(self)), fiber => core.onInterrupt(() => internalFiber.interruptAsFork(fiberId)(fiber))(restore(internalFiber.join(fiber)))))).traced(trace));\n/** @internal */\nexports.disconnect = disconnect;\nconst ensuring = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, finalizer) => core.uninterruptibleMask(restore => core.matchCauseEffect(restore(self), cause1 => core.matchCauseEffect(finalizer, cause2 => core.failCause(internalCause.sequential(cause1, cause2)), () => core.failCause(cause1)), a => core.as(finalizer, a))).traced(trace));\n/** @internal */\nexports.ensuring = ensuring;\nconst ensuringChild = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => ensuringChildren(self, children => restore(f)(fiberRuntime.fiberCollectAll(children))).traced(trace));\n/** @internal */\nexports.ensuringChild = ensuringChild;\nconst ensuringChildren = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, children) => core.flatMap(supervisor.track(), supervisor => ensuring(core.flatMap(supervisor.value(), restore(children)))(supervised(supervisor)(self))).traced(trace));\n/** @internal */\nexports.ensuringChildren = ensuringChildren;\nconst forkAll = /*#__PURE__*/Debug.methodWithTrace(trace => effects => core.map(core.forEach(effects, fiberRuntime.fork), fiberRuntime.fiberCollectAll).traced(trace));\n/** @internal */\nexports.forkAll = forkAll;\nconst forkIn = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, scope) => core.uninterruptibleMask(restore => core.flatMap(scope.fork(ExecutionStrategy.sequential), child => core.tap(fiber => child.addFinalizer(() => core.fiberIdWith(fiberId => Equal.equals(fiberId, fiber.id()) ? core.unit() : core.asUnit(core.interruptFiber(fiber)))))(fiberRuntime.forkDaemon(core.onExit(exit => child.close(exit))(restore(self)))))).traced(trace));\n/** @internal */\nexports.forkIn = forkIn;\nconst forkScoped = /*#__PURE__*/Debug.methodWithTrace(trace => self => fiberRuntime.scopeWith(scope => forkIn(self, scope)).traced(trace));\n/** @internal */\nexports.forkScoped = forkScoped;\nconst fromFiber = /*#__PURE__*/Debug.methodWithTrace(trace => fiber => internalFiber.join(fiber).traced(trace));\n/** @internal */\nexports.fromFiber = fromFiber;\nconst fromFiberEffect = /*#__PURE__*/Debug.methodWithTrace(trace => fiber => core.suspend(() => core.flatMap(fiber, internalFiber.join)).traced(trace));\nexports.fromFiberEffect = fromFiberEffect;\nconst memoKeySymbol = /*#__PURE__*/Symbol.for(\"@effect/io/Effect/memoizeFunction.key\");\nclass Key {\n  constructor(a, eq) {\n    this.a = a;\n    this.eq = eq;\n    this[_a] = memoKeySymbol;\n  }\n  [(_a = memoKeySymbol, Equal.symbol)](that) {\n    if (typeof that === \"object\" && that !== null && memoKeySymbol in that) {\n      if (this.eq) {\n        return this.eq(this.a, that.a);\n      } else {\n        return Equal.equals(this.a, that.a);\n      }\n    }\n    return false;\n  }\n  [Hash.symbol]() {\n    return this.eq ? 0 : Hash.hash(this.a);\n  }\n}\n/** @internal */\nconst memoizeFunction = /*#__PURE__*/Debug.methodWithTrace(trace => (f, eq) => {\n  return core.map(ref => a => core.flatMap(([patch, b]) => core.as(b)(effect.patchFiberRefs(patch)))(core.flatMap(core.deferredAwait)(ref.modifyEffect(map => {\n    const result = MutableHashMap.get(new Key(a, eq))(map);\n    if (Option.isNone(result)) {\n      return core.map(deferred => [deferred, MutableHashMap.set(new Key(a, eq), deferred)(map)])(core.tap(deferred => fiberRuntime.fork(core.intoDeferred(deferred)(effect.diffFiberRefs(f(a)))))(core.deferredMake()));\n    }\n    return core.succeed([result.value, map]);\n  }))))(core.flatMap(makeSynchronized)(core.sync(() => MutableHashMap.empty()))).traced(trace);\n});\n/** @internal */\nexports.memoizeFunction = memoizeFunction;\nconst race = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, that) => core.checkInterruptible(isInterruptible => raceAwait(raceDisconnect(that, isInterruptible))(raceDisconnect(self, isInterruptible))).traced(trace));\n/** @internal */\nexports.race = race;\nconst raceDisconnect = (self, isInterruptible) => isInterruptible ? disconnect(self) : core.interruptible(disconnect(core.uninterruptible(self)));\n/** @internal */\nconst raceAwait = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, that) => core.fiberIdWith(parentFiberId => raceWith(that, (exit, right) => core.exitMatchEffect(cause => effect.mapErrorCause(cause2 => internalCause.parallel(cause, cause2))(internalFiber.join(right)), value => core.as(value)(core.interruptAsFiber(parentFiberId)(right)))(exit), (exit, left) => core.exitMatchEffect(cause => effect.mapErrorCause(cause2 => internalCause.parallel(cause2, cause))(internalFiber.join(left)), value => core.as(value)(core.interruptAsFiber(parentFiberId)(left)))(exit))(self)).traced(trace));\n/** @internal */\nexports.raceAwait = raceAwait;\nconst raceEither = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, that) => race(core.map(self, Either.left), core.map(that, Either.right)).traced(trace));\n/** @internal */\nexports.raceEither = raceEither;\nconst raceFirst = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, that) => (effect => core.flatten(effect))(race(core.exit(that))(core.exit(self))).traced(trace));\n/** @internal */\nexports.raceFirst = raceFirst;\nconst raceFibersWith = /*#__PURE__*/Debug.dualWithTrace(4, (trace, restore) => (self, that, selfWins, thatWins) => core.withFiberRuntime((parentFiber, parentStatus) => {\n  const parentRuntimeFlags = parentStatus.runtimeFlags;\n  const raceIndicator = MutableRef.make(true);\n  const leftFiber = fiberRuntime.unsafeMakeChildFiber(self, parentFiber, parentRuntimeFlags);\n  const rightFiber = fiberRuntime.unsafeMakeChildFiber(that, parentFiber, parentRuntimeFlags);\n  leftFiber.startFork(self);\n  rightFiber.startFork(that);\n  leftFiber.setFiberRef(core.forkScopeOverride, Option.some(parentFiber.scope()));\n  rightFiber.setFiberRef(core.forkScopeOverride, Option.some(parentFiber.scope()));\n  return core.async(cb => {\n    leftFiber.unsafeAddObserver(() => completeRace(leftFiber, rightFiber, restore(selfWins), raceIndicator, cb));\n    rightFiber.unsafeAddObserver(() => completeRace(rightFiber, leftFiber, restore(thatWins), raceIndicator, cb));\n  }, FiberId.combine(rightFiber.id())(leftFiber.id()));\n}).traced(trace));\n/** @internal */\nexports.raceFibersWith = raceFibersWith;\nconst completeRace = (winner, loser, cont, ab, cb) => {\n  if (MutableRef.compareAndSet(true, false)(ab)) {\n    cb(cont(winner, loser));\n  }\n};\n/** @internal */\nconst raceWith = /*#__PURE__*/Debug.dualWithTrace(4, (trace, restore) => (self, that, leftDone, rightDone) => raceFibersWith(self, that, (winner, loser) => core.flatMap(winner.await(), exit => {\n  switch (exit._tag) {\n    case OpCodes.OP_SUCCESS:\n      {\n        return core.flatMap(winner.inheritAll(), () => restore(leftDone)(exit, loser));\n      }\n    case OpCodes.OP_FAILURE:\n      {\n        return restore(leftDone)(exit, loser);\n      }\n  }\n}), (winner, loser) => core.flatMap(winner.await(), exit => {\n  switch (exit._tag) {\n    case OpCodes.OP_SUCCESS:\n      {\n        return core.flatMap(winner.inheritAll(), () => restore(rightDone)(exit, loser));\n      }\n    case OpCodes.OP_FAILURE:\n      {\n        return restore(rightDone)(exit, loser);\n      }\n  }\n})).traced(trace));\n/** @internal */\nexports.raceWith = raceWith;\nconst scheduleForked = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, schedule) => forkScoped(_schedule.schedule_Effect(schedule)(self)).traced(trace));\n/** @internal */\nexports.scheduleForked = scheduleForked;\nconst supervised = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, supervisor) => {\n  const supervise = core.fiberRefLocallyWith(fiberRuntime.currentSupervisor, s => s.zip(supervisor));\n  return supervise(self).traced(trace);\n});\n/** @internal */\nexports.supervised = supervised;\nconst timeout = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, duration) => timeoutTo(self, Option.none(), Option.some, duration).traced(trace));\n/** @internal */\nexports.timeout = timeout;\nconst timeoutFail = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (self, evaluate, duration) => core.flatten(timeoutTo(self, core.failSync(restore(evaluate)), core.succeed, duration)).traced(trace));\n/** @internal */\nexports.timeoutFail = timeoutFail;\nconst timeoutFailCause = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (self, evaluate, duration) => core.flatten(timeoutTo(self, core.failCauseSync(restore(evaluate)), core.succeed, duration)).traced(trace));\n/** @internal */\nexports.timeoutFailCause = timeoutFailCause;\nconst timeoutTo = /*#__PURE__*/Debug.dualWithTrace(4, (trace, restore) => (self, def, f, duration) => raceFirst(core.map(self, restore(f)), core.interruptible(core.as(def)(effect.sleep(duration)))).traced(trace));\n/** @internal */\nexports.timeoutTo = timeoutTo;\nconst validatePar = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, that) => validateWithPar(self, that, (a, b) => [a, b]).traced(trace));\n/** @internal */\nexports.validatePar = validatePar;\nconst validateWithPar = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (self, that, f) => core.flatten(zipWithPar(core.exit(self), core.exit(that), (ea, eb) => core.exitZipWith(eb, restore(f), (ca, cb) => internalCause.parallel(ca, cb))(ea))).traced(trace));\n/** @internal */\nexports.validateWithPar = validateWithPar;\nconst zipPar = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, that) => zipWithPar(self, that, (a, b) => [a, b]).traced(trace));\n/** @internal */\nexports.zipPar = zipPar;\nconst zipParLeft = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, that) => zipWithPar(self, that, (a, _) => a).traced(trace));\n/** @internal */\nexports.zipParLeft = zipParLeft;\nconst zipParRight = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, that) => zipWithPar(self, that, (_, b) => b).traced(trace));\n/** @internal */\nexports.zipParRight = zipParRight;\nconst zipWithPar = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restoreTrace) => (self, that, f) => core.uninterruptibleMask(restore => core.transplant(graft => {\n  const deferred = core.deferredUnsafeMake(FiberId.none);\n  const ref = MutableRef.make(false);\n  return core.flatMap(([left, right]) => core.matchCauseEffect(cause => core.zipRight(core.flatMap(([left, right]) => core.exitMatch(causes => core.failCause(internalCause.parallel(internalCause.stripFailures(cause), causes)), () => core.failCause(internalCause.stripFailures(cause)))(core.exitZipWith(right, f, internalCause.parallel)(left)))(core.zip(internalFiber._await(right))(internalFiber._await(left))))(core.zipRight(fiberRuntime.fiberInterruptFork(right))(fiberRuntime.fiberInterruptFork(left))), () => core.zipWith(internalFiber.join(left), internalFiber.join(right), restoreTrace(f)))(restore(core.deferredAwait(deferred))))(core.zip(forkZipWithPar(that, graft, restore, deferred, ref))(forkZipWithPar(self, graft, restore, deferred, ref)));\n})).traced(trace));\n/** @internal */\nexports.zipWithPar = zipWithPar;\nconst forkZipWithPar = (self, graft, restore, deferred, ref) => fiberRuntime.forkDaemon(core.matchCauseEffect(graft(restore(self)), cause => core.zipRight(core.deferredFail(deferred, void 0), core.failCause(cause)), value => {\n  const flag = MutableRef.get(ref);\n  if (flag) {\n    core.deferredUnsafeDone(deferred, core.unit());\n    return core.succeed(value);\n  }\n  MutableRef.set(true)(ref);\n  return core.succeed(value);\n}));\n// circular with Synchronized\n/** @internal */\nconst SynchronizedSymbolKey = \"@effect/io/Ref/Synchronized\";\n/** @internal */\nconst SynchronizedTypeId = /*#__PURE__*/Symbol.for(SynchronizedSymbolKey);\n/** @internal */\nexports.SynchronizedTypeId = SynchronizedTypeId;\nconst synchronizedVariance = {\n  _A: _ => _\n};\n/** @internal */\nexports.synchronizedVariance = synchronizedVariance;\nclass SynchronizedImpl {\n  constructor(ref, withLock) {\n    this.ref = ref;\n    this.withLock = withLock;\n    this[_b] = synchronizedVariance;\n    this[_c] = internalRef.refVariance;\n  }\n  modify(f) {\n    return Debug.bodyWithTrace((trace, restore) => this.modifyEffect(a => core.succeed(restore(f)(a))).traced(trace));\n  }\n  modifyEffect(f) {\n    return Debug.bodyWithTrace((trace, restore) => this.withLock(core.flatMap(([b, a]) => core.as(internalRef.set(this.ref, a), b))(core.flatMap(internalRef.get(this.ref), restore(f)))).traced(trace));\n  }\n}\n_b = SynchronizedTypeId, _c = internalRef.RefTypeId;\n/** @internal */\nconst makeSynchronized = /*#__PURE__*/Debug.methodWithTrace(trace => value => core.sync(() => unsafeMakeSynchronized(value)).traced(trace));\n/** @internal */\nexports.makeSynchronized = makeSynchronized;\nconst unsafeMakeSynchronized = value => {\n  const ref = internalRef.unsafeMake(value);\n  const sem = unsafeMakeSemaphore(1);\n  return new SynchronizedImpl(ref, sem.withPermits(1));\n};\n/** @internal */\nexports.unsafeMakeSynchronized = unsafeMakeSynchronized;\nconst updateSomeAndGetEffectSynchronized = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, pf) => self.modifyEffect(value => {\n  const result = restore(pf)(value);\n  switch (result._tag) {\n    case \"None\":\n      {\n        return core.succeed([value, value]);\n      }\n    case \"Some\":\n      {\n        return core.map(result.value, a => [a, a]);\n      }\n  }\n}).traced(trace));\n// circular with Fiber\n/** @internal */\nexports.updateSomeAndGetEffectSynchronized = updateSomeAndGetEffectSynchronized;\nconst zipFiber = /*#__PURE__*/Debug.untracedDual(2, () => (self, that) => zipWithFiber(self, that, (a, b) => [a, b]));\n/** @internal */\nexports.zipFiber = zipFiber;\nconst zipLeftFiber = /*#__PURE__*/Debug.untracedDual(2, () => (self, that) => zipWithFiber(self, that, (a, _) => a));\n/** @internal */\nexports.zipLeftFiber = zipLeftFiber;\nconst zipRightFiber = /*#__PURE__*/Debug.untracedDual(2, () => (self, that) => zipWithFiber(self, that, (_, b) => b));\n/** @internal */\nexports.zipRightFiber = zipRightFiber;\nconst zipWithFiber = /*#__PURE__*/Debug.untracedDual(3, restore => (self, that, f) => ({\n  [internalFiber.FiberTypeId]: internalFiber.fiberVariance,\n  id: () => FiberId.getOrElse(that.id())(self.id()),\n  await: Debug.methodWithTrace(trace => () => core.exit(zipWithPar(core.flatten(that.await()), restore(f))(core.flatten(self.await()))).traced(trace)),\n  children: Debug.methodWithTrace(trace => () => self.children().traced(trace)),\n  inheritAll: Debug.methodWithTrace(trace => () => core.zipRight(that.inheritAll(), self.inheritAll()).traced(trace)),\n  poll: Debug.methodWithTrace(trace => () => core.zipWith(self.poll(), that.poll(), (optionA, optionB) => Option.flatMap(exitA => Option.map(exitB => Exit.zipWith(exitB, restore(f), internalCause.parallel)(exitA))(optionB))(optionA)).traced(trace)),\n  interruptAsFork: Debug.methodWithTrace(trace => id => core.zipRight(self.interruptAsFork(id), that.interruptAsFork(id)).traced(trace))\n}));\nexports.zipWithFiber = zipWithFiber;\n//# sourceMappingURL=circular.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.sequential = exports.parallelN = exports.parallel = exports.match = exports.isSequential = exports.isParallelN = exports.isParallel = exports.OP_SEQUENTIAL = exports.OP_PARALLEL_N = exports.OP_PARALLEL = void 0;\nvar _Function = /*#__PURE__*/require(\"@effect/data/Function\");\n/** @internal */\nconst OP_SEQUENTIAL = \"Sequential\";\n/** @internal */\nexports.OP_SEQUENTIAL = OP_SEQUENTIAL;\nconst OP_PARALLEL = \"Parallel\";\n/** @internal */\nexports.OP_PARALLEL = OP_PARALLEL;\nconst OP_PARALLEL_N = \"ParallelN\";\n/** @internal */\nexports.OP_PARALLEL_N = OP_PARALLEL_N;\nconst sequential = {\n  _tag: OP_SEQUENTIAL\n};\n/** @internal */\nexports.sequential = sequential;\nconst parallel = {\n  _tag: OP_PARALLEL\n};\n/** @internal */\nexports.parallel = parallel;\nconst parallelN = parallelism => {\n  return {\n    _tag: OP_PARALLEL_N,\n    parallelism\n  };\n};\n/** @internal */\nexports.parallelN = parallelN;\nconst isSequential = self => {\n  return self._tag === OP_SEQUENTIAL;\n};\n/** @internal */\nexports.isSequential = isSequential;\nconst isParallel = self => {\n  return self._tag === OP_PARALLEL;\n};\n/** @internal */\nexports.isParallel = isParallel;\nconst isParallelN = self => {\n  return self._tag === OP_PARALLEL_N;\n};\n/** @internal */\nexports.isParallelN = isParallelN;\nconst match = /*#__PURE__*/(0, _Function.dual)(4, (self, onSequential, onParallel, onParallelN) => {\n  switch (self._tag) {\n    case OP_SEQUENTIAL:\n      {\n        return onSequential();\n      }\n    case OP_PARALLEL:\n      {\n        return onParallel();\n      }\n    case OP_PARALLEL_N:\n      {\n        return onParallelN(self.parallelism);\n      }\n  }\n});\nexports.match = match;\n//# sourceMappingURL=executionStrategy.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.unsafeRoots = exports.unit = exports.succeed = exports.status = exports.roots = exports.pretty = exports.poll = exports.orElseEither = exports.orElse = exports.never = exports.match = exports.mapFiber = exports.mapEffect = exports.map = exports.join = exports.isRuntimeFiber = exports.isFiber = exports.interrupted = exports.interruptAsFork = exports.interruptAllAs = exports.interruptAll = exports.inheritAll = exports.id = exports.getCurrentFiber = exports.fromEffect = exports.fiberVariance = exports.failCause = exports.fail = exports.dumpAll = exports.dump = exports.done = exports.currentFiberURI = exports.children = exports._await = exports.RuntimeFiberTypeId = exports.Order = exports.FiberTypeId = void 0;\nvar Chunk = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Chunk\"));\nvar Either = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Either\"));\nvar _Function = /*#__PURE__*/require(\"@effect/data/Function\");\nvar HashSet = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/HashSet\"));\nvar number = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Number\"));\nvar Option = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Option\"));\nvar order = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/typeclass/Order\"));\nvar Clock = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Clock\"));\nvar Debug = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Debug\"));\nvar Exit = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Exit\"));\nvar FiberId = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Fiber/Id\"));\nvar FiberStatus = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Fiber/Status\"));\nvar core = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/core\"));\nvar fiberScope = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/fiberScope\"));\nvar runtimeFlags = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/runtimeFlags\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/** @internal */\nconst FiberSymbolKey = \"@effect/io/Fiber\";\n/** @internal */\nconst FiberTypeId = /*#__PURE__*/Symbol.for(FiberSymbolKey);\n/** @internal */\nexports.FiberTypeId = FiberTypeId;\nconst fiberVariance = {\n  _E: _ => _,\n  _A: _ => _\n};\n/** @internal */\nexports.fiberVariance = fiberVariance;\nconst RuntimeFiberSymbolKey = \"@effect/io/Fiber\";\n/** @internal */\nconst RuntimeFiberTypeId = /*#__PURE__*/Symbol.for(RuntimeFiberSymbolKey);\n/** @internal */\nexports.RuntimeFiberTypeId = RuntimeFiberTypeId;\nconst Order = /*#__PURE__*/order.contramap(fiber => [fiber.id().startTimeMillis, fiber.id().id])( /*#__PURE__*/order.tuple(number.Order, number.Order));\n/** @internal */\nexports.Order = Order;\nconst isFiber = u => typeof u === \"object\" && u != null && FiberTypeId in u;\n/** @internal */\nexports.isFiber = isFiber;\nconst isRuntimeFiber = self => RuntimeFiberTypeId in self;\n/** @internal */\nexports.isRuntimeFiber = isRuntimeFiber;\nconst _await = /*#__PURE__*/Debug.methodWithTrace(trace => self => self.await().traced(trace));\n/** @internal */\nexports._await = _await;\nconst children = /*#__PURE__*/Debug.methodWithTrace(trace => self => self.children().traced(trace));\n/** @internal */\nexports.children = children;\nconst done = exit => ({\n  [FiberTypeId]: fiberVariance,\n  id: () => FiberId.none,\n  await: Debug.methodWithTrace(trace => () => core.succeed(exit).traced(trace)),\n  children: Debug.methodWithTrace(trace => () => core.succeed(Chunk.empty()).traced(trace)),\n  inheritAll: Debug.methodWithTrace(trace => () => core.unit().traced(trace)),\n  poll: Debug.methodWithTrace(trace => () => core.succeed(Option.some(exit)).traced(trace)),\n  interruptAsFork: Debug.methodWithTrace(trace => () => core.unit().traced(trace))\n});\n/** @internal */\nexports.done = done;\nconst dump = /*#__PURE__*/Debug.methodWithTrace(trace => self => core.map(self.status(), status => ({\n  id: self.id(),\n  status\n})).traced(trace));\n/** @internal */\nexports.dump = dump;\nconst dumpAll = /*#__PURE__*/Debug.methodWithTrace(trace => fibers => core.forEach(fibers, dump).traced(trace));\n/** @internal */\nexports.dumpAll = dumpAll;\nconst fail = error => {\n  return done(Exit.fail(error));\n};\n/** @internal */\nexports.fail = fail;\nconst failCause = cause => {\n  return done(Exit.failCause(cause));\n};\n/** @internal */\nexports.failCause = failCause;\nconst fromEffect = /*#__PURE__*/Debug.methodWithTrace(trace => effect => core.map(core.exit(effect), done).traced(trace));\n/** @internal */\nexports.fromEffect = fromEffect;\nconst id = self => {\n  return self.id();\n};\n/** @internal */\nexports.id = id;\nconst inheritAll = /*#__PURE__*/Debug.methodWithTrace(trace => self => self.inheritAll().traced(trace));\n/** @internal */\nexports.inheritAll = inheritAll;\nconst interrupted = fiberId => {\n  return done(Exit.interrupt(fiberId));\n};\n/** @internal */\nexports.interrupted = interrupted;\nconst interruptAll = /*#__PURE__*/Debug.methodWithTrace(trace => fibers => core.flatMap(core.fiberId(), fiberId => interruptAllAs(fiberId)(fibers)).traced(trace));\n/** @internal */\nexports.interruptAll = interruptAll;\nconst interruptAllAs = /*#__PURE__*/Debug.dualWithTrace(2, trace => (fibers, fiberId) => core.zipRight(core.forEachDiscard(_await)(fibers))(core.forEachDiscard(fibers, interruptAsFork(fiberId))).traced(trace));\n/** @internal */\nexports.interruptAllAs = interruptAllAs;\nconst interruptAsFork = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, fiberId) => self.interruptAsFork(fiberId).traced(trace));\n/** @internal */\nexports.interruptAsFork = interruptAsFork;\nconst join = /*#__PURE__*/Debug.methodWithTrace(trace => self => core.zipLeft(core.flatten(self.await()), self.inheritAll()).traced(trace));\n/** @internal */\nexports.join = join;\nconst map = /*#__PURE__*/Debug.untracedDual(2, restore => (self, f) => mapEffect(self, a => core.sync(() => restore(f)(a))));\n/** @internal */\nexports.map = map;\nconst mapEffect = /*#__PURE__*/Debug.untracedDual(2, restore => (self, f) => ({\n  [FiberTypeId]: fiberVariance,\n  id: () => self.id(),\n  await: Debug.methodWithTrace(trace => () => core.flatMap(self.await(), Exit.forEachEffect(f)).traced(trace)),\n  children: Debug.methodWithTrace(trace => () => self.children().traced(trace)),\n  inheritAll: Debug.methodWithTrace(trace => () => self.inheritAll().traced(trace)),\n  poll: Debug.methodWithTrace(trace => () => core.flatMap(self.poll(), result => {\n    switch (result._tag) {\n      case \"None\":\n        {\n          return core.succeed(Option.none());\n        }\n      case \"Some\":\n        {\n          return core.map(Option.some)(Exit.forEachEffect(result.value, restore(f)));\n        }\n    }\n  }).traced(trace)),\n  interruptAsFork: Debug.methodWithTrace(trace => id => self.interruptAsFork(id).traced(trace))\n}));\n/** @internal */\nexports.mapEffect = mapEffect;\nconst mapFiber = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => core.map(self.await(), Exit.match(cause => failCause(cause), a => restore(f)(a))).traced(trace));\n/** @internal */\nexports.mapFiber = mapFiber;\nconst match = /*#__PURE__*/Debug.untracedDual(3, restore => (self, onFiber, onRuntimeFiber) => {\n  if (isRuntimeFiber(self)) {\n    return restore(onRuntimeFiber)(self);\n  }\n  return restore(onFiber)(self);\n});\n/** @internal */\nexports.match = match;\nconst never = () => ({\n  [FiberTypeId]: fiberVariance,\n  id: () => FiberId.none,\n  await: Debug.methodWithTrace(trace => () => core.never().traced(trace)),\n  children: Debug.methodWithTrace(trace => () => core.succeed(Chunk.empty()).traced(trace)),\n  inheritAll: Debug.methodWithTrace(trace => () => core.never().traced(trace)),\n  poll: Debug.methodWithTrace(trace => () => core.succeed(Option.none()).traced(trace)),\n  interruptAsFork: Debug.methodWithTrace(trace => () => core.never().traced(trace))\n});\n/** @internal */\nexports.never = never;\nconst orElse = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => ({\n  [FiberTypeId]: fiberVariance,\n  id: () => FiberId.getOrElse(self.id(), that.id()),\n  await: Debug.methodWithTrace(trace => () => core.zipWith(self.await(), that.await(), (exit1, exit2) => Exit.isSuccess(exit1) ? exit1 : exit2).traced(trace)),\n  children: Debug.methodWithTrace(trace => () => self.children().traced(trace)),\n  inheritAll: Debug.methodWithTrace(trace => () => core.zipRight(that.inheritAll(), self.inheritAll()).traced(trace)),\n  poll: Debug.methodWithTrace(trace => () => core.zipWith(self.poll(), that.poll(), (option1, option2) => {\n    switch (option1._tag) {\n      case \"None\":\n        {\n          return Option.none();\n        }\n      case \"Some\":\n        {\n          return Exit.isSuccess(option1.value) ? option1 : option2;\n        }\n    }\n  }).traced(trace)),\n  interruptAsFork: Debug.methodWithTrace(trace => id => core.asUnit(core.zipRight(core.interruptAsFiber(id)(that))(core.interruptAsFiber(self, id))).traced(trace))\n}));\n/** @internal */\nexports.orElse = orElse;\nconst orElseEither = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => orElse(map(self, Either.left), map(that, Either.right)));\n/** @internal */\nexports.orElseEither = orElseEither;\nconst poll = /*#__PURE__*/Debug.methodWithTrace(trace => self => self.poll().traced(trace));\n// forked from https://github.com/sindresorhus/parse-ms/blob/4da2ffbdba02c6e288c08236695bdece0adca173/index.js\n// MIT License\n// Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)\n/** @internal */\nexports.poll = poll;\nconst parseMs = milliseconds => {\n  const roundTowardsZero = milliseconds > 0 ? Math.floor : Math.ceil;\n  return {\n    days: roundTowardsZero(milliseconds / 86400000),\n    hours: roundTowardsZero(milliseconds / 3600000) % 24,\n    minutes: roundTowardsZero(milliseconds / 60000) % 60,\n    seconds: roundTowardsZero(milliseconds / 1000) % 60,\n    milliseconds: roundTowardsZero(milliseconds) % 1000,\n    microseconds: roundTowardsZero(milliseconds * 1000) % 1000,\n    nanoseconds: roundTowardsZero(milliseconds * 1e6) % 1000\n  };\n};\n/** @internal */\nconst renderStatus = status => {\n  if (FiberStatus.isDone(status)) {\n    return \"Done\";\n  }\n  if (FiberStatus.isRunning(status)) {\n    return \"Running\";\n  }\n  const isInterruptible = runtimeFlags.interruptible(status.runtimeFlags) ? \"interruptible\" : \"uninterruptible\";\n  return `Suspended(${isInterruptible})`;\n};\n/** @internal */\nconst pretty = /*#__PURE__*/Debug.methodWithTrace(trace => self => core.flatMap(Clock.currentTimeMillis(), now => core.map(dump(self), dump => {\n  const time = now - dump.id.startTimeMillis;\n  const {\n    days,\n    hours,\n    milliseconds,\n    minutes,\n    seconds\n  } = parseMs(time);\n  const lifeMsg = (days === 0 ? \"\" : `${days}d`) + (days === 0 && hours === 0 ? \"\" : `${hours}h`) + (days === 0 && hours === 0 && minutes === 0 ? \"\" : `${minutes}m`) + (days === 0 && hours === 0 && minutes === 0 && seconds === 0 ? \"\" : `${seconds}s`) + `${milliseconds}ms`;\n  const waitMsg = FiberStatus.isSuspended(dump.status) ? (() => {\n    const ids = FiberId.ids(dump.status.blockingOn);\n    return HashSet.size(ids) > 0 ? `waiting on ` + Array.from(ids).map(id => `${id}`).join(\", \") : \"\";\n  })() : \"\";\n  const statusMsg = renderStatus(dump.status);\n  return `[Fiber](#${dump.id.id}) (${lifeMsg}) ${waitMsg}\\n   Status: ${statusMsg}`;\n})).traced(trace));\n/** @internal */\nexports.pretty = pretty;\nconst roots = /*#__PURE__*/Debug.methodWithTrace(trace => () => core.sync(unsafeRoots).traced(trace));\n/** @internal */\nexports.roots = roots;\nconst unsafeRoots = () => {\n  return Chunk.fromIterable(fiberScope.globalScope.roots);\n};\n/** @internal */\nexports.unsafeRoots = unsafeRoots;\nconst status = /*#__PURE__*/Debug.methodWithTrace(trace => self => self.status().traced(trace));\n/** @internal */\nexports.status = status;\nconst succeed = value => {\n  return done(Exit.succeed(value));\n};\n/** @internal */\nexports.succeed = succeed;\nconst unit = () => succeed(void 0);\n/** @internal */\nexports.unit = unit;\nconst currentFiberURI = \"@effect/io/Fiber/Current\";\n/** @internal */\nexports.currentFiberURI = currentFiberURI;\nconst getCurrentFiber = () => Option.fromNullable(globalThis[currentFiberURI]);\nexports.getCurrentFiber = getCurrentFiber;\n//# sourceMappingURL=fiber.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.unsafeMake = exports.toSet = exports.toOption = exports.threadName = exports.runtime = exports.none = exports.make = exports.isRuntime = exports.isNone = exports.isFiberId = exports.isComposite = exports.ids = exports.getOrElse = exports.composite = exports.combineAll = exports.combine = exports.FiberIdTypeId = void 0;\nvar Equal = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Equal\"));\nvar _Function = /*#__PURE__*/require(\"@effect/data/Function\");\nvar _Global = /*#__PURE__*/require(\"@effect/data/Global\");\nvar Hash = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Hash\"));\nvar HashSet = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/HashSet\"));\nvar MutableRef = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/MutableRef\"));\nvar Option = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Option\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\nvar _a, _b, _c;\n/** @internal */\nconst FiberIdSymbolKey = \"@effect/io/Fiber/Id\";\n/** @internal */\nconst FiberIdTypeId = /*#__PURE__*/Symbol.for(FiberIdSymbolKey);\n/** @internal */\nexports.FiberIdTypeId = FiberIdTypeId;\nconst OP_NONE = \"None\";\n/** @internal */\nconst OP_RUNTIME = \"Runtime\";\n/** @internal */\nconst OP_COMPOSITE = \"Composite\";\n/** @internal */\nclass None {\n  constructor() {\n    this[_a] = FiberIdTypeId;\n    this._tag = OP_NONE;\n  }\n  [(_a = FiberIdTypeId, Hash.symbol)]() {\n    return Hash.combine(Hash.hash(this._tag))(Hash.hash(FiberIdSymbolKey));\n  }\n  [Equal.symbol](that) {\n    return isFiberId(that) && that._tag === OP_NONE;\n  }\n}\n/** @internal */\nclass Runtime {\n  constructor(id, startTimeMillis) {\n    this.id = id;\n    this.startTimeMillis = startTimeMillis;\n    this[_b] = FiberIdTypeId;\n    this._tag = OP_RUNTIME;\n  }\n  [(_b = FiberIdTypeId, Hash.symbol)]() {\n    return Hash.combine(Hash.hash(this.startTimeMillis))(Hash.combine(Hash.hash(this.id))(Hash.combine(Hash.hash(this._tag))(Hash.hash(FiberIdSymbolKey))));\n  }\n  [Equal.symbol](that) {\n    return isFiberId(that) && that._tag === OP_RUNTIME && this.id === that.id && this.startTimeMillis === that.startTimeMillis;\n  }\n}\n/** @internal */\nclass Composite {\n  constructor(left, right) {\n    this.left = left;\n    this.right = right;\n    this[_c] = FiberIdTypeId;\n    this._tag = OP_COMPOSITE;\n  }\n  [(_c = FiberIdTypeId, Hash.symbol)]() {\n    return Hash.combine(Hash.hash(this.right))(Hash.combine(Hash.hash(this.left))(Hash.combine(Hash.hash(this._tag))(Hash.hash(FiberIdSymbolKey))));\n  }\n  [Equal.symbol](that) {\n    return isFiberId(that) && that._tag === OP_COMPOSITE && Equal.equals(this.left, that.left) && Equal.equals(this.right, that.right);\n  }\n}\n/** @internal */\nconst none = /*#__PURE__*/new None();\n/** @internal */\nexports.none = none;\nconst runtime = (id, startTimeMillis) => {\n  return new Runtime(id, startTimeMillis);\n};\n/** @internal */\nexports.runtime = runtime;\nconst composite = (left, right) => {\n  return new Composite(left, right);\n};\n/** @internal */\nexports.composite = composite;\nconst isFiberId = self => {\n  return typeof self === \"object\" && self != null && FiberIdTypeId in self;\n};\n/** @internal */\nexports.isFiberId = isFiberId;\nconst isNone = self => {\n  return self._tag === OP_NONE || HashSet.every(id => isNone(id))(toSet(self));\n};\n/** @internal */\nexports.isNone = isNone;\nconst isRuntime = self => {\n  return self._tag === OP_RUNTIME;\n};\n/** @internal */\nexports.isRuntime = isRuntime;\nconst isComposite = self => {\n  return self._tag === OP_COMPOSITE;\n};\n/** @internal */\nexports.isComposite = isComposite;\nconst combine = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => {\n  if (self._tag === OP_NONE) {\n    return that;\n  }\n  if (that._tag === OP_NONE) {\n    return self;\n  }\n  return new Composite(self, that);\n});\n/** @internal */\nexports.combine = combine;\nconst combineAll = fiberIds => {\n  return HashSet.reduce(none, (a, b) => combine(b)(a))(fiberIds);\n};\n/** @internal */\nexports.combineAll = combineAll;\nconst getOrElse = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => isNone(self) ? that : self);\n/** @internal */\nexports.getOrElse = getOrElse;\nconst ids = self => {\n  switch (self._tag) {\n    case OP_NONE:\n      {\n        return HashSet.empty();\n      }\n    case OP_RUNTIME:\n      {\n        return HashSet.make(self.id);\n      }\n    case OP_COMPOSITE:\n      {\n        return HashSet.union(ids(self.right))(ids(self.left));\n      }\n  }\n};\nexports.ids = ids;\nconst _fiberCounter = /*#__PURE__*/(0, _Global.globalValue)( /*#__PURE__*/Symbol.for(\"@effect/io/Fiber/Id/_fiberCounter\"), () => MutableRef.make(0));\n/** @internal */\nconst make = (id, startTimeSeconds) => {\n  return new Runtime(id, startTimeSeconds);\n};\n/** @internal */\nexports.make = make;\nconst threadName = self => {\n  const identifiers = Array.from(ids(self)).map(n => `#${n}`).join(\",\");\n  return identifiers;\n};\n/** @internal */\nexports.threadName = threadName;\nconst toOption = self => {\n  const fiberIds = toSet(self);\n  if (HashSet.size(fiberIds) === 0) {\n    return Option.none();\n  }\n  let first = true;\n  let acc;\n  for (const fiberId of fiberIds) {\n    if (first) {\n      acc = fiberId;\n      first = false;\n    } else {\n      // @ts-expect-error\n      acc = combine(fiberId)(acc);\n    }\n  }\n  // @ts-expect-error\n  return Option.some(acc);\n};\n/** @internal */\nexports.toOption = toOption;\nconst toSet = self => {\n  switch (self._tag) {\n    case OP_NONE:\n      {\n        return HashSet.empty();\n      }\n    case OP_RUNTIME:\n      {\n        return HashSet.make(self);\n      }\n    case OP_COMPOSITE:\n      {\n        return HashSet.union(toSet(self.right))(toSet(self.left));\n      }\n  }\n};\n/** @internal */\nexports.toSet = toSet;\nconst unsafeMake = () => {\n  const id = MutableRef.get(_fiberCounter);\n  MutableRef.set(id + 1)(_fiberCounter);\n  return new Runtime(id, new Date().getTime());\n};\nexports.unsafeMake = unsafeMake;\n//# sourceMappingURL=fiberId.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.yieldNow = exports.stateful = exports.resume = exports.interruptSignal = exports.OP_YIELD_NOW = exports.OP_STATEFUL = exports.OP_RESUME = exports.OP_INTERRUPT_SIGNAL = void 0;\n/** @internal */\nconst OP_INTERRUPT_SIGNAL = \"InterruptSignal\";\n/** @internal */\nexports.OP_INTERRUPT_SIGNAL = OP_INTERRUPT_SIGNAL;\nconst OP_STATEFUL = \"Stateful\";\n/** @internal */\nexports.OP_STATEFUL = OP_STATEFUL;\nconst OP_RESUME = \"Resume\";\n/** @internal */\nexports.OP_RESUME = OP_RESUME;\nconst OP_YIELD_NOW = \"YieldNow\";\n/** @internal */\nexports.OP_YIELD_NOW = OP_YIELD_NOW;\nconst interruptSignal = cause => ({\n  _tag: OP_INTERRUPT_SIGNAL,\n  cause\n});\n/** @internal */\nexports.interruptSignal = interruptSignal;\nconst stateful = onFiber => ({\n  _tag: OP_STATEFUL,\n  onFiber\n});\n/** @internal */\nexports.stateful = stateful;\nconst resume = effect => ({\n  _tag: OP_RESUME,\n  effect\n});\n/** @internal */\nexports.resume = resume;\nconst yieldNow = () => ({\n  _tag: OP_YIELD_NOW\n});\nexports.yieldNow = yieldNow;\n//# sourceMappingURL=fiberMessage.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.setAll = exports.joinAs = exports.getOrDefault = exports.get = exports.forkAs = exports.fiberRefs = exports.delete_ = exports.FiberRefsSym = exports.FiberRefsImpl = void 0;\nexports.unsafeMake = unsafeMake;\nexports.updatedAs = void 0;\nvar Equal = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Equal\"));\nvar _Function = /*#__PURE__*/require(\"@effect/data/Function\");\nvar HashSet = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/HashSet\"));\nvar Option = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Option\"));\nvar Arr = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/ReadonlyArray\"));\nvar Debug = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Debug\"));\nvar core = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/core\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\nvar _a;\n/** @internal */\nfunction unsafeMake(fiberRefLocals) {\n  return new FiberRefsImpl(fiberRefLocals);\n}\n/** @internal */\nconst FiberRefsSym = /*#__PURE__*/Symbol.for(\"@effect/io/FiberRefs\");\n/** @internal */\nexports.FiberRefsSym = FiberRefsSym;\nclass FiberRefsImpl {\n  constructor(locals) {\n    this.locals = locals;\n    this[_a] = FiberRefsSym;\n  }\n}\nexports.FiberRefsImpl = FiberRefsImpl;\n_a = FiberRefsSym;\n/** @internal */\nconst findAncestor = (_ref, _parentStack, _childStack, _childModified = false) => {\n  const ref = _ref;\n  let parentStack = _parentStack;\n  let childStack = _childStack;\n  let childModified = _childModified;\n  let ret = undefined;\n  while (ret === undefined) {\n    if (Arr.isNonEmptyReadonlyArray(parentStack) && Arr.isNonEmptyReadonlyArray(childStack)) {\n      const parentFiberId = Arr.headNonEmpty(parentStack)[0];\n      const parentAncestors = Arr.tailNonEmpty(parentStack);\n      const childFiberId = Arr.headNonEmpty(childStack)[0];\n      const childRefValue = Arr.headNonEmpty(childStack)[1];\n      const childAncestors = Arr.tailNonEmpty(childStack);\n      if (parentFiberId.startTimeMillis < childFiberId.startTimeMillis) {\n        childStack = childAncestors;\n        childModified = true;\n      } else if (parentFiberId.startTimeMillis > childFiberId.startTimeMillis) {\n        parentStack = parentAncestors;\n      } else {\n        if (parentFiberId.id < childFiberId.id) {\n          childStack = childAncestors;\n          childModified = true;\n        } else if (parentFiberId.id > childFiberId.id) {\n          parentStack = parentAncestors;\n        } else {\n          ret = [childRefValue, childModified];\n        }\n      }\n    } else {\n      ret = [ref.initial, true];\n    }\n  }\n  return ret;\n};\n/** @internal */\nconst joinAs = /*#__PURE__*/(0, _Function.dual)(3, (self, fiberId, that) => {\n  const parentFiberRefs = new Map(self.locals);\n  for (const [fiberRef, childStack] of that.locals) {\n    const childValue = Arr.headNonEmpty(childStack)[1];\n    if (!Equal.equals(Arr.headNonEmpty(childStack)[0], fiberId)) {\n      if (!parentFiberRefs.has(fiberRef)) {\n        if (Equal.equals(childValue, fiberRef.initial)) {\n          continue;\n        }\n        parentFiberRefs.set(fiberRef, [[fiberId, fiberRef.join(fiberRef.initial, childValue)]]);\n        continue;\n      }\n      const parentStack = parentFiberRefs.get(fiberRef);\n      const [ancestor, wasModified] = findAncestor(fiberRef, parentStack, childStack);\n      if (wasModified) {\n        const patch = fiberRef.diff(ancestor, childValue);\n        const oldValue = Arr.headNonEmpty(parentStack)[1];\n        const newValue = fiberRef.join(oldValue, fiberRef.patch(patch)(oldValue));\n        if (!Equal.equals(oldValue, newValue)) {\n          let newStack;\n          const parentFiberId = Arr.headNonEmpty(parentStack)[0];\n          if (Equal.equals(parentFiberId, fiberId)) {\n            newStack = Arr.prepend([parentFiberId, newValue])(Arr.tailNonEmpty(parentStack));\n          } else {\n            newStack = Arr.prepend([fiberId, newValue])(parentStack);\n          }\n          parentFiberRefs.set(fiberRef, newStack);\n        }\n      }\n    }\n  }\n  return new FiberRefsImpl(new Map(parentFiberRefs));\n});\n/** @internal */\nexports.joinAs = joinAs;\nconst forkAs = /*#__PURE__*/(0, _Function.dual)(2, (self, childId) => {\n  const map = new Map();\n  for (const [fiberRef, stack] of self.locals.entries()) {\n    const oldValue = Arr.headNonEmpty(stack)[1];\n    const newValue = fiberRef.patch(fiberRef.fork)(oldValue);\n    if (Equal.equals(oldValue, newValue)) {\n      map.set(fiberRef, stack);\n    } else {\n      map.set(fiberRef, Arr.prepend([childId, newValue])(stack));\n    }\n  }\n  return new FiberRefsImpl(map);\n});\n/** @internal */\nexports.forkAs = forkAs;\nconst fiberRefs = self => HashSet.fromIterable(self.locals.keys());\n/** @internal */\nexports.fiberRefs = fiberRefs;\nconst setAll = /*#__PURE__*/Debug.methodWithTrace(trace => self => core.forEachDiscard(fiberRefs(self), fiberRef => core.fiberRefSet(fiberRef, getOrDefault(self, fiberRef))).traced(trace));\n/** @internal */\nexports.setAll = setAll;\nconst delete_ = /*#__PURE__*/(0, _Function.dual)(2, (self, fiberRef) => {\n  const locals = new Map(self.locals);\n  locals.delete(fiberRef);\n  return new FiberRefsImpl(locals);\n});\n/** @internal */\nexports.delete_ = delete_;\nconst get = /*#__PURE__*/(0, _Function.dual)(2, (self, fiberRef) => {\n  if (!self.locals.has(fiberRef)) {\n    return Option.none();\n  }\n  return Option.some(Arr.headNonEmpty(self.locals.get(fiberRef))[1]);\n});\n/** @internal */\nexports.get = get;\nconst getOrDefault = /*#__PURE__*/(0, _Function.dual)(2, (self, fiberRef) => Option.getOrElse(() => fiberRef.initial)(get(self, fiberRef)));\n/** @internal */\nexports.getOrDefault = getOrDefault;\nconst updatedAs = /*#__PURE__*/(0, _Function.dual)(4, (self, fiberId, fiberRef, value) => {\n  const oldStack = self.locals.has(fiberRef) ? self.locals.get(fiberRef) : Arr.empty();\n  let newStack;\n  if (Arr.isEmptyReadonlyArray(oldStack)) {\n    newStack = Arr.of([fiberId, value]);\n  } else {\n    const [currentId, currentValue] = Arr.headNonEmpty(oldStack);\n    if (Equal.equals(currentId, fiberId)) {\n      if (Equal.equals(currentValue, value)) {\n        return self;\n      } else {\n        newStack = Arr.prepend([fiberId, value])(Arr.tailNonEmpty(oldStack));\n      }\n    } else {\n      newStack = Arr.prepend([fiberId, value])(oldStack);\n    }\n  }\n  const locals = new Map(self.locals);\n  return new FiberRefsImpl(locals.set(fiberRef, newStack));\n});\nexports.updatedAs = updatedAs;\n//# sourceMappingURL=fiberRefs.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.patch = exports.empty = exports.diff = exports.combine = exports.OP_UPDATE = exports.OP_REMOVE = exports.OP_EMPTY = exports.OP_AND_THEN = exports.OP_ADD = void 0;\nvar _Equal = /*#__PURE__*/require(\"@effect/data/Equal\");\nvar _Function = /*#__PURE__*/require(\"@effect/data/Function\");\nvar Arr = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/ReadonlyArray\"));\nvar _fiberRefs = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/fiberRefs\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/** @internal */\nconst OP_EMPTY = \"Empty\";\n/** @internal */\nexports.OP_EMPTY = OP_EMPTY;\nconst OP_ADD = \"Add\";\n/** @internal */\nexports.OP_ADD = OP_ADD;\nconst OP_REMOVE = \"Remove\";\n/** @internal */\nexports.OP_REMOVE = OP_REMOVE;\nconst OP_UPDATE = \"Update\";\n/** @internal */\nexports.OP_UPDATE = OP_UPDATE;\nconst OP_AND_THEN = \"AndThen\";\n/** @internal */\nexports.OP_AND_THEN = OP_AND_THEN;\nconst empty = () => ({\n  _tag: OP_EMPTY\n});\n/** @internal */\nexports.empty = empty;\nconst diff = (oldValue, newValue) => {\n  const missingLocals = new Map(oldValue.locals);\n  let patch = empty();\n  for (const [fiberRef, pairs] of newValue.locals.entries()) {\n    const newValue = Arr.headNonEmpty(pairs)[1];\n    const old = missingLocals.get(fiberRef);\n    if (old !== undefined) {\n      const oldValue = Arr.headNonEmpty(old)[1];\n      if (!(0, _Equal.equals)(oldValue, newValue)) {\n        patch = combine({\n          _tag: OP_UPDATE,\n          fiberRef,\n          patch: fiberRef.diff(oldValue, newValue)\n        })(patch);\n      }\n    } else {\n      patch = combine({\n        _tag: OP_ADD,\n        fiberRef,\n        value: newValue\n      })(patch);\n    }\n    missingLocals.delete(fiberRef);\n  }\n  for (const [fiberRef] of missingLocals.entries()) {\n    patch = combine({\n      _tag: OP_REMOVE,\n      fiberRef\n    })(patch);\n  }\n  return patch;\n};\n/** @internal */\nexports.diff = diff;\nconst combine = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => ({\n  _tag: OP_AND_THEN,\n  first: self,\n  second: that\n}));\n/** @internal */\nexports.combine = combine;\nconst patch = /*#__PURE__*/(0, _Function.dual)(3, (self, fiberId, oldValue) => {\n  let fiberRefs = oldValue;\n  let patches = Arr.of(self);\n  while (Arr.isNonEmptyReadonlyArray(patches)) {\n    const head = Arr.headNonEmpty(patches);\n    const tail = Arr.tailNonEmpty(patches);\n    switch (head._tag) {\n      case OP_EMPTY:\n        {\n          patches = tail;\n          break;\n        }\n      case OP_ADD:\n        {\n          fiberRefs = _fiberRefs.updatedAs(fiberRefs, fiberId, head.fiberRef, head.value);\n          patches = tail;\n          break;\n        }\n      case OP_REMOVE:\n        {\n          fiberRefs = _fiberRefs.delete_(fiberRefs, head.fiberRef);\n          patches = tail;\n          break;\n        }\n      case OP_UPDATE:\n        {\n          const value = _fiberRefs.getOrDefault(fiberRefs, head.fiberRef);\n          fiberRefs = _fiberRefs.updatedAs(fiberRefs, fiberId, head.fiberRef, head.fiberRef.patch(head.patch)(value));\n          patches = tail;\n          break;\n        }\n      case OP_AND_THEN:\n        {\n          patches = Arr.prepend(head.first)(Arr.prepend(head.second)(tail));\n          break;\n        }\n    }\n  }\n  return fiberRefs;\n});\nexports.patch = patch;\n//# sourceMappingURL=patch.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.withRuntimeFlagsScoped = exports.withEarlyRelease = exports.withConfigProviderScoped = exports.withClockScoped = exports.validateFirstPar = exports.validateAllParDiscard = exports.validateAllPar = exports.using = exports.unsome = exports.unsafeMakeChildFiber = exports.unsafeFork = exports.taggedScopedWithLabels = exports.taggedScopedWithLabelSet = exports.taggedScoped = exports.someWith = exports.some = exports.sequentialFinalizers = exports.scopedEffect = exports.scopeWith = exports.scopeUse = exports.scopeTag = exports.scopeMake = exports.scopeExtend = exports.scope = exports.runtimeFiberVariance = exports.releaseMapReleaseAll = exports.reduceAllPar = exports.raceAll = exports.partitionPar = exports.parallelFinalizers = exports.onDoneCause = exports.onDone = exports.mergeAllPar = exports.logFmtLogger = exports.forkWithErrorHandler = exports.forkDaemon = exports.forkAllDiscard = exports.fork = exports.forEachParWithIndex = exports.forEachParDiscard = exports.forEachPar = exports.forEachExec = exports.filterPar = exports.filterNotPar = exports.fiberScoped = exports.fiberRefUnsafeMakeSupervisor = exports.fiberRefMakeWith = exports.fiberRefMakeRuntimeFlags = exports.fiberRefMakeContext = exports.fiberRefMake = exports.fiberRefLocallyScopedWith = exports.fiberRefLocallyScoped = exports.fiberJoinAll = exports.fiberInterruptFork = exports.fiberCollectAll = exports.fiberAwaitAll = exports.existsPar = exports.defaultLogger = exports.daemonChildren = exports.currentSupervisor = exports.currentRuntimeFlags = exports.currentMinimumLogLevel = exports.currentLoggers = exports.collectPar = exports.collectAllWithPar = exports.collectAllSuccessesPar = exports.collectAllParDiscard = exports.collectAllPar = exports.collect = exports.allPar = exports.addFinalizer = exports.acquireRelease = exports.FiberRuntime = void 0;\nvar Chunk = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Chunk\"));\nvar Context = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Context\"));\nvar _Function = /*#__PURE__*/require(\"@effect/data/Function\");\nvar HashSet = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/HashSet\"));\nvar MutableQueue = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/MutableQueue\"));\nvar MRef = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/MutableRef\"));\nvar Option = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Option\"));\nvar Debug = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Debug\"));\nvar Deferred = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Deferred\"));\nvar ExecutionStrategy = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/ExecutionStrategy\"));\nvar FiberId = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Fiber/Id\"));\nvar RuntimeFlagsPatch = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Fiber/Runtime/Flags/Patch\"));\nvar FiberStatus = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Fiber/Status\"));\nvar internalCause = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/cause\"));\nvar clock = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/clock\"));\nvar _configProvider = /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/configProvider\");\nvar core = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/core\"));\nvar defaultServices = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/defaultServices\"));\nvar internalFiber = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/fiber\"));\nvar FiberMessage = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/fiberMessage\"));\nvar fiberRefs = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/fiberRefs\"));\nvar fiberScope = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/fiberScope\"));\nvar internalLogger = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/logger\"));\nvar metric = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/metric\"));\nvar metricBoundaries = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/metric/boundaries\"));\nvar metricLabel = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/metric/label\"));\nvar OpCodes = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/opCodes/effect\"));\nvar _runtimeFlags = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/runtimeFlags\"));\nvar supervisor = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/supervisor\"));\nvar SupervisorPatch = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/supervisor/patch\"));\nvar LogLevel = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Logger/Level\"));\nvar Ref = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Ref\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\nvar _a, _b;\nconst fibersStarted = /*#__PURE__*/metric.counter(\"effect_fiber_started\");\nconst fiberSuccesses = /*#__PURE__*/metric.counter(\"effect_fiber_successes\");\nconst fiberFailures = /*#__PURE__*/metric.counter(\"effect_fiber_failures\");\nconst fiberLifetimes = /*#__PURE__*/metric.histogram(\"effect_fiber_lifetimes\", /*#__PURE__*/metricBoundaries.exponential(1.0, 2.0, 100));\n/** @internal */\nconst EvaluationSignalContinue = \"Continue\";\n/** @internal */\nconst EvaluationSignalDone = \"Done\";\n/** @internal */\nconst EvaluationSignalYieldNow = \"Yield\";\n/** @internal */\nconst runtimeFiberVariance = {\n  _E: _ => _,\n  _A: _ => _\n};\nexports.runtimeFiberVariance = runtimeFiberVariance;\nconst absurd = _ => {\n  throw new Error(`BUG: FiberRuntime - ${JSON.stringify(_)} - please report an issue at https://github.com/Effect-TS/io/issues`);\n};\nconst contOpSuccess = {\n  [OpCodes.OP_ON_SUCCESS]: (_, cont, value) => {\n    return cont.i1(value);\n  },\n  [OpCodes.OP_ON_SUCCESS_AND_FAILURE]: (_, cont, value) => {\n    return cont.i2(value);\n  },\n  [OpCodes.OP_REVERT_FLAGS]: (self, cont, value) => {\n    self.patchRuntimeFlags(self._runtimeFlags, cont.patch);\n    if (_runtimeFlags.interruptible(self._runtimeFlags) && self.isInterrupted()) {\n      return core.exitFailCause(self.getInterruptedCause());\n    } else {\n      return core.exitSucceed(value);\n    }\n  },\n  [OpCodes.OP_WHILE]: (self, cont, value) => {\n    cont.i2(value);\n    if (cont.i0()) {\n      self.pushStack(cont);\n      return cont.i1();\n    } else {\n      return core.unit();\n    }\n  }\n};\nconst drainQueueWhileRunningTable = {\n  [FiberMessage.OP_INTERRUPT_SIGNAL]: (self, runtimeFlags, cur, message) => {\n    self.processNewInterruptSignal(message.cause);\n    return _runtimeFlags.interruptible(runtimeFlags) ? core.exitFailCause(message.cause) : cur;\n  },\n  [FiberMessage.OP_RESUME]: (_self, _runtimeFlags, _cur, _message) => {\n    throw new Error(\"It is illegal to have multiple concurrent run loops in a single fiber\");\n  },\n  [FiberMessage.OP_STATEFUL]: (self, runtimeFlags, cur, message) => {\n    message.onFiber(self, FiberStatus.running(runtimeFlags));\n    return cur;\n  },\n  [FiberMessage.OP_YIELD_NOW]: (_self, _runtimeFlags, cur, _message) => {\n    return core.flatMap(() => cur)(core.yieldNow());\n  }\n};\n/** @internal */\nclass FiberRuntime {\n  constructor(fiberId, fiberRefs0, runtimeFlags0) {\n    this[_a] = internalFiber.fiberVariance;\n    this[_b] = runtimeFiberVariance;\n    this._queue = MutableQueue.unbounded();\n    this._children = null;\n    this._observers = new Array();\n    this._running = false;\n    this._stack = [];\n    this._asyncInterruptor = null;\n    this._asyncBlockingOn = null;\n    this._exitValue = null;\n    this._traceStack = [];\n    this.run = () => {\n      this.drainQueueOnCurrentThread();\n    };\n    this._runtimeFlags = runtimeFlags0;\n    this._fiberId = fiberId;\n    this._fiberRefs = fiberRefs0;\n    if (_runtimeFlags.runtimeMetrics(runtimeFlags0)) {\n      const tags = this.getFiberRef(core.currentTags);\n      fibersStarted.unsafeUpdate(1, tags);\n    }\n  }\n  /**\n   * The identity of the fiber.\n   */\n  id() {\n    return this._fiberId;\n  }\n  /**\n   * Begins execution of the effect associated with this fiber on in the\n   * background. This can be called to \"kick off\" execution of a fiber after\n   * it has been created.\n   */\n  resume(effect) {\n    this.tell(FiberMessage.resume(effect));\n  }\n  /**\n   * The status of the fiber.\n   */\n  status() {\n    return this.ask((_, status) => status);\n  }\n  /**\n   * Gets the fiber runtime flags.\n   */\n  runtimeFlags() {\n    return this.ask((state, status) => {\n      if (FiberStatus.isDone(status)) {\n        return state._runtimeFlags;\n      }\n      return status.runtimeFlags;\n    });\n  }\n  /**\n   * Returns the current `FiberScope` for the fiber.\n   */\n  scope() {\n    return fiberScope.unsafeMake(this);\n  }\n  /**\n   * Retrieves the immediate children of the fiber.\n   */\n  children() {\n    return this.ask(fiber => Chunk.fromIterable(fiber.getChildren()));\n  }\n  /**\n   * Gets the fiber's set of children.\n   */\n  getChildren() {\n    if (this._children === null) {\n      this._children = new Set();\n    }\n    return this._children;\n  }\n  /**\n   * Retrieves the current supervisor the fiber uses for supervising effects.\n   *\n   * **NOTE**: This method is safe to invoke on any fiber, but if not invoked\n   * on this fiber, then values derived from the fiber's state (including the\n   * log annotations and log level) may not be up-to-date.\n   */\n  getSupervisor() {\n    return this.getFiberRef(currentSupervisor);\n  }\n  /**\n   * Retrieves the interrupted cause of the fiber, which will be `Cause.empty`\n   * if the fiber has not been interrupted.\n   *\n   * **NOTE**: This method is safe to invoke on any fiber, but if not invoked\n   * on this fiber, then values derived from the fiber's state (including the\n   * log annotations and log level) may not be up-to-date.\n   */\n  getInterruptedCause() {\n    return this.getFiberRef(core.interruptedCause);\n  }\n  /**\n   * Retrieves the whole set of fiber refs.\n   */\n  fiberRefs() {\n    return this.ask(fiber => fiber.unsafeGetFiberRefs());\n  }\n  /**\n   * Returns an effect that will contain information computed from the fiber\n   * state and status while running on the fiber.\n   *\n   * This allows the outside world to interact safely with mutable fiber state\n   * without locks or immutable data.\n   */\n  ask(f) {\n    return Debug.untraced(() => core.suspend(() => {\n      const deferred = core.deferredUnsafeMake(this._fiberId);\n      this.tell(FiberMessage.stateful((fiber, status) => {\n        core.deferredUnsafeDone(deferred, core.sync(() => f(fiber, status)));\n      }));\n      return core.deferredAwait(deferred);\n    }));\n  }\n  /**\n   * Adds a message to be processed by the fiber on the fiber.\n   */\n  tell(message) {\n    MutableQueue.offer(message)(this._queue);\n    if (!this._running) {\n      this._running = true;\n      this.drainQueueLaterOnExecutor();\n    }\n  }\n  await() {\n    return Debug.untraced(() => core.asyncInterrupt(resume => {\n      const cb = exit => resume(core.succeed(exit));\n      this.tell(FiberMessage.stateful((fiber, _) => {\n        if (fiber._exitValue !== null) {\n          cb(this._exitValue);\n        } else {\n          fiber.unsafeAddObserver(cb);\n        }\n      }));\n      return core.sync(() => this.tell(FiberMessage.stateful((fiber, _) => {\n        fiber.unsafeRemoveObserver(cb);\n      })));\n    }, this.id()));\n  }\n  inheritAll() {\n    return Debug.untraced(() => core.withFiberRuntime((parentFiber, parentStatus) => {\n      const parentFiberId = parentFiber.id();\n      const parentFiberRefs = parentFiber.unsafeGetFiberRefs();\n      const parentRuntimeFlags = parentStatus.runtimeFlags;\n      const childFiberRefs = this.unsafeGetFiberRefs();\n      const updatedFiberRefs = fiberRefs.joinAs(parentFiberRefs, parentFiberId, childFiberRefs);\n      parentFiber.setFiberRefs(updatedFiberRefs);\n      const updatedRuntimeFlags = parentFiber.getFiberRef(currentRuntimeFlags);\n      const patch = RuntimeFlagsPatch.exclude(_runtimeFlags.WindDown)(\n      // Do not inherit WindDown or Interruption!\n      RuntimeFlagsPatch.exclude(_runtimeFlags.Interruption)(_runtimeFlags.diff(parentRuntimeFlags, updatedRuntimeFlags)));\n      return core.updateRuntimeFlags(patch);\n    }));\n  }\n  /**\n   * Tentatively observes the fiber, but returns immediately if it is not\n   * already done.\n   */\n  poll() {\n    return Debug.untraced(() => core.sync(() => Option.fromNullable(this._exitValue)));\n  }\n  /**\n   * Unsafely observes the fiber, but returns immediately if it is not\n   * already done.\n   */\n  unsafePoll() {\n    return this._exitValue;\n  }\n  /**\n   * In the background, interrupts the fiber as if interrupted from the specified fiber.\n   */\n  interruptAsFork(fiberId) {\n    return Debug.untraced(() => core.sync(() => this.tell(FiberMessage.interruptSignal(internalCause.interrupt(fiberId)))));\n  }\n  /**\n   * Adds an observer to the list of observers.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */\n  unsafeAddObserver(observer) {\n    if (this._exitValue !== null) {\n      observer(this._exitValue);\n    } else {\n      this._observers.push(observer);\n    }\n  }\n  /**\n   * Removes the specified observer from the list of observers that will be\n   * notified when the fiber exits.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */\n  unsafeRemoveObserver(observer) {\n    this._observers = this._observers.filter(o => o !== observer);\n  }\n  /**\n   * Retrieves all fiber refs of the fiber.\n   *\n   * **NOTE**: This method is safe to invoke on any fiber, but if not invoked\n   * on this fiber, then values derived from the fiber's state (including the\n   * log annotations and log level) may not be up-to-date.\n   */\n  unsafeGetFiberRefs() {\n    this.setFiberRef(currentRuntimeFlags, this._runtimeFlags);\n    return this._fiberRefs;\n  }\n  /**\n   * Deletes the specified fiber ref.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */\n  unsafeDeleteFiberRef(fiberRef) {\n    this._fiberRefs = fiberRefs.delete_(this._fiberRefs, fiberRef);\n  }\n  /**\n   * Retrieves the state of the fiber ref, or else its initial value.\n   *\n   * **NOTE**: This method is safe to invoke on any fiber, but if not invoked\n   * on this fiber, then values derived from the fiber's state (including the\n   * log annotations and log level) may not be up-to-date.\n   */\n  getFiberRef(fiberRef) {\n    return fiberRefs.getOrDefault(this._fiberRefs, fiberRef);\n  }\n  /**\n   * Sets the fiber ref to the specified value.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */\n  setFiberRef(fiberRef, value) {\n    this._fiberRefs = fiberRefs.updatedAs(this._fiberRefs, this._fiberId, fiberRef, value);\n  }\n  /**\n   * Wholesale replaces all fiber refs of this fiber.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */\n  setFiberRefs(fiberRefs) {\n    this._fiberRefs = fiberRefs;\n  }\n  /**\n   * Adds a reference to the specified fiber inside the children set.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */\n  addChild(child) {\n    this.getChildren().add(child);\n  }\n  /**\n   * Removes a reference to the specified fiber inside the children set.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */\n  removeChild(child) {\n    this.getChildren().delete(child);\n  }\n  /**\n   * On the current thread, executes all messages in the fiber's inbox. This\n   * method may return before all work is done, in the event the fiber executes\n   * an asynchronous operation.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */\n  drainQueueOnCurrentThread() {\n    let recurse = true;\n    while (recurse) {\n      let evaluationSignal = EvaluationSignalContinue;\n      const prev = globalThis[internalFiber.currentFiberURI];\n      globalThis[internalFiber.currentFiberURI] = this;\n      try {\n        while (evaluationSignal === EvaluationSignalContinue) {\n          evaluationSignal = MutableQueue.isEmpty(this._queue) ? EvaluationSignalDone : this.evaluateMessageWhileSuspended(MutableQueue.poll(null)(this._queue));\n        }\n      } finally {\n        this._running = false;\n        globalThis[internalFiber.currentFiberURI] = prev;\n      }\n      // Maybe someone added something to the queue between us checking, and us\n      // giving up the drain. If so, we need to restart the draining, but only\n      // if we beat everyone else to the restart:\n      if (!MutableQueue.isEmpty(this._queue) && !this._running) {\n        this._running = true;\n        if (evaluationSignal === EvaluationSignalYieldNow) {\n          this.drainQueueLaterOnExecutor();\n          recurse = false;\n        } else {\n          recurse = true;\n        }\n      } else {\n        recurse = false;\n      }\n    }\n  }\n  /**\n   * Schedules the execution of all messages in the fiber's inbox.\n   *\n   * This method will return immediately after the scheduling\n   * operation is completed, but potentially before such messages have been\n   * executed.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */\n  drainQueueLaterOnExecutor() {\n    this.getFiberRef(core.currentScheduler).scheduleTask(this.run);\n  }\n  /**\n   * Drains the fiber's message queue while the fiber is actively running,\n   * returning the next effect to execute, which may be the input effect if no\n   * additional effect needs to be executed.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */\n  drainQueueWhileRunning(runtimeFlags, cur0) {\n    let cur = cur0;\n    while (!MutableQueue.isEmpty(this._queue)) {\n      const message = MutableQueue.poll(void 0)(this._queue);\n      // @ts-expect-error\n      cur = drainQueueWhileRunningTable[message._tag](this, runtimeFlags, cur, message);\n    }\n    return cur;\n  }\n  /**\n   * Determines if the fiber is interrupted.\n   *\n   * **NOTE**: This method is safe to invoke on any fiber, but if not invoked\n   * on this fiber, then values derived from the fiber's state (including the\n   * log annotations and log level) may not be up-to-date.\n   */\n  isInterrupted() {\n    return !internalCause.isEmpty(this.getFiberRef(core.interruptedCause));\n  }\n  /**\n   * Adds an interruptor to the set of interruptors that are interrupting this\n   * fiber.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */\n  addInterruptedCause(cause) {\n    const oldSC = this.getFiberRef(core.interruptedCause);\n    this.setFiberRef(core.interruptedCause, internalCause.sequential(oldSC, cause));\n  }\n  /**\n   * Processes a new incoming interrupt signal.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */\n  processNewInterruptSignal(cause) {\n    this.addInterruptedCause(cause);\n    this.sendInterruptSignalToAllChildren();\n  }\n  /**\n   * Interrupts all children of the current fiber, returning an effect that will\n   * await the exit of the children. This method will return null if the fiber\n   * has no children.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */\n  sendInterruptSignalToAllChildren() {\n    if (this._children === null || this._children.size === 0) {\n      return false;\n    }\n    let told = false;\n    for (const child of this._children) {\n      child.tell(FiberMessage.interruptSignal(internalCause.interrupt(this.id())));\n      told = true;\n    }\n    return told;\n  }\n  /**\n   * Interrupts all children of the current fiber, returning an effect that will\n   * await the exit of the children. This method will return null if the fiber\n   * has no children.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */\n  interruptAllChildren() {\n    if (this.sendInterruptSignalToAllChildren()) {\n      const it = this._children.values();\n      this._children = null;\n      let isDone = false;\n      const body = () => {\n        const next = it.next();\n        if (!next.done) {\n          return core.asUnit(next.value.await());\n        } else {\n          return core.sync(() => {\n            isDone = true;\n          });\n        }\n      };\n      return core.whileLoop(() => !isDone, () => body(), () => {\n        //\n      });\n    }\n    return null;\n  }\n  reportExitValue(exit) {\n    if (_runtimeFlags.runtimeMetrics(this._runtimeFlags)) {\n      const tags = this.getFiberRef(core.currentTags);\n      switch (exit._tag) {\n        case OpCodes.OP_SUCCESS:\n          {\n            fiberSuccesses.unsafeUpdate(1, tags);\n            break;\n          }\n        case OpCodes.OP_FAILURE:\n          {\n            fiberFailures.unsafeUpdate(1, tags);\n            break;\n          }\n      }\n    }\n  }\n  setExitValue(exit) {\n    this._exitValue = exit;\n    if (_runtimeFlags.runtimeMetrics(this._runtimeFlags)) {\n      const tags = this.getFiberRef(core.currentTags);\n      const startTimeMillis = this.id().startTimeMillis;\n      const endTimeMillis = new Date().getTime();\n      fiberLifetimes.unsafeUpdate((endTimeMillis - startTimeMillis) / 1000.0, tags);\n    }\n    this.reportExitValue(exit);\n    for (let i = this._observers.length - 1; i >= 0; i--) {\n      this._observers[i](exit);\n    }\n  }\n  getLoggers() {\n    return this.getFiberRef(currentLoggers);\n  }\n  log(message, cause, overrideLogLevel) {\n    const logLevel = Option.isSome(overrideLogLevel) ? overrideLogLevel.value : this.getFiberRef(core.currentLogLevel);\n    const spans = this.getFiberRef(core.currentLogSpan);\n    const annotations = this.getFiberRef(core.currentLogAnnotations);\n    const loggers = this.getLoggers();\n    const contextMap = this.unsafeGetFiberRefs();\n    HashSet.forEach(logger => {\n      logger.log(this.id(), logLevel, message, cause, contextMap, spans, annotations);\n    })(loggers);\n  }\n  /**\n   * Evaluates a single message on the current thread, while the fiber is\n   * suspended. This method should only be called while evaluation of the\n   * fiber's effect is suspended due to an asynchronous operation.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */\n  evaluateMessageWhileSuspended(message) {\n    switch (message._tag) {\n      case FiberMessage.OP_YIELD_NOW:\n        {\n          return EvaluationSignalYieldNow;\n        }\n      case FiberMessage.OP_INTERRUPT_SIGNAL:\n        {\n          this.processNewInterruptSignal(message.cause);\n          if (this._asyncInterruptor !== null) {\n            this._asyncInterruptor(core.exitFailCause(message.cause));\n            this._asyncInterruptor = null;\n          }\n          return EvaluationSignalContinue;\n        }\n      case FiberMessage.OP_RESUME:\n        {\n          this._asyncInterruptor = null;\n          this._asyncBlockingOn = null;\n          this.evaluateEffect(message.effect);\n          return EvaluationSignalContinue;\n        }\n      case FiberMessage.OP_STATEFUL:\n        {\n          message.onFiber(this, this._exitValue !== null ? FiberStatus.done : FiberStatus.suspended(this._runtimeFlags, this._asyncBlockingOn));\n          return EvaluationSignalContinue;\n        }\n      default:\n        {\n          return absurd(message);\n        }\n    }\n  }\n  /**\n   * Evaluates an effect until completion, potentially asynchronously.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */\n  evaluateEffect(effect0) {\n    this.getSupervisor().onResume(this);\n    try {\n      let effect = _runtimeFlags.interruptible(this._runtimeFlags) && this.isInterrupted() ? core.exitFailCause(this.getInterruptedCause()) : effect0;\n      while (effect !== null) {\n        try {\n          const exit = this.runLoop(effect);\n          this._runtimeFlags = _runtimeFlags.enable(_runtimeFlags.WindDown)(this._runtimeFlags);\n          const interruption = this.interruptAllChildren();\n          if (interruption !== null) {\n            effect = Debug.untraced(() => core.flatMap(interruption, () => exit));\n          } else {\n            if (MutableQueue.isEmpty(this._queue)) {\n              // No more messages to process, so we will allow the fiber to end life:\n              this.setExitValue(exit);\n            } else {\n              // There are messages, possibly added by the final op executed by\n              // the fiber. To be safe, we should execute those now before we\n              // allow the fiber to end life:\n              this.tell(FiberMessage.resume(exit));\n            }\n            effect = null;\n          }\n        } catch (e) {\n          if (core.isEffect(e)) {\n            if (e._tag === OpCodes.OP_YIELD) {\n              if (_runtimeFlags.cooperativeYielding(this._runtimeFlags)) {\n                this.tell(FiberMessage.yieldNow());\n                this.tell(FiberMessage.resume(core.exitUnit()));\n                effect = null;\n              } else {\n                effect = core.exitUnit();\n              }\n            } else if (e._tag === OpCodes.OP_ASYNC) {\n              // Terminate this evaluation, async resumption will continue evaluation:\n              effect = null;\n            }\n          } else {\n            throw e;\n          }\n        }\n      }\n    } finally {\n      this.getSupervisor().onSuspend(this);\n    }\n  }\n  /**\n   * Begins execution of the effect associated with this fiber on the current\n   * thread. This can be called to \"kick off\" execution of a fiber after it has\n   * been created, in hopes that the effect can be executed synchronously.\n   *\n   * This is not the normal way of starting a fiber, but it is useful when the\n   * express goal of executing the fiber is to synchronously produce its exit.\n   */\n  start(effect) {\n    if (!this._running) {\n      this._running = true;\n      const prev = globalThis[internalFiber.currentFiberURI];\n      globalThis[internalFiber.currentFiberURI] = this;\n      try {\n        this.evaluateEffect(effect);\n      } finally {\n        this._running = false;\n        globalThis[internalFiber.currentFiberURI] = prev;\n        // Because we're special casing `start`, we have to be responsible\n        // for spinning up the fiber if there were new messages added to\n        // the queue between the completion of the effect and the transition\n        // to the not running state.\n        if (!MutableQueue.isEmpty(this._queue)) {\n          this.drainQueueLaterOnExecutor();\n        }\n      }\n    } else {\n      this.tell(FiberMessage.resume(effect));\n    }\n  }\n  /**\n   * Begins execution of the effect associated with this fiber on in the\n   * background, and on the correct thread pool. This can be called to \"kick\n   * off\" execution of a fiber after it has been created, in hopes that the\n   * effect can be executed synchronously.\n   */\n  startFork(effect) {\n    this.tell(FiberMessage.resume(effect));\n  }\n  /**\n   * Takes the current runtime flags, patches them to return the new runtime\n   * flags, and then makes any changes necessary to fiber state based on the\n   * specified patch.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */\n  patchRuntimeFlags(oldRuntimeFlags, patch) {\n    const newRuntimeFlags = _runtimeFlags.patch(oldRuntimeFlags, patch);\n    globalThis[internalFiber.currentFiberURI] = this;\n    this._runtimeFlags = newRuntimeFlags;\n    return newRuntimeFlags;\n  }\n  /**\n   * Initiates an asynchronous operation, by building a callback that will\n   * resume execution, and then feeding that callback to the registration\n   * function, handling error cases and repeated resumptions appropriately.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */\n  initiateAsync(runtimeFlags, asyncRegister) {\n    let alreadyCalled = false;\n    const callback = effect => {\n      if (!alreadyCalled) {\n        alreadyCalled = true;\n        this.tell(FiberMessage.resume(effect));\n      }\n    };\n    if (_runtimeFlags.interruptible(runtimeFlags)) {\n      this._asyncInterruptor = callback;\n    }\n    try {\n      asyncRegister(callback);\n    } catch (e) {\n      callback(core.failCause(internalCause.die(e)));\n    }\n  }\n  pushStack(cont) {\n    this._stack.push(cont);\n    if (\"trace\" in cont && cont.trace) {\n      this._traceStack.push(cont.trace);\n    }\n  }\n  popStack() {\n    const item = this._stack.pop();\n    if (item) {\n      if (\"trace\" in item && item.trace) {\n        this._traceStack.pop();\n      }\n      return item;\n    }\n    return;\n  }\n  getNextSuccessCont() {\n    let frame = this.popStack();\n    while (frame) {\n      if (frame._tag !== OpCodes.OP_ON_FAILURE && frame._tag !== OpCodes.OP_TRACED) {\n        return frame;\n      }\n      frame = this.popStack();\n    }\n  }\n  getNextFailCont() {\n    let frame = this.popStack();\n    while (frame) {\n      if (frame._tag !== OpCodes.OP_ON_SUCCESS && frame._tag !== OpCodes.OP_WHILE && frame._tag !== OpCodes.OP_TRACED) {\n        return frame;\n      }\n      frame = this.popStack();\n    }\n  }\n  [(_a = internalFiber.FiberTypeId, _b = internalFiber.RuntimeFiberTypeId, OpCodes.OP_SYNC)](op) {\n    const value = op.i0();\n    const cont = this.getNextSuccessCont();\n    if (cont !== undefined) {\n      if (!(cont._tag in contOpSuccess)) {\n        // @ts-expect-error\n        absurd(cont);\n      }\n      // @ts-expect-error\n      return contOpSuccess[cont._tag](this, cont, value);\n    } else {\n      throw core.exitSucceed(value);\n    }\n  }\n  [OpCodes.OP_SUCCESS](op) {\n    const oldCur = op;\n    const cont = this.getNextSuccessCont();\n    if (cont !== undefined) {\n      if (!(cont._tag in contOpSuccess)) {\n        // @ts-expect-error\n        absurd(cont);\n      }\n      // @ts-expect-error\n      return contOpSuccess[cont._tag](this, cont, oldCur.i0);\n    } else {\n      throw oldCur;\n    }\n  }\n  [OpCodes.OP_FAILURE](op) {\n    let cause = op.i0;\n    if (internalCause.isAnnotatedType(cause) && internalCause.isStackAnnotation(cause.annotation)) {\n      const stack = cause.annotation.stack;\n      const currentStack = this.stackToLines();\n      cause = internalCause.annotated(cause.cause, new internalCause.StackAnnotation(Chunk.take(Debug.runtimeDebug.traceStackLimit)(Chunk.dedupeAdjacent(stack.length === 0 ? currentStack : currentStack.length === 0 ? stack : Chunk.unsafeLast(stack) === Chunk.unsafeLast(currentStack) ? stack : Chunk.concat(currentStack)(stack))), cause.annotation.seq));\n    } else {\n      cause = internalCause.annotated(op.i0, new internalCause.StackAnnotation(this.stackToLines(), MRef.getAndIncrement(internalCause.globalErrorSeq)));\n    }\n    const cont = this.getNextFailCont();\n    if (cont !== undefined) {\n      switch (cont._tag) {\n        case OpCodes.OP_ON_FAILURE:\n        case OpCodes.OP_ON_SUCCESS_AND_FAILURE:\n          {\n            if (!(_runtimeFlags.interruptible(this._runtimeFlags) && this.isInterrupted())) {\n              return cont.i1(cause);\n            } else {\n              return core.exitFailCause(internalCause.stripFailures(cause));\n            }\n          }\n        case OpCodes.OP_REVERT_FLAGS:\n          {\n            this.patchRuntimeFlags(this._runtimeFlags, cont.patch);\n            if (_runtimeFlags.interruptible(this._runtimeFlags) && this.isInterrupted()) {\n              return core.exitFailCause(internalCause.sequential(cause, this.getInterruptedCause()));\n            } else {\n              return core.exitFailCause(cause);\n            }\n          }\n        default:\n          {\n            absurd(cont);\n          }\n      }\n    } else {\n      throw core.exitFailCause(cause);\n    }\n  }\n  [OpCodes.OP_WITH_RUNTIME](op) {\n    return op.i0(this, FiberStatus.running(this._runtimeFlags));\n  }\n  [OpCodes.OP_UPDATE_RUNTIME_FLAGS](op) {\n    if (op.i1 === undefined) {\n      this.patchRuntimeFlags(this._runtimeFlags, op.i0);\n      return core.exitUnit();\n    } else {\n      const updateFlags = op.i0;\n      const oldRuntimeFlags = this._runtimeFlags;\n      const newRuntimeFlags = _runtimeFlags.patch(oldRuntimeFlags, updateFlags);\n      if (newRuntimeFlags === oldRuntimeFlags) {\n        // No change, short circuit\n        return op.i1(oldRuntimeFlags);\n      } else {\n        // One more chance to short circuit: if we're immediately going\n        // to interrupt. Interruption will cause immediate reversion of\n        // the flag, so as long as we \"peek ahead\", there's no need to\n        // set them to begin with.\n        if (_runtimeFlags.interruptible(newRuntimeFlags) && this.isInterrupted()) {\n          return core.exitFailCause(this.getInterruptedCause());\n        } else {\n          // Impossible to short circuit, so record the changes\n          this.patchRuntimeFlags(this._runtimeFlags, updateFlags);\n          // Since we updated the flags, we need to revert them\n          const revertFlags = _runtimeFlags.diff(newRuntimeFlags, oldRuntimeFlags);\n          this.pushStack(new core.RevertFlags(revertFlags));\n          return op.i1(oldRuntimeFlags);\n        }\n      }\n    }\n  }\n  [OpCodes.OP_ON_SUCCESS](op) {\n    this.pushStack(op);\n    return op.i0;\n  }\n  [OpCodes.OP_TRACED](op) {\n    this.pushStack(op);\n    return op.i0;\n  }\n  [OpCodes.OP_ON_FAILURE](op) {\n    this.pushStack(op);\n    return op.i0;\n  }\n  [OpCodes.OP_ON_SUCCESS_AND_FAILURE](op) {\n    this.pushStack(op);\n    return op.i0;\n  }\n  [OpCodes.OP_ASYNC](op) {\n    this._asyncBlockingOn = op.i1;\n    this.initiateAsync(this._runtimeFlags, op.i0);\n    throw op;\n  }\n  [OpCodes.OP_YIELD](op) {\n    throw op;\n  }\n  [OpCodes.OP_WHILE](op) {\n    const check = op.i0;\n    const body = op.i1;\n    if (check()) {\n      this.pushStack(op);\n      return body();\n    } else {\n      return core.exitUnit();\n    }\n  }\n  [OpCodes.OP_COMMIT](op) {\n    return op.commit();\n  }\n  /**\n   * The main run-loop for evaluating effects.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */\n  runLoop(effect0) {\n    let cur = effect0;\n    let ops = 0;\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      if (_runtimeFlags.opSupervision(this._runtimeFlags)) {\n        this.getSupervisor().onEffect(this, cur);\n      }\n      cur = this.drainQueueWhileRunning(this._runtimeFlags, cur);\n      ops += 1;\n      if (ops >= 2048) {\n        ops = 0;\n        const oldCur = cur;\n        cur = core.flatMap(() => oldCur)(core.yieldNow());\n      }\n      try {\n        if (!(cur._tag in this)) {\n          // @ts-expect-error\n          absurd(cur);\n        }\n        // @ts-expect-error\n        cur = this[cur._tag](cur);\n      } catch (e) {\n        if (core.isEffect(e)) {\n          if (e._tag === OpCodes.OP_YIELD || e._tag === OpCodes.OP_ASYNC) {\n            throw e;\n          }\n          if (e._tag === OpCodes.OP_SUCCESS || e._tag === OpCodes.OP_FAILURE) {\n            return e;\n          }\n        } else {\n          if (core.isEffectError(e)) {\n            cur = core.exitFailCause(e.cause);\n          } else if (internalCause.isInterruptedException(e)) {\n            cur = core.exitFailCause(internalCause.sequential(internalCause.die(e), internalCause.interrupt(FiberId.none)));\n          } else {\n            cur = core.exitFailCause(internalCause.die(e));\n          }\n        }\n      }\n    }\n  }\n  stackToLines() {\n    if (this._traceStack.length === 0) {\n      return Chunk.empty();\n    }\n    const lines = [];\n    let current = this._traceStack.length - 1;\n    while (current >= 0 && lines.length < Debug.runtimeDebug.traceStackLimit) {\n      const value = this._traceStack[current];\n      lines.push(value);\n      current = current - 1;\n    }\n    return Chunk.unsafeFromArray(lines);\n  }\n}\n// circular with Logger\n/** @internal */\nexports.FiberRuntime = FiberRuntime;\nconst currentMinimumLogLevel = /*#__PURE__*/core.fiberRefUnsafeMake( /*#__PURE__*/LogLevel.fromLiteral(Debug.runtimeDebug.minumumLogLevel));\n/** @internal */\nexports.currentMinimumLogLevel = currentMinimumLogLevel;\nconst defaultLogger = /*#__PURE__*/internalLogger.makeLogger((fiberId, logLevel, message, cause, context, spans, annotations) => {\n  const formatted = internalLogger.stringLogger.log(fiberId, logLevel, message, cause, context, spans, annotations);\n  const filter = fiberRefs.getOrDefault(context, currentMinimumLogLevel);\n  if (LogLevel.greaterThanEqual(filter)(logLevel)) {\n    globalThis.console.log(formatted);\n  }\n});\n/** @internal */\nexports.defaultLogger = defaultLogger;\nconst logFmtLogger = /*#__PURE__*/internalLogger.makeLogger((fiberId, logLevel, message, cause, context, spans, annotations) => {\n  const formatted = internalLogger.logfmtLogger.log(fiberId, logLevel, message, cause, context, spans, annotations);\n  const filter = fiberRefs.getOrDefault(context, currentMinimumLogLevel);\n  if (LogLevel.greaterThanEqual(filter)(logLevel)) {\n    globalThis.console.log(formatted);\n  }\n});\n/** @internal */\nexports.logFmtLogger = logFmtLogger;\nconst currentLoggers = /*#__PURE__*/core.fiberRefUnsafeMakeHashSet( /*#__PURE__*/HashSet.make(defaultLogger));\n// circular with Effect\n/* @internal */\nexports.currentLoggers = currentLoggers;\nconst acquireRelease = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (acquire, release) => core.uninterruptible(core.tap(acquire, a => addFinalizer(exit => restore(release)(a, exit)))).traced(trace));\n/* @internal */\nexports.acquireRelease = acquireRelease;\nconst addFinalizer = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => finalizer => core.flatMap(core.context(), context => core.flatMap(scope(), scope => core.scopeAddFinalizerExit(scope, exit => core.asUnit(core.provideContext(context)(restore(finalizer)(exit)))))).traced(trace));\n/* @internal */\nexports.addFinalizer = addFinalizer;\nconst collect = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (elements, f) => core.map(Chunk.compact)(core.forEach(elements, a => unsome(restore(f)(a)))).traced(trace));\n/* @internal */\nexports.collect = collect;\nconst collectPar = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (elements, f) => core.map(Chunk.compact)(forEachPar(elements, a => unsome(restore(f)(a)))).traced(trace));\n/* @internal */\nexports.collectPar = collectPar;\nconst collectAllPar = /*#__PURE__*/Debug.methodWithTrace(trace => effects => forEachPar(effects, _Function.identity).traced(trace));\n/* @internal */\nexports.collectAllPar = collectAllPar;\nconst collectAllParDiscard = /*#__PURE__*/Debug.methodWithTrace(trace => effects => forEachParDiscard(effects, _Function.identity).traced(trace));\n/* @internal */\nexports.collectAllParDiscard = collectAllParDiscard;\nconst collectAllSuccessesPar = /*#__PURE__*/Debug.methodWithTrace(trace => elements => collectAllWithPar(Array.from(elements).map(core.exit), exit => core.exitIsSuccess(exit) ? Option.some(exit.i0) : Option.none()).traced(trace));\n/* @internal */\nexports.collectAllSuccessesPar = collectAllSuccessesPar;\nconst collectAllWithPar = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (elements, pf) => core.map(collectAllPar(elements), Chunk.filterMap(restore(pf))).traced(trace));\n/* @internal */\nexports.collectAllWithPar = collectAllWithPar;\nconst daemonChildren = /*#__PURE__*/Debug.methodWithTrace(trace => self => {\n  const forkScope = core.fiberRefLocally(core.forkScopeOverride, Option.some(fiberScope.globalScope));\n  return forkScope(self).traced(trace);\n});\n/** @internal */\nexports.daemonChildren = daemonChildren;\nconst _existsParFound = /*#__PURE__*/Symbol(\"@effect/io/Effect/existsPar/found\");\n/* @internal */\nconst existsPar = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (elements, f) => core.matchEffect(forEachPar(elements, a => core.ifEffect(restore(f)(a), core.fail(_existsParFound), core.unit())), e => e === _existsParFound ? core.succeed(true) : core.fail(e), () => core.succeed(false)).traced(trace));\n/* @internal */\nexports.existsPar = existsPar;\nconst filterPar = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (elements, f) => core.map(Chunk.compact)(forEachPar(elements, a => core.map(restore(f)(a), b => b ? Option.some(a) : Option.none()))).traced(trace));\n/* @internal */\nexports.filterPar = filterPar;\nconst filterNotPar = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (elements, f) => filterPar(elements, a => core.map(restore(f)(a), b => !b)).traced(trace));\n/* @internal */\nexports.filterNotPar = filterNotPar;\nconst forEachExec = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (elements, f, strategy) => core.suspend(() => ExecutionStrategy.match(() => core.forEach(restore(f))(elements), () => core.withParallelismUnbounded(forEachPar(restore(f))(elements)), parallelism => core.withParallelism(parallelism)(forEachPar(restore(f))(elements)))(strategy)).traced(trace));\n/* @internal */\nexports.forEachExec = forEachExec;\nconst forEachPar = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => core.fiberRefGetWith(core.currentParallelism, o => o._tag === \"None\" ? forEachParUnbounded(self, restore(f)) : forEachParN(self, o.value, f)).traced(trace));\n/* @internal */\nexports.forEachPar = forEachPar;\nconst forEachParDiscard = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => core.fiberRefGetWith(core.currentParallelism, o => o._tag === \"None\" ? forEachParUnboundedDiscard(self, restore(f)) : forEachParNDiscard(self, o.value, f)).traced(trace));\n/* @internal */\nexports.forEachParDiscard = forEachParDiscard;\nconst forEachParUnbounded = (self, f) => core.suspend(() => {\n  const as = Array.from(self).map((v, i) => [v, i]);\n  const array = new Array(as.length);\n  const fn = ([a, i]) => core.flatMap(f(a), b => core.sync(() => array[i] = b));\n  return core.zipRight(forEachParUnboundedDiscard(as, fn), core.succeed(Chunk.unsafeFromArray(array)));\n});\n/* @internal */\nconst forEachParUnboundedDiscard = (self, f) => core.suspend(() => {\n  const as = Array.from(self);\n  const size = as.length;\n  if (size === 0) {\n    return core.unit();\n  } else if (size === 1) {\n    return core.asUnit(f(as[0]));\n  }\n  return core.uninterruptibleMask(restore => {\n    const deferred = core.deferredUnsafeMake(FiberId.none);\n    let ref = 0;\n    const process = core.transplant(graft => core.forEach(as, a => forkDaemon(graft(core.matchCauseEffect(cause => core.zipRight(core.deferredFail(deferred, void 0), core.failCause(cause)), () => {\n      if (ref + 1 === size) {\n        core.deferredUnsafeDone(deferred, core.unit());\n      } else {\n        ref = ref + 1;\n      }\n      return core.unit();\n    })(restore(core.suspend(() => f(a))))))));\n    return core.flatMap(process, fibers => core.matchCauseEffect(restore(core.deferredAwait(deferred)), cause => core.flatMap(forEachParUnbounded(fibers, core.interruptFiber), exits => {\n      const exit = core.exitCollectAllPar(exits);\n      if (exit._tag === \"Some\" && core.exitIsFailure(exit.value)) {\n        return core.failCause(internalCause.parallel(internalCause.stripFailures(cause), exit.value.i0));\n      } else {\n        return core.failCause(internalCause.stripFailures(cause));\n      }\n    }), () => core.forEachDiscard(fibers, f => f.inheritAll())));\n  });\n});\n/* @internal */\nconst forEachParN = (self, n, f) => core.suspend(() => {\n  const as = Array.from(self).map((v, i) => [v, i]);\n  const array = new Array(as.length);\n  const fn = ([a, i]) => core.map(f(a), b => array[i] = b);\n  return core.zipRight(forEachParNDiscard(as, n, fn), core.succeed(Chunk.unsafeFromArray(array)));\n});\n/* @internal */\nconst forEachParNDiscard = (self, n, f) => core.suspend(() => {\n  const iterator = self[Symbol.iterator]();\n  const worker = core.flatMap(core.sync(() => iterator.next()), next => next.done ? core.unit() : core.flatMap(core.asUnit(f(next.value)), () => worker));\n  const effects = [];\n  for (let i = 0; i < n; i++) {\n    effects.push(worker);\n  }\n  return forEachParUnboundedDiscard(effects, _Function.identity);\n});\n/* @internal */\nconst forEachParWithIndex = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (elements, f) => core.suspend(() => core.flatMap(core.sync(() => []), array => core.map(forEachParDiscard(Array.from(elements).map((a, i) => [a, i]), ([a, i]) => core.flatMap(core.suspend(() => restore(f)(a, i)), b => core.sync(() => {\n  array[i] = b;\n}))), () => Chunk.unsafeFromArray(array)))).traced(trace));\n/* @internal */\nexports.forEachParWithIndex = forEachParWithIndex;\nconst fork = /*#__PURE__*/Debug.methodWithTrace(trace => self => core.withFiberRuntime((state, status) => core.succeed(unsafeFork(self, state, status.runtimeFlags))).traced(trace));\n/* @internal */\nexports.fork = fork;\nconst forkAllDiscard = /*#__PURE__*/Debug.methodWithTrace(trace => effects => core.forEachDiscard(effects, fork).traced(trace));\n/* @internal */\nexports.forkAllDiscard = forkAllDiscard;\nconst forkDaemon = /*#__PURE__*/Debug.methodWithTrace(trace => self => forkWithScopeOverride(self, fiberScope.globalScope).traced(trace));\n/* @internal */\nexports.forkDaemon = forkDaemon;\nconst forkWithErrorHandler = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, handler) => fork(core.onError(self, cause => {\n  const either = internalCause.failureOrCause(cause);\n  switch (either._tag) {\n    case \"Left\":\n      {\n        return restore(handler)(either.left);\n      }\n    case \"Right\":\n      {\n        return core.failCause(either.right);\n      }\n  }\n})).traced(trace));\n/** @internal */\nexports.forkWithErrorHandler = forkWithErrorHandler;\nconst unsafeFork = (effect, parentFiber, parentRuntimeFlags, overrideScope = null) => {\n  const childFiber = unsafeMakeChildFiber(effect, parentFiber, parentRuntimeFlags, overrideScope);\n  childFiber.resume(effect);\n  return childFiber;\n};\n/** @internal */\nexports.unsafeFork = unsafeFork;\nconst unsafeMakeChildFiber = (effect, parentFiber, parentRuntimeFlags, overrideScope = null) => {\n  const childId = FiberId.unsafeMake();\n  const parentFiberRefs = parentFiber.unsafeGetFiberRefs();\n  const childFiberRefs = fiberRefs.forkAs(parentFiberRefs, childId);\n  const childFiber = new FiberRuntime(childId, childFiberRefs, parentRuntimeFlags);\n  const childContext = fiberRefs.getOrDefault(childFiberRefs, core.currentContext);\n  const supervisor = childFiber.getSupervisor();\n  supervisor.onStart(childContext, effect, Option.some(parentFiber), childFiber);\n  childFiber.unsafeAddObserver(exit => supervisor.onEnd(exit, childFiber));\n  const parentScope = overrideScope !== null ? overrideScope : Option.getOrElse(() => parentFiber.scope())(parentFiber.getFiberRef(core.forkScopeOverride));\n  parentScope.add(parentRuntimeFlags, childFiber);\n  return childFiber;\n};\n/* @internal */\nexports.unsafeMakeChildFiber = unsafeMakeChildFiber;\nconst forkWithScopeOverride = (self, scopeOverride) => core.withFiberRuntime((parentFiber, parentStatus) => core.succeed(unsafeFork(self, parentFiber, parentStatus.runtimeFlags, scopeOverride)));\n/* @internal */\nconst mergeAllPar = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (elements, zero, f) => core.flatMap(Ref.make(zero), acc => core.flatMap(forEachParDiscard(elements, core.flatMap(a => Ref.update(acc, b => restore(f)(b, a)))), () => Ref.get(acc))).traced(trace));\n/* @internal */\nexports.mergeAllPar = mergeAllPar;\nconst onDone = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restoreTrace) => (self, onError, onSuccess) => core.uninterruptibleMask(restore => core.asUnit(forkDaemon(core.matchEffect(restore(self), e => restore(restoreTrace(onError)(e)), a => restore(restoreTrace(onSuccess)(a))))).traced(trace)));\n/* @internal */\nexports.onDone = onDone;\nconst onDoneCause = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restoreTrace) => (self, onCause, onSuccess) => core.uninterruptibleMask(restore => core.asUnit(forkDaemon(core.matchCauseEffect(restore(self), c => restore(restoreTrace(onCause)(c)), a => restore(restoreTrace(onSuccess)(a)))))).traced(trace));\n/* @internal */\nexports.onDoneCause = onDoneCause;\nconst partitionPar = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (elements, f) => core.map(chunk => core.partitionMap(chunk, _Function.identity))(forEachPar(elements, a => core.either(restore(f)(a)))).traced(trace));\n/* @internal */\nexports.partitionPar = partitionPar;\nconst raceAll = /*#__PURE__*/Debug.methodWithTrace(trace => all => {\n  const list = Chunk.fromIterable(all);\n  if (!Chunk.isNonEmpty(list)) {\n    return core.dieSync(() => internalCause.IllegalArgumentException(`Received an empty collection of effects`));\n  }\n  const self = Chunk.headNonEmpty(list);\n  const effects = Chunk.tailNonEmpty(list);\n  const inheritAll = res => core.as(res[0])(internalFiber.inheritAll(res[1]));\n  return core.flatMap(done => core.flatMap(fails => core.uninterruptibleMask(restore => core.flatMap(head => core.flatMap(fibers => core.onInterrupt(() => Chunk.reduce(core.unit(), (effect, fiber) => core.zipLeft(core.interruptFiber(fiber))(effect))(fibers))(restore(core.flatMap(inheritAll)(Deferred.await(done)))))(core.tap(fibers => Chunk.reduce(core.unit(), (effect, fiber) => core.zipRight(core.asUnit(fork(core.flatMap(raceAllArbiter(fibers, fiber, done, fails))(internalFiber._await(fiber)))))(effect))(fibers))(core.map(tail => Chunk.prepend(head)(tail))(core.forEach(effect => fork(core.interruptible(effect)))(effects)))))(fork(core.interruptible(self)))))(Ref.make(effects.length)))(core.deferredMake()).traced(trace);\n});\n/* @internal */\nexports.raceAll = raceAll;\nconst raceAllArbiter = (fibers, winner, deferred, fails) => exit => core.exitMatchEffect(cause => core.flatten(Ref.modify(fails, fails => [fails === 0 ? core.asUnit(core.deferredFailCause(deferred, cause)) : core.unit(), fails - 1])), value => core.flatMap(set => set ? Chunk.reduce(core.unit(), (effect, fiber) => fiber === winner ? effect : core.zipLeft(core.interruptFiber(fiber))(effect))(fibers) : core.unit())(core.deferredSucceed(deferred, [value, winner])))(exit);\n/* @internal */\nconst reduceAllPar = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (elements, zero, f) => core.suspend(() => core.map(option => {\n  switch (option._tag) {\n    case \"None\":\n      {\n        throw new Error(\"BUG: Effect.reduceAllPar - please report an issue at https://github.com/Effect-TS/io/issues\");\n      }\n    case \"Some\":\n      {\n        return option.value;\n      }\n  }\n})(mergeAllPar([zero, ...Array.from(elements)], Option.none(), (acc, elem) => {\n  switch (acc._tag) {\n    case \"None\":\n      {\n        return Option.some(elem);\n      }\n    case \"Some\":\n      {\n        return Option.some(restore(f)(acc.value, elem));\n      }\n  }\n}))).traced(trace));\n/* @internal */\nexports.reduceAllPar = reduceAllPar;\nconst parallelFinalizers = /*#__PURE__*/Debug.methodWithTrace(trace => self => core.flatMap(scope(), outerScope => core.flatMap(scopeMake(ExecutionStrategy.parallel), innerScope => core.zipRight(scopeExtend(innerScope)(self))(outerScope.addFinalizer(exit => innerScope.close(exit))))).traced(trace));\n/* @internal */\nexports.parallelFinalizers = parallelFinalizers;\nconst scope = /*#__PURE__*/Debug.methodWithTrace(trace => () => core.service(scopeTag).traced(trace));\n/* @internal */\nexports.scope = scope;\nconst scopeWith = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => f => core.serviceWithEffect(scopeTag, restore(f)).traced(trace));\n/* @internal */\nexports.scopeWith = scopeWith;\nconst scopedEffect = /*#__PURE__*/Debug.methodWithTrace(trace => effect => core.flatMap(scopeMake(), scope => scopeUse(scope)(effect)).traced(trace));\n/* @internal */\nexports.scopedEffect = scopedEffect;\nconst sequentialFinalizers = /*#__PURE__*/Debug.methodWithTrace(trace => self => scopeWith(scope => core.flatMap(scope => scopeExtend(scope)(self))(core.scopeFork(scope, ExecutionStrategy.sequential))).traced(trace));\n/* @internal */\nexports.sequentialFinalizers = sequentialFinalizers;\nconst some = /*#__PURE__*/Debug.methodWithTrace(trace => self => core.matchEffect(self, e => core.fail(Option.some(e)), option => {\n  switch (option._tag) {\n    case \"None\":\n      {\n        return core.fail(Option.none());\n      }\n    case \"Some\":\n      {\n        return core.succeed(option.value);\n      }\n  }\n}).traced(trace));\n/* @internal */\nexports.some = some;\nconst someWith = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => core.suspend(() => unsome(restore(f)(some(self)))).traced(trace));\n/* @internal */\nexports.someWith = someWith;\nconst allPar = /*#__PURE__*/Debug.methodWithTrace(trace => function () {\n  if (arguments.length === 1) {\n    if (core.isEffect(arguments[0])) {\n      return core.map(arguments[0], x => [x]);\n    } else if (Array.isArray(arguments[0])) {\n      return core.map(collectAllPar(arguments[0]), Chunk.toReadonlyArray).traced(trace);\n    } else {\n      return core.map(values => {\n        const res = {};\n        for (const [k, v] of values) {\n          ;\n          res[k] = v;\n        }\n        return res;\n      })(forEachPar(Object.entries(arguments[0]), ([_, e]) => core.map(e, a => [_, a]))).traced(trace);\n    }\n  }\n  return core.map(collectAllPar(arguments), Chunk.toReadonlyArray).traced(trace);\n});\n/* @internal */\nexports.allPar = allPar;\nconst taggedScoped = /*#__PURE__*/Debug.methodWithTrace(trace => (key, value) => taggedScopedWithLabels([metricLabel.make(key, value)]).traced(trace));\n/* @internal */\nexports.taggedScoped = taggedScoped;\nconst taggedScopedWithLabels = /*#__PURE__*/Debug.methodWithTrace(trace => labels => taggedScopedWithLabelSet(HashSet.fromIterable(labels)).traced(trace));\n/* @internal */\nexports.taggedScopedWithLabels = taggedScopedWithLabels;\nconst taggedScopedWithLabelSet = /*#__PURE__*/Debug.methodWithTrace(trace => labels => fiberRefLocallyScopedWith(core.currentTags, set => HashSet.union(labels)(set)).traced(trace));\n/* @internal */\nexports.taggedScopedWithLabelSet = taggedScopedWithLabelSet;\nconst using = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, use) => core.acquireUseRelease(scopeMake(), scope => core.flatMap(restore(use))(scopeExtend(scope)(self)), (scope, exit) => core.scopeClose(scope, exit)).traced(trace));\n/* @internal */\nexports.using = using;\nconst unsome = /*#__PURE__*/Debug.methodWithTrace(trace => self => core.matchEffect(self, option => {\n  switch (option._tag) {\n    case \"None\":\n      {\n        return core.succeed(Option.none());\n      }\n    case \"Some\":\n      {\n        return core.fail(option.value);\n      }\n  }\n}, a => core.succeed(Option.some(a))).traced(trace));\n/* @internal */\nexports.unsome = unsome;\nconst validateAllPar = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (elements, f) => core.flatMap(partitionPar(elements, restore(f)), ([es, bs]) => Chunk.isEmpty(es) ? core.succeed(bs) : core.fail(es)).traced(trace));\n/* @internal */\nexports.validateAllPar = validateAllPar;\nconst validateAllParDiscard = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (elements, f) => core.flatMap(partitionPar(elements, restore(f)), ([es, _]) => Chunk.isEmpty(es) ? core.unit() : core.fail(es)).traced(trace));\n/* @internal */\nexports.validateAllParDiscard = validateAllParDiscard;\nconst validateFirstPar = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (elements, f) => core.flip(forEachPar(elements, a => core.flip(restore(f)(a)))).traced(trace));\n/* @internal */\nexports.validateFirstPar = validateFirstPar;\nconst withClockScoped = /*#__PURE__*/Debug.methodWithTrace(trace => value => fiberRefLocallyScopedWith(defaultServices.currentServices, Context.add(clock.clockTag, value)).traced(trace));\n/* @internal */\nexports.withClockScoped = withClockScoped;\nconst withConfigProviderScoped = /*#__PURE__*/Debug.methodWithTrace(trace => value => fiberRefLocallyScopedWith(defaultServices.currentServices, Context.add(_configProvider.configProviderTag, value)).traced(trace));\n/* @internal */\nexports.withConfigProviderScoped = withConfigProviderScoped;\nconst withEarlyRelease = /*#__PURE__*/Debug.methodWithTrace(trace => self => scopeWith(parent => core.flatMap(core.scopeFork(parent, ExecutionStrategy.sequential), child => core.map(value => [core.fiberIdWith(fiberId => core.scopeClose(child, core.exitInterrupt(fiberId))), value])(scopeExtend(child)(self)))).traced(trace));\n/* @internal */\nexports.withEarlyRelease = withEarlyRelease;\nconst withRuntimeFlagsScoped = /*#__PURE__*/Debug.methodWithTrace(trace => update => {\n  if (update === RuntimeFlagsPatch.empty) {\n    return core.unit();\n  }\n  return core.uninterruptible(core.flatMap(runtimeFlags => {\n    const updatedRuntimeFlags = _runtimeFlags.patch(runtimeFlags, update);\n    const revertRuntimeFlags = _runtimeFlags.diff(updatedRuntimeFlags, runtimeFlags);\n    return core.asUnit(core.zipRight(addFinalizer(() => core.updateRuntimeFlags(revertRuntimeFlags)))(core.updateRuntimeFlags(update)));\n  })(core.runtimeFlags())).traced(trace);\n});\n// circular with ReleaseMap\n/* @internal */\nexports.withRuntimeFlagsScoped = withRuntimeFlagsScoped;\nconst releaseMapReleaseAll = (strategy, exit) => self => core.suspend(() => {\n  switch (self.state._tag) {\n    case \"Exited\":\n      {\n        return core.unit();\n      }\n    case \"Running\":\n      {\n        const finalizersMap = self.state.finalizers;\n        const update = self.state.update;\n        const finalizers = Array.from(finalizersMap.keys()).sort((a, b) => b - a).map(key => finalizersMap.get(key));\n        self.state = {\n          _tag: \"Exited\",\n          nextKey: self.state.nextKey,\n          exit,\n          update\n        };\n        return ExecutionStrategy.isSequential(strategy) ? core.flatMap(results => Option.getOrElse(() => core.exitUnit())(Option.map(core.exitAsUnit)(core.exitCollectAll(results))))(core.forEach(fin => core.exit(update(fin)(exit)))(finalizers)) : ExecutionStrategy.isParallel(strategy) ? core.flatMap(results => Option.getOrElse(() => core.exitUnit())(Option.map(core.exitAsUnit)(core.exitCollectAllPar(results))))(forEachPar(fin => core.exit(update(fin)(exit)))(finalizers)) : core.withParallelism(strategy.parallelism)(core.flatMap(results => Option.getOrElse(() => core.exitUnit())(Option.map(core.exitAsUnit)(core.exitCollectAllPar(results))))(forEachPar(fin => core.exit(update(fin)(exit)))(finalizers)));\n      }\n  }\n});\n// circular with Scope\n/** @internal */\nexports.releaseMapReleaseAll = releaseMapReleaseAll;\nconst scopeTag = /*#__PURE__*/Context.Tag();\n/* @internal */\nexports.scopeTag = scopeTag;\nconst scopeMake = /*#__PURE__*/Debug.methodWithTrace(trace => (strategy = ExecutionStrategy.sequential) => core.map(core.releaseMapMake(), rm => ({\n  [core.ScopeTypeId]: core.ScopeTypeId,\n  [core.CloseableScopeTypeId]: core.CloseableScopeTypeId,\n  fork: strategy => Debug.bodyWithTrace(trace => core.uninterruptible(core.flatMap(scope => core.as(scope)(core.tap(fin => core.scopeAddFinalizerExit(scope, fin))(core.releaseMapAdd(exit => core.scopeClose(scope, exit))(rm))))(scopeMake(strategy))).traced(trace)),\n  close: exit => Debug.bodyWithTrace(trace => core.asUnit(releaseMapReleaseAll(strategy, exit)(rm)).traced(trace)),\n  addFinalizer: fin => Debug.bodyWithTrace(trace => core.asUnit(core.releaseMapAdd(fin)(rm)).traced(trace))\n})).traced(trace));\n/* @internal */\nexports.scopeMake = scopeMake;\nconst scopeExtend = /*#__PURE__*/Debug.dualWithTrace(2, trace => (effect, scope) => core.contramapContext(effect,\n// @ts-expect-error\nContext.merge(Context.make(scopeTag, scope))).traced(trace));\n/* @internal */\nexports.scopeExtend = scopeExtend;\nconst scopeUse = /*#__PURE__*/Debug.dualWithTrace(2, trace => (effect, scope) => core.onExit(exit => scope.close(exit))(scopeExtend(scope)(effect)).traced(trace));\n// circular with Supervisor\n/** @internal */\nexports.scopeUse = scopeUse;\nconst fiberRefUnsafeMakeSupervisor = initial => core.fiberRefUnsafeMakePatch(initial, SupervisorPatch.differ, SupervisorPatch.empty);\n// circular with FiberRef\n/* @internal */\nexports.fiberRefUnsafeMakeSupervisor = fiberRefUnsafeMakeSupervisor;\nconst fiberRefLocallyScoped = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, value) => core.asUnit(acquireRelease(core.flatMap(oldValue => core.as(oldValue)(core.fiberRefSet(self, value)))(core.fiberRefGet(self)), oldValue => core.fiberRefSet(self, oldValue))).traced(trace));\n/* @internal */\nexports.fiberRefLocallyScoped = fiberRefLocallyScoped;\nconst fiberRefLocallyScopedWith = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => core.fiberRefGetWith(self, a => fiberRefLocallyScoped(self, restore(f)(a))).traced(trace));\n/* @internal */\nexports.fiberRefLocallyScopedWith = fiberRefLocallyScopedWith;\nconst fiberRefMake = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => (initial, fork = _Function.identity, join = (_, a) => a) => fiberRefMakeWith(() => core.fiberRefUnsafeMake(initial, restore(fork), restore(join))).traced(trace));\n/* @internal */\nexports.fiberRefMake = fiberRefMake;\nconst fiberRefMakeWith = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => ref => acquireRelease(core.tap(core.sync(restore(ref)), ref => core.fiberRefUpdate(ref, _Function.identity)), fiberRef => core.fiberRefDelete(fiberRef)).traced(trace));\n/* @internal */\nexports.fiberRefMakeWith = fiberRefMakeWith;\nconst fiberRefMakeContext = /*#__PURE__*/Debug.methodWithTrace(trace => initial => fiberRefMakeWith(() => core.fiberRefUnsafeMakeContext(initial)).traced(trace));\n/* @internal */\nexports.fiberRefMakeContext = fiberRefMakeContext;\nconst fiberRefMakeRuntimeFlags = /*#__PURE__*/Debug.methodWithTrace(trace => initial => fiberRefMakeWith(() => core.fiberRefUnsafeMakeRuntimeFlags(initial)).traced(trace));\n/** @internal */\nexports.fiberRefMakeRuntimeFlags = fiberRefMakeRuntimeFlags;\nconst currentRuntimeFlags = /*#__PURE__*/core.fiberRefUnsafeMakeRuntimeFlags(_runtimeFlags.none);\n/** @internal */\nexports.currentRuntimeFlags = currentRuntimeFlags;\nconst currentSupervisor = /*#__PURE__*/fiberRefUnsafeMakeSupervisor(supervisor.none);\n// circular with Fiber\n/* @internal */\nexports.currentSupervisor = currentSupervisor;\nconst fiberAwaitAll = /*#__PURE__*/Debug.methodWithTrace(trace => fibers => core.asUnit(internalFiber._await(fiberCollectAll(fibers))).traced(trace));\n/** @internal */\nexports.fiberAwaitAll = fiberAwaitAll;\nconst fiberCollectAll = fibers => ({\n  [internalFiber.FiberTypeId]: internalFiber.fiberVariance,\n  id: () => Array.from(fibers).reduce((id, fiber) => FiberId.combine(id, fiber.id()), FiberId.none),\n  await: Debug.methodWithTrace(trace => () => core.exit(forEachPar(fibers, fiber => core.flatten(fiber.await()))).traced(trace)),\n  children: Debug.methodWithTrace(trace => () => core.map(forEachPar(fibers, fiber => fiber.children()), Chunk.flatten).traced(trace)),\n  inheritAll: Debug.methodWithTrace(trace => () => core.forEachDiscard(fibers, fiber => fiber.inheritAll()).traced(trace)),\n  poll: Debug.methodWithTrace(trace => () => core.map(core.forEach(fibers, fiber => fiber.poll()), Chunk.reduceRight(Option.some(core.exitSucceed(Chunk.empty())), (optionB, optionA) => {\n    switch (optionA._tag) {\n      case \"None\":\n        {\n          return Option.none();\n        }\n      case \"Some\":\n        {\n          switch (optionB._tag) {\n            case \"None\":\n              {\n                return Option.none();\n              }\n            case \"Some\":\n              {\n                return Option.some(core.exitZipWith(optionB.value, (a, chunk) => Chunk.prepend(a)(chunk), internalCause.parallel)(optionA.value));\n              }\n          }\n        }\n    }\n  })).traced(trace)),\n  interruptAsFork: Debug.methodWithTrace(trace => fiberId => core.forEachDiscard(fibers, fiber => fiber.interruptAsFork(fiberId)).traced(trace))\n});\n/* @internal */\nexports.fiberCollectAll = fiberCollectAll;\nconst fiberInterruptFork = /*#__PURE__*/Debug.methodWithTrace(trace => self => core.asUnit(forkDaemon(core.interruptFiber(self))).traced(trace));\n/* @internal */\nexports.fiberInterruptFork = fiberInterruptFork;\nconst fiberJoinAll = /*#__PURE__*/Debug.methodWithTrace(trace => fibers => core.asUnit(internalFiber.join(fiberCollectAll(fibers))).traced(trace));\n/* @internal */\nexports.fiberJoinAll = fiberJoinAll;\nconst fiberScoped = /*#__PURE__*/Debug.methodWithTrace(trace => self => acquireRelease(core.succeed(self), core.interruptFiber).traced(trace));\nexports.fiberScoped = fiberScoped;\n//# sourceMappingURL=fiberRuntime.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.unsafeMake = exports.globalScope = exports.FiberScopeTypeId = void 0;\nvar _Global = /*#__PURE__*/require(\"@effect/data/Global\");\nvar FiberId = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Fiber/Id\"));\nvar FiberMessage = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/fiberMessage\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\nvar _a, _b;\n/** @internal */\nconst FiberScopeSymbolKey = \"@effect/io/Fiber/Scope\";\n/** @internal */\nconst FiberScopeTypeId = /*#__PURE__*/Symbol.for(FiberScopeSymbolKey);\n/** @internal */\nexports.FiberScopeTypeId = FiberScopeTypeId;\nclass Global {\n  constructor() {\n    this[_a] = FiberScopeTypeId;\n    this.fiberId = FiberId.none;\n    this.roots = new Set();\n  }\n  add(_runtimeFlags, child) {\n    this.roots.add(child);\n    child.unsafeAddObserver(() => {\n      this.roots.delete(child);\n    });\n  }\n}\n_a = FiberScopeTypeId;\n/** @internal */\nclass Local {\n  constructor(fiberId, parent) {\n    this.fiberId = fiberId;\n    this.parent = parent;\n    this[_b] = FiberScopeTypeId;\n  }\n  add(_runtimeFlags, child) {\n    this.parent.tell(FiberMessage.stateful(parentFiber => {\n      parentFiber.addChild(child);\n      child.unsafeAddObserver(() => {\n        parentFiber.removeChild(child);\n      });\n    }));\n  }\n}\n_b = FiberScopeTypeId;\n/** @internal */\nconst unsafeMake = fiber => {\n  return new Local(fiber.id(), fiber);\n};\n/** @internal */\nexports.unsafeMake = unsafeMake;\nconst globalScope = /*#__PURE__*/(0, _Global.globalValue)( /*#__PURE__*/Symbol.for(\"@effect/io/FiberScope/Global\"), () => new Global());\nexports.globalScope = globalScope;\n//# sourceMappingURL=fiberScope.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.suspended = exports.running = exports.isSuspended = exports.isRunning = exports.isFiberStatus = exports.isDone = exports.done = exports.OP_SUSPENDED = exports.OP_RUNNING = exports.OP_DONE = exports.FiberStatusTypeId = void 0;\nvar Equal = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Equal\"));\nvar Hash = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Hash\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\nvar _a, _b, _c;\nconst FiberStatusSymbolKey = \"@effect/io/Fiber/Status\";\n/** @internal */\nconst FiberStatusTypeId = /*#__PURE__*/Symbol.for(FiberStatusSymbolKey);\n/** @internal */\nexports.FiberStatusTypeId = FiberStatusTypeId;\nconst OP_DONE = \"Done\";\n/** @internal */\nexports.OP_DONE = OP_DONE;\nconst OP_RUNNING = \"Running\";\n/** @internal */\nexports.OP_RUNNING = OP_RUNNING;\nconst OP_SUSPENDED = \"Suspended\";\n/** @internal */\nexports.OP_SUSPENDED = OP_SUSPENDED;\nclass Done {\n  constructor() {\n    this[_a] = FiberStatusTypeId;\n    this._tag = OP_DONE;\n  }\n  [(_a = FiberStatusTypeId, Hash.symbol)]() {\n    return Hash.combine(Hash.hash(this._tag))(Hash.hash(FiberStatusSymbolKey));\n  }\n  [Equal.symbol](that) {\n    return isFiberStatus(that) && that._tag === OP_DONE;\n  }\n}\n/** @internal */\nclass Running {\n  constructor(runtimeFlags) {\n    this.runtimeFlags = runtimeFlags;\n    this[_b] = FiberStatusTypeId;\n    this._tag = OP_RUNNING;\n  }\n  [(_b = FiberStatusTypeId, Hash.symbol)]() {\n    return Hash.combine(Hash.hash(this.runtimeFlags))(Hash.combine(Hash.hash(this._tag))(Hash.hash(FiberStatusSymbolKey)));\n  }\n  [Equal.symbol](that) {\n    return isFiberStatus(that) && that._tag === OP_RUNNING && this.runtimeFlags === that.runtimeFlags;\n  }\n}\n/** @internal */\nclass Suspended {\n  constructor(runtimeFlags, blockingOn) {\n    this.runtimeFlags = runtimeFlags;\n    this.blockingOn = blockingOn;\n    this[_c] = FiberStatusTypeId;\n    this._tag = OP_SUSPENDED;\n  }\n  [(_c = FiberStatusTypeId, Hash.symbol)]() {\n    return Hash.combine(Hash.hash(this.blockingOn))(Hash.combine(Hash.hash(this.runtimeFlags))(Hash.combine(Hash.hash(this._tag))(Hash.hash(FiberStatusSymbolKey))));\n  }\n  [Equal.symbol](that) {\n    return isFiberStatus(that) && that._tag === OP_SUSPENDED && this.runtimeFlags === that.runtimeFlags && Equal.equals(this.blockingOn, that.blockingOn);\n  }\n}\n/** @internal */\nconst done = /*#__PURE__*/new Done();\n/** @internal */\nexports.done = done;\nconst running = runtimeFlags => new Running(runtimeFlags);\n/** @internal */\nexports.running = running;\nconst suspended = (runtimeFlags, blockingOn) => new Suspended(runtimeFlags, blockingOn);\n/** @internal */\nexports.suspended = suspended;\nconst isFiberStatus = u => typeof u === \"object\" && u != null && FiberStatusTypeId in u;\n/** @internal */\nexports.isFiberStatus = isFiberStatus;\nconst isDone = self => self._tag === OP_DONE;\n/** @internal */\nexports.isDone = isDone;\nconst isRunning = self => self._tag === OP_RUNNING;\n/** @internal */\nexports.isRunning = isRunning;\nconst isSuspended = self => self._tag === OP_SUSPENDED;\nexports.isSuspended = isSuspended;\n//# sourceMappingURL=fiberStatus.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.unsafeMakeSubscription = exports.unsafeMakeHub = exports.unbounded = exports.subscribe = exports.sliding = exports.size = exports.shutdown = exports.publishAll = exports.publish = exports.makeHub = exports.isShutdown = exports.isFull = exports.isEmpty = exports.dropping = exports.capacity = exports.bounded = exports.awaitShutdown = exports.SlidingStrategy = exports.DroppingStrategy = void 0;\nvar Chunk = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Chunk\"));\nvar MutableQueue = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/MutableQueue\"));\nvar MutableRef = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/MutableRef\"));\nvar Debug = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Debug\"));\nvar cause = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/cause\"));\nvar core = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/core\"));\nvar fiberRuntime = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/fiberRuntime\"));\nvar queue = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/queue\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\nvar _a, _b;\nconst addSubscribers = (subscription, pollers) => subscribers => {\n  if (!subscribers.has(subscription)) {\n    subscribers.set(subscription, new Set());\n  }\n  const set = subscribers.get(subscription);\n  set.add(pollers);\n};\nconst removeSubscribers = (subscription, pollers) => subscribers => {\n  if (!subscribers.has(subscription)) {\n    return;\n  }\n  const set = subscribers.get(subscription);\n  set.delete(pollers);\n  if (set.size === 0) {\n    subscribers.delete(subscription);\n  }\n};\n/** @internal */\nconst bounded = /*#__PURE__*/Debug.methodWithTrace(trace => requestedCapacity => core.flatMap(atomicHub => makeHub(atomicHub, new BackPressureStrategy()))(core.sync(() => makeBoundedHub(requestedCapacity))).traced(trace));\n/** @internal */\nexports.bounded = bounded;\nconst dropping = /*#__PURE__*/Debug.methodWithTrace(trace => requestedCapacity => core.flatMap(atomicHub => makeHub(atomicHub, new DroppingStrategy()))(core.sync(() => makeBoundedHub(requestedCapacity))).traced(trace));\n/** @internal */\nexports.dropping = dropping;\nconst sliding = /*#__PURE__*/Debug.methodWithTrace(trace => requestedCapacity => core.flatMap(atomicHub => makeHub(atomicHub, new SlidingStrategy()))(core.sync(() => makeBoundedHub(requestedCapacity))).traced(trace));\n/** @internal */\nexports.sliding = sliding;\nconst unbounded = /*#__PURE__*/Debug.methodWithTrace(trace => () => core.flatMap(atomicHub => makeHub(atomicHub, new DroppingStrategy()))(core.sync(() => makeUnboundedHub())).traced(trace));\n/** @internal */\nexports.unbounded = unbounded;\nconst capacity = self => {\n  return self.capacity();\n};\n/** @internal */\nexports.capacity = capacity;\nconst size = /*#__PURE__*/Debug.methodWithTrace(trace => self => self.size().traced(trace));\n/** @internal */\nexports.size = size;\nconst isFull = /*#__PURE__*/Debug.methodWithTrace(trace => self => self.isFull().traced(trace));\n/** @internal */\nexports.isFull = isFull;\nconst isEmpty = /*#__PURE__*/Debug.methodWithTrace(trace => self => self.isEmpty().traced(trace));\n/** @internal */\nexports.isEmpty = isEmpty;\nconst shutdown = /*#__PURE__*/Debug.methodWithTrace(trace => self => self.shutdown().traced(trace));\n/** @internal */\nexports.shutdown = shutdown;\nconst isShutdown = /*#__PURE__*/Debug.methodWithTrace(trace => self => self.isShutdown().traced(trace));\n/** @internal */\nexports.isShutdown = isShutdown;\nconst awaitShutdown = /*#__PURE__*/Debug.methodWithTrace(trace => self => self.awaitShutdown().traced(trace));\n/** @internal */\nexports.awaitShutdown = awaitShutdown;\nconst publish = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, value) => self.publish(value).traced(trace));\n/** @internal */\nexports.publish = publish;\nconst publishAll = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, elements) => self.publishAll(elements).traced(trace));\n/** @internal */\nexports.publishAll = publishAll;\nconst subscribe = /*#__PURE__*/Debug.methodWithTrace(trace => self => self.subscribe().traced(trace));\n/** @internal */\nexports.subscribe = subscribe;\nconst makeBoundedHub = requestedCapacity => {\n  ensureCapacity(requestedCapacity);\n  if (requestedCapacity === 1) {\n    return new BoundedHubSingle();\n  } else if (nextPow2(requestedCapacity) === requestedCapacity) {\n    return new BoundedHubPow2(requestedCapacity);\n  } else {\n    return new BoundedHubArb(requestedCapacity);\n  }\n};\n/** @internal */\nconst makeUnboundedHub = () => {\n  return new UnboundedHub();\n};\n/** @internal */\nconst makeSubscription = /*#__PURE__*/Debug.methodWithTrace(trace => (hub, subscribers, strategy) => core.map(core.deferredMake(), deferred => unsafeMakeSubscription(hub, subscribers, hub.subscribe(), MutableQueue.unbounded(), deferred, MutableRef.make(false), strategy)).traced(trace));\n/** @internal */\nconst unsafeMakeSubscription = (hub, subscribers, subscription, pollers, shutdownHook, shutdownFlag, strategy) => {\n  return new SubscriptionImpl(hub, subscribers, subscription, pollers, shutdownHook, shutdownFlag, strategy);\n};\n/** @internal */\nexports.unsafeMakeSubscription = unsafeMakeSubscription;\nclass BoundedHubArb {\n  constructor(requestedCapacity) {\n    this.publisherIndex = 0;\n    this.subscriberCount = 0;\n    this.subscribersIndex = 0;\n    this.array = Array.from({\n      length: requestedCapacity\n    });\n    this.subscribers = Array.from({\n      length: requestedCapacity\n    });\n    this.capacity = requestedCapacity;\n  }\n  isEmpty() {\n    return this.publisherIndex === this.subscribersIndex;\n  }\n  isFull() {\n    return this.publisherIndex === this.subscribersIndex + this.capacity;\n  }\n  size() {\n    return this.publisherIndex - this.subscribersIndex;\n  }\n  publish(value) {\n    if (this.isFull()) {\n      return false;\n    }\n    if (this.subscriberCount !== 0) {\n      const index = this.publisherIndex % this.capacity;\n      this.array[index] = value;\n      this.subscribers[index] = this.subscriberCount;\n      this.publisherIndex += 1;\n    }\n    return true;\n  }\n  publishAll(elements) {\n    const chunk = Chunk.fromIterable(elements);\n    const n = chunk.length;\n    const size = this.publisherIndex - this.subscribersIndex;\n    const available = this.capacity - size;\n    const forHub = Math.min(n, available);\n    if (forHub === 0) {\n      return chunk;\n    }\n    let iteratorIndex = 0;\n    const publishAllIndex = this.publisherIndex + forHub;\n    while (this.publisherIndex !== publishAllIndex) {\n      const a = Chunk.unsafeGet(iteratorIndex++)(chunk);\n      const index = this.publisherIndex % this.capacity;\n      this.array[index] = a;\n      this.subscribers[index] = this.subscriberCount;\n      this.publisherIndex += 1;\n    }\n    return Chunk.drop(iteratorIndex - 1)(chunk);\n  }\n  slide() {\n    if (this.subscribersIndex !== this.publisherIndex) {\n      const index = this.subscribersIndex % this.capacity;\n      this.array[index] = null;\n      this.subscribers[index] = 0;\n      this.subscribersIndex += 1;\n    }\n  }\n  subscribe() {\n    this.subscriberCount += 1;\n    return new BoundedHubArbSubscription(this, this.publisherIndex, false);\n  }\n}\nclass BoundedHubArbSubscription {\n  constructor(self, subscriberIndex, unsubscribed) {\n    this.self = self;\n    this.subscriberIndex = subscriberIndex;\n    this.unsubscribed = unsubscribed;\n  }\n  isEmpty() {\n    return this.unsubscribed || this.self.publisherIndex === this.subscriberIndex || this.self.publisherIndex === this.self.subscribersIndex;\n  }\n  size() {\n    if (this.unsubscribed) {\n      return 0;\n    }\n    return this.self.publisherIndex - Math.max(this.subscriberIndex, this.self.subscribersIndex);\n  }\n  poll(default_) {\n    if (this.unsubscribed) {\n      return default_;\n    }\n    this.subscriberIndex = Math.max(this.subscriberIndex, this.self.subscribersIndex);\n    if (this.subscriberIndex !== this.self.publisherIndex) {\n      const index = this.subscriberIndex % this.self.capacity;\n      const elem = this.self.array[index];\n      this.self.subscribers[index] -= 1;\n      if (this.self.subscribers[index] === 0) {\n        this.self.array[index] = null;\n        this.self.subscribersIndex += 1;\n      }\n      this.subscriberIndex += 1;\n      return elem;\n    }\n    return default_;\n  }\n  pollUpTo(n) {\n    if (this.unsubscribed) {\n      return Chunk.empty();\n    }\n    this.subscriberIndex = Math.max(this.subscriberIndex, this.self.subscribersIndex);\n    const size = this.self.publisherIndex - this.subscriberIndex;\n    const toPoll = Math.min(n, size);\n    if (toPoll <= 0) {\n      return Chunk.empty();\n    }\n    const builder = [];\n    const pollUpToIndex = this.subscriberIndex + toPoll;\n    while (this.subscriberIndex !== pollUpToIndex) {\n      const index = this.subscriberIndex % this.self.capacity;\n      const a = this.self.array[index];\n      this.self.subscribers[index] -= 1;\n      if (this.self.subscribers[index] === 0) {\n        this.self.array[index] = null;\n        this.self.subscribersIndex += 1;\n      }\n      builder.push(a);\n      this.subscriberIndex += 1;\n    }\n    return Chunk.fromIterable(builder);\n  }\n  unsubscribe() {\n    if (!this.unsubscribed) {\n      this.unsubscribed = true;\n      this.self.subscriberCount -= 1;\n      this.subscriberIndex = Math.max(this.subscriberIndex, this.self.subscribersIndex);\n      while (this.subscriberIndex !== this.self.publisherIndex) {\n        const index = this.subscriberIndex % this.self.capacity;\n        this.self.subscribers[index] -= 1;\n        if (this.self.subscribers[index] === 0) {\n          this.self.array[index] = null;\n          this.self.subscribersIndex += 1;\n        }\n        this.subscriberIndex += 1;\n      }\n    }\n  }\n}\n/** @internal */\nclass BoundedHubPow2 {\n  constructor(requestedCapacity) {\n    this.publisherIndex = 0;\n    this.subscriberCount = 0;\n    this.subscribersIndex = 0;\n    this.array = Array.from({\n      length: requestedCapacity\n    });\n    this.mask = requestedCapacity - 1;\n    this.subscribers = Array.from({\n      length: requestedCapacity\n    });\n    this.capacity = requestedCapacity;\n  }\n  isEmpty() {\n    return this.publisherIndex === this.subscribersIndex;\n  }\n  isFull() {\n    return this.publisherIndex === this.subscribersIndex + this.capacity;\n  }\n  size() {\n    return this.publisherIndex - this.subscribersIndex;\n  }\n  publish(value) {\n    if (this.isFull()) {\n      return false;\n    }\n    if (this.subscriberCount !== 0) {\n      const index = this.publisherIndex & this.mask;\n      this.array[index] = value;\n      this.subscribers[index] = this.subscriberCount;\n      this.publisherIndex += 1;\n    }\n    return true;\n  }\n  publishAll(elements) {\n    const chunk = Chunk.fromIterable(elements);\n    const n = chunk.length;\n    const size = this.publisherIndex - this.subscribersIndex;\n    const available = this.capacity - size;\n    const forHub = Math.min(n, available);\n    if (forHub === 0) {\n      return chunk;\n    }\n    let iteratorIndex = 0;\n    const publishAllIndex = this.publisherIndex + forHub;\n    while (this.publisherIndex !== publishAllIndex) {\n      const elem = Chunk.unsafeGet(iteratorIndex++)(chunk);\n      const index = this.publisherIndex & this.mask;\n      this.array[index] = elem;\n      this.subscribers[index] = this.subscriberCount;\n      this.publisherIndex += 1;\n    }\n    return Chunk.drop(iteratorIndex - 1)(chunk);\n  }\n  slide() {\n    if (this.subscribersIndex !== this.publisherIndex) {\n      const index = this.subscribersIndex & this.mask;\n      this.array[index] = null;\n      this.subscribers[index] = 0;\n      this.subscribersIndex += 1;\n    }\n  }\n  subscribe() {\n    this.subscriberCount += 1;\n    return new BoundedHubPow2Subscription(this, this.publisherIndex, false);\n  }\n}\n/** @internal */\nclass BoundedHubPow2Subscription {\n  constructor(self, subscriberIndex, unsubscribed) {\n    this.self = self;\n    this.subscriberIndex = subscriberIndex;\n    this.unsubscribed = unsubscribed;\n  }\n  isEmpty() {\n    return this.unsubscribed || this.self.publisherIndex === this.subscriberIndex || this.self.publisherIndex === this.self.subscribersIndex;\n  }\n  size() {\n    if (this.unsubscribed) {\n      return 0;\n    }\n    return this.self.publisherIndex - Math.max(this.subscriberIndex, this.self.subscribersIndex);\n  }\n  poll(default_) {\n    if (this.unsubscribed) {\n      return default_;\n    }\n    this.subscriberIndex = Math.max(this.subscriberIndex, this.self.subscribersIndex);\n    if (this.subscriberIndex !== this.self.publisherIndex) {\n      const index = this.subscriberIndex & this.self.mask;\n      const elem = this.self.array[index];\n      this.self.subscribers[index] -= 1;\n      if (this.self.subscribers[index] === 0) {\n        this.self.array[index] = null;\n        this.self.subscribersIndex += 1;\n      }\n      this.subscriberIndex += 1;\n      return elem;\n    }\n    return default_;\n  }\n  pollUpTo(n) {\n    if (this.unsubscribed) {\n      return Chunk.empty();\n    }\n    this.subscriberIndex = Math.max(this.subscriberIndex, this.self.subscribersIndex);\n    const size = this.self.publisherIndex - this.subscriberIndex;\n    const toPoll = Math.min(n, size);\n    if (toPoll <= 0) {\n      return Chunk.empty();\n    }\n    const builder = [];\n    const pollUpToIndex = this.subscriberIndex + toPoll;\n    while (this.subscriberIndex !== pollUpToIndex) {\n      const index = this.subscriberIndex & this.self.mask;\n      const elem = this.self.array[index];\n      this.self.subscribers[index] -= 1;\n      if (this.self.subscribers[index] === 0) {\n        this.self.array[index] = null;\n        this.self.subscribersIndex += 1;\n      }\n      builder.push(elem);\n      this.subscriberIndex += 1;\n    }\n    return Chunk.fromIterable(builder);\n  }\n  unsubscribe() {\n    if (!this.unsubscribed) {\n      this.unsubscribed = true;\n      this.self.subscriberCount -= 1;\n      this.subscriberIndex = Math.max(this.subscriberIndex, this.self.subscribersIndex);\n      while (this.subscriberIndex !== this.self.publisherIndex) {\n        const index = this.subscriberIndex & this.self.mask;\n        this.self.subscribers[index] -= 1;\n        if (this.self.subscribers[index] === 0) {\n          this.self.array[index] = null;\n          this.self.subscribersIndex += 1;\n        }\n        this.subscriberIndex += 1;\n      }\n    }\n  }\n}\n/** @internal */\nclass BoundedHubSingle {\n  constructor() {\n    this.publisherIndex = 0;\n    this.subscriberCount = 0;\n    this.subscribers = 0;\n    this.value = null;\n    this.capacity = 1;\n  }\n  isEmpty() {\n    return this.subscribers === 0;\n  }\n  isFull() {\n    return !this.isEmpty();\n  }\n  size() {\n    return this.isEmpty() ? 0 : 1;\n  }\n  publish(value) {\n    if (this.isFull()) {\n      return false;\n    }\n    if (this.subscriberCount !== 0) {\n      this.value = value;\n      this.subscribers = this.subscriberCount;\n      this.publisherIndex += 1;\n    }\n    return true;\n  }\n  publishAll(elements) {\n    const chunk = Chunk.fromIterable(elements);\n    if (Chunk.isEmpty(chunk)) {\n      return chunk;\n    }\n    if (this.publish(Chunk.unsafeHead(chunk))) {\n      return Chunk.drop(1)(chunk);\n    } else {\n      return chunk;\n    }\n  }\n  slide() {\n    if (this.isFull()) {\n      this.subscribers = 0;\n      this.value = null;\n    }\n  }\n  subscribe() {\n    this.subscriberCount += 1;\n    return new BoundedHubSingleSubscription(this, this.publisherIndex, false);\n  }\n}\n/** @internal */\nclass BoundedHubSingleSubscription {\n  constructor(self, subscriberIndex, unsubscribed) {\n    this.self = self;\n    this.subscriberIndex = subscriberIndex;\n    this.unsubscribed = unsubscribed;\n  }\n  isEmpty() {\n    return this.unsubscribed || this.self.subscribers === 0 || this.subscriberIndex === this.self.publisherIndex;\n  }\n  size() {\n    return this.isEmpty() ? 0 : 1;\n  }\n  poll(default_) {\n    if (this.isEmpty()) {\n      return default_;\n    }\n    const elem = this.self.value;\n    this.self.subscribers -= 1;\n    if (this.self.subscribers === 0) {\n      this.self.value = null;\n    }\n    this.subscriberIndex += 1;\n    return elem;\n  }\n  pollUpTo(n) {\n    if (this.isEmpty() || n < 1) {\n      return Chunk.empty();\n    }\n    const a = this.self.value;\n    this.self.subscribers -= 1;\n    if (this.self.subscribers === 0) {\n      this.self.value = null;\n    }\n    this.subscriberIndex += 1;\n    return Chunk.of(a);\n  }\n  unsubscribe() {\n    if (!this.unsubscribed) {\n      this.unsubscribed = true;\n      this.self.subscriberCount -= 1;\n      if (this.subscriberIndex !== this.self.publisherIndex) {\n        this.self.subscribers -= 1;\n        if (this.self.subscribers === 0) {\n          this.self.value = null;\n        }\n      }\n    }\n  }\n}\n/** @internal */\nclass Node {\n  constructor(value, subscribers, next) {\n    this.value = value;\n    this.subscribers = subscribers;\n    this.next = next;\n  }\n}\n/** @internal */\nclass UnboundedHub {\n  constructor() {\n    this.publisherHead = new Node(null, 0, null);\n    this.publisherIndex = 0;\n    this.subscribersIndex = 0;\n    this.capacity = Number.MAX_SAFE_INTEGER;\n    this.publisherTail = this.publisherHead;\n  }\n  isEmpty() {\n    return this.publisherHead === this.publisherTail;\n  }\n  isFull() {\n    return false;\n  }\n  size() {\n    return this.publisherIndex - this.subscribersIndex;\n  }\n  publish(value) {\n    const subscribers = this.publisherTail.subscribers;\n    if (subscribers !== 0) {\n      this.publisherTail.next = new Node(value, subscribers, null);\n      this.publisherTail = this.publisherTail.next;\n      this.publisherIndex += 1;\n    }\n    return true;\n  }\n  publishAll(elements) {\n    for (const a of elements) {\n      this.publish(a);\n    }\n    return Chunk.empty();\n  }\n  slide() {\n    if (this.publisherHead !== this.publisherTail) {\n      this.publisherHead = this.publisherHead.next;\n      this.publisherHead.value = null;\n      this.subscribersIndex += 1;\n    }\n  }\n  subscribe() {\n    this.publisherTail.subscribers += 1;\n    return new UnboundedHubSubscription(this, this.publisherTail, this.publisherIndex, false);\n  }\n}\n/** @internal */\nclass UnboundedHubSubscription {\n  constructor(self, subscriberHead, subscriberIndex, unsubscribed) {\n    this.self = self;\n    this.subscriberHead = subscriberHead;\n    this.subscriberIndex = subscriberIndex;\n    this.unsubscribed = unsubscribed;\n  }\n  isEmpty() {\n    if (this.unsubscribed) {\n      return true;\n    }\n    let empty = true;\n    let loop = true;\n    while (loop) {\n      if (this.subscriberHead === this.self.publisherTail) {\n        loop = false;\n      } else {\n        if (this.subscriberHead.next.value !== null) {\n          empty = false;\n          loop = false;\n        } else {\n          this.subscriberHead = this.subscriberHead.next;\n          this.subscriberIndex += 1;\n        }\n      }\n    }\n    return empty;\n  }\n  size() {\n    if (this.unsubscribed) {\n      return 0;\n    }\n    return this.self.publisherIndex - Math.max(this.subscriberIndex, this.self.subscribersIndex);\n  }\n  poll(default_) {\n    if (this.unsubscribed) {\n      return default_;\n    }\n    let loop = true;\n    let polled = default_;\n    while (loop) {\n      if (this.subscriberHead === this.self.publisherTail) {\n        loop = false;\n      } else {\n        const elem = this.subscriberHead.next.value;\n        if (elem !== null) {\n          polled = elem;\n          this.subscriberHead.subscribers -= 1;\n          if (this.subscriberHead.subscribers === 0) {\n            this.self.publisherHead = this.self.publisherHead.next;\n            this.self.publisherHead.value = null;\n            this.self.subscribersIndex += 1;\n          }\n          loop = false;\n        }\n        this.subscriberHead = this.subscriberHead.next;\n        this.subscriberIndex += 1;\n      }\n    }\n    return polled;\n  }\n  pollUpTo(n) {\n    const builder = [];\n    const default_ = null;\n    let i = 0;\n    while (i !== n) {\n      const a = this.poll(default_);\n      if (a === default_) {\n        i = n;\n      } else {\n        builder.push(a);\n        i += 1;\n      }\n    }\n    return Chunk.fromIterable(builder);\n  }\n  unsubscribe() {\n    if (!this.unsubscribed) {\n      this.unsubscribed = true;\n      this.self.publisherTail.subscribers -= 1;\n      while (this.subscriberHead !== this.self.publisherTail) {\n        if (this.subscriberHead.next.value !== null) {\n          this.subscriberHead.subscribers -= 1;\n          if (this.subscriberHead.subscribers === 0) {\n            this.self.publisherHead = this.self.publisherHead.next;\n            this.self.publisherHead.value = null;\n            this.self.subscribersIndex += 1;\n          }\n        }\n        this.subscriberHead = this.subscriberHead.next;\n      }\n    }\n  }\n}\n/** @internal */\nclass SubscriptionImpl {\n  constructor(hub, subscribers, subscription, pollers, shutdownHook, shutdownFlag, strategy) {\n    this.hub = hub;\n    this.subscribers = subscribers;\n    this.subscription = subscription;\n    this.pollers = pollers;\n    this.shutdownHook = shutdownHook;\n    this.shutdownFlag = shutdownFlag;\n    this.strategy = strategy;\n    this[_a] = queue.dequeueVariance;\n  }\n  capacity() {\n    return this.hub.capacity;\n  }\n  size() {\n    return Debug.bodyWithTrace(trace => core.suspend(() => MutableRef.get(this.shutdownFlag) ? core.interrupt() : core.succeed(this.subscription.size())).traced(trace));\n  }\n  isFull() {\n    return Debug.bodyWithTrace(trace => core.map(this.size(), size => size === this.capacity()).traced(trace));\n  }\n  isEmpty() {\n    return Debug.bodyWithTrace(trace => core.map(this.size(), size => size === 0).traced(trace));\n  }\n  shutdown() {\n    return Debug.bodyWithTrace(trace => core.uninterruptible(core.withFiberRuntime(state => {\n      MutableRef.set(true)(this.shutdownFlag);\n      return core.asUnit(core.whenEffect(core.deferredSucceed(this.shutdownHook, void 0))(core.zipRight(core.sync(() => this.strategy.unsafeOnHubEmptySpace(this.hub, this.subscribers)))(core.zipRight(core.sync(() => this.subscription.unsubscribe()))(fiberRuntime.forEachPar(d => core.deferredInterruptWith(d, state.id()))(unsafePollAllQueue(this.pollers))))));\n    }).traced(trace)));\n  }\n  isShutdown() {\n    return Debug.bodyWithTrace(trace => core.sync(() => MutableRef.get(this.shutdownFlag)).traced(trace));\n  }\n  awaitShutdown() {\n    return Debug.bodyWithTrace(trace => core.deferredAwait(this.shutdownHook).traced(trace));\n  }\n  take() {\n    return Debug.bodyWithTrace(trace => core.withFiberRuntime(state => {\n      if (MutableRef.get(this.shutdownFlag)) {\n        return core.interrupt();\n      }\n      const message = MutableQueue.isEmpty(this.pollers) ? this.subscription.poll(MutableQueue.EmptyMutableQueue) : MutableQueue.EmptyMutableQueue;\n      if (message === MutableQueue.EmptyMutableQueue) {\n        const deferred = core.deferredUnsafeMake(state.id());\n        return core.onInterrupt(() => core.sync(() => unsafeRemove(this.pollers, deferred)))(core.suspend(() => {\n          MutableQueue.offer(deferred)(this.pollers);\n          addSubscribers(this.subscription, this.pollers)(this.subscribers);\n          this.strategy.unsafeCompletePollers(this.hub, this.subscribers, this.subscription, this.pollers);\n          return MutableRef.get(this.shutdownFlag) ? core.interrupt() : core.deferredAwait(deferred);\n        }));\n      } else {\n        this.strategy.unsafeOnHubEmptySpace(this.hub, this.subscribers);\n        return core.succeed(message);\n      }\n    }).traced(trace));\n  }\n  takeAll() {\n    return Debug.bodyWithTrace(trace => core.suspend(() => {\n      if (MutableRef.get(this.shutdownFlag)) {\n        return core.interrupt();\n      }\n      const as = MutableQueue.isEmpty(this.pollers) ? unsafePollAllSubscription(this.subscription) : Chunk.empty();\n      this.strategy.unsafeOnHubEmptySpace(this.hub, this.subscribers);\n      return core.succeed(as);\n    }).traced(trace));\n  }\n  takeUpTo(max) {\n    return Debug.bodyWithTrace(trace => core.suspend(() => {\n      if (MutableRef.get(this.shutdownFlag)) {\n        return core.interrupt();\n      }\n      const as = MutableQueue.isEmpty(this.pollers) ? unsafePollN(this.subscription, max) : Chunk.empty();\n      this.strategy.unsafeOnHubEmptySpace(this.hub, this.subscribers);\n      return core.succeed(as);\n    }).traced(trace));\n  }\n  takeBetween(min, max) {\n    return Debug.bodyWithTrace(trace => core.suspend(() => takeRemainderLoop(this, min, max, Chunk.empty())).traced(trace));\n  }\n}\n_a = queue.DequeueTypeId;\n/** @internal */\nconst takeRemainderLoop = (self, min, max, acc) => {\n  if (max < min) {\n    return core.succeed(acc);\n  }\n  return core.flatMap(bs => {\n    const remaining = min - bs.length;\n    if (remaining === 1) {\n      return core.map(b => Chunk.append(b)(Chunk.concat(bs)(acc)))(self.take());\n    }\n    if (remaining > 1) {\n      return core.flatMap(b => takeRemainderLoop(self, remaining - 1, max - bs.length - 1, Chunk.append(b)(Chunk.concat(bs)(acc))))(self.take());\n    }\n    return core.succeed(Chunk.concat(bs)(acc));\n  })(self.takeUpTo(max));\n};\n/** @internal */\nclass HubImpl {\n  constructor(hub, subscribers, scope, shutdownHook, shutdownFlag, strategy) {\n    this.hub = hub;\n    this.subscribers = subscribers;\n    this.scope = scope;\n    this.shutdownHook = shutdownHook;\n    this.shutdownFlag = shutdownFlag;\n    this.strategy = strategy;\n    this[_b] = queue.enqueueVariance;\n  }\n  capacity() {\n    return this.hub.capacity;\n  }\n  size() {\n    return Debug.bodyWithTrace(trace => core.suspend(() => MutableRef.get(this.shutdownFlag) ? core.interrupt() : core.sync(() => this.hub.size())).traced(trace));\n  }\n  isFull() {\n    return Debug.bodyWithTrace(trace => core.map(size => size === this.capacity())(this.size()).traced(trace));\n  }\n  isEmpty() {\n    return Debug.bodyWithTrace(trace => core.map(size => size === 0)(this.size()).traced(trace));\n  }\n  awaitShutdown() {\n    return Debug.bodyWithTrace(trace => core.deferredAwait(this.shutdownHook).traced(trace));\n  }\n  isShutdown() {\n    return Debug.bodyWithTrace(trace => core.sync(() => MutableRef.get(this.shutdownFlag)).traced(trace));\n  }\n  shutdown() {\n    return Debug.bodyWithTrace(trace => core.uninterruptible(core.withFiberRuntime(state => {\n      MutableRef.set(true)(this.shutdownFlag);\n      return core.asUnit(core.whenEffect(core.deferredSucceed(this.shutdownHook, void 0))(core.zipRight(this.strategy.shutdown())(this.scope.close(core.exitInterrupt(state.id())))));\n    })).traced(trace));\n  }\n  publish(value) {\n    return Debug.bodyWithTrace(trace => core.suspend(() => {\n      if (MutableRef.get(this.shutdownFlag)) {\n        return core.interrupt();\n      }\n      if (this.hub.publish(value)) {\n        this.strategy.unsafeCompleteSubscribers(this.hub, this.subscribers);\n        return core.succeed(true);\n      }\n      return this.strategy.handleSurplus(this.hub, this.subscribers, Chunk.of(value), this.shutdownFlag);\n    }).traced(trace));\n  }\n  publishAll(elements) {\n    return Debug.bodyWithTrace(trace => core.suspend(() => {\n      if (MutableRef.get(this.shutdownFlag)) {\n        return core.interrupt();\n      }\n      const surplus = unsafePublishAll(this.hub, elements);\n      this.strategy.unsafeCompleteSubscribers(this.hub, this.subscribers);\n      if (Chunk.isEmpty(surplus)) {\n        return core.succeed(true);\n      }\n      return this.strategy.handleSurplus(this.hub, this.subscribers, surplus, this.shutdownFlag);\n    }).traced(trace));\n  }\n  subscribe() {\n    return Debug.bodyWithTrace(trace => fiberRuntime.acquireRelease(core.tap(dequeue => this.scope.addFinalizer(() => dequeue.shutdown()))(makeSubscription(this.hub, this.subscribers, this.strategy)), dequeue => dequeue.shutdown()).traced(trace));\n  }\n  offer(value) {\n    return Debug.bodyWithTrace(trace => this.publish(value).traced(trace));\n  }\n  offerAll(elements) {\n    return Debug.bodyWithTrace(trace => this.publishAll(elements).traced(trace));\n  }\n}\n_b = queue.EnqueueTypeId;\n/** @internal */\nconst makeHub = /*#__PURE__*/Debug.methodWithTrace(trace => (hub, strategy) => core.flatMap(fiberRuntime.scopeMake(), scope => core.map(core.deferredMake(), deferred => unsafeMakeHub(hub, new Map(), scope, deferred, MutableRef.make(false), strategy))).traced(trace));\n/** @internal */\nexports.makeHub = makeHub;\nconst unsafeMakeHub = (hub, subscribers, scope, shutdownHook, shutdownFlag, strategy) => {\n  return new HubImpl(hub, subscribers, scope, shutdownHook, shutdownFlag, strategy);\n};\n/** @internal */\nexports.unsafeMakeHub = unsafeMakeHub;\nconst nextPow2 = n => {\n  const nextPow = Math.ceil(Math.log(n) / Math.log(2.0));\n  return Math.max(Math.pow(2, nextPow), 2);\n};\n/** @internal */\nconst ensureCapacity = capacity => {\n  if (capacity <= 0) {\n    throw cause.InvalidHubCapacityException(`Cannot construct Hub with capacity of ${capacity}`);\n  }\n};\n/** @internal */\nconst unsafeCompleteDeferred = (deferred, a) => {\n  core.deferredUnsafeDone(deferred, core.succeed(a));\n};\n/** @internal */\nconst unsafeOfferAll = (queue, as) => {\n  return MutableQueue.offerAll(as)(queue);\n};\n/** @internal */\nconst unsafePollAllQueue = queue => {\n  return MutableQueue.pollUpTo(Number.POSITIVE_INFINITY)(queue);\n};\n/** @internal */\nconst unsafePollAllSubscription = subscription => {\n  return subscription.pollUpTo(Number.POSITIVE_INFINITY);\n};\n/** @internal */\nconst unsafePollN = (subscription, max) => {\n  return subscription.pollUpTo(max);\n};\n/** @internal */\nconst unsafePublishAll = (hub, as) => {\n  return hub.publishAll(as);\n};\n/** @internal */\nconst unsafeRemove = (queue, value) => {\n  unsafeOfferAll(queue, Chunk.filter(elem => elem !== value)(unsafePollAllQueue(queue)));\n};\n/**\n * A strategy that applies back pressure to publishers when the hub is at\n * capacity. This guarantees that all subscribers will receive all messages\n * published to the hub while they are subscribed. However, it creates the\n * risk that a slow subscriber will slow down the rate at which messages\n * are published and received by other subscribers.\n *\n * @internal\n */\nclass BackPressureStrategy {\n  constructor() {\n    this.publishers = MutableQueue.unbounded();\n  }\n  shutdown() {\n    return core.flatMap(core.fiberId(), fiberId => core.flatMap(core.sync(() => unsafePollAllQueue(this.publishers)), publishers => fiberRuntime.forEachParDiscard(publishers, ([_, deferred, last]) => last ? core.asUnit(core.deferredInterruptWith(deferred, fiberId)) : core.unit())));\n  }\n  handleSurplus(hub, subscribers, elements, isShutdown) {\n    return core.withFiberRuntime(state => {\n      const deferred = core.deferredUnsafeMake(state.id());\n      return core.onInterrupt(() => core.sync(() => this.unsafeRemove(deferred)))(core.suspend(() => {\n        this.unsafeOffer(elements, deferred);\n        this.unsafeOnHubEmptySpace(hub, subscribers);\n        this.unsafeCompleteSubscribers(hub, subscribers);\n        return MutableRef.get(isShutdown) ? core.interrupt() : core.deferredAwait(deferred);\n      }));\n    });\n  }\n  unsafeOnHubEmptySpace(hub, subscribers) {\n    let keepPolling = true;\n    while (keepPolling && !hub.isFull()) {\n      const publisher = MutableQueue.poll(MutableQueue.EmptyMutableQueue)(this.publishers);\n      if (publisher === MutableQueue.EmptyMutableQueue) {\n        keepPolling = false;\n      } else {\n        const published = hub.publish(publisher[0]);\n        if (published && publisher[2]) {\n          unsafeCompleteDeferred(publisher[1], true);\n        } else if (!published) {\n          unsafeOfferAll(this.publishers, Chunk.prepend(publisher)(unsafePollAllQueue(this.publishers)));\n        }\n        this.unsafeCompleteSubscribers(hub, subscribers);\n      }\n    }\n  }\n  unsafeCompletePollers(hub, subscribers, subscription, pollers) {\n    return unsafeStrategyCompletePollers(this, hub, subscribers, subscription, pollers);\n  }\n  unsafeCompleteSubscribers(hub, subscribers) {\n    return unsafeStrategyCompleteSubscribers(this, hub, subscribers);\n  }\n  unsafeOffer(elements, deferred) {\n    const iterator = elements[Symbol.iterator]();\n    let next = iterator.next();\n    if (!next.done) {\n      // eslint-disable-next-line no-constant-condition\n      while (1) {\n        const value = next.value;\n        next = iterator.next();\n        if (next.done) {\n          MutableQueue.offer([value, deferred, true])(this.publishers);\n          break;\n        }\n        MutableQueue.offer([value, deferred, false])(this.publishers);\n      }\n    }\n  }\n  unsafeRemove(deferred) {\n    unsafeOfferAll(this.publishers, Chunk.filter(([_, a]) => a !== deferred)(unsafePollAllQueue(this.publishers)));\n  }\n}\n/**\n * A strategy that drops new messages when the hub is at capacity. This\n * guarantees that a slow subscriber will not slow down the rate at which\n * messages are published. However, it creates the risk that a slow\n * subscriber will slow down the rate at which messages are received by\n * other subscribers and that subscribers may not receive all messages\n * published to the hub while they are subscribed.\n *\n * @internal\n */\nclass DroppingStrategy {\n  shutdown() {\n    return core.unit();\n  }\n  handleSurplus(_hub, _subscribers, _elements, _isShutdown) {\n    return core.succeed(false);\n  }\n  unsafeOnHubEmptySpace(_hub, _subscribers) {\n    //\n  }\n  unsafeCompletePollers(hub, subscribers, subscription, pollers) {\n    return unsafeStrategyCompletePollers(this, hub, subscribers, subscription, pollers);\n  }\n  unsafeCompleteSubscribers(hub, subscribers) {\n    return unsafeStrategyCompleteSubscribers(this, hub, subscribers);\n  }\n}\n/**\n * A strategy that adds new messages and drops old messages when the hub is\n * at capacity. This guarantees that a slow subscriber will not slow down\n * the rate at which messages are published and received by other\n * subscribers. However, it creates the risk that a slow subscriber will\n * not receive some messages published to the hub while it is subscribed.\n *\n * @internal\n */\nexports.DroppingStrategy = DroppingStrategy;\nclass SlidingStrategy {\n  shutdown() {\n    return core.unit();\n  }\n  handleSurplus(hub, subscribers, elements, _isShutdown) {\n    return core.sync(() => {\n      this.unsafeSlidingPublish(hub, elements);\n      this.unsafeCompleteSubscribers(hub, subscribers);\n      return true;\n    });\n  }\n  unsafeOnHubEmptySpace(_hub, _subscribers) {\n    //\n  }\n  unsafeCompletePollers(hub, subscribers, subscription, pollers) {\n    return unsafeStrategyCompletePollers(this, hub, subscribers, subscription, pollers);\n  }\n  unsafeCompleteSubscribers(hub, subscribers) {\n    return unsafeStrategyCompleteSubscribers(this, hub, subscribers);\n  }\n  unsafeSlidingPublish(hub, elements) {\n    const it = elements[Symbol.iterator]();\n    let next = it.next();\n    if (!next.done && hub.capacity > 0) {\n      let a = next.value;\n      let loop = true;\n      while (loop) {\n        hub.slide();\n        const pub = hub.publish(a);\n        if (pub && (next = it.next()) && !next.done) {\n          a = next.value;\n        } else if (pub) {\n          loop = false;\n        }\n      }\n    }\n  }\n}\n/** @internal */\nexports.SlidingStrategy = SlidingStrategy;\nconst unsafeStrategyCompletePollers = (strategy, hub, subscribers, subscription, pollers) => {\n  let keepPolling = true;\n  while (keepPolling && !subscription.isEmpty()) {\n    const poller = MutableQueue.poll(MutableQueue.EmptyMutableQueue)(pollers);\n    if (poller === MutableQueue.EmptyMutableQueue) {\n      removeSubscribers(subscription, pollers)(subscribers);\n      if (MutableQueue.isEmpty(pollers)) {\n        keepPolling = false;\n      } else {\n        addSubscribers(subscription, pollers)(subscribers);\n      }\n    } else {\n      const pollResult = subscription.poll(MutableQueue.EmptyMutableQueue);\n      if (pollResult === MutableQueue.EmptyMutableQueue) {\n        unsafeOfferAll(pollers, Chunk.prepend(poller)(unsafePollAllQueue(pollers)));\n      } else {\n        unsafeCompleteDeferred(poller, pollResult);\n        strategy.unsafeOnHubEmptySpace(hub, subscribers);\n      }\n    }\n  }\n};\n/** @internal */\nconst unsafeStrategyCompleteSubscribers = (strategy, hub, subscribers) => {\n  for (const [subscription, pollersSet] of subscribers) {\n    for (const pollers of pollersSet) {\n      strategy.unsafeCompletePollers(hub, subscribers, subscription, pollers);\n    }\n  }\n};\n//# sourceMappingURL=hub.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.fromEffect = exports.fresh = exports.flatten = exports.flatMap = exports.failSync = exports.failCauseSync = exports.failCause = exports.fail = exports.extendScope = exports.discard = exports.dieSync = exports.die = exports.context = exports.catchAllCause = exports.catchAll = exports.buildWithScope = exports.build = exports.LayerTypeId = void 0;\nexports.fromEffectContext = fromEffectContext;\nexports.zipWithPar = exports.useMerge = exports.use = exports.toRuntime = exports.toLayerScoped = exports.toLayer = exports.tapErrorCause = exports.tapError = exports.tap = exports.syncContext = exports.sync = exports.suspend = exports.succeedContext = exports.succeed = exports.service = exports.scopedDiscard = exports.scopedContext = exports.scoped = exports.scope = exports.retry = exports.provideSomeLayer = exports.provideMerge = exports.provideLayer = exports.provide = exports.project = exports.passthrough = exports.orElse = exports.orDie = exports.mergeAll = exports.merge = exports.memoize = exports.matchLayer = exports.matchCauseLayer = exports.mapError = exports.map = exports.launch = exports.isLayer = exports.isFresh = exports.fromFunction = exports.fromEffectDiscard = void 0;\nvar Context = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Context\"));\nvar Duration = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Duration\"));\nvar _Function = /*#__PURE__*/require(\"@effect/data/Function\");\nvar Cause = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Cause\"));\nvar Clock = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Clock\"));\nvar Debug = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Debug\"));\nvar core = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/core\"));\nvar effect = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/effect\"));\nvar circular = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/effect/circular\"));\nvar fiberRuntime = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/fiberRuntime\"));\nvar EffectOpCodes = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/opCodes/effect\"));\nvar OpCodes = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/opCodes/layer\"));\nvar ref = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/ref\"));\nvar runtime = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/runtime\"));\nvar synchronized = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/synchronizedRef\"));\nvar ScheduleDecision = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Schedule/Decision\"));\nvar Intervals = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Schedule/Intervals\"));\nvar Scope = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Scope\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/** @internal */\nconst LayerSymbolKey = \"@effect/io/Layer\";\n/** @internal */\nconst LayerTypeId = /*#__PURE__*/Symbol.for(LayerSymbolKey);\n/** @internal */\nexports.LayerTypeId = LayerTypeId;\nconst layerVariance = {\n  _RIn: _ => _,\n  _E: _ => _,\n  _ROut: _ => _\n};\n/** @internal */\nconst proto = {\n  [LayerTypeId]: layerVariance\n};\n/** @internal */\nconst isLayer = u => {\n  return typeof u === \"object\" && u != null && LayerTypeId in u;\n};\n/** @internal */\nexports.isLayer = isLayer;\nconst isFresh = self => {\n  return self._tag === OpCodes.OP_FRESH;\n};\n// -----------------------------------------------------------------------------\n// MemoMap\n// -----------------------------------------------------------------------------\n/** @internal */\nexports.isFresh = isFresh;\nclass MemoMap {\n  constructor(ref) {\n    this.ref = ref;\n  }\n  /**\n   * Checks the memo map to see if a layer exists. If it is, immediately\n   * returns it. Otherwise, obtains the layer, stores it in the memo map,\n   * and adds a finalizer to the `Scope`.\n   */\n  getOrElseMemoize(layer, scope) {\n    return core.flatten(synchronized.modifyEffect(this.ref, map => {\n      const inMap = map.get(layer);\n      if (inMap !== undefined) {\n        const [acquire, release] = inMap;\n        const cached = core.onExit(core.exitMatch(() => core.unit(), () => core.scopeAddFinalizerExit(scope, release)))(core.flatMap(([patch, b]) => core.as(b)(effect.patchFiberRefs(patch)))(acquire));\n        return core.succeed([cached, map]);\n      }\n      return core.flatMap(observers => core.flatMap(deferred => core.map(finalizerRef => {\n        const resource = core.uninterruptibleMask(restore => core.flatMap(innerScope => core.flatMap(exit => {\n          switch (exit._tag) {\n            case EffectOpCodes.OP_FAILURE:\n              {\n                return core.zipRight(core.failCause(exit.i0))(core.zipRight(core.scopeClose(innerScope, exit))(core.deferredFailCause(deferred, exit.i0)));\n              }\n            case EffectOpCodes.OP_SUCCESS:\n              {\n                return core.as(exit.i0[1])(core.zipRight(core.deferredSucceed(deferred, exit.i0))(core.zipRight(core.scopeAddFinalizerExit(scope, exit => core.flatMap(finalizer => finalizer(exit))(ref.get(finalizerRef))))(core.zipRight(ref.update(observers, n => n + 1))(ref.set(finalizerRef, exit => core.asUnit(core.whenEffect(ref.modify(observers, n => [n === 1, n - 1]))(core.scopeClose(innerScope, exit))))))));\n              }\n          }\n        })(core.exit(restore(core.flatMap(withScope(layer, innerScope), f => effect.diffFiberRefs(f(this)))))))(fiberRuntime.scopeMake()));\n        const memoized = [core.onExit(core.exitMatchEffect(() => core.unit(), () => ref.update(observers, n => n + 1)))(core.deferredAwait(deferred)), exit => core.flatMap(finalizer => finalizer(exit))(ref.get(finalizerRef))];\n        return [resource, isFresh(layer) ? map : map.set(layer, memoized)];\n      })(ref.make(() => core.unit())))(core.deferredMake()))(ref.make(0));\n    }));\n  }\n}\nconst makeMemoMap = () => {\n  return core.map(ref => new MemoMap(ref))(circular.makeSynchronized(new Map()));\n};\n/** @internal */\nconst build = /*#__PURE__*/Debug.methodWithTrace(trace => self => fiberRuntime.scopeWith(scope => buildWithScope(scope)(self)).traced(trace));\n/** @internal */\nexports.build = build;\nconst buildWithScope = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, scope) => core.flatMap(makeMemoMap(), memoMap => core.flatMap(withScope(self, scope), run => run(memoMap))).traced(trace));\nexports.buildWithScope = buildWithScope;\nconst withScope = (self, scope) => {\n  const op = self;\n  switch (op._tag) {\n    case OpCodes.OP_EXTEND_SCOPE:\n      {\n        return core.sync(() => memoMap => fiberRuntime.scopeWith(scope => memoMap.getOrElseMemoize(op.layer, scope)));\n      }\n    case OpCodes.OP_FOLD:\n      {\n        return core.sync(() => memoMap => core.matchCauseEffect(cause => memoMap.getOrElseMemoize(op.failureK(cause), scope), value => memoMap.getOrElseMemoize(op.successK(value), scope))(memoMap.getOrElseMemoize(op.layer, scope)));\n      }\n    case OpCodes.OP_FRESH:\n      {\n        return core.sync(() => _ => buildWithScope(scope)(op.layer));\n      }\n    case OpCodes.OP_FROM_EFFECT:\n      {\n        return core.sync(() => _ => op.effect);\n      }\n    case OpCodes.OP_PROVIDE_TO:\n      {\n        return core.sync(() => memoMap => core.flatMap(env => core.provideContext(env)(memoMap.getOrElseMemoize(op.second, scope)))(memoMap.getOrElseMemoize(op.first, scope)));\n      }\n    case OpCodes.OP_SCOPED:\n      {\n        return core.sync(() => _ => fiberRuntime.scopeExtend(op.effect, scope));\n      }\n    case OpCodes.OP_SUSPEND:\n      {\n        return core.sync(() => memoMap => memoMap.getOrElseMemoize(op.evaluate(), scope));\n      }\n    case OpCodes.OP_ZIP_WITH:\n      {\n        return core.sync(() => memoMap => core.zipWith(memoMap.getOrElseMemoize(op.second, scope), op.zipK)(memoMap.getOrElseMemoize(op.first, scope)));\n      }\n    case OpCodes.OP_ZIP_WITH_PAR:\n      {\n        return core.sync(() => memoMap => circular.zipWithPar(memoMap.getOrElseMemoize(op.second, scope), op.zipK)(memoMap.getOrElseMemoize(op.first, scope)));\n      }\n  }\n};\n// -----------------------------------------------------------------------------\n// Layer\n// -----------------------------------------------------------------------------\n/** @internal */\nconst catchAll = /*#__PURE__*/Debug.untracedDual(2, restore => (self, onError) => matchLayer(self, restore(onError), succeedContext));\n/** @internal */\nexports.catchAll = catchAll;\nconst catchAllCause = /*#__PURE__*/Debug.untracedDual(2, restore => (self, onError) => matchCauseLayer(self, restore(onError), succeedContext));\n/** @internal */\nexports.catchAllCause = catchAllCause;\nconst die = defect => failCause(Cause.die(defect));\n/** @internal */\nexports.die = die;\nconst dieSync = evaluate => failCauseSync(() => Cause.die(evaluate()));\n/** @internal */\nexports.dieSync = dieSync;\nconst discard = self => map(self, () => Context.empty());\n/** @internal */\nexports.discard = discard;\nconst context = () => fromEffectContext(core.context());\n/** @internal */\nexports.context = context;\nconst extendScope = self => {\n  const extendScope = Object.create(proto);\n  extendScope._tag = OpCodes.OP_EXTEND_SCOPE;\n  extendScope.layer = self;\n  return extendScope;\n};\n/** @internal */\nexports.extendScope = extendScope;\nconst fail = error => failCause(Cause.fail(error));\n/** @internal */\nexports.fail = fail;\nconst failSync = evaluate => failCauseSync(() => Cause.fail(evaluate()));\n/** @internal */\nexports.failSync = failSync;\nconst failCause = cause => fromEffectContext(core.failCause(cause));\n/** @internal */\nexports.failCause = failCause;\nconst failCauseSync = evaluate => fromEffectContext(core.failCauseSync(evaluate));\n/** @internal */\nexports.failCauseSync = failCauseSync;\nconst flatMap = /*#__PURE__*/Debug.untracedDual(2, restore => (self, f) => matchLayer(self, fail, restore(f)));\n/** @internal */\nexports.flatMap = flatMap;\nconst flatten = /*#__PURE__*/(0, _Function.dual)(2, (self, tag) => flatMap(self, Context.get(tag)));\n/** @internal */\nexports.flatten = flatten;\nconst fresh = self => {\n  const fresh = Object.create(proto);\n  fresh._tag = OpCodes.OP_FRESH;\n  fresh.layer = self;\n  return fresh;\n};\n/** @internal */\nexports.fresh = fresh;\nconst fromEffect = (tag, effect) => fromEffectContext(core.map(effect, service => Context.make(tag, service)));\n/** @internal */\nexports.fromEffect = fromEffect;\nconst fromEffectDiscard = effect => fromEffectContext(core.map(effect, () => Context.empty()));\n/** @internal */\nexports.fromEffectDiscard = fromEffectDiscard;\nfunction fromEffectContext(effect) {\n  const fromEffect = Object.create(proto);\n  fromEffect._tag = OpCodes.OP_FROM_EFFECT;\n  fromEffect.effect = effect;\n  return fromEffect;\n}\n/** @internal */\nconst fromFunction = (tagA, tagB, f) => fromEffectContext(core.serviceWith(tagA, a => Context.make(tagB, f(a))));\n/** @internal */\nexports.fromFunction = fromFunction;\nconst launch = /*#__PURE__*/Debug.methodWithTrace(trace => self => fiberRuntime.scopedEffect(core.zipRight(fiberRuntime.scopeWith(scope => buildWithScope(scope)(self)), core.never())).traced(trace));\n/** @internal */\nexports.launch = launch;\nconst map = /*#__PURE__*/Debug.untracedDual(2, restore => (self, f) => flatMap(self, context => succeedContext(restore(f)(context))));\n/** @internal */\nexports.map = map;\nconst mapError = /*#__PURE__*/Debug.untracedDual(2, restore => (self, f) => catchAll(self, error => failSync(() => restore(f)(error))));\n/** @internal */\nexports.mapError = mapError;\nconst matchCauseLayer = /*#__PURE__*/Debug.untracedDual(3, restore => (self, onFailure, onSuccess) => {\n  const fold = Object.create(proto);\n  fold._tag = OpCodes.OP_FOLD;\n  fold.layer = self;\n  fold.failureK = restore(onFailure);\n  fold.successK = restore(onSuccess);\n  return fold;\n});\n/** @internal */\nexports.matchCauseLayer = matchCauseLayer;\nconst matchLayer = /*#__PURE__*/Debug.untracedDual(3, restore => (self, onFailure, onSuccess) => matchCauseLayer(self, cause => {\n  const failureOrCause = Cause.failureOrCause(cause);\n  switch (failureOrCause._tag) {\n    case \"Left\":\n      {\n        return restore(onFailure)(failureOrCause.left);\n      }\n    case \"Right\":\n      {\n        return failCause(failureOrCause.right);\n      }\n  }\n}, restore(onSuccess)));\n/** @internal */\nexports.matchLayer = matchLayer;\nconst memoize = /*#__PURE__*/Debug.methodWithTrace(trace => self => fiberRuntime.scopeWith(scope => core.map(fromEffectContext)(effect.memoize(buildWithScope(self, scope)))).traced(trace));\n/** @internal */\nexports.memoize = memoize;\nconst merge = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => zipWithPar(self, that, (a, b) => Context.merge(b)(a)));\n/** @internal */\nexports.merge = merge;\nconst mergeAll = (...layers) => {\n  let final = layers[0];\n  for (let i = 1; i < layers.length; i++) {\n    final = merge(layers[i])(final);\n  }\n  return final;\n};\n/** @internal */\nexports.mergeAll = mergeAll;\nconst orDie = self => catchAll(self, defect => die(defect));\n/** @internal */\nexports.orDie = orDie;\nconst orElse = /*#__PURE__*/Debug.untracedDual(2, restore => (self, that) => catchAll(self, restore(that)));\n/** @internal */\nexports.orElse = orElse;\nconst passthrough = self => merge(context(), self);\n/** @internal */\nexports.passthrough = passthrough;\nconst project = /*#__PURE__*/Debug.untracedDual(4, restore => (self, tagA, tagB, f) => map(self, context => Context.make(tagB, restore(f)(Context.unsafeGet(context, tagA)))));\n/** @internal */\nexports.project = project;\nconst provide = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => suspend(() => {\n  const provideTo = Object.create(proto);\n  provideTo._tag = OpCodes.OP_PROVIDE_TO;\n  provideTo.first = Object.create(proto, {\n    _tag: {\n      value: OpCodes.OP_ZIP_WITH,\n      enumerable: true\n    },\n    first: {\n      value: context(),\n      enumerable: true\n    },\n    second: {\n      value: self\n    },\n    zipK: {\n      value: (a, b) => Context.merge(b)(a)\n    }\n  });\n  provideTo.second = that;\n  return provideTo;\n}));\n/** @internal */\nexports.provide = provide;\nconst provideMerge = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => {\n  const zipWith = Object.create(proto);\n  zipWith._tag = OpCodes.OP_ZIP_WITH;\n  zipWith.first = self;\n  zipWith.second = provide(that)(self);\n  zipWith.zipK = (a, b) => {\n    return Context.merge(b)(a);\n  };\n  return zipWith;\n});\n/** @internal */\nexports.provideMerge = provideMerge;\nconst retry = /*#__PURE__*/(0, _Function.dual)(2, (self, schedule) => suspend(() => {\n  const stateTag = Context.Tag();\n  return flatMap(env => retryLoop(self, schedule, stateTag, Context.get(stateTag)(env).state))(succeed(stateTag, {\n    state: schedule.initial\n  }));\n}));\n/** @internal */\nexports.retry = retry;\nconst retryLoop = (self, schedule, stateTag, state) => {\n  return catchAll(error => flatMap(env => fresh(retryLoop(self, schedule, stateTag, Context.get(stateTag)(env).state)))(retryUpdate(schedule, stateTag, error, state)))(self);\n};\n/** @internal */\nconst retryUpdate = (schedule, stateTag, error, state) => {\n  return fromEffect(stateTag, core.flatMap(now => core.flatMap(([state, _, decision]) => ScheduleDecision.isDone(decision) ? core.fail(error) : core.as({\n    state\n  })(Clock.sleep(Duration.millis(Intervals.start(decision.intervals) - now))))(schedule.step(now, error, state)))(Clock.currentTimeMillis()));\n};\n/** @internal */\nconst scope = () => {\n  return scopedContext(core.map(scope => Context.make(Scope.Tag, scope))(fiberRuntime.acquireRelease(fiberRuntime.scopeMake(), (scope, exit) => scope.close(exit))));\n};\n/** @internal */\nexports.scope = scope;\nconst scoped = (tag, effect) => {\n  return scopedContext(core.map(effect, service => Context.make(tag, service)));\n};\n/** @internal */\nexports.scoped = scoped;\nconst scopedDiscard = effect => {\n  return scopedContext(core.as(Context.empty())(effect));\n};\n/** @internal */\nexports.scopedDiscard = scopedDiscard;\nconst scopedContext = effect => {\n  const scoped = Object.create(proto);\n  scoped._tag = OpCodes.OP_SCOPED;\n  scoped.effect = effect;\n  return scoped;\n};\n/** @internal */\nexports.scopedContext = scopedContext;\nconst service = tag => {\n  return fromEffect(tag, core.service(tag));\n};\n/** @internal */\nexports.service = service;\nconst succeed = (tag, resource) => {\n  return fromEffectContext(core.succeed(Context.make(tag, resource)));\n};\n/** @internal */\nexports.succeed = succeed;\nconst succeedContext = context => {\n  return fromEffectContext(core.succeed(context));\n};\n/** @internal */\nexports.succeedContext = succeedContext;\nconst suspend = evaluate => {\n  const suspend = Object.create(proto);\n  suspend._tag = OpCodes.OP_SUSPEND;\n  suspend.evaluate = evaluate;\n  return suspend;\n};\n/** @internal */\nexports.suspend = suspend;\nconst sync = (tag, evaluate) => {\n  return fromEffectContext(core.sync(() => Context.make(tag, evaluate())));\n};\n/** @internal */\nexports.sync = sync;\nconst syncContext = evaluate => {\n  return fromEffectContext(core.sync(evaluate));\n};\n/** @internal */\nexports.syncContext = syncContext;\nconst tap = /*#__PURE__*/Debug.untracedDual(2, restore => (self, f) => flatMap(self, context => fromEffectContext(core.as(restore(f)(context), context))));\n/** @internal */\nexports.tap = tap;\nconst tapError = /*#__PURE__*/Debug.untracedDual(2, restore => (self, f) => catchAll(self, e => fromEffectContext(core.flatMap(restore(f)(e), () => core.fail(e)))));\n/** @internal */\nexports.tapError = tapError;\nconst tapErrorCause = /*#__PURE__*/Debug.untracedDual(2, restore => (self, f) => catchAllCause(self, cause => fromEffectContext(core.flatMap(restore(f)(cause), () => core.failCause(cause)))));\n/** @internal */\nexports.tapErrorCause = tapErrorCause;\nconst toRuntime = self => {\n  return core.flatMap(context => core.provideContext(context)(runtime.runtime()))(fiberRuntime.scopeWith(scope => buildWithScope(scope)(self)));\n};\n/** @internal */\nexports.toRuntime = toRuntime;\nconst use = /*#__PURE__*/(0, _Function.dual)(2, (that, self) => suspend(() => {\n  const provideTo = Object.create(proto);\n  provideTo._tag = OpCodes.OP_PROVIDE_TO;\n  provideTo.first = Object.create(proto, {\n    _tag: {\n      value: OpCodes.OP_ZIP_WITH,\n      enumerable: true\n    },\n    first: {\n      value: context(),\n      enumerable: true\n    },\n    second: {\n      value: self\n    },\n    zipK: {\n      value: (a, b) => Context.merge(b)(a)\n    }\n  });\n  provideTo.second = that;\n  return provideTo;\n}));\n/** @internal */\nexports.use = use;\nconst useMerge = /*#__PURE__*/(0, _Function.dual)(2, (that, self) => {\n  const zipWith = Object.create(proto);\n  zipWith._tag = OpCodes.OP_ZIP_WITH;\n  zipWith.first = self;\n  zipWith.second = provide(that)(self);\n  zipWith.zipK = (a, b) => {\n    return Context.merge(b)(a);\n  };\n  return zipWith;\n});\n/** @internal */\nexports.useMerge = useMerge;\nconst zipWithPar = /*#__PURE__*/Debug.untracedDual(3, restore => (self, that, f) => suspend(() => {\n  const zipWithPar = Object.create(proto);\n  zipWithPar._tag = OpCodes.OP_ZIP_WITH_PAR;\n  zipWithPar.first = self;\n  zipWithPar.second = that;\n  zipWithPar.zipK = restore(f);\n  return zipWithPar;\n}));\n// circular with Effect\n/** @internal */\nexports.zipWithPar = zipWithPar;\nconst provideLayer = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, layer) => core.acquireUseRelease(fiberRuntime.scopeMake(), scope => core.flatMap(buildWithScope(layer, scope), context => core.provideContext(self, context)), (scope, exit) => core.scopeClose(scope, exit)).traced(trace));\n/** @internal */\nexports.provideLayer = provideLayer;\nconst provideSomeLayer = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, layer) => provideLayer(self, merge(layer)(context())).traced(trace));\n/** @internal */\nexports.provideSomeLayer = provideSomeLayer;\nconst toLayer = /*#__PURE__*/(0, _Function.dual)(2, (self, tag) => fromEffect(tag, self));\n/** @internal */\nexports.toLayer = toLayer;\nconst toLayerScoped = /*#__PURE__*/(0, _Function.dual)(2, (self, tag) => scoped(tag, self));\nexports.toLayerScoped = toLayerScoped;\n//# sourceMappingURL=layer.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.withMinimumLogLevel = exports.setConfigProvider = exports.replaceLogger = exports.removeLogger = exports.minimumLogLevel = exports.enableWindDown = exports.enableRuntimeMetrics = exports.enableOpSupervision = exports.enableInterruption = exports.enableCooperativeYielding = exports.disableWindDown = exports.disableRuntimeMetrics = exports.disableOpSupervision = exports.disableInterruption = exports.disableCooperativeYielding = exports.addSupervisor = exports.addLogger = void 0;\nvar _Function = /*#__PURE__*/require(\"@effect/data/Function\");\nvar HashSet = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/HashSet\"));\nvar Debug = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Debug\"));\nvar core = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/core\"));\nvar fiberRuntime = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/fiberRuntime\"));\nvar layer = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/layer\"));\nvar runtimeFlags = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/runtimeFlags\"));\nvar runtimeFlagsPatch = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/runtimeFlagsPatch\"));\nvar _supervisor = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/supervisor\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n// circular with Logger\n/** @internal */\nconst minimumLogLevel = /*#__PURE__*/Debug.untracedMethod(() => level => layer.scopedDiscard(fiberRuntime.fiberRefLocallyScoped(fiberRuntime.currentMinimumLogLevel, level)));\n/** @internal */\nexports.minimumLogLevel = minimumLogLevel;\nconst withMinimumLogLevel = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, level) => core.fiberRefLocally(fiberRuntime.currentMinimumLogLevel, level)(self).traced(trace));\n/** @internal */\nexports.withMinimumLogLevel = withMinimumLogLevel;\nconst addLogger = /*#__PURE__*/Debug.methodWithTrace(trace => logger => layer.scopedDiscard(fiberRuntime.fiberRefLocallyScopedWith(fiberRuntime.currentLoggers, HashSet.add(logger)).traced(trace)));\n/** @internal */\nexports.addLogger = addLogger;\nconst removeLogger = /*#__PURE__*/Debug.untracedMethod(() => logger => layer.scopedDiscard(fiberRuntime.fiberRefLocallyScopedWith(fiberRuntime.currentLoggers, HashSet.remove(logger))));\n/** @internal */\nexports.removeLogger = removeLogger;\nconst replaceLogger = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => layer.flatMap(removeLogger(self), () => addLogger(that)));\n/** @internal */\nexports.replaceLogger = replaceLogger;\nconst addSupervisor = /*#__PURE__*/Debug.untracedMethod(() => supervisor => layer.scopedDiscard(fiberRuntime.fiberRefLocallyScopedWith(fiberRuntime.currentSupervisor, current => new _supervisor.Zip(current, supervisor))));\n/** @internal */\nexports.addSupervisor = addSupervisor;\nconst enableCooperativeYielding = /*#__PURE__*/Debug.untracedMethod(() => () => layer.scopedDiscard(fiberRuntime.withRuntimeFlagsScoped(runtimeFlagsPatch.enable(runtimeFlags.CooperativeYielding))));\n/** @internal */\nexports.enableCooperativeYielding = enableCooperativeYielding;\nconst enableInterruption = /*#__PURE__*/Debug.untracedMethod(() => () => layer.scopedDiscard(fiberRuntime.withRuntimeFlagsScoped(runtimeFlagsPatch.enable(runtimeFlags.Interruption))));\n/** @internal */\nexports.enableInterruption = enableInterruption;\nconst enableOpSupervision = /*#__PURE__*/Debug.untracedMethod(() => () => layer.scopedDiscard(fiberRuntime.withRuntimeFlagsScoped(runtimeFlagsPatch.enable(runtimeFlags.OpSupervision))));\n/** @internal */\nexports.enableOpSupervision = enableOpSupervision;\nconst enableRuntimeMetrics = /*#__PURE__*/Debug.untracedMethod(() => () => layer.scopedDiscard(fiberRuntime.withRuntimeFlagsScoped(runtimeFlagsPatch.enable(runtimeFlags.RuntimeMetrics))));\n/** @internal */\nexports.enableRuntimeMetrics = enableRuntimeMetrics;\nconst enableWindDown = /*#__PURE__*/Debug.untracedMethod(() => () => layer.scopedDiscard(fiberRuntime.withRuntimeFlagsScoped(runtimeFlagsPatch.enable(runtimeFlags.WindDown))));\n/** @internal */\nexports.enableWindDown = enableWindDown;\nconst disableCooperativeYielding = /*#__PURE__*/Debug.untracedMethod(() => () => layer.scopedDiscard(fiberRuntime.withRuntimeFlagsScoped(runtimeFlagsPatch.disable(runtimeFlags.CooperativeYielding))));\n/** @internal */\nexports.disableCooperativeYielding = disableCooperativeYielding;\nconst disableInterruption = /*#__PURE__*/Debug.untracedMethod(() => () => layer.scopedDiscard(fiberRuntime.withRuntimeFlagsScoped(runtimeFlagsPatch.disable(runtimeFlags.Interruption))));\n/** @internal */\nexports.disableInterruption = disableInterruption;\nconst disableOpSupervision = /*#__PURE__*/Debug.untracedMethod(() => () => layer.scopedDiscard(fiberRuntime.withRuntimeFlagsScoped(runtimeFlagsPatch.disable(runtimeFlags.OpSupervision))));\n/** @internal */\nexports.disableOpSupervision = disableOpSupervision;\nconst disableRuntimeMetrics = /*#__PURE__*/Debug.untracedMethod(() => () => layer.scopedDiscard(fiberRuntime.withRuntimeFlagsScoped(runtimeFlagsPatch.disable(runtimeFlags.RuntimeMetrics))));\n/** @internal */\nexports.disableRuntimeMetrics = disableRuntimeMetrics;\nconst disableWindDown = /*#__PURE__*/Debug.untracedMethod(() => () => layer.scopedDiscard(fiberRuntime.withRuntimeFlagsScoped(runtimeFlagsPatch.disable(runtimeFlags.WindDown))));\n/** @internal */\nexports.disableWindDown = disableWindDown;\nconst setConfigProvider = /*#__PURE__*/Debug.untracedMethod(() => configProvider => layer.scopedDiscard(fiberRuntime.withConfigProviderScoped(configProvider)));\nexports.setConfigProvider = setConfigProvider;\n//# sourceMappingURL=circular.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.render = exports.make = void 0;\n/** @internal */\nconst make = (label, startTime) => ({\n  label,\n  startTime\n});\n/** @internal */\nexports.make = make;\nconst render = now => {\n  return self => {\n    const label = self.label.replace(/[\\s=\"]/g, \"_\");\n    return `${label}=${now - self.startTime}ms`;\n  };\n};\nexports.render = render;\n//# sourceMappingURL=logSpan.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.zipRight = exports.zipLeft = exports.zip = exports.sync = exports.succeed = exports.stringLogger = exports.simple = exports.none = exports.map = exports.makeLogger = exports.logfmtLogger = exports.filterLogLevel = exports.contramap = exports.LoggerTypeId = void 0;\nvar Chunk = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Chunk\"));\nvar _Function = /*#__PURE__*/require(\"@effect/data/Function\");\nvar HashMap = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/HashMap\"));\nvar Option = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Option\"));\nvar Debug = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Debug\"));\nvar Cause = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/cause\"));\nvar Pretty = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/cause-pretty\"));\nvar _fiberId = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/fiberId\"));\nvar LogSpan = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Logger/Span\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/** @internal */\nconst LoggerSymbolKey = \"@effect/io/Logger\";\n/** @internal */\nconst LoggerTypeId = /*#__PURE__*/Symbol.for(LoggerSymbolKey);\n/** @internal */\nexports.LoggerTypeId = LoggerTypeId;\nconst loggerVariance = {\n  _Message: _ => _,\n  _Output: _ => _\n};\n/** @internal */\nconst makeLogger = log => ({\n  [LoggerTypeId]: loggerVariance,\n  log\n});\n/** @internal */\nexports.makeLogger = makeLogger;\nconst stringLogger = /*#__PURE__*/makeLogger((fiberId, logLevel, message, cause, _context, spans, annotations) => {\n  const now = new Date();\n  const nowMillis = now.getTime();\n  const outputArray = [`timestamp=${now.toISOString()}`, `level=${logLevel.label}`, `fiber=${_fiberId.threadName(fiberId)}`];\n  let output = outputArray.join(\" \");\n  if (message.length > 0) {\n    output = output + \" message=\";\n    output = appendQuoted(message, output);\n  }\n  if (cause != null && cause != Cause.empty) {\n    output = output + \" cause=\";\n    output = appendQuoted(Pretty.pretty(cause), output);\n  }\n  if (Chunk.isNonEmpty(spans)) {\n    output = output + \" \";\n    let first = true;\n    for (const span of spans) {\n      if (first) {\n        first = false;\n      } else {\n        output = output + \" \";\n      }\n      output = output + LogSpan.render(nowMillis)(span);\n    }\n  }\n  if (HashMap.size(annotations) > 0) {\n    output = output + \" \";\n    let first = true;\n    for (const [key, value] of annotations) {\n      if (first) {\n        first = false;\n      } else {\n        output = output + \" \";\n      }\n      output = output + filterKeyName(key);\n      output = output + \"=\";\n      output = appendQuoted(value, output);\n    }\n  }\n  return output;\n});\n/** @internal */\nexports.stringLogger = stringLogger;\nconst escapeDoubleQuotes = str => `\"${str.replace(/\\\\([\\s\\S])|(\")/g, \"\\\\$1$2\")}\"`;\nconst textOnly = /^[^\\s\"=]+$/;\n/** @internal */\nconst appendQuoted = (label, output) => output + (label.match(textOnly) ? label : escapeDoubleQuotes(label));\n/** @internal */\nconst logfmtLogger = /*#__PURE__*/makeLogger((fiberId, logLevel, message, cause, _context, spans, annotations) => {\n  const now = new Date();\n  const nowMillis = now.getTime();\n  const outputArray = [`timestamp=${now.toISOString()}`, `level=${logLevel.label}`, `fiber=${_fiberId.threadName(fiberId)}`];\n  let output = outputArray.join(\" \");\n  if (message.length > 0) {\n    output = output + \" message=\";\n    output = appendQuotedLogfmt(message, output);\n  }\n  if (cause != null && cause != Cause.empty) {\n    output = output + \" cause=\";\n    output = appendQuotedLogfmt(Pretty.pretty(cause), output);\n  }\n  if (Chunk.isNonEmpty(spans)) {\n    output = output + \" \";\n    let first = true;\n    for (const span of spans) {\n      if (first) {\n        first = false;\n      } else {\n        output = output + \" \";\n      }\n      output = output + renderLogSpanLogfmt(nowMillis)(span);\n    }\n  }\n  if (HashMap.size(annotations) > 0) {\n    output = output + \" \";\n    let first = true;\n    for (const [key, value] of annotations) {\n      if (first) {\n        first = false;\n      } else {\n        output = output + \" \";\n      }\n      output = output + filterKeyName(key);\n      output = output + \"=\";\n      output = appendQuotedLogfmt(value, output);\n    }\n  }\n  return output;\n});\n/** @internal */\nexports.logfmtLogger = logfmtLogger;\nconst filterKeyName = key => key.replace(/[\\s=\"]/g, \"_\");\n/** @internal */\nconst escapeDoubleQuotesLogfmt = str => JSON.stringify(str);\n/** @internal */\nconst appendQuotedLogfmt = (label, output) => output + (label.match(textOnly) ? label : escapeDoubleQuotesLogfmt(label));\n/** @internal */\nconst renderLogSpanLogfmt = now => self => {\n  const label = filterKeyName(self.label);\n  return `${label}=${now - self.startTime}ms`;\n};\n/** @internal */\nconst contramap = /*#__PURE__*/Debug.untracedDual(2, restore => (self, f) => makeLogger((fiberId, logLevel, message, cause, context, spans, annotations) => self.log(fiberId, logLevel, restore(f)(message), cause, context, spans, annotations)));\n/** @internal */\nexports.contramap = contramap;\nconst filterLogLevel = /*#__PURE__*/Debug.untracedDual(2, restore => (self, f) => makeLogger((fiberId, logLevel, message, cause, context, spans, annotations) => restore(f)(logLevel) ? Option.some(self.log(fiberId, logLevel, message, cause, context, spans, annotations)) : Option.none()));\n/** @internal */\nexports.filterLogLevel = filterLogLevel;\nconst map = /*#__PURE__*/Debug.untracedDual(2, restore => (self, f) => makeLogger((fiberId, logLevel, message, cause, context, spans, annotations) => restore(f)(self.log(fiberId, logLevel, message, cause, context, spans, annotations))));\n/** @internal */\nexports.map = map;\nconst none = () => ({\n  [LoggerTypeId]: loggerVariance,\n  log: _Function.constVoid\n});\n/** @internal */\nexports.none = none;\nconst simple = log => ({\n  [LoggerTypeId]: loggerVariance,\n  log: (_fiberId, _logLevel, message, _cause, _context, _spans, _annotations) => {\n    return log(message);\n  }\n});\n/** @internal */\nexports.simple = simple;\nconst succeed = value => {\n  return simple(() => value);\n};\n/** @internal */\nexports.succeed = succeed;\nconst sync = evaluate => {\n  return simple(evaluate);\n};\n/** @internal */\nexports.sync = sync;\nconst zip = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => makeLogger((fiberId, logLevel, message, cause, context, spans, annotations) => [self.log(fiberId, logLevel, message, cause, context, spans, annotations), that.log(fiberId, logLevel, message, cause, context, spans, annotations)]));\n/** @internal */\nexports.zip = zip;\nconst zipLeft = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => map(zip(self, that), tuple => tuple[0]));\n/** @internal */\nexports.zipLeft = zipLeft;\nconst zipRight = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => map(zip(self, that), tuple => tuple[1]));\nexports.zipRight = zipRight;\n//# sourceMappingURL=logger.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.zip = exports.withNow = exports.withConstantInput = exports.value = exports.update = exports.unsafeSnapshot = exports.trackSuccessWith = exports.trackSuccess = exports.trackErrorWith = exports.trackError = exports.trackDurationWith = exports.trackDuration = exports.trackDefectWith = exports.trackDefect = exports.trackAll = exports.timerWithBoundaries = exports.timer = exports.taggedWithLabelsInput = exports.taggedWithLabels = exports.tagged = exports.sync = exports.summaryTimestamp = exports.summary = exports.succeed = exports.snapshot = exports.set = exports.mapType = exports.map = exports.make = exports.incrementBy = exports.increment = exports.histogram = exports.globalMetricRegistry = exports.gauge = exports.fromMetricKey = exports.frequency = exports.counter = exports.contramap = exports.MetricTypeId = void 0;\nvar Chunk = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Chunk\"));\nvar Duration = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Duration\"));\nvar _Function = /*#__PURE__*/require(\"@effect/data/Function\");\nvar _Global = /*#__PURE__*/require(\"@effect/data/Global\");\nvar HashSet = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/HashSet\"));\nvar Debug = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Debug\"));\nvar Cause = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/cause\"));\nvar core = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/core\"));\nvar _effect = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/effect\"));\nvar metricBoundaries = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/metric/boundaries\"));\nvar metricKey = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/metric/key\"));\nvar metricLabel = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/metric/label\"));\nvar metricRegistry = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/metric/registry\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/** @internal */\nconst MetricSymbolKey = \"@effect/io/Metric\";\n/** @internal */\nconst MetricTypeId = /*#__PURE__*/Symbol.for(MetricSymbolKey);\n/** @internal */\nexports.MetricTypeId = MetricTypeId;\nconst metricVariance = {\n  _Type: _ => _,\n  _In: _ => _,\n  _Out: _ => _\n};\n/** @internal */\nconst globalMetricRegistry = /*#__PURE__*/(0, _Global.globalValue)( /*#__PURE__*/Symbol.for(\"@effect/io/Metric/globalMetricRegistry\"), () => metricRegistry.make());\n/** @internal */\nexports.globalMetricRegistry = globalMetricRegistry;\nconst make = function (keyType, unsafeUpdate, unsafeValue) {\n  const metric = Object.assign(Debug.methodWithTrace((trace, restore) => effect => core.tap(effect, a => core.sync(() => restore(unsafeUpdate)(a, HashSet.empty()))).traced(trace)), {\n    [MetricTypeId]: metricVariance,\n    keyType,\n    unsafeUpdate,\n    unsafeValue\n  });\n  return metric;\n};\n/** @internal */\nexports.make = make;\nconst contramap = /*#__PURE__*/Debug.untracedDual(2, restore => (self, f) => make(self.keyType, (input, extraTags) => self.unsafeUpdate(restore(f)(input), extraTags), self.unsafeValue));\n/** @internal */\nexports.contramap = contramap;\nconst counter = name => fromMetricKey(metricKey.counter(name));\n/** @internal */\nexports.counter = counter;\nconst frequency = name => fromMetricKey(metricKey.frequency(name));\n/** @internal */\nexports.frequency = frequency;\nconst withConstantInput = /*#__PURE__*/Debug.untracedDual(2, () => (self, input) => contramap(self, () => input));\n/** @internal */\nexports.withConstantInput = withConstantInput;\nconst fromMetricKey = key => {\n  const hook = extraTags => {\n    const fullKey = metricKey.taggedWithLabelSet(extraTags)(key);\n    return globalMetricRegistry.get(fullKey);\n  };\n  return make(key.keyType, (input, extraTags) => hook(extraTags).update(input), extraTags => hook(extraTags).get());\n};\n/** @internal */\nexports.fromMetricKey = fromMetricKey;\nconst gauge = name => fromMetricKey(metricKey.gauge(name));\n/** @internal */\nexports.gauge = gauge;\nconst histogram = (name, boundaries) => fromMetricKey(metricKey.histogram(name, boundaries));\n/* @internal */\nexports.histogram = histogram;\nconst increment = /*#__PURE__*/Debug.methodWithTrace(trace => self => update(self, 1).traced(trace));\n/* @internal */\nexports.increment = increment;\nconst incrementBy = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, amount) => update(self, amount).traced(trace));\n/** @internal */\nexports.incrementBy = incrementBy;\nconst map = /*#__PURE__*/Debug.untracedDual(2, restore => (self, f) => make(self.keyType, self.unsafeUpdate, extraTags => restore(f)(self.unsafeValue(extraTags))));\n/** @internal */\nexports.map = map;\nconst mapType = /*#__PURE__*/Debug.untracedDual(2, restore => (self, f) => make(restore(f)(self.keyType), self.unsafeUpdate, self.unsafeValue));\n/* @internal */\nexports.mapType = mapType;\nconst set = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, value) => update(self, value).traced(trace));\n/** @internal */\nexports.set = set;\nconst snapshot = /*#__PURE__*/Debug.methodWithTrace(trace => () => core.sync(unsafeSnapshot).traced(trace));\n/** @internal */\nexports.snapshot = snapshot;\nconst succeed = out => make(void 0, _Function.constVoid, () => out);\n/** @internal */\nexports.succeed = succeed;\nconst sync = evaluate => make(void 0, _Function.constVoid, evaluate);\n/** @internal */\nexports.sync = sync;\nconst summary = (name, maxAge, maxSize, error, quantiles) => withNow(summaryTimestamp(name, maxAge, maxSize, error, quantiles));\n/** @internal */\nexports.summary = summary;\nconst summaryTimestamp = (name, maxAge, maxSize, error, quantiles) => fromMetricKey(metricKey.summary(name, maxAge, maxSize, error, quantiles));\n/** @internal */\nexports.summaryTimestamp = summaryTimestamp;\nconst tagged = /*#__PURE__*/(0, _Function.dual)(3, (self, key, value) => taggedWithLabels(self, HashSet.make(metricLabel.make(key, value))));\n/** @internal */\nexports.tagged = tagged;\nconst taggedWithLabelsInput = /*#__PURE__*/Debug.untracedDual(2, restore => (self, f) => map(make(self.keyType, (input, extraTags) => self.unsafeUpdate(input, HashSet.union(HashSet.fromIterable(restore(f)(input)), extraTags)), self.unsafeValue), _Function.constVoid));\n/** @internal */\nexports.taggedWithLabelsInput = taggedWithLabelsInput;\nconst taggedWithLabels = /*#__PURE__*/(0, _Function.dual)(2, (self, extraTagsIterable) => {\n  const extraTags = HashSet.isHashSet(extraTagsIterable) ? extraTagsIterable : HashSet.fromIterable(extraTagsIterable);\n  return make(self.keyType, (input, extraTags1) => self.unsafeUpdate(input, HashSet.union(extraTags1)(extraTags)), extraTags1 => self.unsafeValue(HashSet.union(extraTags1)(extraTags)));\n});\n/** @internal */\nexports.taggedWithLabels = taggedWithLabels;\nconst timer = name => {\n  const boundaries = metricBoundaries.exponential(1, 2, 100);\n  const base = tagged(\"time_unit\", \"milliseconds\")(histogram(name, boundaries));\n  return contramap(duration => duration.millis)(base);\n};\n/** @internal */\nexports.timer = timer;\nconst timerWithBoundaries = (name, boundaries) => {\n  const base = tagged(\"time_unit\", \"milliseconds\")(histogram(name, metricBoundaries.fromChunk(boundaries)));\n  return contramap(base, duration => duration.millis);\n};\n/* @internal */\nexports.timerWithBoundaries = timerWithBoundaries;\nconst trackAll = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, input) => effect => Debug.untraced(() => core.matchCauseEffect(effect, cause => {\n  self.unsafeUpdate(input, HashSet.empty());\n  return core.failCause(cause);\n}, value => {\n  self.unsafeUpdate(input, HashSet.empty());\n  return core.succeed(value);\n}).traced(trace)));\n/* @internal */\nexports.trackAll = trackAll;\nconst trackDefect = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, metric) => trackDefectWith(self, metric, _Function.identity).traced(trace));\n/* @internal */\nexports.trackDefect = trackDefect;\nconst trackDefectWith = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (self, metric, f) => Debug.untraced(() => {\n  const updater = defect => metric.unsafeUpdate(restore(f)(defect), HashSet.empty());\n  return _effect.tapDefect(self, cause => core.sync(() => Chunk.forEach(updater)(Cause.defects(cause)))).traced(trace);\n}));\n/* @internal */\nexports.trackDefectWith = trackDefectWith;\nconst trackDuration = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, metric) => trackDurationWith(self, metric, _Function.identity).traced(trace));\n/* @internal */\nexports.trackDuration = trackDuration;\nconst trackDurationWith = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (self, metric, f) => Debug.untraced(() => core.suspend(() => {\n  const startTime = Date.now();\n  return core.map(self, a => {\n    const endTime = Date.now();\n    const duration = Duration.millis(endTime - startTime);\n    metric.unsafeUpdate(restore(f)(duration), HashSet.empty());\n    return a;\n  });\n}).traced(trace)));\n/* @internal */\nexports.trackDurationWith = trackDurationWith;\nconst trackError = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, metric) => trackErrorWith(self, metric, a => a).traced(trace));\n/* @internal */\nexports.trackError = trackError;\nconst trackErrorWith = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (self, metric, f) => Debug.untraced(() => {\n  const updater = error => update(metric, restore(f)(error));\n  return _effect.tapError(self, updater).traced(trace);\n}));\n/* @internal */\nexports.trackErrorWith = trackErrorWith;\nconst trackSuccess = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, metric) => trackSuccessWith(self, metric, a => a).traced(trace));\n/* @internal */\nexports.trackSuccess = trackSuccess;\nconst trackSuccessWith = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (self, metric, f) => Debug.untraced(() => {\n  const updater = value => update(metric, restore(f)(value));\n  return core.tap(self, updater).traced(trace);\n}));\n/* @internal */\nexports.trackSuccessWith = trackSuccessWith;\nconst update = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, input) => core.fiberRefGetWith(core.currentTags, tags => core.sync(() => self.unsafeUpdate(input, tags))).traced(trace));\n/* @internal */\nexports.update = update;\nconst value = /*#__PURE__*/Debug.methodWithTrace(trace => self => core.fiberRefGetWith(core.currentTags, tags => core.sync(() => self.unsafeValue(tags))).traced(trace));\n/** @internal */\nexports.value = value;\nconst withNow = self => contramap(self, input => [input, Date.now()]);\n/** @internal */\nexports.withNow = withNow;\nconst zip = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => make([self.keyType, that.keyType], (input, extraTags) => {\n  const [l, r] = input;\n  self.unsafeUpdate(l, extraTags);\n  that.unsafeUpdate(r, extraTags);\n}, extraTags => [self.unsafeValue(extraTags), that.unsafeValue(extraTags)]));\n/** @internal */\nexports.zip = zip;\nconst unsafeSnapshot = () => globalMetricRegistry.snapshot();\nexports.unsafeSnapshot = unsafeSnapshot;\n//# sourceMappingURL=metric.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.linear = exports.isMetricBoundaries = exports.fromChunk = exports.exponential = exports.MetricBoundariesTypeId = void 0;\nvar Chunk = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Chunk\"));\nvar Equal = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Equal\"));\nvar Hash = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Hash\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\nvar _a;\n/** @internal */\nconst MetricBoundariesSymbolKey = \"@effect/io/Metric/Boundaries\";\n/** @internal */\nconst MetricBoundariesTypeId = /*#__PURE__*/Symbol.for(MetricBoundariesSymbolKey);\n/** @internal */\nexports.MetricBoundariesTypeId = MetricBoundariesTypeId;\nclass MetricBoundariesImpl {\n  constructor(values) {\n    this.values = values;\n    this[_a] = MetricBoundariesTypeId;\n  }\n  [(_a = MetricBoundariesTypeId, Hash.symbol)]() {\n    return Hash.combine(Hash.hash(this.values))(Hash.hash(MetricBoundariesSymbolKey));\n  }\n  [Equal.symbol](u) {\n    return isMetricBoundaries(u) && Equal.equals(this.values, u.values);\n  }\n}\n/** @internal */\nconst isMetricBoundaries = u => {\n  return typeof u === \"object\" && u != null && MetricBoundariesTypeId in u;\n};\n/** @internal */\nexports.isMetricBoundaries = isMetricBoundaries;\nconst fromChunk = chunk => {\n  const values = Chunk.dedupe(Chunk.concat(Chunk.of(Number.POSITIVE_INFINITY))(chunk));\n  return new MetricBoundariesImpl(values);\n};\n/** @internal */\nexports.fromChunk = fromChunk;\nconst linear = (start, width, count) => {\n  return fromChunk(Chunk.map(i => start + i * width)(Chunk.range(0, count - 1)));\n};\n/** @internal */\nexports.linear = linear;\nconst exponential = (start, factor, count) => {\n  return fromChunk(Chunk.map(i => start * Math.pow(factor, i))(Chunk.range(0, count - 1)));\n};\nexports.exponential = exponential;\n//# sourceMappingURL=boundaries.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.summary = exports.onUpdate = exports.make = exports.histogram = exports.gauge = exports.frequency = exports.counter = exports.MetricHookTypeId = void 0;\nvar Chunk = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Chunk\"));\nvar Duration = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Duration\"));\nvar _Function = /*#__PURE__*/require(\"@effect/data/Function\");\nvar HashMap = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/HashMap\"));\nvar number = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Number\"));\nvar Option = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Option\"));\nvar metricState = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/metric/state\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/** @internal */\nconst MetricHookSymbolKey = \"@effect/io/Metric/Hook\";\n/** @internal */\nconst MetricHookTypeId = /*#__PURE__*/Symbol.for(MetricHookSymbolKey);\n/** @internal */\nexports.MetricHookTypeId = MetricHookTypeId;\nconst metricHookVariance = {\n  _In: _ => _,\n  _Out: _ => _\n};\n/** @internal */\nconst make = (get, update) => {\n  return {\n    [MetricHookTypeId]: metricHookVariance,\n    update,\n    get\n  };\n};\n/** @internal */\nexports.make = make;\nconst onUpdate = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => ({\n  [MetricHookTypeId]: metricHookVariance,\n  get: self.get,\n  update: input => {\n    self.update(input);\n    return f(input);\n  }\n}));\n/** @internal */\nexports.onUpdate = onUpdate;\nconst counter = _key => {\n  let sum = 0;\n  return make(() => metricState.counter(sum), value => {\n    sum = sum + value;\n  });\n};\n/** @internal */\nexports.counter = counter;\nconst frequency = _key => {\n  let count = 0;\n  const values = new Map();\n  const update = word => {\n    count = count + 1;\n    const slotCount = values.get(word) ?? 0;\n    values.set(word, slotCount + 1);\n  };\n  const snapshot = () => HashMap.fromIterable(Array.from(values.entries()).map(([k, v]) => [k, v]));\n  return make(() => metricState.frequency(snapshot()), update);\n};\n/** @internal */\nexports.frequency = frequency;\nconst gauge = (_key, startAt) => {\n  let value = startAt;\n  return make(() => metricState.gauge(value), v => {\n    value = v;\n  });\n};\n/** @internal */\nexports.gauge = gauge;\nconst histogram = key => {\n  const bounds = key.keyType.boundaries.values;\n  const size = bounds.length;\n  const values = Array(size + 1);\n  const boundaries = Array(size);\n  let count = 0;\n  let sum = 0;\n  let min = Number.MAX_VALUE;\n  let max = Number.MIN_VALUE;\n  Chunk.mapWithIndex((i, n) => {\n    boundaries[i] = n;\n  })(Chunk.sort(number.Order)(bounds));\n  // Insert the value into the right bucket with a binary search\n  const update = value => {\n    let from = 0;\n    let to = size;\n    while (from !== to) {\n      const mid = Math.floor(from + (to - from) / 2);\n      const boundary = boundaries[mid];\n      if (value <= boundary) {\n        to = mid;\n      } else {\n        from = mid;\n      }\n      // The special case when to / from have a distance of one\n      if (to === from + 1) {\n        if (value <= boundaries[from]) {\n          to = from;\n        } else {\n          from = to;\n        }\n      }\n    }\n    values[from] = values[from] + 1;\n    count = count + 1;\n    sum = sum + value;\n    if (value < min) {\n      min = value;\n    }\n    if (value > max) {\n      max = value;\n    }\n  };\n  const getBuckets = () => {\n    const builder = [];\n    let i = 0;\n    let cumulated = 0;\n    while (i != size) {\n      const boundary = boundaries[i];\n      const value = values[i];\n      cumulated = cumulated + value;\n      builder.push([boundary, cumulated]);\n      i = i + 1;\n    }\n    return Chunk.fromIterable(builder);\n  };\n  return make(() => metricState.histogram(getBuckets(), count, min, max, sum), update);\n};\n/** @internal */\nexports.histogram = histogram;\nconst summary = key => {\n  const {\n    error,\n    maxAge,\n    maxSize,\n    quantiles\n  } = key.keyType;\n  const sortedQuantiles = Chunk.sort(number.Order)(quantiles);\n  const values = Array(maxSize);\n  let head = 0;\n  let count = 0;\n  let sum = 0;\n  let min = Number.MAX_VALUE;\n  let max = Number.MIN_VALUE;\n  // Just before the snapshot we filter out all values older than maxAge\n  const snapshot = now => {\n    const builder = [];\n    // If the buffer is not full yet it contains valid items at the 0..last\n    // indices and null values at the rest of the positions.\n    //\n    // If the buffer is already full then all elements contains a valid\n    // measurement with timestamp.\n    //\n    // At any given point in time we can enumerate all the non-null elements in\n    // the buffer and filter them by timestamp to get a valid view of a time\n    // window.\n    //\n    // The order does not matter because it gets sorted before passing to\n    // `calculateQuantiles`.\n    let i = 0;\n    while (i !== maxSize - 1) {\n      const item = values[i];\n      if (item != null) {\n        const [t, v] = item;\n        const age = Duration.millis(now - t);\n        if (age.millis >= 0 && age <= maxAge) {\n          builder.push(v);\n        }\n      }\n      i = i + 1;\n    }\n    return calculateQuantiles(error, sortedQuantiles, Chunk.sort(number.Order)(Chunk.fromIterable(builder)));\n  };\n  const observe = (value, timestamp) => {\n    if (maxSize > 0) {\n      head = head + 1;\n      const target = head % maxSize;\n      values[target] = [timestamp, value];\n    }\n    count = count + 1;\n    sum = sum + value;\n    if (value < min) {\n      min = value;\n    }\n    if (value > max) {\n      max = value;\n    }\n  };\n  return make(() => metricState.summary(error, snapshot(Date.now()), count, min, max, sum), ([value, timestamp]) => observe(value, timestamp));\n};\n/** @internal */\nexports.summary = summary;\nconst calculateQuantiles = (error, sortedQuantiles, sortedSamples) => {\n  // The number of samples examined\n  const sampleCount = sortedSamples.length;\n  if (Chunk.isEmpty(sortedQuantiles)) {\n    return Chunk.empty();\n  }\n  const head = Chunk.unsafeHead(sortedQuantiles);\n  const tail = Chunk.drop(1)(sortedQuantiles);\n  const resolved = Chunk.reduce(Chunk.of(resolveQuantile(error, sampleCount, Option.none(), 0, head, sortedSamples)), (accumulator, quantile) => {\n    const h = Chunk.unsafeHead(accumulator);\n    return Chunk.append(resolveQuantile(error, sampleCount, h.value, h.consumed, quantile, h.rest))(accumulator);\n  })(tail);\n  return Chunk.map(rq => [rq.quantile, rq.value])(resolved);\n};\n/** @internal */\nconst resolveQuantile = (error, sampleCount, current, consumed, quantile, rest) => {\n  let error_1 = error;\n  let sampleCount_1 = sampleCount;\n  let current_1 = current;\n  let consumed_1 = consumed;\n  let quantile_1 = quantile;\n  let rest_1 = rest;\n  let error_2 = error;\n  let sampleCount_2 = sampleCount;\n  let current_2 = current;\n  let consumed_2 = consumed;\n  let quantile_2 = quantile;\n  let rest_2 = rest;\n  // eslint-disable-next-line no-constant-condition\n  while (1) {\n    // If the remaining list of samples is empty, there is nothing more to resolve\n    if (Chunk.isEmpty(rest_1)) {\n      return {\n        quantile: quantile_1,\n        value: Option.none(),\n        consumed: consumed_1,\n        rest: Chunk.empty()\n      };\n    }\n    // If the quantile is the 100% quantile, we can take the maximum of all the\n    // remaining values as the result\n    if (quantile_1 === 1) {\n      return {\n        quantile: quantile_1,\n        value: Option.some(Chunk.unsafeLast(rest_1)),\n        consumed: consumed_1 + rest_1.length,\n        rest: Chunk.empty()\n      };\n    }\n    // Split into two chunks - the first chunk contains all elements of the same\n    // value as the chunk head\n    const sameHead = Chunk.splitWhere(n => n > Chunk.unsafeHead(rest_1))(rest_1);\n    // How many elements do we want to accept for this quantile\n    const desired = quantile_1 * sampleCount_1;\n    // The error margin\n    const allowedError = error_1 / 2 * desired;\n    // Taking into account the elements consumed from the samples so far and the\n    // number of same elements at the beginning of the chunk, calculate the number\n    // of elements we would have if we selected the current head as result\n    const candConsumed = consumed_1 + sameHead[0].length;\n    const candError = Math.abs(candConsumed - desired);\n    // If we haven't got enough elements yet, recurse\n    if (candConsumed < desired - allowedError) {\n      error_2 = error_1;\n      sampleCount_2 = sampleCount_1;\n      current_2 = Chunk.head(rest_1);\n      consumed_2 = candConsumed;\n      quantile_2 = quantile_1;\n      rest_2 = sameHead[1];\n      error_1 = error_2;\n      sampleCount_1 = sampleCount_2;\n      current_1 = current_2;\n      consumed_1 = consumed_2;\n      quantile_1 = quantile_2;\n      rest_1 = rest_2;\n      continue;\n    }\n    // If we have too many elements, select the previous value and hand back the\n    // the rest as leftover\n    if (candConsumed > desired + allowedError) {\n      return {\n        quantile: quantile_1,\n        value: current_1,\n        consumed: consumed_1,\n        rest: rest_1\n      };\n    }\n    // If we are in the target interval, select the current head and hand back the leftover after dropping all elements\n    // from the sample chunk that are equal to the current head\n    switch (current_1._tag) {\n      case \"None\":\n        {\n          error_2 = error_1;\n          sampleCount_2 = sampleCount_1;\n          current_2 = Chunk.head(rest_1);\n          consumed_2 = candConsumed;\n          quantile_2 = quantile_1;\n          rest_2 = sameHead[1];\n          error_1 = error_2;\n          sampleCount_1 = sampleCount_2;\n          current_1 = current_2;\n          consumed_1 = consumed_2;\n          quantile_1 = quantile_2;\n          rest_1 = rest_2;\n          continue;\n        }\n      case \"Some\":\n        {\n          const prevError = Math.abs(desired - current_1.value);\n          if (candError < prevError) {\n            error_2 = error_1;\n            sampleCount_2 = sampleCount_1;\n            current_2 = Chunk.head(rest_1);\n            consumed_2 = candConsumed;\n            quantile_2 = quantile_1;\n            rest_2 = sameHead[1];\n            error_1 = error_2;\n            sampleCount_1 = sampleCount_2;\n            current_1 = current_2;\n            consumed_1 = consumed_2;\n            quantile_1 = quantile_2;\n            rest_1 = rest_2;\n            continue;\n          }\n          return {\n            quantile: quantile_1,\n            value: Option.some(current_1.value),\n            consumed: consumed_1,\n            rest: rest_1\n          };\n        }\n    }\n  }\n  throw new Error(\"BUG: MetricHook.resolveQuantiles - please report an issue at https://github.com/Effect-TS/io/issues\");\n};\n//# sourceMappingURL=hook.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.taggedWithLabels = exports.taggedWithLabelSet = exports.tagged = exports.summary = exports.isMetricKey = exports.histogram = exports.gauge = exports.frequency = exports.counter = exports.MetricKeyTypeId = void 0;\nvar Equal = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Equal\"));\nvar _Function = /*#__PURE__*/require(\"@effect/data/Function\");\nvar Hash = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Hash\"));\nvar HashSet = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/HashSet\"));\nvar metricKeyType = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/metric/keyType\"));\nvar metricLabel = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/metric/label\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\nvar _a;\n/** @internal */\nconst MetricKeySymbolKey = \"@effect/io/Metric/Key\";\n/** @internal */\nconst MetricKeyTypeId = /*#__PURE__*/Symbol.for(MetricKeySymbolKey);\n/** @internal */\nexports.MetricKeyTypeId = MetricKeyTypeId;\nconst metricKeyVariance = {\n  _Type: _ => _\n};\n/** @internal */\nclass MetricKeyImpl {\n  constructor(name, keyType, tags = HashSet.empty()) {\n    this.name = name;\n    this.keyType = keyType;\n    this.tags = tags;\n    this[_a] = metricKeyVariance;\n  }\n  [(_a = MetricKeyTypeId, Hash.symbol)]() {\n    return Hash.combine(Hash.hash(this.tags))(Hash.combine(Hash.hash(this.keyType))(Hash.hash(this.name)));\n  }\n  [Equal.symbol](u) {\n    return isMetricKey(u) && this.name === u.name && Equal.equals(this.keyType, u.keyType) && Equal.equals(this.tags, u.tags);\n  }\n}\n/** @internal */\nconst isMetricKey = u => {\n  return typeof u === \"object\" && u != null && MetricKeyTypeId in u;\n};\n/** @internal */\nexports.isMetricKey = isMetricKey;\nconst counter = name => {\n  return new MetricKeyImpl(name, metricKeyType.counter);\n};\n/** @internal */\nexports.counter = counter;\nconst frequency = name => {\n  return new MetricKeyImpl(name, metricKeyType.frequency);\n};\n/** @internal */\nexports.frequency = frequency;\nconst gauge = name => {\n  return new MetricKeyImpl(name, metricKeyType.gauge);\n};\n/** @internal */\nexports.gauge = gauge;\nconst histogram = (name, boundaries) => {\n  return new MetricKeyImpl(name, metricKeyType.histogram(boundaries));\n};\n/** @internal */\nexports.histogram = histogram;\nconst summary = (name, maxAge, maxSize, error, quantiles) => {\n  return new MetricKeyImpl(name, metricKeyType.summary(maxAge, maxSize, error, quantiles));\n};\n/** @internal */\nexports.summary = summary;\nconst tagged = /*#__PURE__*/(0, _Function.dual)(3, (self, key, value) => taggedWithLabelSet(self, HashSet.make(metricLabel.make(key, value))));\n/** @internal */\nexports.tagged = tagged;\nconst taggedWithLabels = /*#__PURE__*/(0, _Function.dual)(2, (self, extraTags) => taggedWithLabelSet(self, HashSet.fromIterable(extraTags)));\n/** @internal */\nexports.taggedWithLabels = taggedWithLabels;\nconst taggedWithLabelSet = /*#__PURE__*/(0, _Function.dual)(2, (self, extraTags) => HashSet.size(extraTags) === 0 ? self : new MetricKeyImpl(self.name, self.keyType, HashSet.union(extraTags)(self.tags)));\nexports.taggedWithLabelSet = taggedWithLabelSet;\n//# sourceMappingURL=key.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.summary = exports.isSummaryKey = exports.isMetricKeyType = exports.isHistogramKey = exports.isGaugeKey = exports.isFrequencyKey = exports.isCounterKey = exports.histogram = exports.gauge = exports.frequency = exports.counter = exports.SummaryKeyTypeTypeId = exports.MetricKeyTypeTypeId = exports.HistogramKeyTypeTypeId = exports.HistogramKeyType = exports.GaugeKeyTypeTypeId = exports.FrequencyKeyTypeTypeId = exports.CounterKeyTypeTypeId = void 0;\nvar Equal = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Equal\"));\nvar Hash = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Hash\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\nvar _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\n/** @internal */\nconst MetricKeyTypeSymbolKey = \"@effect/io/Metric/KeyType\";\n/** @internal */\nconst MetricKeyTypeTypeId = /*#__PURE__*/Symbol.for(MetricKeyTypeSymbolKey);\n/** @internal */\nexports.MetricKeyTypeTypeId = MetricKeyTypeTypeId;\nconst CounterKeyTypeSymbolKey = \"effect/io/Metric/KeyType/Counter\";\n/** @internal */\nconst CounterKeyTypeTypeId = /*#__PURE__*/Symbol.for(CounterKeyTypeSymbolKey);\n/** @internal */\nexports.CounterKeyTypeTypeId = CounterKeyTypeTypeId;\nconst FrequencyKeyTypeSymbolKey = \"effect/io/Metric/KeyType/Frequency\";\n/** @internal */\nconst FrequencyKeyTypeTypeId = /*#__PURE__*/Symbol.for(FrequencyKeyTypeSymbolKey);\n/** @internal */\nexports.FrequencyKeyTypeTypeId = FrequencyKeyTypeTypeId;\nconst GaugeKeyTypeSymbolKey = \"effect/io/Metric/KeyType/Gauge\";\n/** @internal */\nconst GaugeKeyTypeTypeId = /*#__PURE__*/Symbol.for(GaugeKeyTypeSymbolKey);\n/** @internal */\nexports.GaugeKeyTypeTypeId = GaugeKeyTypeTypeId;\nconst HistogramKeyTypeSymbolKey = \"effect/io/Metric/KeyType/Histogram\";\n/** @internal */\nconst HistogramKeyTypeTypeId = /*#__PURE__*/Symbol.for(HistogramKeyTypeSymbolKey);\n/** @internal */\nexports.HistogramKeyTypeTypeId = HistogramKeyTypeTypeId;\nconst SummaryKeyTypeSymbolKey = \"effect/io/Metric/KeyType/Summary\";\n/** @internal */\nconst SummaryKeyTypeTypeId = /*#__PURE__*/Symbol.for(SummaryKeyTypeSymbolKey);\n/** @internal */\nexports.SummaryKeyTypeTypeId = SummaryKeyTypeTypeId;\nconst metricKeyTypeVariance = {\n  _In: _ => _,\n  _Out: _ => _\n};\n/** @internal */\nclass CounterKeyType {\n  constructor() {\n    this[_a] = metricKeyTypeVariance;\n    this[_b] = CounterKeyTypeTypeId;\n  }\n  [(_a = MetricKeyTypeTypeId, _b = CounterKeyTypeTypeId, Hash.symbol)]() {\n    return Hash.hash(CounterKeyTypeSymbolKey);\n  }\n  [Equal.symbol](that) {\n    return isCounterKey(that);\n  }\n}\n/** @internal */\nclass FrequencyKeyType {\n  constructor() {\n    this[_c] = metricKeyTypeVariance;\n    this[_d] = FrequencyKeyTypeTypeId;\n  }\n  [(_c = MetricKeyTypeTypeId, _d = FrequencyKeyTypeTypeId, Hash.symbol)]() {\n    return Hash.hash(FrequencyKeyTypeSymbolKey);\n  }\n  [Equal.symbol](that) {\n    return isFrequencyKey(that);\n  }\n}\n/** @internal */\nclass GaugeKeyType {\n  constructor() {\n    this[_e] = metricKeyTypeVariance;\n    this[_f] = GaugeKeyTypeTypeId;\n  }\n  [(_e = MetricKeyTypeTypeId, _f = GaugeKeyTypeTypeId, Hash.symbol)]() {\n    return Hash.hash(GaugeKeyTypeSymbolKey);\n  }\n  [Equal.symbol](that) {\n    return isGaugeKey(that);\n  }\n}\n/**\n * @category model\n * @since 1.0.0\n */\nclass HistogramKeyType {\n  constructor(boundaries) {\n    this.boundaries = boundaries;\n    this[_g] = metricKeyTypeVariance;\n    this[_h] = HistogramKeyTypeTypeId;\n  }\n  [(_g = MetricKeyTypeTypeId, _h = HistogramKeyTypeTypeId, Hash.symbol)]() {\n    return Hash.combine(Hash.hash(this.boundaries))(Hash.hash(HistogramKeyTypeSymbolKey));\n  }\n  [Equal.symbol](that) {\n    return isHistogramKey(that) && Equal.equals(this.boundaries, that.boundaries);\n  }\n}\n/** @internal */\nexports.HistogramKeyType = HistogramKeyType;\nclass SummaryKeyType {\n  constructor(maxAge, maxSize, error, quantiles) {\n    this.maxAge = maxAge;\n    this.maxSize = maxSize;\n    this.error = error;\n    this.quantiles = quantiles;\n    this[_j] = metricKeyTypeVariance;\n    this[_k] = SummaryKeyTypeTypeId;\n  }\n  [(_j = MetricKeyTypeTypeId, _k = SummaryKeyTypeTypeId, Hash.symbol)]() {\n    return Hash.combine(Hash.hash(this.quantiles))(Hash.combine(Hash.hash(this.error))(Hash.combine(Hash.hash(this.maxSize))(Hash.combine(Hash.hash(this.maxAge))(Hash.hash(SummaryKeyTypeSymbolKey)))));\n  }\n  [Equal.symbol](that) {\n    return isSummaryKey(that) && Equal.equals(this.maxAge, that.maxAge) && this.maxSize === that.maxSize && this.error === that.error && Equal.equals(this.quantiles, that.quantiles);\n  }\n}\n/**\n * @since 1.0.0\n * @category constructors\n */\nconst counter = /*#__PURE__*/new CounterKeyType();\n/**\n * @since 1.0.0\n * @category constructors\n */\nexports.counter = counter;\nconst frequency = /*#__PURE__*/new FrequencyKeyType();\n/**\n * @since 1.0.0\n * @category constructors\n */\nexports.frequency = frequency;\nconst gauge = /*#__PURE__*/new GaugeKeyType();\n/**\n * @since 1.0.0\n * @category constructors\n */\nexports.gauge = gauge;\nconst histogram = boundaries => {\n  return new HistogramKeyType(boundaries);\n};\n/**\n * @since 1.0.0\n * @category constructors\n */\nexports.histogram = histogram;\nconst summary = (maxAge, maxSize, error, quantiles) => {\n  return new SummaryKeyType(maxAge, maxSize, error, quantiles);\n};\n/**\n * @since 1.0.0\n * @category refinements\n */\nexports.summary = summary;\nconst isMetricKeyType = u => {\n  return typeof u === \"object\" && u != null && MetricKeyTypeTypeId in u;\n};\n/**\n * @since 1.0.0\n * @category refinements\n */\nexports.isMetricKeyType = isMetricKeyType;\nconst isCounterKey = u => {\n  return typeof u === \"object\" && u != null && CounterKeyTypeTypeId in u;\n};\n/**\n * @since 1.0.0\n * @category refinements\n */\nexports.isCounterKey = isCounterKey;\nconst isFrequencyKey = u => {\n  return typeof u === \"object\" && u != null && FrequencyKeyTypeTypeId in u;\n};\n/**\n * @since 1.0.0\n * @category refinements\n */\nexports.isFrequencyKey = isFrequencyKey;\nconst isGaugeKey = u => {\n  return typeof u === \"object\" && u != null && GaugeKeyTypeTypeId in u;\n};\n/**\n * @since 1.0.0\n * @category refinements\n */\nexports.isGaugeKey = isGaugeKey;\nconst isHistogramKey = u => {\n  return typeof u === \"object\" && u != null && HistogramKeyTypeTypeId in u;\n};\n/**\n * @since 1.0.0\n * @category refinements\n */\nexports.isHistogramKey = isHistogramKey;\nconst isSummaryKey = u => {\n  return typeof u === \"object\" && u != null && SummaryKeyTypeTypeId in u;\n};\nexports.isSummaryKey = isSummaryKey;\n//# sourceMappingURL=keyType.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.make = exports.isMetricLabel = exports.MetricLabelTypeId = void 0;\nvar Equal = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Equal\"));\nvar Hash = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Hash\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\nvar _a;\n/** @internal */\nconst MetricLabelSymbolKey = \"@effect/io/Metric/Label\";\n/** @internal */\nconst MetricLabelTypeId = /*#__PURE__*/Symbol.for(MetricLabelSymbolKey);\n/** @internal */\nexports.MetricLabelTypeId = MetricLabelTypeId;\nclass MetricLabelImpl {\n  constructor(key, value) {\n    this.key = key;\n    this.value = value;\n    this[_a] = MetricLabelTypeId;\n  }\n  [(_a = MetricLabelTypeId, Hash.symbol)]() {\n    return Hash.combine(Hash.hash(this.value))(Hash.combine(Hash.hash(this.key))(Hash.hash(MetricLabelSymbolKey)));\n  }\n  [Equal.symbol](that) {\n    return isMetricLabel(that) && this.key === that.key && this.value === that.value;\n  }\n}\n/** @internal */\nconst make = (key, value) => {\n  return new MetricLabelImpl(key, value);\n};\n/** @internal */\nexports.make = make;\nconst isMetricLabel = u => {\n  return typeof u === \"object\" && u != null && MetricLabelTypeId in u;\n};\nexports.isMetricLabel = isMetricLabel;\n//# sourceMappingURL=label.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.unsafeMake = exports.make = exports.MetricPairTypeId = void 0;\n/** @internal */\nconst MetricPairSymbolKey = \"@effect/io/Metric/Pair\";\n/** @internal */\nconst MetricPairTypeId = /*#__PURE__*/Symbol.for(MetricPairSymbolKey);\n/** @internal */\nexports.MetricPairTypeId = MetricPairTypeId;\nconst metricPairVariance = {\n  _Type: _ => _\n};\n/** @internal */\nconst make = (metricKey, metricState) => {\n  return {\n    [MetricPairTypeId]: metricPairVariance,\n    metricKey,\n    metricState\n  };\n};\n/** @internal */\nexports.make = make;\nconst unsafeMake = (metricKey, metricState) => {\n  return {\n    [MetricPairTypeId]: metricPairVariance,\n    metricKey,\n    metricState\n  };\n};\nexports.unsafeMake = unsafeMake;\n//# sourceMappingURL=pair.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.make = exports.MetricRegistryTypeId = void 0;\nvar HashSet = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/HashSet\"));\nvar MutableHashMap = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/MutableHashMap\"));\nvar Option = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Option\"));\nvar metricHook = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/metric/hook\"));\nvar metricKeyType = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/metric/keyType\"));\nvar metricPair = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/metric/pair\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\nvar _a;\n/** @internal */\nconst MetricRegistrySymbolKey = \"@effect/io/Metric/Registry\";\n/** @internal */\nconst MetricRegistryTypeId = /*#__PURE__*/Symbol.for(MetricRegistrySymbolKey);\n/** @internal */\nexports.MetricRegistryTypeId = MetricRegistryTypeId;\nclass MetricRegistryImpl {\n  constructor() {\n    this[_a] = MetricRegistryTypeId;\n    this.map = MutableHashMap.empty();\n  }\n  snapshot() {\n    const result = [];\n    for (const [key, hook] of this.map) {\n      result.push(metricPair.unsafeMake(key, hook.get()));\n    }\n    return HashSet.fromIterable(result);\n  }\n  get(key) {\n    const hook = Option.getOrUndefined(MutableHashMap.get(key)(this.map));\n    if (hook == null) {\n      if (metricKeyType.isCounterKey(key.keyType)) {\n        return this.getCounter(key);\n      }\n      if (metricKeyType.isGaugeKey(key.keyType)) {\n        return this.getGauge(key);\n      }\n      if (metricKeyType.isFrequencyKey(key.keyType)) {\n        return this.getFrequency(key);\n      }\n      if (metricKeyType.isHistogramKey(key.keyType)) {\n        return this.getHistogram(key);\n      }\n      if (metricKeyType.isSummaryKey(key.keyType)) {\n        return this.getSummary(key);\n      }\n      throw new Error(\"BUG: MetricRegistry.get - unknown MetricKeyType - please report an issue at https://github.com/Effect-TS/io/issues\");\n    } else {\n      return hook;\n    }\n  }\n  getCounter(key) {\n    let value = Option.getOrUndefined(MutableHashMap.get(key)(this.map));\n    if (value == null) {\n      const counter = metricHook.counter(key);\n      if (!MutableHashMap.has(key)(this.map)) {\n        MutableHashMap.set(key, counter)(this.map);\n      }\n      value = counter;\n    }\n    return value;\n  }\n  getFrequency(key) {\n    let value = Option.getOrUndefined(MutableHashMap.get(key)(this.map));\n    if (value == null) {\n      const frequency = metricHook.frequency(key);\n      if (!MutableHashMap.has(key)(this.map)) {\n        MutableHashMap.set(key, frequency)(this.map);\n      }\n      value = frequency;\n    }\n    return value;\n  }\n  getGauge(key) {\n    let value = Option.getOrUndefined(MutableHashMap.get(key)(this.map));\n    if (value == null) {\n      const gauge = metricHook.gauge(key, 0);\n      if (!MutableHashMap.has(key)(this.map)) {\n        MutableHashMap.set(key, gauge)(this.map);\n      }\n      value = gauge;\n    }\n    return value;\n  }\n  getHistogram(key) {\n    let value = Option.getOrUndefined(MutableHashMap.get(key)(this.map));\n    if (value == null) {\n      const histogram = metricHook.histogram(key);\n      if (!MutableHashMap.has(key)(this.map)) {\n        MutableHashMap.set(key, histogram)(this.map);\n      }\n      value = histogram;\n    }\n    return value;\n  }\n  getSummary(key) {\n    let value = Option.getOrUndefined(MutableHashMap.get(key)(this.map));\n    if (value == null) {\n      const summary = metricHook.summary(key);\n      if (!MutableHashMap.has(key)(this.map)) {\n        MutableHashMap.set(key, summary)(this.map);\n      }\n      value = summary;\n    }\n    return value;\n  }\n}\n_a = MetricRegistryTypeId;\n/** @internal */\nconst make = () => {\n  return new MetricRegistryImpl();\n};\nexports.make = make;\n//# sourceMappingURL=registry.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.summary = exports.isSummaryState = exports.isMetricState = exports.isHistogramState = exports.isGaugeState = exports.isFrequencyState = exports.isCounterState = exports.histogram = exports.gauge = exports.frequency = exports.counter = exports.SummaryStateTypeId = exports.SummaryState = exports.MetricStateTypeId = exports.HistogramStateTypeId = exports.HistogramState = exports.GaugeStateTypeId = exports.FrequencyStateTypeId = exports.CounterStateTypeId = void 0;\nvar Equal = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Equal\"));\nvar Hash = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Hash\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\nvar _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\n/** @internal */\nconst MetricStateSymbolKey = \"@effect/io/Metric/State\";\n/** @internal */\nconst MetricStateTypeId = /*#__PURE__*/Symbol.for(MetricStateSymbolKey);\n/** @internal */\nexports.MetricStateTypeId = MetricStateTypeId;\nconst CounterStateSymbolKey = \"effect/io/Metric/State/Counter\";\n/** @internal */\nconst CounterStateTypeId = /*#__PURE__*/Symbol.for(CounterStateSymbolKey);\n/** @internal */\nexports.CounterStateTypeId = CounterStateTypeId;\nconst FrequencyStateSymbolKey = \"effect/io/Metric/State/Frequency\";\n/** @internal */\nconst FrequencyStateTypeId = /*#__PURE__*/Symbol.for(FrequencyStateSymbolKey);\n/** @internal */\nexports.FrequencyStateTypeId = FrequencyStateTypeId;\nconst GaugeStateSymbolKey = \"effect/io/Metric/State/Gauge\";\n/** @internal */\nconst GaugeStateTypeId = /*#__PURE__*/Symbol.for(GaugeStateSymbolKey);\n/** @internal */\nexports.GaugeStateTypeId = GaugeStateTypeId;\nconst HistogramStateSymbolKey = \"effect/io/Metric/State/Histogram\";\n/** @internal */\nconst HistogramStateTypeId = /*#__PURE__*/Symbol.for(HistogramStateSymbolKey);\n/** @internal */\nexports.HistogramStateTypeId = HistogramStateTypeId;\nconst SummaryStateSymbolKey = \"effect/io/Metric/State/Summary\";\n/** @internal */\nconst SummaryStateTypeId = /*#__PURE__*/Symbol.for(SummaryStateSymbolKey);\n/** @internal */\nexports.SummaryStateTypeId = SummaryStateTypeId;\nconst metricStateVariance = {\n  _A: _ => _\n};\n/** @internal */\nclass CounterState {\n  constructor(count) {\n    this.count = count;\n    this[_a] = metricStateVariance;\n    this[_b] = CounterStateTypeId;\n  }\n  [(_a = MetricStateTypeId, _b = CounterStateTypeId, Hash.symbol)]() {\n    return Hash.combine(Hash.hash(this.count))(Hash.hash(CounterStateSymbolKey));\n  }\n  [Equal.symbol](that) {\n    return isCounterState(that) && this.count === that.count;\n  }\n}\n/** @internal */\nclass FrequencyState {\n  constructor(occurrences) {\n    this.occurrences = occurrences;\n    this[_c] = metricStateVariance;\n    this[_d] = FrequencyStateTypeId;\n  }\n  [(_c = MetricStateTypeId, _d = FrequencyStateTypeId, Hash.symbol)]() {\n    return Hash.combine(Hash.hash(this.occurrences))(Hash.hash(FrequencyStateSymbolKey));\n  }\n  [Equal.symbol](that) {\n    return isFrequencyState(that) && Equal.equals(this.occurrences, that.occurrences);\n  }\n}\n/** @internal */\nclass GaugeState {\n  constructor(value) {\n    this.value = value;\n    this[_e] = metricStateVariance;\n    this[_f] = GaugeStateTypeId;\n  }\n  [(_e = MetricStateTypeId, _f = GaugeStateTypeId, Hash.symbol)]() {\n    return Hash.combine(Hash.hash(this.value))(Hash.hash(GaugeStateSymbolKey));\n  }\n  [Equal.symbol](u) {\n    return isGaugeState(u) && this.value === u.value;\n  }\n}\n/** @internal */\nclass HistogramState {\n  constructor(buckets, count, min, max, sum) {\n    this.buckets = buckets;\n    this.count = count;\n    this.min = min;\n    this.max = max;\n    this.sum = sum;\n    this[_g] = metricStateVariance;\n    this[_h] = HistogramStateTypeId;\n  }\n  [(_g = MetricStateTypeId, _h = HistogramStateTypeId, Hash.symbol)]() {\n    return Hash.combine(Hash.hash(this.sum))(Hash.combine(Hash.hash(this.max))(Hash.combine(Hash.hash(this.min))(Hash.combine(Hash.hash(this.count))(Hash.combine(Hash.hash(this.buckets))(Hash.hash(HistogramStateSymbolKey))))));\n  }\n  [Equal.symbol](that) {\n    return isHistogramState(that) && Equal.equals(this.buckets, that.buckets) && this.count === that.count && this.min === that.min && this.max === that.max && this.sum === that.sum;\n  }\n}\n/** @internal */\nexports.HistogramState = HistogramState;\nclass SummaryState {\n  constructor(error, quantiles, count, min, max, sum) {\n    this.error = error;\n    this.quantiles = quantiles;\n    this.count = count;\n    this.min = min;\n    this.max = max;\n    this.sum = sum;\n    this[_j] = metricStateVariance;\n    this[_k] = SummaryStateTypeId;\n  }\n  [(_j = MetricStateTypeId, _k = SummaryStateTypeId, Hash.symbol)]() {\n    return Hash.combine(Hash.hash(this.sum))(Hash.combine(Hash.hash(this.max))(Hash.combine(Hash.hash(this.min))(Hash.combine(Hash.hash(this.count))(Hash.combine(Hash.hash(this.quantiles))(Hash.combine(Hash.hash(this.error))(Hash.hash(SummaryStateSymbolKey)))))));\n  }\n  [Equal.symbol](that) {\n    return isSummaryState(that) && this.error === that.error && Equal.equals(this.quantiles, that.quantiles) && this.count === that.count && this.min === that.min && this.max === that.max && this.sum === that.sum;\n  }\n}\n/** @internal */\nexports.SummaryState = SummaryState;\nconst counter = count => {\n  return new CounterState(count);\n};\n/** @internal */\nexports.counter = counter;\nconst frequency = occurrences => {\n  return new FrequencyState(occurrences);\n};\n/** @internal */\nexports.frequency = frequency;\nconst gauge = value => {\n  return new GaugeState(value);\n};\n/** @internal */\nexports.gauge = gauge;\nconst histogram = (buckets, count, min, max, sum) => {\n  return new HistogramState(buckets, count, min, max, sum);\n};\n/** @internal */\nexports.histogram = histogram;\nconst summary = (error, quantiles, count, min, max, sum) => {\n  return new SummaryState(error, quantiles, count, min, max, sum);\n};\n/** @internal */\nexports.summary = summary;\nconst isMetricState = u => {\n  return typeof u === \"object\" && u != null && MetricStateTypeId in u;\n};\n/** @internal */\nexports.isMetricState = isMetricState;\nconst isCounterState = u => {\n  return typeof u === \"object\" && u != null && CounterStateTypeId in u;\n};\n/**\n * @since 1.0.0\n * @category refinements\n */\nexports.isCounterState = isCounterState;\nconst isFrequencyState = u => {\n  return typeof u === \"object\" && u != null && FrequencyStateTypeId in u;\n};\n/**\n * @since 1.0.0\n * @category refinements\n */\nexports.isFrequencyState = isFrequencyState;\nconst isGaugeState = u => {\n  return typeof u === \"object\" && u != null && GaugeStateTypeId in u;\n};\n/**\n * @since 1.0.0\n * @category refinements\n */\nexports.isGaugeState = isGaugeState;\nconst isHistogramState = u => {\n  return typeof u === \"object\" && u != null && HistogramStateTypeId in u;\n};\n/**\n * @since 1.0.0\n * @category refinements\n */\nexports.isHistogramState = isHistogramState;\nconst isSummaryState = u => {\n  return typeof u === \"object\" && u != null && SummaryStateTypeId in u;\n};\nexports.isSummaryState = isSummaryState;\n//# sourceMappingURL=state.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.OP_SEQUENTIAL = exports.OP_PARALLEL = exports.OP_INTERRUPT = exports.OP_FAIL = exports.OP_EMPTY = exports.OP_DIE = exports.OP_ANNOTATED = void 0;\n/** @internal */\nconst OP_DIE = \"Die\";\n/** @internal */\nexports.OP_DIE = OP_DIE;\nconst OP_EMPTY = \"Empty\";\n/** @internal */\nexports.OP_EMPTY = OP_EMPTY;\nconst OP_FAIL = \"Fail\";\n/** @internal */\nexports.OP_FAIL = OP_FAIL;\nconst OP_INTERRUPT = \"Interrupt\";\n/** @internal */\nexports.OP_INTERRUPT = OP_INTERRUPT;\nconst OP_ANNOTATED = \"Annotated\";\n/** @internal */\nexports.OP_ANNOTATED = OP_ANNOTATED;\nconst OP_PARALLEL = \"Parallel\";\n/** @internal */\nexports.OP_PARALLEL = OP_PARALLEL;\nconst OP_SEQUENTIAL = \"Sequential\";\nexports.OP_SEQUENTIAL = OP_SEQUENTIAL;\n//# sourceMappingURL=cause.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.OP_ZIP_WITH = exports.OP_TABLE = exports.OP_SEQUENCE = exports.OP_PRIMITIVE = exports.OP_NESTED = exports.OP_MAP_OR_FAIL = exports.OP_LAZY = exports.OP_FALLBACK = exports.OP_FAIL = exports.OP_DESCRIBED = exports.OP_CONSTANT = void 0;\n/** @internal */\nconst OP_CONSTANT = \"Constant\";\n/** @internal */\nexports.OP_CONSTANT = OP_CONSTANT;\nconst OP_FAIL = \"Fail\";\n/** @internal */\nexports.OP_FAIL = OP_FAIL;\nconst OP_FALLBACK = \"Fallback\";\n/** @internal */\nexports.OP_FALLBACK = OP_FALLBACK;\nconst OP_DESCRIBED = \"Described\";\n/** @internal */\nexports.OP_DESCRIBED = OP_DESCRIBED;\nconst OP_LAZY = \"Lazy\";\n/** @internal */\nexports.OP_LAZY = OP_LAZY;\nconst OP_MAP_OR_FAIL = \"MapOrFail\";\n/** @internal */\nexports.OP_MAP_OR_FAIL = OP_MAP_OR_FAIL;\nconst OP_NESTED = \"Nested\";\n/** @internal */\nexports.OP_NESTED = OP_NESTED;\nconst OP_PRIMITIVE = \"Primitive\";\n/** @internal */\nexports.OP_PRIMITIVE = OP_PRIMITIVE;\nconst OP_SEQUENCE = \"Sequence\";\n/** @internal */\nexports.OP_SEQUENCE = OP_SEQUENCE;\nconst OP_TABLE = \"Table\";\n/** @internal */\nexports.OP_TABLE = OP_TABLE;\nconst OP_ZIP_WITH = \"ZipWith\";\nexports.OP_ZIP_WITH = OP_ZIP_WITH;\n//# sourceMappingURL=config.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.OP_UNSUPPORTED = exports.OP_SOURCE_UNAVAILABLE = exports.OP_OR = exports.OP_MISSING_DATA = exports.OP_INVALID_DATA = exports.OP_AND = void 0;\n/** @internal */\nconst OP_AND = \"And\";\n/** @internal */\nexports.OP_AND = OP_AND;\nconst OP_OR = \"Or\";\n/** @internal */\nexports.OP_OR = OP_OR;\nconst OP_INVALID_DATA = \"InvalidData\";\n/** @internal */\nexports.OP_INVALID_DATA = OP_INVALID_DATA;\nconst OP_MISSING_DATA = \"MissingData\";\n/** @internal */\nexports.OP_MISSING_DATA = OP_MISSING_DATA;\nconst OP_SOURCE_UNAVAILABLE = \"SourceUnavailable\";\n/** @internal */\nexports.OP_SOURCE_UNAVAILABLE = OP_SOURCE_UNAVAILABLE;\nconst OP_UNSUPPORTED = \"Unsupported\";\nexports.OP_UNSUPPORTED = OP_UNSUPPORTED;\n//# sourceMappingURL=configError.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.OP_STATE_PENDING = exports.OP_STATE_DONE = void 0;\n/** @internal */\nconst OP_STATE_PENDING = \"Pending\";\n/** @internal */\nexports.OP_STATE_PENDING = OP_STATE_PENDING;\nconst OP_STATE_DONE = \"Done\";\nexports.OP_STATE_DONE = OP_STATE_DONE;\n//# sourceMappingURL=deferred.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.OP_YIELD = exports.OP_WITH_RUNTIME = exports.OP_WHILE = exports.OP_UPDATE_RUNTIME_FLAGS = exports.OP_TRACED = exports.OP_SYNC = exports.OP_SUCCESS = exports.OP_REVERT_FLAGS = exports.OP_ON_SUCCESS_AND_FAILURE = exports.OP_ON_SUCCESS = exports.OP_ON_FAILURE = exports.OP_FAILURE = exports.OP_COMMIT = exports.OP_ASYNC = void 0;\n/** @internal */\nconst OP_ASYNC = \"Async\";\n/** @internal */\nexports.OP_ASYNC = OP_ASYNC;\nconst OP_COMMIT = \"Commit\";\n/** @internal */\nexports.OP_COMMIT = OP_COMMIT;\nconst OP_FAILURE = \"Failure\";\n/** @internal */\nexports.OP_FAILURE = OP_FAILURE;\nconst OP_ON_FAILURE = \"OnFailure\";\n/** @internal */\nexports.OP_ON_FAILURE = OP_ON_FAILURE;\nconst OP_ON_SUCCESS = \"OnSuccess\";\n/** @internal */\nexports.OP_ON_SUCCESS = OP_ON_SUCCESS;\nconst OP_ON_SUCCESS_AND_FAILURE = \"OnSuccessAndFailure\";\n/** @internal */\nexports.OP_ON_SUCCESS_AND_FAILURE = OP_ON_SUCCESS_AND_FAILURE;\nconst OP_TRACED = \"OpTraced\";\n/** @internal */\nexports.OP_TRACED = OP_TRACED;\nconst OP_SUCCESS = \"Success\";\n/** @internal */\nexports.OP_SUCCESS = OP_SUCCESS;\nconst OP_SYNC = \"Sync\";\n/** @internal */\nexports.OP_SYNC = OP_SYNC;\nconst OP_UPDATE_RUNTIME_FLAGS = \"UpdateRuntimeFlags\";\n/** @internal */\nexports.OP_UPDATE_RUNTIME_FLAGS = OP_UPDATE_RUNTIME_FLAGS;\nconst OP_WHILE = \"While\";\n/** @internal */\nexports.OP_WHILE = OP_WHILE;\nconst OP_WITH_RUNTIME = \"WithRuntime\";\n/** @internal */\nexports.OP_WITH_RUNTIME = OP_WITH_RUNTIME;\nconst OP_YIELD = \"Yield\";\n/** @internal */\nexports.OP_YIELD = OP_YIELD;\nconst OP_REVERT_FLAGS = \"RevertFlags\";\nexports.OP_REVERT_FLAGS = OP_REVERT_FLAGS;\n//# sourceMappingURL=effect.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.OP_ZIP_WITH_PAR = exports.OP_ZIP_WITH = exports.OP_SUSPEND = exports.OP_SCOPED = exports.OP_PROVIDE_TO = exports.OP_FROM_EFFECT = exports.OP_FRESH = exports.OP_FOLD = exports.OP_EXTEND_SCOPE = void 0;\n/** @internal */\nconst OP_EXTEND_SCOPE = \"ExtendScope\";\n/** @internal */\nexports.OP_EXTEND_SCOPE = OP_EXTEND_SCOPE;\nconst OP_FOLD = \"Fold\";\n/** @internal */\nexports.OP_FOLD = OP_FOLD;\nconst OP_FRESH = \"Fresh\";\n/** @internal */\nexports.OP_FRESH = OP_FRESH;\nconst OP_FROM_EFFECT = \"FromEffect\";\n/** @internal */\nexports.OP_FROM_EFFECT = OP_FROM_EFFECT;\nconst OP_SCOPED = \"Scoped\";\n/** @internal */\nexports.OP_SCOPED = OP_SCOPED;\nconst OP_SUSPEND = \"Suspend\";\n/** @internal */\nexports.OP_SUSPEND = OP_SUSPEND;\nconst OP_PROVIDE_TO = \"ProvideTo\";\n/** @internal */\nexports.OP_PROVIDE_TO = OP_PROVIDE_TO;\nconst OP_ZIP_WITH = \"ZipWith\";\n/** @internal */\nexports.OP_ZIP_WITH = OP_ZIP_WITH;\nconst OP_ZIP_WITH_PAR = \"ZipWithPar\";\nexports.OP_ZIP_WITH_PAR = OP_ZIP_WITH_PAR;\n//# sourceMappingURL=layer.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.unsafeRemove = exports.unsafeCompleteTakers = exports.unbounded = exports.takeUpTo = exports.takeN = exports.takeBetween = exports.takeAll = exports.take = exports.slidingStrategy = exports.sliding = exports.size = exports.shutdown = exports.poll = exports.offerAll = exports.offer = exports.isShutdown = exports.isQueue = exports.isFull = exports.isEnqueue = exports.isEmpty = exports.isDequeue = exports.enqueueVariance = exports.droppingStrategy = exports.dropping = exports.dequeueVariance = exports.capacity = exports.bounded = exports.backPressureStrategy = exports.awaitShutdown = exports.QueueStrategyTypeId = exports.EnqueueTypeId = exports.DequeueTypeId = void 0;\nvar Chunk = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Chunk\"));\nvar MutableQueue = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/MutableQueue\"));\nvar MutableRef = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/MutableRef\"));\nvar ReadonlyArray = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/ReadonlyArray\"));\nvar Debug = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Debug\"));\nvar core = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/core\"));\nvar fiberRuntime = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/fiberRuntime\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\nvar _a, _b, _c, _d, _e;\n/** @internal */\nconst EnqueueSymbolKey = \"@effect/io/Queue/Enqueue\";\n/** @internal */\nconst EnqueueTypeId = /*#__PURE__*/Symbol.for(EnqueueSymbolKey);\n/** @internal */\nexports.EnqueueTypeId = EnqueueTypeId;\nconst DequeueSymbolKey = \"@effect/io/Queue/Dequeue\";\n/** @internal */\nconst DequeueTypeId = /*#__PURE__*/Symbol.for(DequeueSymbolKey);\n/** @internal */\nexports.DequeueTypeId = DequeueTypeId;\nconst QueueStrategySymbolKey = \"@effect/io/Queue/Strategy\";\n/** @internal */\nconst QueueStrategyTypeId = /*#__PURE__*/Symbol.for(QueueStrategySymbolKey);\n/** @internal */\nexports.QueueStrategyTypeId = QueueStrategyTypeId;\nconst queueStrategyVariance = {\n  _A: _ => _\n};\n/** @internal */\nconst enqueueVariance = {\n  _In: _ => _\n};\n/** @internal */\nexports.enqueueVariance = enqueueVariance;\nconst dequeueVariance = {\n  _Out: _ => _\n};\n/** @internal */\nexports.dequeueVariance = dequeueVariance;\nclass QueueImpl {\n  constructor( /** @internal */\n  queue, /** @internal */\n  takers, /** @internal */\n  shutdownHook, /** @internal */\n  shutdownFlag, /** @internal */\n  strategy) {\n    this.queue = queue;\n    this.takers = takers;\n    this.shutdownHook = shutdownHook;\n    this.shutdownFlag = shutdownFlag;\n    this.strategy = strategy;\n    this[_a] = enqueueVariance;\n    this[_b] = dequeueVariance;\n  }\n  capacity() {\n    return MutableQueue.capacity(this.queue);\n  }\n  size() {\n    return Debug.bodyWithTrace(trace => core.suspend(() => MutableRef.get(this.shutdownFlag) ? core.interrupt() : core.succeed(MutableQueue.length(this.queue) - MutableQueue.length(this.takers) + this.strategy.surplusSize())).traced(trace));\n  }\n  isEmpty() {\n    return Debug.bodyWithTrace(trace => core.map(this.size(), size => size <= 0).traced(trace));\n  }\n  isFull() {\n    return Debug.bodyWithTrace(trace => core.map(this.size(), size => size >= this.capacity()).traced(trace));\n  }\n  shutdown() {\n    return Debug.bodyWithTrace(trace => core.uninterruptible(core.withFiberRuntime(state => {\n      MutableRef.set(true)(this.shutdownFlag);\n      return core.asUnit(core.whenEffect(core.deferredSucceed(this.shutdownHook, void 0))(core.zipRight(this.strategy.shutdown())(fiberRuntime.forEachParDiscard(d => core.deferredInterruptWith(d, state.id()))(unsafePollAll(this.takers)))));\n    })).traced(trace));\n  }\n  isShutdown() {\n    return Debug.bodyWithTrace(trace => core.sync(() => MutableRef.get(this.shutdownFlag)).traced(trace));\n  }\n  awaitShutdown() {\n    return Debug.bodyWithTrace(trace => core.deferredAwait(this.shutdownHook).traced(trace));\n  }\n  offer(value) {\n    return Debug.bodyWithTrace(trace => core.suspend(() => {\n      if (MutableRef.get(this.shutdownFlag)) {\n        return core.interrupt();\n      }\n      let noRemaining;\n      if (MutableQueue.isEmpty(this.queue)) {\n        const taker = MutableQueue.poll(MutableQueue.EmptyMutableQueue)(this.takers);\n        if (taker !== MutableQueue.EmptyMutableQueue) {\n          unsafeCompleteDeferred(taker, value);\n          noRemaining = true;\n        } else {\n          noRemaining = false;\n        }\n      } else {\n        noRemaining = false;\n      }\n      if (noRemaining) {\n        return core.succeed(true);\n      }\n      // Not enough takers, offer to the queue\n      const succeeded = MutableQueue.offer(value)(this.queue);\n      unsafeCompleteTakers(this.strategy, this.queue, this.takers);\n      return succeeded ? core.succeed(true) : this.strategy.handleSurplus([value], this.queue, this.takers, this.shutdownFlag);\n    }).traced(trace));\n  }\n  offerAll(iterable) {\n    return Debug.bodyWithTrace(trace => core.suspend(() => {\n      if (MutableRef.get(this.shutdownFlag)) {\n        return core.interrupt();\n      }\n      const values = ReadonlyArray.fromIterable(iterable);\n      const pTakers = MutableQueue.isEmpty(this.queue) ? ReadonlyArray.fromIterable(unsafePollN(this.takers, values.length)) : ReadonlyArray.empty;\n      const [forTakers, remaining] = ReadonlyArray.splitAt(pTakers.length)(values);\n      for (let i = 0; i < pTakers.length; i++) {\n        const taker = pTakers[i];\n        const item = forTakers[i];\n        unsafeCompleteDeferred(taker, item);\n      }\n      if (remaining.length === 0) {\n        return core.succeed(true);\n      }\n      // Not enough takers, offer to the queue\n      const surplus = unsafeOfferAll(this.queue, remaining);\n      unsafeCompleteTakers(this.strategy, this.queue, this.takers);\n      return Chunk.isEmpty(surplus) ? core.succeed(true) : this.strategy.handleSurplus(surplus, this.queue, this.takers, this.shutdownFlag);\n    }).traced(trace));\n  }\n  take() {\n    return Debug.bodyWithTrace(trace => core.withFiberRuntime(state => {\n      if (MutableRef.get(this.shutdownFlag)) {\n        return core.interrupt();\n      }\n      const item = MutableQueue.poll(MutableQueue.EmptyMutableQueue)(this.queue);\n      if (item !== MutableQueue.EmptyMutableQueue) {\n        this.strategy.unsafeOnQueueEmptySpace(this.queue, this.takers);\n        return core.succeed(item);\n      } else {\n        // Add the deferred to takers, then:\n        // - Try to take again in case a value was added since\n        // - Wait for the deferred to be completed\n        // - Clean up resources in case of interruption\n        const deferred = core.deferredUnsafeMake(state.id());\n        return core.onInterrupt(() => {\n          return core.sync(() => unsafeRemove(this.takers, deferred));\n        })(core.suspend(() => {\n          MutableQueue.offer(deferred)(this.takers);\n          unsafeCompleteTakers(this.strategy, this.queue, this.takers);\n          return MutableRef.get(this.shutdownFlag) ? core.interrupt() : core.deferredAwait(deferred);\n        }));\n      }\n    }).traced(trace));\n  }\n  takeAll() {\n    return Debug.bodyWithTrace(trace => core.suspend(() => {\n      return MutableRef.get(this.shutdownFlag) ? core.interrupt() : core.sync(() => {\n        const values = unsafePollAll(this.queue);\n        this.strategy.unsafeOnQueueEmptySpace(this.queue, this.takers);\n        return Chunk.fromIterable(values);\n      });\n    }).traced(trace));\n  }\n  takeUpTo(max) {\n    return Debug.bodyWithTrace(trace => core.suspend(() => MutableRef.get(this.shutdownFlag) ? core.interrupt() : core.sync(() => {\n      const values = unsafePollN(this.queue, max);\n      this.strategy.unsafeOnQueueEmptySpace(this.queue, this.takers);\n      return Chunk.fromIterable(values);\n    })).traced(trace));\n  }\n  takeBetween(min, max) {\n    return Debug.bodyWithTrace(trace => core.suspend(() => takeRemainderLoop(this, min, max, Chunk.empty())).traced(trace));\n  }\n}\n_a = EnqueueTypeId, _b = DequeueTypeId;\n/** @internal */\nconst takeRemainderLoop = (self, min, max, acc) => {\n  if (max < min) {\n    return core.succeed(acc);\n  }\n  return core.flatMap(bs => {\n    const remaining = min - bs.length;\n    if (remaining === 1) {\n      return core.map(b => Chunk.append(b)(Chunk.concat(bs)(acc)))(take(self));\n    }\n    if (remaining > 1) {\n      return core.flatMap(b => takeRemainderLoop(self, remaining - 1, max - bs.length - 1, Chunk.append(b)(Chunk.concat(bs)(acc))))(take(self));\n    }\n    return core.succeed(Chunk.concat(bs)(acc));\n  })(takeUpTo(self, max));\n};\n/** @internal */\nconst isQueue = u => {\n  return isEnqueue(u) && isDequeue(u);\n};\n/** @internal */\nexports.isQueue = isQueue;\nconst isEnqueue = u => {\n  return typeof u === \"object\" && u != null && EnqueueTypeId in u;\n};\n/** @internal */\nexports.isEnqueue = isEnqueue;\nconst isDequeue = u => {\n  return typeof u === \"object\" && u != null && DequeueTypeId in u;\n};\n/** @internal */\nexports.isDequeue = isDequeue;\nconst bounded = /*#__PURE__*/Debug.methodWithTrace(trace => requestedCapacity => core.flatMap(queue => make(queue, backPressureStrategy()))(core.sync(() => MutableQueue.bounded(requestedCapacity))).traced(trace));\n/** @internal */\nexports.bounded = bounded;\nconst dropping = /*#__PURE__*/Debug.methodWithTrace(trace => requestedCapacity => core.flatMap(queue => make(queue, droppingStrategy()))(core.sync(() => MutableQueue.bounded(requestedCapacity))).traced(trace));\n/** @internal */\nexports.dropping = dropping;\nconst sliding = /*#__PURE__*/Debug.methodWithTrace(trace => requestedCapacity => core.flatMap(queue => make(queue, slidingStrategy()))(core.sync(() => MutableQueue.bounded(requestedCapacity))).traced(trace));\n/** @internal */\nexports.sliding = sliding;\nconst unbounded = /*#__PURE__*/Debug.methodWithTrace(trace => () => core.flatMap(queue => make(queue, droppingStrategy()))(core.sync(() => MutableQueue.unbounded())).traced(trace));\n/** @internal */\nexports.unbounded = unbounded;\nconst unsafeMake = (queue, takers, shutdownHook, shutdownFlag, strategy) => {\n  return new QueueImpl(queue, takers, shutdownHook, shutdownFlag, strategy);\n};\n/** @internal */\nconst make = /*#__PURE__*/Debug.methodWithTrace(trace => (queue, strategy) => core.map(deferred => unsafeMake(queue, MutableQueue.unbounded(), deferred, MutableRef.make(false), strategy))(core.deferredMake()).traced(trace));\n/** @internal */\nconst capacity = self => {\n  return self.capacity();\n};\n/** @internal */\nexports.capacity = capacity;\nconst size = /*#__PURE__*/Debug.methodWithTrace(trace => self => self.size().traced(trace));\n/** @internal */\nexports.size = size;\nconst isFull = /*#__PURE__*/Debug.methodWithTrace(trace => self => self.isFull().traced(trace));\n/** @internal */\nexports.isFull = isFull;\nconst isEmpty = /*#__PURE__*/Debug.methodWithTrace(trace => self => self.isEmpty().traced(trace));\n/** @internal */\nexports.isEmpty = isEmpty;\nconst isShutdown = /*#__PURE__*/Debug.methodWithTrace(trace => self => self.isShutdown().traced(trace));\n/** @internal */\nexports.isShutdown = isShutdown;\nconst awaitShutdown = /*#__PURE__*/Debug.methodWithTrace(trace => self => self.awaitShutdown().traced(trace));\n/** @internal */\nexports.awaitShutdown = awaitShutdown;\nconst shutdown = /*#__PURE__*/Debug.methodWithTrace(trace => self => self.shutdown().traced(trace));\n/** @internal */\nexports.shutdown = shutdown;\nconst offer = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, value) => self.offer(value).traced(trace));\n/** @internal */\nexports.offer = offer;\nconst offerAll = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, iterable) => self.offerAll(iterable).traced(trace));\n/** @internal */\nexports.offerAll = offerAll;\nconst poll = /*#__PURE__*/Debug.methodWithTrace(trace => self => core.map(Chunk.head)(self.takeUpTo(1)).traced(trace));\n/** @internal */\nexports.poll = poll;\nconst take = /*#__PURE__*/Debug.methodWithTrace(trace => self => self.take().traced(trace));\n/** @internal */\nexports.take = take;\nconst takeAll = /*#__PURE__*/Debug.methodWithTrace(trace => self => self.takeAll().traced(trace));\n/** @internal */\nexports.takeAll = takeAll;\nconst takeUpTo = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, max) => self.takeUpTo(max).traced(trace));\n/** @internal */\nexports.takeUpTo = takeUpTo;\nconst takeBetween = /*#__PURE__*/Debug.dualWithTrace(3, trace => (self, min, max) => self.takeBetween(min, max).traced(trace));\n/** @internal */\nexports.takeBetween = takeBetween;\nconst takeN = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, n) => self.takeBetween(n, n).traced(trace));\n// -----------------------------------------------------------------------------\n// Strategy\n// -----------------------------------------------------------------------------\n/** @internal */\nexports.takeN = takeN;\nconst backPressureStrategy = () => {\n  return new BackPressureStrategy();\n};\n/** @internal */\nexports.backPressureStrategy = backPressureStrategy;\nconst droppingStrategy = () => {\n  return new DroppingStrategy();\n};\n/** @internal */\nexports.droppingStrategy = droppingStrategy;\nconst slidingStrategy = () => {\n  return new SlidingStrategy();\n};\n/** @internal */\nexports.slidingStrategy = slidingStrategy;\nclass BackPressureStrategy {\n  constructor() {\n    this[_c] = queueStrategyVariance;\n    this.putters = MutableQueue.unbounded();\n  }\n  surplusSize() {\n    return MutableQueue.length(this.putters);\n  }\n  shutdown() {\n    return core.flatMap(fiberId => core.flatMap(fiberRuntime.forEachParDiscard(([_, deferred, isLastItem]) => isLastItem ? core.asUnit(core.deferredInterruptWith(deferred, fiberId)) : core.unit()))(core.sync(() => unsafePollAll(this.putters))))(core.fiberId());\n  }\n  handleSurplus(iterable, queue, takers, isShutdown) {\n    return core.withFiberRuntime(state => {\n      const deferred = core.deferredUnsafeMake(state.id());\n      return core.onInterrupt(() => core.sync(() => this.unsafeRemove(deferred)))(core.suspend(() => {\n        this.unsafeOffer(iterable, deferred);\n        this.unsafeOnQueueEmptySpace(queue, takers);\n        unsafeCompleteTakers(this, queue, takers);\n        return MutableRef.get(isShutdown) ? core.interrupt() : core.deferredAwait(deferred);\n      }));\n    });\n  }\n  unsafeOnQueueEmptySpace(queue, takers) {\n    let keepPolling = true;\n    while (keepPolling && !MutableQueue.isFull(queue)) {\n      const putter = MutableQueue.poll(MutableQueue.EmptyMutableQueue)(this.putters);\n      if (putter === MutableQueue.EmptyMutableQueue) {\n        keepPolling = false;\n      } else {\n        const offered = MutableQueue.offer(putter[0])(queue);\n        if (offered && putter[2]) {\n          unsafeCompleteDeferred(putter[1], true);\n        } else if (!offered) {\n          unsafeOfferAll(this.putters, Chunk.prepend(putter)(unsafePollAll(this.putters)));\n        }\n        unsafeCompleteTakers(this, queue, takers);\n      }\n    }\n  }\n  unsafeOffer(iterable, deferred) {\n    const iterator = iterable[Symbol.iterator]();\n    let next = iterator.next();\n    if (!next.done) {\n      // eslint-disable-next-line no-constant-condition\n      while (1) {\n        const value = next.value;\n        next = iterator.next();\n        if (next.done) {\n          MutableQueue.offer([value, deferred, true])(this.putters);\n          break;\n        }\n        MutableQueue.offer([value, deferred, false])(this.putters);\n      }\n    }\n  }\n  unsafeRemove(deferred) {\n    unsafeOfferAll(this.putters, Chunk.filter(([, _]) => _ !== deferred)(unsafePollAll(this.putters)));\n  }\n}\n_c = QueueStrategyTypeId;\n/** @internal */\nclass DroppingStrategy {\n  constructor() {\n    this[_d] = queueStrategyVariance;\n  }\n  surplusSize() {\n    return 0;\n  }\n  shutdown() {\n    return core.unit();\n  }\n  handleSurplus(_iterable, _queue, _takers, _isShutdown) {\n    return core.succeed(false);\n  }\n  unsafeOnQueueEmptySpace(_queue, _takers) {\n    //\n  }\n}\n_d = QueueStrategyTypeId;\n/** @internal */\nclass SlidingStrategy {\n  constructor() {\n    this[_e] = queueStrategyVariance;\n  }\n  surplusSize() {\n    return 0;\n  }\n  shutdown() {\n    return core.unit();\n  }\n  handleSurplus(iterable, queue, takers, _isShutdown) {\n    return core.sync(() => {\n      this.unsafeOffer(queue, iterable);\n      unsafeCompleteTakers(this, queue, takers);\n      return true;\n    });\n  }\n  unsafeOnQueueEmptySpace(_queue, _takers) {\n    //\n  }\n  unsafeOffer(queue, iterable) {\n    const iterator = iterable[Symbol.iterator]();\n    let next;\n    let offering = true;\n    while (!(next = iterator.next()).done && offering) {\n      if (MutableQueue.capacity(queue) === 0) {\n        return;\n      }\n      // Poll 1 and retry\n      MutableQueue.poll(MutableQueue.EmptyMutableQueue)(queue);\n      offering = MutableQueue.offer(next.value)(queue);\n    }\n  }\n}\n_e = QueueStrategyTypeId;\n/** @internal */\nconst unsafeCompleteDeferred = (deferred, a) => {\n  return core.deferredUnsafeDone(deferred, core.succeed(a));\n};\n/** @internal */\nconst unsafeOfferAll = (queue, as) => {\n  return MutableQueue.offerAll(as)(queue);\n};\n/** @internal */\nconst unsafePollAll = queue => {\n  return MutableQueue.pollUpTo(Number.POSITIVE_INFINITY)(queue);\n};\n/** @internal */\nconst unsafePollN = (queue, max) => {\n  return MutableQueue.pollUpTo(max)(queue);\n};\n/** @internal */\nconst unsafeRemove = (queue, a) => {\n  unsafeOfferAll(queue, Chunk.filter(b => a !== b)(unsafePollAll(queue)));\n};\n/** @internal */\nexports.unsafeRemove = unsafeRemove;\nconst unsafeCompleteTakers = (strategy, queue, takers) => {\n  // Check both a taker and an item are in the queue, starting with the taker\n  let keepPolling = true;\n  while (keepPolling && !MutableQueue.isEmpty(queue)) {\n    const taker = MutableQueue.poll(MutableQueue.EmptyMutableQueue)(takers);\n    if (taker !== MutableQueue.EmptyMutableQueue) {\n      const element = MutableQueue.poll(MutableQueue.EmptyMutableQueue)(queue);\n      if (element !== MutableQueue.EmptyMutableQueue) {\n        unsafeCompleteDeferred(taker, element);\n        strategy.unsafeOnQueueEmptySpace(queue, takers);\n      } else {\n        unsafeOfferAll(takers, Chunk.prepend(taker)(unsafePollAll(takers)));\n      }\n      keepPolling = true;\n    } else {\n      keepPolling = false;\n    }\n  }\n};\nexports.unsafeCompleteTakers = unsafeCompleteTakers;\n//# sourceMappingURL=queue.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.randomTag = exports.make = exports.RandomTypeId = void 0;\nvar Chunk = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Chunk\"));\nvar Context = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Context\"));\nvar PCGRandom = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Random\"));\nvar Debug = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Debug\"));\nvar core = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/core\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\nvar _a;\n/** @internal */\nconst RandomSymbolKey = \"@effect/io/Random\";\n/** @internal */\nconst RandomTypeId = /*#__PURE__*/Symbol.for(RandomSymbolKey);\n/** @internal */\nexports.RandomTypeId = RandomTypeId;\nconst randomTag = /*#__PURE__*/Context.Tag(RandomTypeId);\n/** @internal */\nexports.randomTag = randomTag;\nclass RandomImpl {\n  constructor(seed) {\n    this.seed = seed;\n    this[_a] = RandomTypeId;\n    this.PRNG = new PCGRandom.PCGRandom(seed);\n  }\n  next() {\n    return Debug.bodyWithTrace(trace => core.sync(() => this.PRNG.number()).traced(trace));\n  }\n  nextBoolean() {\n    return Debug.bodyWithTrace(trace => core.map(this.next(), n => n > 0.5).traced(trace));\n  }\n  nextInt() {\n    return Debug.bodyWithTrace(trace => core.sync(() => this.PRNG.integer(Number.MAX_SAFE_INTEGER)).traced(trace));\n  }\n  nextRange(min, max) {\n    return Debug.bodyWithTrace(trace => core.map(this.next(), n => (max - min) * n + min).traced(trace));\n  }\n  nextIntBetween(min, max) {\n    return Debug.bodyWithTrace(trace => core.sync(() => this.PRNG.integer(1 + max - min) + min).traced(trace));\n  }\n  shuffle(elements) {\n    return Debug.bodyWithTrace(trace => shuffleWith(elements, n => this.nextIntBetween(0, n)).traced(trace));\n  }\n}\n_a = RandomTypeId;\nconst shuffleWith = (elements, nextIntBounded) => {\n  return core.suspend(() => core.flatMap(buffer => {\n    const numbers = [];\n    for (let i = buffer.length; i >= 2; i = i - 1) {\n      numbers.push(i);\n    }\n    return core.as(Chunk.fromIterable(buffer))(core.forEachDiscard(n => core.map(k => swap(buffer, n - 1, k))(nextIntBounded(n)))(numbers));\n  })(core.sync(() => Array.from(elements))));\n};\nconst swap = (buffer, index1, index2) => {\n  const tmp = buffer[index1];\n  buffer[index1] = buffer[index2];\n  buffer[index2] = tmp;\n  return buffer;\n};\nconst make = seed => new RandomImpl(seed);\nexports.make = make;\n//# sourceMappingURL=random.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.updateSomeAndGet = exports.updateSome = exports.updateAndGet = exports.update = exports.unsafeMake = exports.unsafeGet = exports.setAndGet = exports.set = exports.refVariance = exports.modifySome = exports.modify = exports.make = exports.getAndUpdateSome = exports.getAndUpdate = exports.getAndSet = exports.get = exports.RefTypeId = void 0;\nvar MutableRef = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/MutableRef\"));\nvar Option = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Option\"));\nvar Debug = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Debug\"));\nvar core = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/core\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\nvar _a;\n/** @internal */\nconst RefTypeId = /*#__PURE__*/Symbol.for(\"@effect/io/Ref\");\n/** @internal */\nexports.RefTypeId = RefTypeId;\nconst refVariance = {\n  _A: _ => _\n};\nexports.refVariance = refVariance;\nclass RefImpl {\n  constructor(ref) {\n    this.ref = ref;\n    this[_a] = refVariance;\n  }\n  modify(f) {\n    return Debug.bodyWithTrace((trace, restore) => core.sync(() => {\n      const current = MutableRef.get(this.ref);\n      const [b, a] = restore(f)(current);\n      if (current !== a) {\n        MutableRef.set(a)(this.ref);\n      }\n      return b;\n    }).traced(trace));\n  }\n}\n_a = RefTypeId;\n/** @internal */\nconst unsafeMake = value => new RefImpl(MutableRef.make(value));\n/** @internal */\nexports.unsafeMake = unsafeMake;\nconst make = /*#__PURE__*/Debug.methodWithTrace(trace => value => core.sync(() => unsafeMake(value)).traced(trace));\n/** @internal */\nexports.make = make;\nconst get = /*#__PURE__*/Debug.methodWithTrace(trace => self => self.modify(a => [a, a]).traced(trace));\n/** @internal */\nexports.get = get;\nconst set = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, value) => self.modify(() => [void 0, value]).traced(trace));\n/** @internal */\nexports.set = set;\nconst getAndSet = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, value) => self.modify(a => [a, value]).traced(trace));\n/** @internal */\nexports.getAndSet = getAndSet;\nconst getAndUpdate = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => self.modify(a => [a, restore(f)(a)]).traced(trace));\n/** @internal */\nexports.getAndUpdate = getAndUpdate;\nconst getAndUpdateSome = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, pf) => self.modify(value => {\n  const option = restore(pf)(value);\n  switch (option._tag) {\n    case \"None\":\n      {\n        return [value, value];\n      }\n    case \"Some\":\n      {\n        return [value, option.value];\n      }\n  }\n}).traced(trace));\n/** @internal */\nexports.getAndUpdateSome = getAndUpdateSome;\nconst setAndGet = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, value) => self.modify(() => [value, value]).traced(trace));\n/** @internal */\nexports.setAndGet = setAndGet;\nconst modify = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => self.modify(restore(f)).traced(trace));\n/** @internal */\nexports.modify = modify;\nconst modifySome = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (self, fallback, pf) => self.modify(value => {\n  const option = restore(pf)(value);\n  switch (option._tag) {\n    case \"None\":\n      {\n        return [fallback, value];\n      }\n    case \"Some\":\n      {\n        return option.value;\n      }\n  }\n}).traced(trace));\n/** @internal */\nexports.modifySome = modifySome;\nconst update = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => self.modify(a => [void 0, restore(f)(a)]).traced(trace));\n/** @internal */\nexports.update = update;\nconst updateAndGet = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => self.modify(a => {\n  const result = restore(f)(a);\n  return [result, result];\n}).traced(trace));\n/** @internal */\nexports.updateAndGet = updateAndGet;\nconst updateSome = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => self.modify(a => [void 0, Option.match(() => a, b => b)(restore(f)(a))]).traced(trace));\n/** @internal */\nexports.updateSome = updateSome;\nconst updateSomeAndGet = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, pf) => self.modify(value => {\n  const option = restore(pf)(value);\n  switch (option._tag) {\n    case \"None\":\n      {\n        return [value, value];\n      }\n    case \"Some\":\n      {\n        return [option.value, option.value];\n      }\n  }\n}).traced(trace));\n/** @internal */\nexports.updateSomeAndGet = updateSomeAndGet;\nconst unsafeGet = self => MutableRef.get(self.ref);\nexports.unsafeGet = unsafeGet;\n//# sourceMappingURL=ref.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.unsafeRunSyncExitOrFiberEffect = exports.unsafeRunSyncExitOrFiber = exports.unsafeRunSyncExitEffect = exports.unsafeRunSyncExit = exports.unsafeRunSyncEitherEffect = exports.unsafeRunSyncEither = exports.unsafeRunSyncEffect = exports.unsafeRunSync = exports.unsafeRunPromiseExitEffect = exports.unsafeRunPromiseExit = exports.unsafeRunPromiseEitherEffect = exports.unsafeRunPromiseEither = exports.unsafeRunPromiseEffect = exports.unsafeRunPromise = exports.unsafeRunEffect = exports.unsafeRunCallback = exports.unsafeForkEffect = exports.unsafeFork = exports.runtime = exports.make = exports.defaultRuntimeFlags = exports.defaultRuntime = exports.asyncEffect = exports.RuntimeImpl = exports.AsyncFiber = void 0;\nvar Context = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Context\"));\nvar Either = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Either\"));\nvar Option = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Option\"));\nvar Debug = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Debug\"));\nvar Exit = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Exit\"));\nvar Fiber = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Fiber\"));\nvar FiberId = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Fiber/Id\"));\nvar FiberRefs = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/FiberRefs\"));\nvar CausePretty = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/cause-pretty\"));\nvar core = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/core\"));\nvar FiberRuntime = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/fiberRuntime\"));\nvar fiberScope = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/fiberScope\"));\nvar OpCodes = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/opCodes/effect\"));\nvar runtimeFlags = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/runtimeFlags\"));\nvar _supervisor = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/supervisor\"));\nvar _scheduler = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Scheduler\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/** @internal */\nconst unsafeFork = runtime => Debug.methodWithTrace(trace => (self, scheduler) => {\n  const fiberId = FiberId.unsafeMake();\n  const effect = self.traced(trace);\n  let fiberRefs = FiberRefs.updatedAs(runtime.fiberRefs, fiberId, core.currentContext, runtime.context);\n  if (scheduler) {\n    fiberRefs = FiberRefs.updatedAs(fiberRefs, fiberId, core.currentScheduler, scheduler);\n  }\n  const fiberRuntime = new FiberRuntime.FiberRuntime(fiberId, FiberRefs.forkAs(fiberRefs, fiberId), runtime.runtimeFlags);\n  const supervisor = fiberRuntime.getSupervisor();\n  if (supervisor !== _supervisor.none) {\n    supervisor.onStart(runtime.context, effect, Option.none(), fiberRuntime);\n    fiberRuntime.unsafeAddObserver(exit => supervisor.onEnd(exit, fiberRuntime));\n  }\n  fiberScope.globalScope.add(runtime.runtimeFlags, fiberRuntime);\n  fiberRuntime.start(effect);\n  return fiberRuntime;\n});\n/** @internal */\nexports.unsafeFork = unsafeFork;\nconst unsafeRunCallback = runtime => Debug.methodWithTrace(trace => (effect, onExit) => {\n  const fiberRuntime = unsafeFork(runtime)(effect.traced(trace));\n  if (onExit) {\n    fiberRuntime.unsafeAddObserver(exit => {\n      onExit(exit);\n    });\n  }\n  return (id, onExitInterrupt) => unsafeRunCallback(runtime)(Fiber.interruptAs(id ?? FiberId.none)(fiberRuntime), onExitInterrupt ? exit => {\n    return onExitInterrupt(Exit.flatten(exit));\n  } : void 0);\n});\n/** @internal */\nexports.unsafeRunCallback = unsafeRunCallback;\nconst unsafeRunSyncExit = runtime => Debug.methodWithTrace(trace => effect => {\n  const scheduler = new _scheduler.SyncScheduler(\"Sync\");\n  const fiberRuntime = unsafeFork(runtime)(effect.traced(trace), scheduler);\n  scheduler.flush();\n  const result = fiberRuntime.unsafePoll();\n  if (result) {\n    return result;\n  }\n  return Exit.die(new AsyncFiber(fiberRuntime));\n});\n/** @internal */\nexports.unsafeRunSyncExit = unsafeRunSyncExit;\nconst unsafeRunSyncExitOrFiber = runtime => Debug.methodWithTrace(trace => effect => {\n  const scheduler = new _scheduler.SyncScheduler(\"PreferSync\");\n  const fiberRuntime = unsafeFork(runtime)(effect.traced(trace), scheduler);\n  scheduler.flush();\n  const result = fiberRuntime.unsafePoll();\n  if (result) {\n    return Either.right(result);\n  }\n  return Either.left(fiberRuntime);\n});\n/** @internal */\nexports.unsafeRunSyncExitOrFiber = unsafeRunSyncExitOrFiber;\nclass AsyncFiber {\n  constructor(fiber) {\n    this.fiber = fiber;\n    this._tag = \"AsyncFiber\";\n  }\n  toString() {\n    return `Fiber #${this.fiber.id().id} has suspended work asyncroniously`;\n  }\n  [Symbol.for(\"nodejs.util.inspect.custom\")]() {\n    return this.toString();\n  }\n}\nexports.AsyncFiber = AsyncFiber;\nclass FiberFailure extends Error {\n  constructor(originalCause) {\n    const limit = Error.stackTraceLimit;\n    Error.stackTraceLimit = 0;\n    super();\n    this.originalCause = originalCause;\n    this._tag = \"FiberFailure\";\n    this._id = Symbol.for(\"@effect/io/Runtime/FiberFailure\");\n    Error.stackTraceLimit = limit;\n    const pretty = CausePretty.prettyErrors(this.originalCause);\n    if (pretty.length > 0) {\n      this.name = pretty[0].message.split(\":\")[0];\n      this.message = pretty[0].message.substring(this.name.length + 2);\n      this.stack = pretty[0].stack;\n    }\n  }\n  toString() {\n    return CausePretty.pretty(this.originalCause);\n  }\n  [Symbol.for(\"nodejs.util.inspect.custom\")]() {\n    return this.toString();\n  }\n}\n/** @internal */\nconst unsafeRunSync = runtime => Debug.methodWithTrace(trace => effect => {\n  const exit = unsafeRunSyncExit(runtime)(effect.traced(trace));\n  if (exit._tag === OpCodes.OP_FAILURE) {\n    throw new FiberFailure(exit.i0);\n  }\n  return exit.i0;\n});\n/** @internal */\nexports.unsafeRunSync = unsafeRunSync;\nconst unsafeRunSyncEither = runtime => effect => Debug.untraced(() => unsafeRunSync(runtime)(core.either(effect)));\n/** @internal */\nexports.unsafeRunSyncEither = unsafeRunSyncEither;\nconst unsafeRunPromise = runtime => effect => {\n  return new Promise((resolve, reject) => {\n    unsafeRunCallback(runtime)(effect, exit => {\n      switch (exit._tag) {\n        case OpCodes.OP_SUCCESS:\n          {\n            resolve(exit.i0);\n            break;\n          }\n        case OpCodes.OP_FAILURE:\n          {\n            reject(new FiberFailure(exit.i0));\n            break;\n          }\n      }\n    });\n  });\n};\n/** @internal */\nexports.unsafeRunPromise = unsafeRunPromise;\nconst unsafeRunPromiseExit = runtime => Debug.methodWithTrace(trace => effect => {\n  return new Promise(resolve => {\n    unsafeRunCallback(runtime)(effect.traced(trace), exit => {\n      resolve(exit);\n    });\n  });\n});\n/** @internal */\nexports.unsafeRunPromiseExit = unsafeRunPromiseExit;\nconst unsafeRunPromiseEither = runtime => effect => unsafeRunPromise(runtime)(core.either(effect));\n/** @internal */\nexports.unsafeRunPromiseEither = unsafeRunPromiseEither;\nclass RuntimeImpl {\n  constructor(context, runtimeFlags, fiberRefs) {\n    this.context = context;\n    this.runtimeFlags = runtimeFlags;\n    this.fiberRefs = fiberRefs;\n  }\n}\n/** @internal */\nexports.RuntimeImpl = RuntimeImpl;\nconst make = (context, runtimeFlags, fiberRefs) => new RuntimeImpl(context, runtimeFlags, fiberRefs);\n/** @internal */\nexports.make = make;\nconst runtime = /*#__PURE__*/Debug.methodWithTrace(trace => () => core.withFiberRuntime((state, status) => core.succeed(new RuntimeImpl(state.getFiberRef(core.currentContext), status.runtimeFlags, state.unsafeGetFiberRefs()))).traced(trace));\n/** @internal */\nexports.runtime = runtime;\nconst defaultRuntimeFlags = /*#__PURE__*/runtimeFlags.make(runtimeFlags.Interruption, runtimeFlags.CooperativeYielding);\n/** @internal */\nexports.defaultRuntimeFlags = defaultRuntimeFlags;\nconst defaultRuntime = /*#__PURE__*/make( /*#__PURE__*/Context.empty(), defaultRuntimeFlags, /*#__PURE__*/FiberRefs.unsafeMake( /*#__PURE__*/new Map()));\n/** @internal */\nexports.defaultRuntime = defaultRuntime;\nconst unsafeRunEffect = /*#__PURE__*/unsafeRunCallback(defaultRuntime);\n/** @internal */\nexports.unsafeRunEffect = unsafeRunEffect;\nconst unsafeForkEffect = /*#__PURE__*/unsafeFork(defaultRuntime);\n/** @internal */\nexports.unsafeForkEffect = unsafeForkEffect;\nconst unsafeRunPromiseEffect = /*#__PURE__*/unsafeRunPromise(defaultRuntime);\n/** @internal */\nexports.unsafeRunPromiseEffect = unsafeRunPromiseEffect;\nconst unsafeRunPromiseEitherEffect = /*#__PURE__*/unsafeRunPromiseEither(defaultRuntime);\n/** @internal */\nexports.unsafeRunPromiseEitherEffect = unsafeRunPromiseEitherEffect;\nconst unsafeRunPromiseExitEffect = /*#__PURE__*/unsafeRunPromiseExit(defaultRuntime);\n/** @internal */\nexports.unsafeRunPromiseExitEffect = unsafeRunPromiseExitEffect;\nconst unsafeRunSyncEffect = /*#__PURE__*/unsafeRunSync(defaultRuntime);\n/** @internal */\nexports.unsafeRunSyncEffect = unsafeRunSyncEffect;\nconst unsafeRunSyncExitEffect = /*#__PURE__*/unsafeRunSyncExit(defaultRuntime);\n/** @internal */\nexports.unsafeRunSyncExitEffect = unsafeRunSyncExitEffect;\nconst unsafeRunSyncEitherEffect = /*#__PURE__*/unsafeRunSyncEither(defaultRuntime);\n/** @internal */\nexports.unsafeRunSyncEitherEffect = unsafeRunSyncEitherEffect;\nconst unsafeRunSyncExitOrFiberEffect = /*#__PURE__*/unsafeRunSyncExitOrFiber(defaultRuntime);\n// circular with Effect\n/** @internal */\nexports.unsafeRunSyncExitOrFiberEffect = unsafeRunSyncExitOrFiberEffect;\nconst asyncEffect = /*#__PURE__*/Debug.methodWithTrace((trace, restoreTrace) => register => core.flatMap(core.deferredMake(), deferred => core.flatMap(runtime(), runtime => core.uninterruptibleMask(restore => core.zipRight(FiberRuntime.fork(restore(core.catchAllCause(restoreTrace(register)(cb => unsafeRunCallback(runtime)(core.intoDeferred(deferred)(cb))), cause => core.deferredFailCause(deferred, cause)))), restore(core.deferredAwait(deferred)))))).traced(trace));\nexports.asyncEffect = asyncEffect;\n//# sourceMappingURL=runtime.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.windDown = exports.toSet = exports.runtimeMetrics = exports.renderPatch = exports.render = exports.patch = exports.opSupervision = exports.none = exports.make = exports.isEnabled = exports.isDisabled = exports.interruption = exports.interruptible = exports.enabledSet = exports.enableAll = exports.enable = exports.disabledSet = exports.disableAll = exports.disable = exports.differ = exports.diff = exports.cooperativeYielding = exports.allFlags = exports.WindDown = exports.RuntimeMetrics = exports.OpSupervision = exports.None = exports.Interruption = exports.CooperativeYielding = void 0;\nvar Differ = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Differ\"));\nvar _Function = /*#__PURE__*/require(\"@effect/data/Function\");\nvar runtimeFlagsPatch = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/runtimeFlagsPatch\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/** @internal */\nconst None = 0;\n/** @internal */\nexports.None = None;\nconst Interruption = 1 << 0;\n/** @internal */\nexports.Interruption = Interruption;\nconst OpSupervision = 1 << 1;\n/** @internal */\nexports.OpSupervision = OpSupervision;\nconst RuntimeMetrics = 1 << 2;\n/** @internal */\nexports.RuntimeMetrics = RuntimeMetrics;\nconst WindDown = 1 << 4;\n/** @internal */\nexports.WindDown = WindDown;\nconst CooperativeYielding = 1 << 5;\n/** @internal */\nexports.CooperativeYielding = CooperativeYielding;\nconst allFlags = [None, Interruption, OpSupervision, RuntimeMetrics, WindDown, CooperativeYielding];\n/** @internal */\nexports.allFlags = allFlags;\nconst cooperativeYielding = self => isEnabled(self, CooperativeYielding);\n/** @internal */\nexports.cooperativeYielding = cooperativeYielding;\nconst disable = /*#__PURE__*/(0, _Function.dual)(2, (self, flag) => self & ~flag);\n/** @internal */\nexports.disable = disable;\nconst disableAll = /*#__PURE__*/(0, _Function.dual)(2, (self, flags) => self & ~flags);\n/** @internal */\nexports.disableAll = disableAll;\nconst enable = /*#__PURE__*/(0, _Function.dual)(2, (self, flag) => self | flag);\n/** @internal */\nexports.enable = enable;\nconst enableAll = /*#__PURE__*/(0, _Function.dual)(2, (self, flags) => self | flags);\n/** @internal */\nexports.enableAll = enableAll;\nconst interruptible = self => interruption(self) && !windDown(self);\n/** @internal */\nexports.interruptible = interruptible;\nconst interruption = self => isEnabled(self, Interruption);\n/** @internal */\nexports.interruption = interruption;\nconst isDisabled = /*#__PURE__*/(0, _Function.dual)(2, (self, flag) => !isEnabled(self, flag));\n/** @internal */\nexports.isDisabled = isDisabled;\nconst isEnabled = /*#__PURE__*/(0, _Function.dual)(2, (self, flag) => (self & flag) !== 0);\n/** @internal */\nexports.isEnabled = isEnabled;\nconst make = (...flags) => flags.reduce((a, b) => a | b, 0);\n/** @internal */\nexports.make = make;\nconst none = /*#__PURE__*/make(None);\n/** @internal */\nexports.none = none;\nconst opSupervision = self => isEnabled(self, OpSupervision);\n/** @internal */\nexports.opSupervision = opSupervision;\nconst render = self => {\n  const active = [];\n  allFlags.forEach(flag => {\n    if (isEnabled(self, flag)) {\n      active.push(`${flag}`);\n    }\n  });\n  return `RuntimeFlags(${active.join(\", \")})`;\n};\n/** @internal */\nexports.render = render;\nconst runtimeMetrics = self => isEnabled(self, RuntimeMetrics);\n/** @internal */\nexports.runtimeMetrics = runtimeMetrics;\nconst toSet = self => new Set(allFlags.filter(flag => isEnabled(self, flag)));\nexports.toSet = toSet;\nconst windDown = self => isEnabled(self, WindDown);\n// circular with RuntimeFlagsPatch\n/** @internal */\nexports.windDown = windDown;\nconst enabledSet = self => toSet(runtimeFlagsPatch.active(self) & runtimeFlagsPatch.enabled(self));\n/** @internal */\nexports.enabledSet = enabledSet;\nconst disabledSet = self => toSet(runtimeFlagsPatch.active(self) & ~runtimeFlagsPatch.enabled(self));\n/** @internal */\nexports.disabledSet = disabledSet;\nconst diff = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => runtimeFlagsPatch.make(self ^ that, that));\n/** @internal */\nexports.diff = diff;\nconst patch = /*#__PURE__*/(0, _Function.dual)(2, (self, patch) => self & (runtimeFlagsPatch.invert(runtimeFlagsPatch.active(patch)) | runtimeFlagsPatch.enabled(patch)) | runtimeFlagsPatch.active(patch) & runtimeFlagsPatch.enabled(patch));\n/** @internal */\nexports.patch = patch;\nconst renderFlag = a => `${allFlags.find(b => a === b)}`;\n/** @internal */\nconst renderPatch = self => {\n  const enabled = Array.from(enabledSet(self)).map(flag => renderFlag(flag)).join(\", \");\n  const disabled = Array.from(disabledSet(self)).map(flag => renderFlag(flag)).join(\", \");\n  return `RuntimeFlagsPatch(enabled = (${enabled}), disabled = (${disabled}))`;\n};\n/** @internal */\nexports.renderPatch = renderPatch;\nconst differ = () => Differ.make({\n  empty: runtimeFlagsPatch.empty,\n  diff: (oldValue, newValue) => diff(oldValue, newValue),\n  combine: (first, second) => runtimeFlagsPatch.andThen(second)(first),\n  patch: (_patch, oldValue) => patch(oldValue, _patch)\n});\nexports.differ = differ;\n//# sourceMappingURL=runtimeFlags.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.make = exports.isEnabled = exports.isEmpty = exports.isDisabled = exports.isActive = exports.invert = exports.inverse = exports.exclude = exports.enabled = exports.enable = exports.empty = exports.either = exports.disable = exports.both = exports.andThen = exports.active = void 0;\nvar _Function = /*#__PURE__*/require(\"@effect/data/Function\");\n/** @internal */\nconst BIT_MASK = 0xff;\n/** @internal */\nconst BIT_SHIFT = 0x08;\n/** @internal */\nconst active = patch => patch & BIT_MASK;\n/** @internal */\nexports.active = active;\nconst enabled = patch => patch >> BIT_SHIFT & BIT_MASK;\n/** @internal */\nexports.enabled = enabled;\nconst make = (active, enabled) => (active & BIT_MASK) + ((enabled & active & BIT_MASK) << BIT_SHIFT);\n/** @internal */\nexports.make = make;\nconst empty = /*#__PURE__*/make(0, 0);\n/** @internal */\nexports.empty = empty;\nconst enable = flag => make(flag, flag);\n/** @internal */\nexports.enable = enable;\nconst disable = flag => make(flag, 0);\n/** @internal */\nexports.disable = disable;\nconst isEmpty = patch => patch === 0;\n/** @internal */\nexports.isEmpty = isEmpty;\nconst isActive = /*#__PURE__*/(0, _Function.dual)(2, (self, flag) => (active(self) & flag) !== 0);\n/** @internal */\nexports.isActive = isActive;\nconst isEnabled = /*#__PURE__*/(0, _Function.dual)(2, (self, flag) => (enabled(self) & flag) !== 0);\n/** @internal */\nexports.isEnabled = isEnabled;\nconst isDisabled = /*#__PURE__*/(0, _Function.dual)(2, (self, flag) => (active(self) & flag) !== 0 && (enabled(self) & flag) === 0);\n/** @internal */\nexports.isDisabled = isDisabled;\nconst exclude = /*#__PURE__*/(0, _Function.dual)(2, (self, flag) => make(active(self) & ~flag, enabled(self)));\n/** @internal */\nexports.exclude = exclude;\nconst both = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => make(active(self) | active(that), enabled(self) & enabled(that)));\n/** @internal */\nexports.both = both;\nconst either = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => make(active(self) | active(that), enabled(self) | enabled(that)));\n/** @internal */\nexports.either = either;\nconst andThen = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => self | that);\n/** @internal */\nexports.andThen = andThen;\nconst inverse = patch => make(enabled(patch), invert(active(patch)));\n/** @internal */\nexports.inverse = inverse;\nconst invert = n => ~n >>> 0 & BIT_MASK;\nexports.invert = invert;\n//# sourceMappingURL=runtimeFlagsPatch.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.repeatWhile_Effect = exports.repeatWhileEquals_Effect = exports.repeatWhileEffect_Effect = exports.repeatUntil_Effect = exports.repeatUntilEquals_Effect = exports.repeatUntilEffect_Effect = exports.repeatOrElse_Effect = exports.repeatOrElseEither_Effect = exports.repeatForever = exports.reduceEffect = exports.reduce = exports.recurs = exports.recurWhileEquals = exports.recurWhileEffect = exports.recurWhile = exports.recurUpTo = exports.recurUntilOption = exports.recurUntilEquals = exports.recurUntilEffect = exports.recurUntil = exports.reconsiderEffect = exports.reconsider = exports.provideService = exports.provideContext = exports.passthrough = exports.once = exports.onDecision = exports.nextSecond = exports.nextMinute = exports.nextHour = exports.nextDayOfMonth = exports.nextDay = exports.modifyDelayEffect = exports.modifyDelay = exports.minuteOfHour = exports.mapEffect = exports.map = exports.makeWithState = exports.linear = exports.left = exports.jitteredWith = exports.jittered = exports.intersectWith = exports.intersect = exports.identity = exports.hourOfDay = exports.fromFunction = exports.fromDelays = exports.fromDelay = exports.forever = exports.fixed = exports.findNextMonth = exports.fibonacci = exports.exponential = exports.ensuring = exports.endOfSecond = exports.endOfMinute = exports.endOfHour = exports.endOfDay = exports.elapsed = exports.eitherWith = exports.either = exports.duration = exports.driver = exports.dimapEffect = exports.dimap = exports.delays = exports.delayedSchedule = exports.delayedEffect = exports.delayed = exports.dayOfWeek = exports.dayOfMonth = exports.count = exports.contramapEffect = exports.contramapContext = exports.contramap = exports.compose = exports.collectWhileEffect = exports.collectWhile = exports.collectUntilEffect = exports.collectUntil = exports.collectAllOutputs = exports.collectAllInputs = exports.chooseMerge = exports.choose = exports.checkEffect = exports.check = exports.bothInOut = exports.beginningOfSecond = exports.beginningOfMinute = exports.beginningOfHour = exports.beginningOfDay = exports.asUnit = exports.as = exports.andThenEither = exports.andThen = exports.addDelayEffect = exports.addDelay = exports.ScheduleTypeId = exports.ScheduleDriverTypeId = void 0;\nexports.zipWith = exports.zipRight = exports.zipLeft = exports.windowed = exports.whileOutputEffect = exports.whileOutput = exports.whileInputEffect = exports.whileInput = exports.upTo = exports.untilOutputEffect = exports.untilOutput = exports.untilInputEffect = exports.untilInput = exports.unionWith = exports.union = exports.unfold = exports.tapOutput = exports.tapInput = exports.sync = exports.succeed = exports.stop = exports.spaced = exports.secondOfMinute = exports.schedule_Effect = exports.scheduleFrom_Effect = exports.run = exports.right = exports.retry_Effect = exports.retryWhile_Effect = exports.retryWhileEquals_Effect = exports.retryWhileEffect_Effect = exports.retryUntil_Effect = exports.retryUntilEquals_Effect = exports.retryUntilEffect_Effect = exports.retryOrElse_Effect = exports.retryOrElseEither_Effect = exports.retryN_Effect = exports.resetWhen = exports.resetAfter = exports.repetitions = exports.repeat_Effect = void 0;\nvar Chunk = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Chunk\"));\nvar Context = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Context\"));\nvar Duration = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Duration\"));\nvar Either = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Either\"));\nvar Equal = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Equal\"));\nvar _Function = /*#__PURE__*/require(\"@effect/data/Function\");\nvar Option = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Option\"));\nvar Clock = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Clock\"));\nvar Debug = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Debug\"));\nvar internalCause = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/cause\"));\nvar core = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/core\"));\nvar effect = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/effect\"));\nvar Random = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Random\"));\nvar Ref = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Ref\"));\nvar ScheduleDecision = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Schedule/Decision\"));\nvar Interval = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Schedule/Interval\"));\nvar Intervals = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Schedule/Intervals\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\nvar _a, _b;\n/** @internal */\nconst ScheduleSymbolKey = \"@effect/io/Schedule\";\n/** @internal */\nconst ScheduleTypeId = /*#__PURE__*/Symbol.for(ScheduleSymbolKey);\n/** @internal */\nexports.ScheduleTypeId = ScheduleTypeId;\nconst ScheduleDriverSymbolKey = \"@effect/io/Schedule/Driver\";\n/** @internal */\nconst ScheduleDriverTypeId = /*#__PURE__*/Symbol.for(ScheduleDriverSymbolKey);\n/** @internal */\nexports.ScheduleDriverTypeId = ScheduleDriverTypeId;\nconst scheduleVariance = {\n  _Env: _ => _,\n  _In: _ => _,\n  _Out: _ => _\n};\nconst scheduleDriverVariance = {\n  _Env: _ => _,\n  _In: _ => _,\n  _Out: _ => _\n};\n/** @internal */\nclass ScheduleImpl {\n  constructor(initial, step) {\n    this.initial = initial;\n    this.step = step;\n    this[_a] = scheduleVariance;\n  }\n}\n_a = ScheduleTypeId;\n/** @internal */\nclass ScheduleDriverImpl {\n  constructor(schedule, ref) {\n    this.schedule = schedule;\n    this.ref = ref;\n    this[_b] = scheduleDriverVariance;\n  }\n  state() {\n    return Debug.bodyWithTrace(trace => core.map(Ref.get(this.ref), tuple => tuple[1]).traced(trace));\n  }\n  last() {\n    return Debug.bodyWithTrace(trace => core.flatMap(Ref.get(this.ref), ([element, _]) => {\n      switch (element._tag) {\n        case \"None\":\n          {\n            return core.failSync(() => internalCause.NoSuchElementException());\n          }\n        case \"Some\":\n          {\n            return core.succeed(element.value);\n          }\n      }\n    }).traced(trace));\n  }\n  reset() {\n    return Debug.bodyWithTrace(trace => Ref.set(this.ref, [Option.none(), this.schedule.initial]).traced(trace));\n  }\n  next(input) {\n    return Debug.bodyWithTrace((trace, restore) => core.flatMap(state => core.flatMap(now => core.flatMap(([state, out, decision]) => ScheduleDecision.isDone(decision) ? core.zipRight(core.fail(Option.none()))(Ref.set(this.ref, [Option.some(out), state])) : core.as(out)(core.zipRight(effect.sleep(Duration.millis(Intervals.start(decision.intervals) - now)))(Ref.set(this.ref, [Option.some(out), state]))))(core.suspend(restore(() => this.schedule.step(now, input, state)))))(Clock.currentTimeMillis()))(core.map(Ref.get(this.ref), tuple => tuple[1])).traced(trace));\n  }\n}\n_b = ScheduleDriverTypeId;\n/** @internal */\nconst makeWithState = /*#__PURE__*/Debug.untracedMethod(restore => (initial, step) => new ScheduleImpl(initial, restore(step)));\n/** @internal */\nexports.makeWithState = makeWithState;\nconst addDelay = /*#__PURE__*/Debug.untracedDual(2, restore => (self, f) => addDelayEffect(self, out => core.sync(() => restore(f)(out))));\n/** @internal */\nexports.addDelay = addDelay;\nconst addDelayEffect = /*#__PURE__*/Debug.untracedDual(2, restore => (self, f) => modifyDelayEffect(self, (out, duration) => core.map(restore(f)(out), delay => Duration.millis(duration.millis + delay.millis))));\n/** @internal */\nexports.addDelayEffect = addDelayEffect;\nconst andThen = /*#__PURE__*/Debug.untracedDual(2, () => (self, that) => map(Either.merge)(andThenEither(self, that)));\n/** @internal */\nexports.andThen = andThen;\nconst andThenEither = /*#__PURE__*/Debug.untracedDual(2, restore => (self, that) => makeWithState([self.initial, that.initial, true], (now, input, state) => state[2] ? core.flatMap(restore(self.step)(now, input, state[0]), ([lState, out, decision]) => {\n  if (ScheduleDecision.isDone(decision)) {\n    return core.map(that.step(now, input, state[1]), ([rState, out, decision]) => [[lState, rState, false], Either.right(out), decision]);\n  }\n  return core.succeed([[lState, state[1], true], Either.left(out), decision]);\n}) : core.map(that.step(now, input, state[1]), ([rState, out, decision]) => [[state[0], rState, false], Either.right(out), decision])));\n/** @internal */\nexports.andThenEither = andThenEither;\nconst as = /*#__PURE__*/Debug.untracedDual(2, () => (self, out) => map(self, () => out));\n/** @internal */\nexports.as = as;\nconst asUnit = /*#__PURE__*/Debug.untracedMethod(() => self => map(self, _Function.constVoid));\n/** @internal */\nexports.asUnit = asUnit;\nconst bothInOut = /*#__PURE__*/Debug.untracedDual(2, restore => (self, that) => makeWithState([self.initial, that.initial], (now, [in1, in2], state) => core.zipWith(restore(self.step)(now, in1, state[0]), restore(that.step)(now, in2, state[1]), ([lState, out, lDecision], [rState, out2, rDecision]) => {\n  if (ScheduleDecision.isContinue(lDecision) && ScheduleDecision.isContinue(rDecision)) {\n    const interval = Intervals.union(rDecision.intervals)(lDecision.intervals);\n    return [[lState, rState], [out, out2], ScheduleDecision.continue(interval)];\n  }\n  return [[lState, rState], [out, out2], ScheduleDecision.done];\n})));\n/** @internal */\nexports.bothInOut = bothInOut;\nconst check = /*#__PURE__*/Debug.untracedDual(2, restore => (self, test) => checkEffect(self, (input, out) => core.sync(() => restore(test)(input, out))));\n/** @internal */\nexports.check = check;\nconst checkEffect = /*#__PURE__*/Debug.untracedDual(2, restore => (self, test) => makeWithState(self.initial, (now, input, state) => core.flatMap(restore(self.step)(now, input, state), ([state, out, decision]) => {\n  if (ScheduleDecision.isDone(decision)) {\n    return core.succeed([state, out, ScheduleDecision.done]);\n  }\n  return core.map(restore(test)(input, out), cont => cont ? [state, out, decision] : [state, out, ScheduleDecision.done]);\n})));\n/** @internal */\nexports.checkEffect = checkEffect;\nconst choose = /*#__PURE__*/Debug.untracedDual(2, restore => (self, that) => makeWithState([self.initial, that.initial], (now, either, state) => {\n  switch (either._tag) {\n    case \"Left\":\n      {\n        return core.map(restore(self.step)(now, either.left, state[0]), ([lState, out, decision]) => [[lState, state[1]], Either.left(out), decision]);\n      }\n    case \"Right\":\n      {\n        return core.map(([rState, out2, decision]) => [[state[0], rState], Either.right(out2), decision])(that.step(now, either.right, state[1]));\n      }\n  }\n}));\n/** @internal */\nexports.choose = choose;\nconst chooseMerge = /*#__PURE__*/Debug.untracedDual(2, () => (self, that) => map(choose(self, that), Either.merge));\n/** @internal */\nexports.chooseMerge = chooseMerge;\nconst collectAllInputs = /*#__PURE__*/Debug.untracedMethod(() => () => collectAllOutputs(identity()));\n/** @internal */\nexports.collectAllInputs = collectAllInputs;\nconst collectAllOutputs = /*#__PURE__*/Debug.untracedMethod(() => self => reduce(self, Chunk.empty(), (outs, out) => Chunk.append(out)(outs)));\n/** @internal */\nexports.collectAllOutputs = collectAllOutputs;\nconst collectUntil = /*#__PURE__*/Debug.untracedMethod(restore => f => collectAllOutputs(recurUntil(restore(f))));\n/** @internal */\nexports.collectUntil = collectUntil;\nconst collectUntilEffect = /*#__PURE__*/Debug.untracedMethod(restore => f => collectAllOutputs(recurUntilEffect(restore(f))));\n/** @internal */\nexports.collectUntilEffect = collectUntilEffect;\nconst collectWhile = /*#__PURE__*/Debug.untracedMethod(restore => f => collectAllOutputs(recurWhile(restore(f))));\n/** @internal */\nexports.collectWhile = collectWhile;\nconst collectWhileEffect = /*#__PURE__*/Debug.untracedMethod(restore => f => collectAllOutputs(recurWhileEffect(restore(f))));\n/** @internal */\nexports.collectWhileEffect = collectWhileEffect;\nconst compose = /*#__PURE__*/Debug.untracedDual(2, restore => (self, that) => makeWithState([self.initial, that.initial], (now, input, state) => core.flatMap(restore(self.step)(now, input, state[0]), ([lState, out, lDecision]) => core.map(that.step(now, out, state[1]), ([rState, out2, rDecision]) => ScheduleDecision.isDone(lDecision) ? [[lState, rState], out2, ScheduleDecision.done] : ScheduleDecision.isDone(rDecision) ? [[lState, rState], out2, ScheduleDecision.done] : [[lState, rState], out2, ScheduleDecision.continue(Intervals.max(rDecision.intervals)(lDecision.intervals))]))));\n/** @internal */\nexports.compose = compose;\nconst contramap = /*#__PURE__*/Debug.untracedDual(2, restore => (self, f) => contramapEffect(self, input2 => core.sync(() => restore(f)(input2))));\n/** @internal */\nexports.contramap = contramap;\nconst contramapContext = /*#__PURE__*/Debug.untracedDual(2, restore => (self, f) => makeWithState(self.initial, (now, input, state) => core.contramapContext(restore(self.step)(now, input, state), restore(f))));\n/** @internal */\nexports.contramapContext = contramapContext;\nconst contramapEffect = /*#__PURE__*/Debug.untracedDual(2, restore => (self, f) => makeWithState(self.initial, (now, input2, state) => core.flatMap(restore(f)(input2), input => restore(self.step)(now, input, state))));\n/** @internal */\nexports.contramapEffect = contramapEffect;\nconst count = /*#__PURE__*/Debug.untracedMethod(() => () => unfold(0, n => n + 1));\n/** @internal */\nexports.count = count;\nconst dayOfMonth = /*#__PURE__*/Debug.untracedMethod(() => day => {\n  return makeWithState([Number.NEGATIVE_INFINITY, 0], (now, _, state) => {\n    if (!Number.isInteger(day) || day < 1 || 31 < day) {\n      return core.dieSync(() => internalCause.IllegalArgumentException(`Invalid argument in: dayOfMonth(${day}). Must be in range 1...31`));\n    }\n    const n = state[1];\n    const initial = n === 0;\n    const day0 = nextDayOfMonth(now, day, initial);\n    const start = beginningOfDay(day0);\n    const end = endOfDay(day0);\n    const interval = Interval.make(start, end);\n    return core.succeed([[end, n + 1], n, ScheduleDecision.continueWith(interval)]);\n  });\n});\n/** @internal */\nexports.dayOfMonth = dayOfMonth;\nconst dayOfWeek = /*#__PURE__*/Debug.untracedMethod(() => day => {\n  return makeWithState([Number.MIN_SAFE_INTEGER, 0], (now, _, state) => {\n    if (!Number.isInteger(day) || day < 1 || 7 < day) {\n      return core.dieSync(() => internalCause.IllegalArgumentException(`Invalid argument in: dayOfWeek(${day}). Must be in range 1 (Monday)...7 (Sunday)`));\n    }\n    const n = state[1];\n    const initial = n === 0;\n    const day0 = nextDay(now, day, initial);\n    const start = beginningOfDay(day0);\n    const end = endOfDay(day0);\n    const interval = Interval.make(start, end);\n    return core.succeed([[end, n + 1], n, ScheduleDecision.continueWith(interval)]);\n  });\n});\n/** @internal */\nexports.dayOfWeek = dayOfWeek;\nconst delayed = /*#__PURE__*/Debug.untracedDual(2, restore => (self, f) => delayedEffect(self, duration => core.sync(() => restore(f)(duration))));\n/** @internal */\nexports.delayed = delayed;\nconst delayedEffect = /*#__PURE__*/Debug.untracedDual(2, restore => (self, f) => modifyDelayEffect(self, (_, delay) => restore(f)(delay)));\n/** @internal */\nexports.delayedEffect = delayedEffect;\nconst delayedSchedule = /*#__PURE__*/Debug.untracedMethod(() => schedule => addDelay(schedule, x => x));\n/** @internal */\nexports.delayedSchedule = delayedSchedule;\nconst delays = /*#__PURE__*/Debug.untracedMethod(restore => self => makeWithState(self.initial, (now, input, state) => core.flatMap(([state, _, decision]) => {\n  if (ScheduleDecision.isDone(decision)) {\n    return core.succeed([state, Duration.zero, decision]);\n  }\n  return core.succeed([state, Duration.millis(Intervals.start(decision.intervals) - now), decision]);\n})(restore(self.step)(now, input, state))));\n/** @internal */\nexports.delays = delays;\nconst dimap = /*#__PURE__*/Debug.untracedDual(3, restore => (self, f, g) => map(restore(g))(contramap(self, restore(f))));\n/** @internal */\nexports.dimap = dimap;\nconst dimapEffect = /*#__PURE__*/Debug.untracedDual(3, restore => (self, f, g) => mapEffect(restore(g))(contramapEffect(self, restore(f))));\n/** @internal */\nexports.dimapEffect = dimapEffect;\nconst driver = /*#__PURE__*/Debug.methodWithTrace(trace => self => core.map(ref => new ScheduleDriverImpl(self, ref))(Ref.make([Option.none(), self.initial])).traced(trace));\n/** @internal */\nexports.driver = driver;\nconst duration = /*#__PURE__*/Debug.untracedMethod(() => duration => makeWithState(true, (now, _, state) => core.succeed(state ? [false, duration, ScheduleDecision.continueWith(Interval.after(now + duration.millis))] : [false, Duration.zero, ScheduleDecision.done])));\n/** @internal */\nexports.duration = duration;\nconst either = /*#__PURE__*/Debug.untracedDual(2, () => (self, that) => union(self, that));\n/** @internal */\nexports.either = either;\nconst eitherWith = /*#__PURE__*/Debug.untracedDual(3, restore => (self, that, f) => unionWith(self, that, restore(f)));\n/** @internal */\nexports.eitherWith = eitherWith;\nconst elapsed = /*#__PURE__*/Debug.untracedMethod(() => () => makeWithState(Option.none(), (now, _, state) => {\n  switch (state._tag) {\n    case \"None\":\n      {\n        return core.succeed([Option.some(now), Duration.zero, ScheduleDecision.continueWith(Interval.after(now))]);\n      }\n    case \"Some\":\n      {\n        return core.succeed([Option.some(state.value), Duration.millis(now - state.value), ScheduleDecision.continueWith(Interval.after(now))]);\n      }\n  }\n}));\n/** @internal */\nexports.elapsed = elapsed;\nconst ensuring = /*#__PURE__*/Debug.untracedDual(2, restore => (self, finalizer) => makeWithState(self.initial, (now, input, state) => core.flatMap(restore(self.step)(now, input, state), ([state, out, decision]) => ScheduleDecision.isDone(decision) ? core.as(finalizer, [state, out, decision]) : core.succeed([state, out, decision]))));\n/** @internal */\nexports.ensuring = ensuring;\nconst exponential = /*#__PURE__*/Debug.untracedMethod(() => (base, factor = 2.0) => delayedSchedule(map(i => Duration.millis(base.millis * Math.pow(factor, i)))(forever())));\n/** @internal */\nexports.exponential = exponential;\nconst fibonacci = /*#__PURE__*/Debug.untracedMethod(() => one => delayedSchedule(map(out => out[0])(unfold([one, one], ([a, b]) => [b, Duration.sum(a, b)]))));\n/** @internal */\nexports.fibonacci = fibonacci;\nconst fixed = /*#__PURE__*/Debug.untracedMethod(() => interval => makeWithState([Option.none(), 0], (now, _, [option, n]) => core.sync(() => {\n  const intervalMillis = interval.millis;\n  switch (option._tag) {\n    case \"None\":\n      {\n        return [[Option.some([now, now + intervalMillis]), n + 1], n, ScheduleDecision.continueWith(Interval.after(now + intervalMillis))];\n      }\n    case \"Some\":\n      {\n        const [startMillis, lastRun] = option.value;\n        const runningBehind = now > lastRun + intervalMillis;\n        const boundary = Equal.equals(interval, Duration.zero) ? interval : Duration.millis(intervalMillis - (now - startMillis) % intervalMillis);\n        const sleepTime = Equal.equals(boundary, Duration.zero) ? interval : boundary;\n        const nextRun = runningBehind ? now : now + sleepTime.millis;\n        return [[Option.some([startMillis, nextRun]), n + 1], n, ScheduleDecision.continueWith(Interval.after(nextRun))];\n      }\n  }\n})));\n/** @internal */\nexports.fixed = fixed;\nconst forever = /*#__PURE__*/Debug.untracedMethod(() => () => unfold(0, n => n + 1));\n/** @internal */\nexports.forever = forever;\nconst fromDelay = /*#__PURE__*/Debug.untracedMethod(() => delay => duration(delay));\n/** @internal */\nexports.fromDelay = fromDelay;\nconst fromDelays = /*#__PURE__*/Debug.untracedMethod(() => (delay, ...delays) => makeWithState([[delay, ...delays], true], (now, _, [durations, cont]) => core.sync(() => {\n  if (cont) {\n    const x = durations[0];\n    const interval = Interval.after(now + x.millis);\n    if (durations.length >= 2) {\n      return [[durations.slice(1), true], x, ScheduleDecision.continueWith(interval)];\n    }\n    const y = durations.slice(1);\n    return [[[x, ...y], false], x, ScheduleDecision.continueWith(interval)];\n  }\n  return [[durations, false], Duration.zero, ScheduleDecision.done];\n})));\n/** @internal */\nexports.fromDelays = fromDelays;\nconst fromFunction = /*#__PURE__*/Debug.untracedMethod(restore => f => map(restore(f))(identity()));\n/** @internal */\nexports.fromFunction = fromFunction;\nconst hourOfDay = /*#__PURE__*/Debug.untracedMethod(() => hour => makeWithState([Number.NEGATIVE_INFINITY, 0], (now, _, state) => {\n  if (!Number.isInteger(hour) || hour < 0 || 23 < hour) {\n    return core.dieSync(() => internalCause.IllegalArgumentException(`Invalid argument in: hourOfDay(${hour}). Must be in range 0...23`));\n  }\n  const n = state[1];\n  const initial = n === 0;\n  const hour0 = nextHour(now, hour, initial);\n  const start = beginningOfHour(hour0);\n  const end = endOfHour(hour0);\n  const interval = Interval.make(start, end);\n  return core.succeed([[end, n + 1], n, ScheduleDecision.continueWith(interval)]);\n}));\n/** @internal */\nexports.hourOfDay = hourOfDay;\nconst identity = /*#__PURE__*/Debug.untracedMethod(() => () => makeWithState(void 0, (now, input, state) => core.succeed([state, input, ScheduleDecision.continueWith(Interval.after(now))])));\n/** @internal */\nexports.identity = identity;\nconst intersect = /*#__PURE__*/Debug.untracedDual(2, () => (self, that) => intersectWith(self, that, (selfIntervals, thatIntervals) => Intervals.intersect(thatIntervals)(selfIntervals)));\n/** @internal */\nexports.intersect = intersect;\nconst intersectWith = /*#__PURE__*/Debug.untracedDual(3, restore => (self, that, f) => makeWithState([self.initial, that.initial], (now, input, state) => core.flatMap(([[lState, out, lDecision], [rState, out2, rDecision]]) => {\n  if (ScheduleDecision.isContinue(lDecision) && ScheduleDecision.isContinue(rDecision)) {\n    return intersectWithLoop(self, that, input, lState, out, lDecision.intervals, rState, out2, rDecision.intervals, restore(f));\n  }\n  return core.succeed([[lState, rState], [out, out2], ScheduleDecision.done]);\n})(core.zipWith(restore(self.step)(now, input, state[0]), restore(that.step)(now, input, state[1]), (a, b) => [a, b]))));\n/** @internal */\nexports.intersectWith = intersectWith;\nconst intersectWithLoop = (self, that, input, lState, out, lInterval, rState, out2, rInterval, f) => {\n  const combined = f(lInterval, rInterval);\n  if (Intervals.isNonEmpty(combined)) {\n    return core.succeed([[lState, rState], [out, out2], ScheduleDecision.continue(combined)]);\n  }\n  if (Intervals.lessThan(rInterval)(lInterval)) {\n    return core.flatMap(self.step(Intervals.end(lInterval), input, lState), ([lState, out, decision]) => {\n      if (ScheduleDecision.isDone(decision)) {\n        return core.succeed([[lState, rState], [out, out2], ScheduleDecision.done]);\n      }\n      return intersectWithLoop(self, that, input, lState, out, decision.intervals, rState, out2, rInterval, f);\n    });\n  }\n  return core.flatMap(that.step(Intervals.end(rInterval), input, rState), ([rState, out2, decision]) => {\n    if (ScheduleDecision.isDone(decision)) {\n      return core.succeed([[lState, rState], [out, out2], ScheduleDecision.done]);\n    }\n    return intersectWithLoop(self, that, input, lState, out, lInterval, rState, out2, decision.intervals, f);\n  });\n};\n/** @internal */\nconst jittered = /*#__PURE__*/Debug.untracedMethod(() => self => jitteredWith(self, {\n  min: 0.8,\n  max: 1.2\n}));\n/** @internal */\nexports.jittered = jittered;\nconst jitteredWith = /*#__PURE__*/Debug.untracedDual(2, () => (self, options) => {\n  const {\n    max,\n    min\n  } = Object.assign({\n    min: 0.8,\n    max: 1.2\n  }, options);\n  return delayedEffect(self, duration => core.map(Random.next(), random => {\n    const d = duration.millis;\n    const jittered = d * min * (1 - random) + d * max * random;\n    return Duration.millis(jittered);\n  }));\n});\n/** @internal */\nexports.jitteredWith = jitteredWith;\nconst left = /*#__PURE__*/Debug.untracedMethod(() => self => choose(self, identity()));\n/** @internal */\nexports.left = left;\nconst linear = /*#__PURE__*/Debug.untracedMethod(() => base => delayedSchedule(map(i => Duration.millis(base.millis * (i + 1)))(forever())));\n/** @internal */\nexports.linear = linear;\nconst map = /*#__PURE__*/Debug.untracedDual(2, restore => (self, f) => mapEffect(self, out => core.sync(() => restore(f)(out))));\n/** @internal */\nexports.map = map;\nconst mapEffect = /*#__PURE__*/Debug.untracedDual(2, restore => (self, f) => makeWithState(self.initial, (now, input, state) => core.flatMap(restore(self.step)(now, input, state), ([state, out, decision]) => core.map(restore(f)(out), out2 => [state, out2, decision]))));\n/** @internal */\nexports.mapEffect = mapEffect;\nconst minuteOfHour = /*#__PURE__*/Debug.untracedMethod(() => minute => makeWithState([Number.MIN_SAFE_INTEGER, 0], (now, _, state) => {\n  if (!Number.isInteger(minute) || minute < 0 || 59 < minute) {\n    return core.dieSync(() => internalCause.IllegalArgumentException(`Invalid argument in: minuteOfHour(${minute}). Must be in range 0...59`));\n  }\n  const n = state[1];\n  const initial = n === 0;\n  const minute0 = nextMinute(now, minute, initial);\n  const start = beginningOfMinute(minute0);\n  const end = endOfMinute(minute0);\n  const interval = Interval.make(start, end);\n  return core.succeed([[end, n + 1], n, ScheduleDecision.continueWith(interval)]);\n}));\n/** @internal */\nexports.minuteOfHour = minuteOfHour;\nconst modifyDelay = /*#__PURE__*/Debug.untracedDual(2, restore => (self, f) => modifyDelayEffect(self, (out, duration) => core.sync(() => restore(f)(out, duration))));\n/** @internal */\nexports.modifyDelay = modifyDelay;\nconst modifyDelayEffect = /*#__PURE__*/Debug.untracedDual(2, restore => (self, f) => makeWithState(self.initial, (now, input, state) => core.flatMap(restore(self.step)(now, input, state), ([state, out, decision]) => {\n  if (ScheduleDecision.isDone(decision)) {\n    return core.succeed([state, out, decision]);\n  }\n  const intervals = decision.intervals;\n  const delay = Interval.size(Interval.make(now, Intervals.start(intervals)));\n  return core.map(restore(f)(out, delay), duration => {\n    const oldStart = Intervals.start(intervals);\n    const newStart = now + duration.millis;\n    const delta = newStart - oldStart;\n    const newEnd = Math.min(Math.max(0, Intervals.end(intervals) + delta), Number.MAX_SAFE_INTEGER);\n    const newInterval = Interval.make(newStart, newEnd);\n    return [state, out, ScheduleDecision.continueWith(newInterval)];\n  });\n})));\n/** @internal */\nexports.modifyDelayEffect = modifyDelayEffect;\nconst onDecision = /*#__PURE__*/Debug.untracedDual(2, restore => (self, f) => makeWithState(self.initial, (now, input, state) => core.flatMap(restore(self.step)(now, input, state), ([state, out, decision]) => core.as(restore(f)(out, decision), [state, out, decision]))));\n/** @internal */\nexports.onDecision = onDecision;\nconst once = /*#__PURE__*/Debug.untracedMethod(() => () => asUnit(recurs(1)));\n/** @internal */\nexports.once = once;\nconst passthrough = /*#__PURE__*/Debug.untracedMethod(restore => self => makeWithState(self.initial, (now, input, state) => core.map(([state, _, decision]) => [state, input, decision])(restore(self.step)(now, input, state))));\n/** @internal */\nexports.passthrough = passthrough;\nconst provideContext = /*#__PURE__*/Debug.untracedDual(2, restore => (self, context) => makeWithState(self.initial, (now, input, state) => core.provideContext(restore(self.step)(now, input, state), context)));\n/** @internal */\nexports.provideContext = provideContext;\nconst provideService = /*#__PURE__*/Debug.untracedDual(3, restore => (self, tag, service) => makeWithState(self.initial, (now, input, state) => core.contextWithEffect(env => core.provideContext(\n// @ts-expect-error\nrestore(self.step)(now, input, state), Context.add(tag, service)(env)))));\n/** @internal */\nexports.provideService = provideService;\nconst reconsider = /*#__PURE__*/Debug.untracedDual(2, restore => (self, f) => reconsiderEffect(self, (out, decision) => core.sync(() => restore(f)(out, decision))));\n/** @internal */\nexports.reconsider = reconsider;\nconst reconsiderEffect = /*#__PURE__*/Debug.untracedDual(2, restore => (self, f) => makeWithState(self.initial, (now, input, state) => core.flatMap(restore(self.step)(now, input, state), ([state, out, decision]) => ScheduleDecision.isDone(decision) ? core.map(restore(f)(out, decision), either => {\n  switch (either._tag) {\n    case \"Left\":\n      {\n        return [state, either.left, ScheduleDecision.done];\n      }\n    case \"Right\":\n      {\n        const [out2] = either.right;\n        return [state, out2, ScheduleDecision.done];\n      }\n  }\n}) : core.map(restore(f)(out, decision), either => {\n  switch (either._tag) {\n    case \"Left\":\n      {\n        return [state, either.left, ScheduleDecision.done];\n      }\n    case \"Right\":\n      {\n        const [out2, interval] = either.right;\n        return [state, out2, ScheduleDecision.continueWith(interval)];\n      }\n  }\n}))));\n/** @internal */\nexports.reconsiderEffect = reconsiderEffect;\nconst recurUntil = /*#__PURE__*/Debug.untracedMethod(restore => f => untilInput(identity(), restore(f)));\n/** @internal */\nexports.recurUntil = recurUntil;\nconst recurUntilEffect = /*#__PURE__*/Debug.untracedMethod(restore => f => untilInputEffect(identity(), restore(f)));\n/** @internal */\nexports.recurUntilEffect = recurUntilEffect;\nconst recurUntilEquals = /*#__PURE__*/Debug.untracedMethod(() => value => untilInput(identity(), input => Equal.equals(input, value)));\n/** @internal */\nexports.recurUntilEquals = recurUntilEquals;\nconst recurUntilOption = /*#__PURE__*/Debug.untracedMethod(restore => pf => untilOutput(Option.isSome)(map(restore(pf))(identity())));\n/** @internal */\nexports.recurUntilOption = recurUntilOption;\nconst recurUpTo = /*#__PURE__*/Debug.untracedMethod(() => duration => whileOutput(elapsed(), elapsed => Duration.lessThan(duration)(elapsed)));\n/** @internal */\nexports.recurUpTo = recurUpTo;\nconst recurWhile = /*#__PURE__*/Debug.untracedMethod(restore => f => whileInput(identity(), restore(f)));\n/** @internal */\nexports.recurWhile = recurWhile;\nconst recurWhileEffect = /*#__PURE__*/Debug.untracedMethod(restore => f => whileInputEffect(identity(), restore(f)));\n/** @internal */\nexports.recurWhileEffect = recurWhileEffect;\nconst recurWhileEquals = /*#__PURE__*/Debug.untracedMethod(() => value => whileInput(input => Equal.equals(input, value))(identity()));\n/** @internal */\nexports.recurWhileEquals = recurWhileEquals;\nconst recurs = /*#__PURE__*/Debug.untracedMethod(() => n => whileOutput(forever(), out => out < n));\n/** @internal */\nexports.recurs = recurs;\nconst reduce = /*#__PURE__*/Debug.untracedDual(3, restore => (self, zero, f) => reduceEffect(self, zero, (z, out) => core.sync(() => restore(f)(z, out))));\n/** @internal */\nexports.reduce = reduce;\nconst reduceEffect = /*#__PURE__*/Debug.untracedDual(3, restore => (self, zero, f) => makeWithState([self.initial, zero], (now, input, [s, z]) => core.flatMap(restore(self.step)(now, input, s), ([s, out, decision]) => ScheduleDecision.isDone(decision) ? core.succeed([[s, z], z, decision]) : core.map(restore(f)(z, out), z2 => [[s, z2], z, decision]))));\n/** @internal */\nexports.reduceEffect = reduceEffect;\nconst repeatForever = /*#__PURE__*/Debug.untracedMethod(restore => self => makeWithState(self.initial, (now, input, state) => {\n  const step = (now, input, state) => core.flatMap(restore(self.step)(now, input, state), ([state, out, decision]) => ScheduleDecision.isDone(decision) ? step(now, input, self.initial) : core.succeed([state, out, decision]));\n  return step(now, input, state);\n}));\n/** @internal */\nexports.repeatForever = repeatForever;\nconst repetitions = /*#__PURE__*/Debug.untracedMethod(() => self => reduce(self, 0, (n, _) => n + 1));\n/** @internal */\nexports.repetitions = repetitions;\nconst resetAfter = /*#__PURE__*/Debug.untracedDual(2, () => (self, duration) => map(out => out[0])(resetWhen(([, time]) => Duration.greaterThanOrEqualTo(duration)(time))(intersect(elapsed())(self))));\n/** @internal */\nexports.resetAfter = resetAfter;\nconst resetWhen = /*#__PURE__*/Debug.untracedDual(2, restore => (self, f) => makeWithState(self.initial, (now, input, state) => core.flatMap(restore(self.step)(now, input, state), ([state, out, decision]) => restore(f)(out) ? restore(self.step)(now, input, self.initial) : core.succeed([state, out, decision]))));\n/** @internal */\nexports.resetWhen = resetWhen;\nconst right = /*#__PURE__*/Debug.untracedMethod(() => self => choose(identity(), self));\n/** @internal */\nexports.right = right;\nconst run = /*#__PURE__*/Debug.dualWithTrace(3, trace => (self, now, input) => core.map(list => Chunk.reverse(list))(runLoop(self, now, Chunk.fromIterable(input), self.initial, Chunk.empty())).traced(trace));\n/** @internal */\nexports.run = run;\nconst runLoop = (self, now, inputs, state, acc) => {\n  if (!Chunk.isNonEmpty(inputs)) {\n    return core.succeed(acc);\n  }\n  const input = Chunk.headNonEmpty(inputs);\n  const nextInputs = Chunk.tailNonEmpty(inputs);\n  return core.flatMap(self.step(now, input, state), ([state, out, decision]) => {\n    if (ScheduleDecision.isDone(decision)) {\n      return core.sync(() => Chunk.prepend(out)(acc));\n    }\n    return runLoop(self, Intervals.start(decision.intervals), nextInputs, state, Chunk.prepend(out)(acc));\n  });\n};\n/** @internal */\nconst secondOfMinute = /*#__PURE__*/Debug.untracedMethod(() => second => makeWithState([Number.NEGATIVE_INFINITY, 0], (now, _, state) => {\n  if (!Number.isInteger(second) || second < 0 || 59 < second) {\n    return core.dieSync(() => internalCause.IllegalArgumentException(`Invalid argument in: secondOfMinute(${second}). Must be in range 0...59`));\n  }\n  const n = state[1];\n  const initial = n === 0;\n  const second0 = nextSecond(now, second, initial);\n  const start = beginningOfSecond(second0);\n  const end = endOfSecond(second0);\n  const interval = Interval.make(start, end);\n  return core.succeed([[end, n + 1], n, ScheduleDecision.continueWith(interval)]);\n}));\n/** @internal */\nexports.secondOfMinute = secondOfMinute;\nconst spaced = /*#__PURE__*/Debug.untracedMethod(() => duration => addDelay(forever(), () => duration));\n/** @internal */\nexports.spaced = spaced;\nconst stop = /*#__PURE__*/Debug.untracedMethod(() => () => asUnit(recurs(0)));\n/** @internal */\nexports.stop = stop;\nconst succeed = /*#__PURE__*/Debug.untracedMethod(() => value => map(forever(), () => value));\n/** @internal */\nexports.succeed = succeed;\nconst sync = /*#__PURE__*/Debug.untracedMethod(restore => evaluate => map(forever(), restore(evaluate)));\n/** @internal */\nexports.sync = sync;\nconst tapInput = /*#__PURE__*/Debug.untracedDual(2, restore => (self, f) => makeWithState(self.initial, (now, input, state) => core.zipRight(restore(f)(input), restore(self.step)(now, input, state))));\n/** @internal */\nexports.tapInput = tapInput;\nconst tapOutput = /*#__PURE__*/Debug.untracedDual(2, restore => (self, f) => makeWithState(self.initial, (now, input, state) => core.tap(restore(self.step)(now, input, state), ([, out]) => restore(f)(out))));\n/** @internal */\nexports.tapOutput = tapOutput;\nconst unfold = /*#__PURE__*/Debug.untracedMethod(restore => (initial, f) => makeWithState(initial, (now, _, state) => core.sync(() => [restore(f)(state), state, ScheduleDecision.continueWith(Interval.after(now))])));\n/** @internal */\nexports.unfold = unfold;\nconst union = /*#__PURE__*/Debug.untracedDual(2, () => (self, that) => unionWith(self, that, (selfIntervals, thatIntervals) => Intervals.union(thatIntervals)(selfIntervals)));\n/** @internal */\nexports.union = union;\nconst unionWith = /*#__PURE__*/Debug.untracedDual(3, restore => (self, that, f) => makeWithState([self.initial, that.initial], (now, input, state) => core.zipWith(restore(self.step)(now, input, state[0]), restore(that.step)(now, input, state[1]), ([lState, l, lDecision], [rState, r, rDecision]) => {\n  if (ScheduleDecision.isDone(lDecision) && ScheduleDecision.isDone(rDecision)) {\n    return [[lState, rState], [l, r], ScheduleDecision.done];\n  }\n  if (ScheduleDecision.isDone(lDecision) && ScheduleDecision.isContinue(rDecision)) {\n    return [[lState, rState], [l, r], ScheduleDecision.continue(rDecision.intervals)];\n  }\n  if (ScheduleDecision.isContinue(lDecision) && ScheduleDecision.isDone(rDecision)) {\n    return [[lState, rState], [l, r], ScheduleDecision.continue(lDecision.intervals)];\n  }\n  if (ScheduleDecision.isContinue(lDecision) && ScheduleDecision.isContinue(rDecision)) {\n    const combined = restore(f)(lDecision.intervals, rDecision.intervals);\n    return [[lState, rState], [l, r], ScheduleDecision.continue(combined)];\n  }\n  throw new Error(\"BUG: Schedule.unionWith - please report an issue at https://github.com/Effect-TS/io/issues\");\n})));\n/** @internal */\nexports.unionWith = unionWith;\nconst untilInput = /*#__PURE__*/Debug.untracedDual(2, restore => (self, f) => check(self, (input, _) => !restore(f)(input)));\n/** @internal */\nexports.untilInput = untilInput;\nconst untilInputEffect = /*#__PURE__*/Debug.untracedDual(2, restore => (self, f) => checkEffect(self, (input, _) => effect.negate(restore(f)(input))));\n/** @internal */\nexports.untilInputEffect = untilInputEffect;\nconst untilOutput = /*#__PURE__*/Debug.untracedDual(2, restore => (self, f) => check(self, (_, out) => !restore(f)(out)));\n/** @internal */\nexports.untilOutput = untilOutput;\nconst untilOutputEffect = /*#__PURE__*/Debug.untracedDual(2, restore => (self, f) => checkEffect(self, (_, out) => effect.negate(restore(f)(out))));\n/** @internal */\nexports.untilOutputEffect = untilOutputEffect;\nconst upTo = /*#__PURE__*/Debug.untracedDual(2, () => (self, duration) => zipLeft(self, recurUpTo(duration)));\n/** @internal */\nexports.upTo = upTo;\nconst whileInput = /*#__PURE__*/Debug.untracedDual(2, restore => (self, f) => check(self, (input, _) => restore(f)(input)));\n/** @internal */\nexports.whileInput = whileInput;\nconst whileInputEffect = /*#__PURE__*/Debug.untracedDual(2, restore => (self, f) => checkEffect(self, (input, _) => restore(f)(input)));\n/** @internal */\nexports.whileInputEffect = whileInputEffect;\nconst whileOutput = /*#__PURE__*/Debug.untracedDual(2, restore => (self, f) => check(self, (_, out) => restore(f)(out)));\n/** @internal */\nexports.whileOutput = whileOutput;\nconst whileOutputEffect = /*#__PURE__*/Debug.untracedDual(2, restore => (self, f) => checkEffect(self, (_, out) => restore(f)(out)));\n/** @internal */\nexports.whileOutputEffect = whileOutputEffect;\nconst windowed = /*#__PURE__*/Debug.untracedMethod(() => interval => {\n  const millis = interval.millis;\n  return makeWithState([Option.none(), 0], (now, _, [option, n]) => {\n    switch (option._tag) {\n      case \"None\":\n        {\n          return core.succeed([[Option.some(now), n + 1], n, ScheduleDecision.continueWith(Interval.after(now + millis))]);\n        }\n      case \"Some\":\n        {\n          return core.succeed([[Option.some(option.value), n + 1], n, ScheduleDecision.continueWith(Interval.after(now + (millis - (now - option.value) % millis)))]);\n        }\n    }\n  });\n});\n/** @internal */\nexports.windowed = windowed;\nconst zipLeft = /*#__PURE__*/Debug.untracedDual(2, () => (self, that) => map(out => out[0])(intersect(self, that)));\n/** @internal */\nexports.zipLeft = zipLeft;\nconst zipRight = /*#__PURE__*/Debug.untracedDual(2, () => (self, that) => map(out => out[1])(intersect(self, that)));\n/** @internal */\nexports.zipRight = zipRight;\nconst zipWith = /*#__PURE__*/Debug.untracedDual(3, restore => (self, that, f) => map(([out, out2]) => restore(f)(out, out2))(intersect(self, that)));\n// -----------------------------------------------------------------------------\n// Seconds\n// -----------------------------------------------------------------------------\n/** @internal */\nexports.zipWith = zipWith;\nconst beginningOfSecond = now => {\n  const date = new Date(now);\n  return new Date(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), 0).getTime();\n};\n/** @internal */\nexports.beginningOfSecond = beginningOfSecond;\nconst endOfSecond = now => {\n  const date = new Date(beginningOfSecond(now));\n  return date.setSeconds(date.getSeconds() + 1);\n};\n/** @internal */\nexports.endOfSecond = endOfSecond;\nconst nextSecond = (now, second, initial) => {\n  const date = new Date(now);\n  if (date.getSeconds() === second && initial) {\n    return now;\n  }\n  if (date.getSeconds() < second) {\n    return date.setSeconds(second);\n  }\n  // Set seconds to the provided value and add one minute\n  const newDate = new Date(date.setSeconds(second));\n  return newDate.setTime(newDate.getTime() + 1000 * 60);\n};\n// -----------------------------------------------------------------------------\n// Minutes\n// -----------------------------------------------------------------------------\n/** @internal */\nexports.nextSecond = nextSecond;\nconst beginningOfMinute = now => {\n  const date = new Date(now);\n  return new Date(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), 0, 0).getTime();\n};\n/** @internal */\nexports.beginningOfMinute = beginningOfMinute;\nconst endOfMinute = now => {\n  const date = new Date(beginningOfMinute(now));\n  return date.setMinutes(date.getMinutes() + 1);\n};\n/** @internal */\nexports.endOfMinute = endOfMinute;\nconst nextMinute = (now, minute, initial) => {\n  const date = new Date(now);\n  if (date.getMinutes() === minute && initial) {\n    return now;\n  }\n  if (date.getMinutes() < minute) {\n    return date.setMinutes(minute);\n  }\n  // Set minutes to the provided value and add one hour\n  const newDate = new Date(date.setMinutes(minute));\n  return newDate.setTime(newDate.getTime() + 1000 * 60 * 60);\n};\n// -----------------------------------------------------------------------------\n// Hours\n// -----------------------------------------------------------------------------\n/** @internal */\nexports.nextMinute = nextMinute;\nconst beginningOfHour = now => {\n  const date = new Date(now);\n  return new Date(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), 0, 0, 0).getTime();\n};\n/** @internal */\nexports.beginningOfHour = beginningOfHour;\nconst endOfHour = now => {\n  const date = new Date(beginningOfHour(now));\n  return date.setHours(date.getHours() + 1);\n};\n/** @internal */\nexports.endOfHour = endOfHour;\nconst nextHour = (now, hour, initial) => {\n  const date = new Date(now);\n  if (date.getHours() === hour && initial) {\n    return now;\n  }\n  if (date.getHours() < hour) {\n    return date.setHours(hour);\n  }\n  // Set hours to the provided value and add one day\n  const newDate = new Date(date.setHours(hour));\n  return newDate.setTime(newDate.getTime() + 1000 * 60 * 60 * 24);\n};\n// -----------------------------------------------------------------------------\n// Days\n// -----------------------------------------------------------------------------\n/** @internal */\nexports.nextHour = nextHour;\nconst beginningOfDay = now => {\n  const date = new Date(now);\n  return new Date(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0, 0).getTime();\n};\n/** @internal */\nexports.beginningOfDay = beginningOfDay;\nconst endOfDay = now => {\n  const date = new Date(beginningOfDay(now));\n  return date.setDate(date.getDate() + 1);\n};\n/** @internal */\nexports.endOfDay = endOfDay;\nconst nextDay = (now, dayOfWeek, initial) => {\n  const date = new Date(now);\n  if (date.getDay() === dayOfWeek && initial) {\n    return now;\n  }\n  const nextDayOfWeek = (7 + dayOfWeek - date.getDay()) % 7;\n  return date.setDate(date.getDate() + (nextDayOfWeek === 0 ? 7 : nextDayOfWeek));\n};\n/** @internal */\nexports.nextDay = nextDay;\nconst nextDayOfMonth = (now, day, initial) => {\n  const date = new Date(now);\n  if (date.getDate() === day && initial) {\n    return now;\n  }\n  if (date.getDate() < day) {\n    return date.setDate(day);\n  }\n  return findNextMonth(now, day, 1);\n};\n/** @internal */\nexports.nextDayOfMonth = nextDayOfMonth;\nconst findNextMonth = (now, day, months) => {\n  const d = new Date(now);\n  const tmp1 = new Date(d.setDate(day));\n  const tmp2 = new Date(tmp1.setMonth(tmp1.getMonth() + months));\n  if (tmp2.getDate() === day) {\n    const d2 = new Date(now);\n    const tmp3 = new Date(d2.setDate(day));\n    return tmp3.setMonth(tmp3.getMonth() + months);\n  }\n  return findNextMonth(now, day, months + 1);\n};\n// circular with Effect\n/** @internal */\nexports.findNextMonth = findNextMonth;\nconst repeat_Effect = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, schedule) => repeatOrElse_Effect(self, schedule, (e, _) => core.fail(e)).traced(trace));\n/** @internal */\nexports.repeat_Effect = repeat_Effect;\nconst repeatOrElse_Effect = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (self, schedule, orElse) => core.map(repeatOrElseEither_Effect(self, schedule, restore(orElse)), Either.merge).traced(trace));\n/** @internal */\nexports.repeatOrElse_Effect = repeatOrElse_Effect;\nconst repeatOrElseEither_Effect = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (self, schedule, orElse) => core.flatMap(driver(schedule), driver => core.matchEffect(self, error => core.map(Either.left)(restore(orElse)(error, Option.none())), value => repeatOrElseEitherEffectLoop(self, driver, restore(orElse), value))).traced(trace));\n/** @internal */\nexports.repeatOrElseEither_Effect = repeatOrElseEither_Effect;\nconst repeatOrElseEitherEffectLoop = (self, driver, orElse, value) => {\n  return core.matchEffect(() => core.map(Either.right)(core.orDie(driver.last())), b => core.matchEffect(error => core.map(Either.left)(orElse(error, Option.some(b))), value => repeatOrElseEitherEffectLoop(self, driver, orElse, value))(self))(driver.next(value));\n};\n/** @internal */\nconst repeatUntil_Effect = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => repeatUntilEffect_Effect(self, a => core.sync(() => restore(f)(a))).traced(trace));\n/** @internal */\nexports.repeatUntil_Effect = repeatUntil_Effect;\nconst repeatUntilEffect_Effect = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => core.flatMap(self, a => core.flatMap(f(a), result => result ? core.succeed(a) : core.zipRight(core.yieldNow(), repeatUntilEffect_Effect(self, restore(f))))).traced(trace));\n/** @internal */\nexports.repeatUntilEffect_Effect = repeatUntilEffect_Effect;\nconst repeatUntilEquals_Effect = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, value) => repeatUntil_Effect(self, a => Equal.equals(a, value)).traced(trace));\n/** @internal */\nexports.repeatUntilEquals_Effect = repeatUntilEquals_Effect;\nconst repeatWhile_Effect = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => repeatWhileEffect_Effect(self, a => core.sync(() => restore(f)(a))).traced(trace));\n/** @internal */\nexports.repeatWhile_Effect = repeatWhile_Effect;\nconst repeatWhileEffect_Effect = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => repeatUntilEffect_Effect(self, a => effect.negate(restore(f)(a))).traced(trace));\n/** @internal */\nexports.repeatWhileEffect_Effect = repeatWhileEffect_Effect;\nconst repeatWhileEquals_Effect = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, value) => repeatWhile_Effect(self, a => Equal.equals(a, value)).traced(trace));\n/** @internal */\nexports.repeatWhileEquals_Effect = repeatWhileEquals_Effect;\nconst retry_Effect = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, policy) => retryOrElse_Effect(self, policy, (e, _) => core.fail(e)).traced(trace));\n/** @internal */\nexports.retry_Effect = retry_Effect;\nconst retryN_Effect = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, n) => retryN_EffectLoop(self, n).traced(trace));\n/** @internal */\nexports.retryN_Effect = retryN_Effect;\nconst retryN_EffectLoop = (self, n) => {\n  return core.catchAll(self, e => n < 0 ? core.fail(e) : core.flatMap(core.yieldNow(), () => retryN_EffectLoop(self, n - 1)));\n};\n/** @internal */\nconst retryOrElse_Effect = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (self, policy, orElse) => core.map(retryOrElseEither_Effect(self, policy, restore(orElse)), Either.merge).traced(trace));\n/** @internal */\nexports.retryOrElse_Effect = retryOrElse_Effect;\nconst retryOrElseEither_Effect = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (self, policy, orElse) => core.flatMap(driver(policy), driver => retryOrElseEither_EffectLoop(self, driver, restore(orElse))).traced(trace));\n/** @internal */\nexports.retryOrElseEither_Effect = retryOrElseEither_Effect;\nconst retryOrElseEither_EffectLoop = (self, driver, orElse) => {\n  return core.catchAll(e => core.matchEffect(() => core.flatMap(out => core.map(Either.left)(orElse(e, out)))(core.orDie(driver.last())), () => retryOrElseEither_EffectLoop(self, driver, orElse))(driver.next(e)))(core.map(Either.right)(self));\n};\n/** @internal */\nconst retryUntil_Effect = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => retryUntilEffect_Effect(self, e => core.sync(() => restore(f)(e))).traced(trace));\n/** @internal */\nexports.retryUntil_Effect = retryUntil_Effect;\nconst retryUntilEffect_Effect = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => core.catchAll(self, e => core.flatMap(restore(f)(e), b => b ? core.fail(e) : core.flatMap(core.yieldNow(), () => retryUntilEffect_Effect(self, restore(f))))).traced(trace));\n/** @internal */\nexports.retryUntilEffect_Effect = retryUntilEffect_Effect;\nconst retryUntilEquals_Effect = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, e) => retryUntil_Effect(self, _ => Equal.equals(_, e)).traced(trace));\n/** @internal */\nexports.retryUntilEquals_Effect = retryUntilEquals_Effect;\nconst retryWhile_Effect = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => retryWhileEffect_Effect(self, e => core.sync(() => restore(f)(e))).traced(trace));\n/** @internal */\nexports.retryWhile_Effect = retryWhile_Effect;\nconst retryWhileEffect_Effect = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => retryUntilEffect_Effect(self, e => effect.negate(restore(f)(e))).traced(trace));\n/** @internal */\nexports.retryWhileEffect_Effect = retryWhileEffect_Effect;\nconst retryWhileEquals_Effect = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, e) => retryWhile_Effect(self, err => Equal.equals(e, err)).traced(trace));\n/** @internal */\nexports.retryWhileEquals_Effect = retryWhileEquals_Effect;\nconst schedule_Effect = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, schedule) => scheduleFrom_Effect(self, void 0, schedule).traced(trace));\n/** @internal */\nexports.schedule_Effect = schedule_Effect;\nconst scheduleFrom_Effect = /*#__PURE__*/Debug.dualWithTrace(3, trace => (self, initial, schedule) => core.flatMap(driver(schedule), driver => scheduleFrom_EffectLoop(self, initial, driver)).traced(trace));\n/** @internal */\nexports.scheduleFrom_Effect = scheduleFrom_Effect;\nconst scheduleFrom_EffectLoop = (self, initial, driver) => core.matchEffect(() => core.orDie(driver.last()), () => core.flatMap(a => scheduleFrom_EffectLoop(self, a, driver))(self))(driver.next(initial));\n//# sourceMappingURL=schedule.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isDone = exports.isContinue = exports.done = exports.continueWith = exports._continue = exports.OP_DONE = exports.OP_CONTINUE = void 0;\nvar Chunk = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Chunk\"));\nvar Intervals = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Schedule/Intervals\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/** @internal */\nconst OP_CONTINUE = \"Continue\";\n/** @internal */\nexports.OP_CONTINUE = OP_CONTINUE;\nconst OP_DONE = \"Done\";\n/** @internal */\nexports.OP_DONE = OP_DONE;\nconst _continue = intervals => {\n  return {\n    _tag: OP_CONTINUE,\n    intervals\n  };\n};\n/** @internal */\nexports._continue = _continue;\nconst continueWith = interval => {\n  return {\n    _tag: OP_CONTINUE,\n    intervals: Intervals.make(Chunk.of(interval))\n  };\n};\n/** @internal */\nexports.continueWith = continueWith;\nconst done = {\n  _tag: OP_DONE\n};\n/** @internal */\nexports.done = done;\nconst isContinue = self => {\n  return self._tag === OP_CONTINUE;\n};\n/** @internal */\nexports.isContinue = isContinue;\nconst isDone = self => {\n  return self._tag === OP_DONE;\n};\nexports.isDone = isDone;\n//# sourceMappingURL=decision.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.union = exports.size = exports.min = exports.max = exports.make = exports.lessThan = exports.isNonEmpty = exports.isEmpty = exports.intersect = exports.empty = exports.before = exports.after = exports.IntervalTypeId = void 0;\nvar Duration = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Duration\"));\nvar _Function = /*#__PURE__*/require(\"@effect/data/Function\");\nvar Option = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Option\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/** @internal */\nconst IntervalSymbolKey = \"@effect/io/Schedule/Interval\";\n/** @internal */\nconst IntervalTypeId = /*#__PURE__*/Symbol.for(IntervalSymbolKey);\n/** @internal */\nexports.IntervalTypeId = IntervalTypeId;\nconst empty = {\n  [IntervalTypeId]: IntervalTypeId,\n  startMillis: 0,\n  endMillis: 0\n};\n/** @internal */\nexports.empty = empty;\nconst make = (startMillis, endMillis) => {\n  if (startMillis > endMillis) {\n    return empty;\n  }\n  return {\n    [IntervalTypeId]: IntervalTypeId,\n    startMillis,\n    endMillis\n  };\n};\n/** @internal */\nexports.make = make;\nconst lessThan = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => min(self, that) === self);\n/** @internal */\nexports.lessThan = lessThan;\nconst min = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => {\n  if (self.endMillis <= that.startMillis) return self;\n  if (that.endMillis <= self.startMillis) return that;\n  if (self.startMillis < that.startMillis) return self;\n  if (that.startMillis < self.startMillis) return that;\n  if (self.endMillis <= that.endMillis) return self;\n  return that;\n});\n/** @internal */\nexports.min = min;\nconst max = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => min(self, that) === self ? that : self);\n/** @internal */\nexports.max = max;\nconst isEmpty = self => {\n  return self.startMillis >= self.endMillis;\n};\n/** @internal */\nexports.isEmpty = isEmpty;\nconst isNonEmpty = self => {\n  return !isEmpty(self);\n};\n/** @internal */\nexports.isNonEmpty = isNonEmpty;\nconst intersect = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => {\n  const start = Math.max(self.startMillis, that.startMillis);\n  const end = Math.min(self.endMillis, that.endMillis);\n  return make(start, end);\n});\n/** @internal */\nexports.intersect = intersect;\nconst size = self => {\n  return Duration.millis(self.endMillis - self.startMillis);\n};\n/** @internal */\nexports.size = size;\nconst union = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => {\n  const start = Math.max(self.startMillis, that.startMillis);\n  const end = Math.min(self.endMillis, that.endMillis);\n  return start < end ? Option.none() : Option.some(make(start, end));\n});\n/** @internal */\nexports.union = union;\nconst after = startMilliseconds => {\n  return make(startMilliseconds, Number.POSITIVE_INFINITY);\n};\n/** @internal */\nexports.after = after;\nconst before = endMilliseconds => {\n  return make(Number.NEGATIVE_INFINITY, endMilliseconds);\n};\nexports.before = before;\n//# sourceMappingURL=interval.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.union = exports.start = exports.max = exports.make = exports.lessThan = exports.isNonEmpty = exports.intersect = exports.fromIterable = exports.end = exports.empty = exports.IntervalsTypeId = void 0;\nvar Chunk = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Chunk\"));\nvar _Function = /*#__PURE__*/require(\"@effect/data/Function\");\nvar Option = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Option\"));\nvar Interval = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Schedule/Interval\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/** @internal */\nconst IntervalsSymbolKey = \"@effect/io/Schedule/Intervals\";\n/** @internal */\nconst IntervalsTypeId = /*#__PURE__*/Symbol.for(IntervalsSymbolKey);\n/** @internal */\nexports.IntervalsTypeId = IntervalsTypeId;\nconst make = intervals => {\n  return {\n    [IntervalsTypeId]: IntervalsTypeId,\n    intervals\n  };\n};\n/** @internal */\nexports.make = make;\nconst empty = /*#__PURE__*/make( /*#__PURE__*/Chunk.empty());\n/** @internal */\nexports.empty = empty;\nconst fromIterable = intervals => Array.from(intervals).reduce((intervals, interval) => union(make(Chunk.of(interval)))(intervals), empty);\n/** @internal */\nexports.fromIterable = fromIterable;\nconst union = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => {\n  if (!Chunk.isNonEmpty(that.intervals)) {\n    return self;\n  }\n  if (!Chunk.isNonEmpty(self.intervals)) {\n    return that;\n  }\n  if (Chunk.headNonEmpty(self.intervals).startMillis < Chunk.headNonEmpty(that.intervals).startMillis) {\n    return unionLoop(Chunk.tailNonEmpty(self.intervals), that.intervals, Chunk.headNonEmpty(self.intervals), Chunk.empty());\n  }\n  return unionLoop(self.intervals, Chunk.tailNonEmpty(that.intervals), Chunk.headNonEmpty(that.intervals), Chunk.empty());\n});\n/** @internal */\nexports.union = union;\nconst unionLoop = (_self, _that, _interval, _acc) => {\n  let self = _self;\n  let that = _that;\n  let interval = _interval;\n  let acc = _acc;\n  while (Chunk.isNonEmpty(self) || Chunk.isNonEmpty(that)) {\n    if (!Chunk.isNonEmpty(self) && Chunk.isNonEmpty(that)) {\n      if (interval.endMillis < Chunk.headNonEmpty(that).startMillis) {\n        acc = Chunk.prepend(interval)(acc);\n        interval = Chunk.headNonEmpty(that);\n        that = Chunk.tailNonEmpty(that);\n        self = Chunk.empty();\n      } else {\n        interval = Interval.make(interval.startMillis, Chunk.headNonEmpty(that).endMillis);\n        that = Chunk.tailNonEmpty(that);\n        self = Chunk.empty();\n      }\n    } else if (Chunk.isNonEmpty(self) && Chunk.isEmpty(that)) {\n      if (interval.endMillis < Chunk.headNonEmpty(self).startMillis) {\n        acc = Chunk.prepend(interval)(acc);\n        interval = Chunk.headNonEmpty(self);\n        that = Chunk.empty();\n        self = Chunk.tailNonEmpty(self);\n      } else {\n        interval = Interval.make(interval.startMillis, Chunk.headNonEmpty(self).endMillis);\n        that = Chunk.empty();\n        self = Chunk.tailNonEmpty(self);\n      }\n    } else if (Chunk.isNonEmpty(self) && Chunk.isNonEmpty(that)) {\n      if (Chunk.headNonEmpty(self).startMillis < Chunk.headNonEmpty(that).startMillis) {\n        if (interval.endMillis < Chunk.headNonEmpty(self).startMillis) {\n          acc = Chunk.prepend(interval)(acc);\n          interval = Chunk.headNonEmpty(self);\n          self = Chunk.tailNonEmpty(self);\n        } else {\n          interval = Interval.make(interval.startMillis, Chunk.headNonEmpty(self).endMillis);\n          self = Chunk.tailNonEmpty(self);\n        }\n      } else if (interval.endMillis < Chunk.headNonEmpty(that).startMillis) {\n        acc = Chunk.prepend(interval)(acc);\n        interval = Chunk.headNonEmpty(that);\n        that = Chunk.tailNonEmpty(that);\n      } else {\n        interval = Interval.make(interval.startMillis, Chunk.headNonEmpty(that).endMillis);\n        that = Chunk.tailNonEmpty(that);\n      }\n    } else {\n      throw new Error(\"BUG: Intervals.unionLoop - please report an issue at https://github.com/Effect-TS/io/issues\");\n    }\n  }\n  return make(Chunk.reverse(Chunk.prepend(interval)(acc)));\n};\n/** @internal */\nconst intersect = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => intersectLoop(self.intervals, that.intervals, Chunk.empty()));\n/** @internal */\nexports.intersect = intersect;\nconst intersectLoop = (_left, _right, _acc) => {\n  let left = _left;\n  let right = _right;\n  let acc = _acc;\n  while (Chunk.isNonEmpty(left) && Chunk.isNonEmpty(right)) {\n    const interval = Interval.intersect(Chunk.headNonEmpty(right))(Chunk.headNonEmpty(left));\n    const intervals = Interval.isEmpty(interval) ? acc : Chunk.prepend(interval)(acc);\n    if (Interval.lessThan(Chunk.headNonEmpty(right))(Chunk.headNonEmpty(left))) {\n      left = Chunk.tailNonEmpty(left);\n    } else {\n      right = Chunk.tailNonEmpty(right);\n    }\n    acc = intervals;\n  }\n  return make(Chunk.reverse(acc));\n};\n/** @internal */\nconst start = self => {\n  return Option.getOrElse(() => Interval.empty)(Chunk.head(self.intervals)).startMillis;\n};\n/** @internal */\nexports.start = start;\nconst end = self => {\n  return Option.getOrElse(() => Interval.empty)(Chunk.head(self.intervals)).endMillis;\n};\n/** @internal */\nexports.end = end;\nconst lessThan = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => start(self) < start(that));\n/** @internal */\nexports.lessThan = lessThan;\nconst isNonEmpty = self => {\n  return Chunk.isNonEmpty(self.intervals);\n};\n/** @internal */\nexports.isNonEmpty = isNonEmpty;\nconst max = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => lessThan(self, that) ? that : self);\nexports.max = max;\n//# sourceMappingURL=intervals.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SingleShotGen = void 0;\n/** @internal */\nclass SingleShotGen {\n  constructor(self) {\n    this.self = self;\n    this.called = false;\n  }\n  next(a) {\n    return this.called ? {\n      value: a,\n      done: true\n    } : (this.called = true, {\n      value: this.self,\n      done: false\n    });\n  }\n  return(a) {\n    return {\n      value: a,\n      done: true\n    };\n  }\n  throw(e) {\n    throw e;\n  }\n  [Symbol.iterator]() {\n    return new SingleShotGen(this.self);\n  }\n}\nexports.SingleShotGen = SingleShotGen;\n//# sourceMappingURL=singleShotGen.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.upperCase = exports.snakeCase = exports.pascalCase = exports.lowerCase = exports.kebabCase = exports.constantCase = exports.camelCase = void 0;\n/**\n * Adapted from the `change-case` library.\n *\n * Copyright (c) 2014 Blake Embrey (hello@blakeembrey.com)\n */\n/** @internal */\nconst lowerCase = str => str.toLowerCase();\n/** @internal */\nexports.lowerCase = lowerCase;\nconst upperCase = str => str.toUpperCase();\n/**\n * Replace `re` in the input string with the replacement value.\n */\nexports.upperCase = upperCase;\nconst replace = (input, re, value) => re instanceof RegExp ? input.replace(re, value) : re.reduce((input, re) => input.replace(re, value), input);\n// Support camel case (\"camelCase\" -> \"camel Case\" and \"CAMELCase\" -> \"CAMEL Case\").\nconst DEFAULT_SPLIT_REGEXP = [/([a-z0-9])([A-Z])/g, /([A-Z])([A-Z][a-z])/g];\n// Remove all non-word characters.\nconst DEFAULT_STRIP_REGEXP = /[^A-Z0-9]+/gi;\n/**\n * Normalize the string into something other libraries can manipulate easier.\n */\nconst noCase = (input, options = {}) => {\n  const {\n    delimiter = \" \",\n    splitRegexp = DEFAULT_SPLIT_REGEXP,\n    stripRegexp = DEFAULT_STRIP_REGEXP,\n    transform = lowerCase\n  } = options;\n  const result = replace(replace(input, splitRegexp, \"$1\\0$2\"), stripRegexp, \"\\0\");\n  let start = 0;\n  let end = result.length;\n  // Trim the delimiter from around the output string.\n  while (result.charAt(start) === \"\\0\") {\n    start++;\n  }\n  while (result.charAt(end - 1) === \"\\0\") {\n    end--;\n  }\n  // Transform each token independently.\n  return result.slice(start, end).split(\"\\0\").map(transform).join(delimiter);\n};\nconst pascalCaseTransform = (input, index) => {\n  const firstChar = input.charAt(0);\n  const lowerChars = input.substring(1).toLowerCase();\n  if (index > 0 && firstChar >= \"0\" && firstChar <= \"9\") {\n    return `_${firstChar}${lowerChars}`;\n  }\n  return `${firstChar.toUpperCase()}${lowerChars}`;\n};\n/** @internal */\nconst pascalCase = (input, options = {}) => noCase(input, {\n  delimiter: \"\",\n  transform: pascalCaseTransform,\n  ...options\n});\nexports.pascalCase = pascalCase;\nconst camelCaseTransform = (input, index) => index === 0 ? input.toLowerCase() : pascalCaseTransform(input, index);\n/** @internal */\nconst camelCase = (input, options = {}) => pascalCase(input, {\n  transform: camelCaseTransform,\n  ...options\n});\n/** @internal */\nexports.camelCase = camelCase;\nconst constantCase = (input, options = {}) => noCase(input, {\n  delimiter: \"_\",\n  transform: upperCase,\n  ...options\n});\n/** @internal */\nexports.constantCase = constantCase;\nconst kebabCase = (input, options = {}) => noCase(input, {\n  delimiter: \"-\",\n  ...options\n});\n/** @internal */\nexports.kebabCase = kebabCase;\nconst snakeCase = (input, options = {}) => noCase(input, {\n  delimiter: \"_\",\n  ...options\n});\nexports.snakeCase = snakeCase;\n//# sourceMappingURL=string-utils.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.unsafeTrack = exports.track = exports.none = exports.fromEffect = exports.fibersIn = exports.Zip = exports.Track = exports.SupervisorTypeId = exports.ProxySupervisor = exports.Const = void 0;\nvar Chunk = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Chunk\"));\nvar MutableRef = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/MutableRef\"));\nvar SortedSet = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/SortedSet\"));\nvar Debug = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Debug\"));\nvar core = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/core\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\nvar _a, _b, _c, _d, _e;\n/** @internal */\nconst SupervisorSymbolKey = \"@effect/io/Supervisor\";\n/** @internal */\nconst SupervisorTypeId = /*#__PURE__*/Symbol.for(SupervisorSymbolKey);\n/** @internal */\nexports.SupervisorTypeId = SupervisorTypeId;\nconst supervisorVariance = {\n  _T: _ => _\n};\n/** @internal */\nclass ProxySupervisor {\n  constructor(underlying, value0) {\n    this.underlying = underlying;\n    this.value0 = value0;\n    this[_a] = supervisorVariance;\n  }\n  value() {\n    return Debug.bodyWithTrace(trace => this.value0().traced(trace));\n  }\n  onStart(context, effect, parent, fiber) {\n    this.underlying.onStart(context, effect, parent, fiber);\n  }\n  onEnd(value, fiber) {\n    this.underlying.onEnd(value, fiber);\n  }\n  onEffect(fiber, effect) {\n    this.underlying.onEffect(fiber, effect);\n  }\n  onSuspend(fiber) {\n    this.underlying.onSuspend(fiber);\n  }\n  onResume(fiber) {\n    this.underlying.onResume(fiber);\n  }\n  map(f) {\n    return new ProxySupervisor(this, () => core.map(f)(this.value()));\n  }\n  zip(right) {\n    return new Zip(this, right);\n  }\n}\nexports.ProxySupervisor = ProxySupervisor;\n_a = SupervisorTypeId;\n/** @internal */\nclass Zip {\n  constructor(left, right) {\n    this.left = left;\n    this.right = right;\n    this[_b] = supervisorVariance;\n  }\n  value() {\n    return Debug.bodyWithTrace(trace => core.zip(this.left.value(), this.right.value()).traced(trace));\n  }\n  onStart(context, effect, parent, fiber) {\n    this.left.onStart(context, effect, parent, fiber);\n    this.right.onStart(context, effect, parent, fiber);\n  }\n  onEnd(value, fiber) {\n    this.left.onEnd(value, fiber);\n    this.right.onEnd(value, fiber);\n  }\n  onEffect(fiber, effect) {\n    this.left.onEffect(fiber, effect);\n    this.right.onEffect(fiber, effect);\n  }\n  onSuspend(fiber) {\n    this.left.onSuspend(fiber);\n    this.right.onSuspend(fiber);\n  }\n  onResume(fiber) {\n    this.left.onResume(fiber);\n    this.right.onResume(fiber);\n  }\n  map(f) {\n    return new ProxySupervisor(this, () => core.map(f)(this.value()));\n  }\n  zip(right) {\n    return new Zip(this, right);\n  }\n}\nexports.Zip = Zip;\n_b = SupervisorTypeId;\nclass Track {\n  constructor() {\n    this[_c] = supervisorVariance;\n    this.fibers = new Set();\n  }\n  value() {\n    return Debug.bodyWithTrace(trace => core.sync(() => Chunk.fromIterable(this.fibers)).traced(trace));\n  }\n  onStart(_context, _effect, _parent, fiber) {\n    this.fibers.add(fiber);\n  }\n  onEnd(_value, fiber) {\n    this.fibers.delete(fiber);\n  }\n  onEffect(_fiber, _effect) {\n    //\n  }\n  onSuspend(_fiber) {\n    //\n  }\n  onResume(_fiber) {\n    //\n  }\n  map(f) {\n    return new ProxySupervisor(this, () => core.map(f)(this.value()));\n  }\n  zip(right) {\n    return new Zip(this, right);\n  }\n}\nexports.Track = Track;\n_c = SupervisorTypeId;\nclass Const {\n  constructor(effect) {\n    this.effect = effect;\n    this[_d] = supervisorVariance;\n  }\n  value() {\n    return Debug.bodyWithTrace(trace => this.effect.traced(trace));\n  }\n  onStart(_context, _effect, _parent, _fiber) {\n    //\n  }\n  onEnd(_value, _fiber) {\n    //\n  }\n  onEffect(_fiber, _effect) {\n    //\n  }\n  onSuspend(_fiber) {\n    //\n  }\n  onResume(_fiber) {\n    //\n  }\n  map(f) {\n    return new ProxySupervisor(this, () => core.map(f)(this.value()));\n  }\n  zip(right) {\n    return new Zip(this, right);\n  }\n}\nexports.Const = Const;\n_d = SupervisorTypeId;\nclass FibersIn {\n  constructor(ref) {\n    this.ref = ref;\n    this[_e] = supervisorVariance;\n  }\n  value() {\n    return Debug.bodyWithTrace(trace => core.sync(() => MutableRef.get(this.ref)).traced(trace));\n  }\n  onStart(_context, _effect, _parent, fiber) {\n    MutableRef.set(SortedSet.add(fiber)(MutableRef.get(this.ref)))(this.ref);\n  }\n  onEnd(_value, fiber) {\n    MutableRef.set(SortedSet.remove(fiber)(MutableRef.get(this.ref)))(this.ref);\n  }\n  onEffect(_fiber, _effect) {\n    //\n  }\n  onSuspend(_fiber) {\n    //\n  }\n  onResume(_fiber) {\n    //\n  }\n  map(f) {\n    return new ProxySupervisor(this, () => core.map(f)(this.value()));\n  }\n  zip(right) {\n    return new Zip(this, right);\n  }\n}\n_e = SupervisorTypeId;\n/** @internal */\nconst unsafeTrack = () => {\n  return new Track();\n};\n/** @internal */\nexports.unsafeTrack = unsafeTrack;\nconst track = /*#__PURE__*/Debug.methodWithTrace(trace => () => core.sync(unsafeTrack).traced(trace));\n/** @internal */\nexports.track = track;\nconst fromEffect = effect => {\n  return new Const(effect);\n};\n/** @internal */\nexports.fromEffect = fromEffect;\nconst none = /*#__PURE__*/fromEffect( /*#__PURE__*/core.unit());\n/** @internal */\nexports.none = none;\nconst fibersIn = /*#__PURE__*/Debug.methodWithTrace(trace => ref => core.sync(() => new FibersIn(ref)).traced(trace));\nexports.fibersIn = fibersIn;\n//# sourceMappingURL=supervisor.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.patch = exports.empty = exports.differ = exports.diff = exports.combine = exports.OP_REMOVE_SUPERVISOR = exports.OP_EMPTY = exports.OP_AND_THEN = exports.OP_ADD_SUPERVISOR = void 0;\nvar Chunk = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Chunk\"));\nvar Differ = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Differ\"));\nvar Equal = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Equal\"));\nvar HashSet = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/HashSet\"));\nvar supervisor = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/supervisor\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/** @internal */\nconst OP_EMPTY = \"Empty\";\n/** @internal */\nexports.OP_EMPTY = OP_EMPTY;\nconst OP_ADD_SUPERVISOR = \"AddSupervisor\";\n/** @internal */\nexports.OP_ADD_SUPERVISOR = OP_ADD_SUPERVISOR;\nconst OP_REMOVE_SUPERVISOR = \"RemoveSupervisor\";\n/** @internal */\nexports.OP_REMOVE_SUPERVISOR = OP_REMOVE_SUPERVISOR;\nconst OP_AND_THEN = \"AndThen\";\n/**\n * The empty `SupervisorPatch`.\n *\n * @internal\n */\nexports.OP_AND_THEN = OP_AND_THEN;\nconst empty = {\n  _tag: OP_EMPTY\n};\n/**\n * Combines two patches to produce a new patch that describes applying the\n * updates from this patch and then the updates from the specified patch.\n *\n * @internal\n */\nexports.empty = empty;\nconst combine = (self, that) => {\n  return {\n    _tag: OP_AND_THEN,\n    first: self,\n    second: that\n  };\n};\n/**\n * Applies a `SupervisorPatch` to a `Supervisor` to produce a new `Supervisor`.\n *\n * @internal\n */\nexports.combine = combine;\nconst patch = (self, supervisor) => {\n  return patchLoop(supervisor, Chunk.of(self));\n};\n/** @internal */\nexports.patch = patch;\nconst patchLoop = (_supervisor, _patches) => {\n  let supervisor = _supervisor;\n  let patches = _patches;\n  while (Chunk.isNonEmpty(patches)) {\n    const head = Chunk.headNonEmpty(patches);\n    switch (head._tag) {\n      case OP_EMPTY:\n        {\n          patches = Chunk.tailNonEmpty(patches);\n          break;\n        }\n      case OP_ADD_SUPERVISOR:\n        {\n          supervisor = supervisor.zip(head.supervisor);\n          patches = Chunk.tailNonEmpty(patches);\n          break;\n        }\n      case OP_REMOVE_SUPERVISOR:\n        {\n          supervisor = removeSupervisor(supervisor, head.supervisor);\n          patches = Chunk.tailNonEmpty(patches);\n          break;\n        }\n      case OP_AND_THEN:\n        {\n          patches = Chunk.prepend(head.first)(Chunk.prepend(head.second)(Chunk.tailNonEmpty(patches)));\n          break;\n        }\n    }\n  }\n  return supervisor;\n};\n/** @internal */\nconst removeSupervisor = (self, that) => {\n  if (Equal.equals(self, that)) {\n    return supervisor.none;\n  } else {\n    if (self instanceof supervisor.Zip) {\n      return removeSupervisor(self.left, that).zip(removeSupervisor(self.right, that));\n    } else {\n      return self;\n    }\n  }\n};\n/** @internal */\nconst toSet = self => {\n  if (Equal.equals(self, supervisor.none)) {\n    return HashSet.empty();\n  } else {\n    if (self instanceof supervisor.Zip) {\n      return HashSet.union(toSet(self.right))(toSet(self.left));\n    } else {\n      return HashSet.make(self);\n    }\n  }\n};\n/** @internal */\nconst diff = (oldValue, newValue) => {\n  if (Equal.equals(oldValue, newValue)) {\n    return empty;\n  }\n  const oldSupervisors = toSet(oldValue);\n  const newSupervisors = toSet(newValue);\n  const added = HashSet.reduce(empty, (patch, supervisor) => combine(patch, {\n    _tag: OP_ADD_SUPERVISOR,\n    supervisor\n  }))(HashSet.difference(oldSupervisors)(newSupervisors));\n  const removed = HashSet.reduce(empty, (patch, supervisor) => combine(patch, {\n    _tag: OP_REMOVE_SUPERVISOR,\n    supervisor\n  }))(HashSet.difference(newSupervisors)(oldSupervisors));\n  return combine(added, removed);\n};\n/** @internal */\nexports.diff = diff;\nconst differ = /*#__PURE__*/Differ.make({\n  empty,\n  patch,\n  combine,\n  diff\n});\nexports.differ = differ;\n//# sourceMappingURL=patch.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.updateSomeEffect = exports.updateEffect = exports.updateAndGetEffect = exports.modifySomeEffect = exports.modifyEffect = exports.modify = exports.getAndUpdateSomeEffect = exports.getAndUpdateEffect = void 0;\nvar Option = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Option\"));\nvar Debug = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Debug\"));\nvar core = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/internal_effect_untraced/core\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/** @internal */\nconst getAndUpdateEffect = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => self.modifyEffect(value => core.map(restore(f)(value), result => [value, result])).traced(trace));\n/** @internal */\nexports.getAndUpdateEffect = getAndUpdateEffect;\nconst getAndUpdateSomeEffect = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, pf) => self.modifyEffect(value => {\n  const result = restore(pf)(value);\n  switch (result._tag) {\n    case \"None\":\n      {\n        return core.succeed([value, value]);\n      }\n    case \"Some\":\n      {\n        return core.map(result.value, newValue => [value, newValue]);\n      }\n  }\n}).traced(trace));\n/** @internal */\nexports.getAndUpdateSomeEffect = getAndUpdateSomeEffect;\nconst modify = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => self.modify(restore(f)).traced(trace));\n/** @internal */\nexports.modify = modify;\nconst modifyEffect = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => self.modifyEffect(restore(f)).traced(trace));\n/** @internal */\nexports.modifyEffect = modifyEffect;\nconst modifySomeEffect = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (self, fallback, pf) => self.modifyEffect(value => Option.getOrElse(() => core.succeed([fallback, value]))(restore(pf)(value))).traced(trace));\n/** @internal */\nexports.modifySomeEffect = modifySomeEffect;\nconst updateEffect = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => self.modifyEffect(value => core.map(restore(f)(value), result => [undefined, result])).traced(trace));\n/** @internal */\nexports.updateEffect = updateEffect;\nconst updateAndGetEffect = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => self.modifyEffect(value => core.map(restore(f)(value), result => [result, result])).traced(trace));\n/** @internal */\nexports.updateAndGetEffect = updateAndGetEffect;\nconst updateSomeEffect = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, pf) => self.modifyEffect(value => {\n  const result = restore(pf)(value);\n  switch (result._tag) {\n    case \"None\":\n      {\n        return core.succeed([void 0, value]);\n      }\n    case \"Some\":\n      {\n        return core.map(result.value, a => [void 0, a]);\n      }\n  }\n}).traced(trace));\nexports.updateSomeEffect = updateSomeEffect;\n//# sourceMappingURL=synchronizedRef.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.match = exports.isMergeDecision = exports.MergeDecisionTypeId = exports.Done = exports.AwaitConst = exports.Await = void 0;\nvar internal = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/stream/internal/channel/mergeDecision\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/**\n * @since 1.0.0\n * @category symbols\n */\nconst MergeDecisionTypeId = internal.MergeDecisionTypeId;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexports.MergeDecisionTypeId = MergeDecisionTypeId;\nconst Done = internal.Done;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexports.Done = Done;\nconst Await = internal.Await;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexports.Await = Await;\nconst AwaitConst = internal.AwaitConst;\n/**\n * Returns `true` if the specified value is a `MergeDecision`, `false`\n * otherwise.\n *\n * @since 1.0.0\n * @category refinements\n */\nexports.AwaitConst = AwaitConst;\nconst isMergeDecision = internal.isMergeDecision;\n/**\n * @since 1.0.0\n * @category folding\n */\nexports.isMergeDecision = isMergeDecision;\nconst match = internal.match;\nexports.match = match;\n//# sourceMappingURL=MergeDecision.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.flattenIterables = exports.flattenExitOption = exports.flattenExit = exports.flattenEffectParUnordered = exports.flattenEffectPar = exports.flattenEffect = exports.flattenChunks = exports.flatten = exports.flatMapParSwitchBuffer = exports.flatMapParSwitch = exports.flatMapParBuffer = exports.flatMapPar = exports.flatMap = exports.findEffect = exports.find = exports.finalizer = exports.filterEffect = exports.filter = exports.failSync = exports.failCauseSync = exports.failCause = exports.fail = exports.execute = exports.ensuring = exports.empty = exports.either = exports.dropWhileEffect = exports.dropWhile = exports.dropUntilEffect = exports.dropUntil = exports.dropRight = exports.drop = exports.drainFork = exports.drain = exports.done = exports.distributedWithDynamic = exports.distributedWith = exports.dieSync = exports.dieMessage = exports.die = exports.debounce = exports.crossWith = exports.crossRight = exports.crossLeft = exports.cross = exports.contramapContext = exports.contextWithStream = exports.contextWithEffect = exports.contextWith = exports.context = exports.concatAll = exports.concat = exports.combineChunks = exports.combine = exports.collectWhileSuccess = exports.collectWhileSome = exports.collectWhileRight = exports.collectWhileLeft = exports.collectWhileEffect = exports.collectWhile = exports.collectSuccess = exports.collectSome = exports.collectRight = exports.collectLeft = exports.collectEffect = exports.collect = exports.chunksWith = exports.chunks = exports.changesWithEffect = exports.changesWith = exports.changes = exports.catchSomeCause = exports.catchSome = exports.catchAllCause = exports.catchAll = exports.bufferUnbounded = exports.bufferSliding = exports.bufferDropping = exports.bufferChunksSliding = exports.bufferChunksDropping = exports.bufferChunks = exports.buffer = exports.broadcastedQueuesDynamic = exports.broadcastedQueues = exports.broadcastDynamic = exports.broadcast = exports.branchAfter = exports.asyncScoped = exports.asyncOption = exports.asyncInterrupt = exports.asyncEffect = exports.async = exports.as = exports.aggregateWithinEither = exports.aggregateWithin = exports.aggregate = exports.acquireRelease = exports.absolve = exports.StreamTypeId = exports.DefaultChunkSize = void 0;\nexports.onDone = exports.never = exports.mkString = exports.mergeWithHaltStrategy = exports.mergeWith = exports.mergeRight = exports.mergeLeft = exports.mergeHaltStrategy = exports.mergeHaltRight = exports.mergeHaltLeft = exports.mergeHaltEither = exports.mergeEither = exports.mergeAllUnbounded = exports.mergeAll = exports.merge = exports.mapErrorCause = exports.mapError = exports.mapEffectParUnordered = exports.mapEffectParByKeyBuffer = exports.mapEffectParByKey = exports.mapEffectPar = exports.mapEffect = exports.mapConcatEffect = exports.mapConcatChunkEffect = exports.mapConcatChunk = exports.mapConcat = exports.mapChunksEffect = exports.mapChunks = exports.mapBoth = exports.mapAccumEffect = exports.mapAccum = exports.map = exports.make = exports.logWarningCauseMessage = exports.logWarningCause = exports.logWarning = exports.logTraceCauseMessage = exports.logTraceCause = exports.logTrace = exports.logInfoCauseMessage = exports.logInfoCause = exports.logInfo = exports.logFatalCauseMessage = exports.logFatalCause = exports.logFatal = exports.logErrorCauseMessage = exports.logErrorCause = exports.logError = exports.logDebugCauseMessage = exports.logDebugCause = exports.logDebug = exports.log = exports.iterate = exports.intersperseAffixes = exports.intersperse = exports.interruptWhenDeferred = exports.interruptWhen = exports.interruptAfter = exports.interleaveWith = exports.interleave = exports.identity = exports.haltWhenDeferred = exports.haltWhen = exports.haltAfter = exports.groupedWithin = exports.grouped = exports.groupByKeyBuffer = exports.groupByKey = exports.groupByBuffer = exports.groupBy = exports.groupAdjacentBy = exports.fromSchedule = exports.fromQueueWithShutdown = exports.fromQueue = exports.fromPull = exports.fromIteratorSucceed = exports.fromIterableEffect = exports.fromIterable = exports.fromHubWithShutdown = exports.fromHubScopedWithShutdown = exports.fromHubScoped = exports.fromHub = exports.fromEffectOption = exports.fromEffect = exports.fromChunks = exports.fromChunkQueueWithShutdown = exports.fromChunkQueue = exports.fromChunkHubWithShutdown = exports.fromChunkHubScopedWithShutdown = exports.fromChunkHubScoped = exports.fromChunkHub = exports.fromChunk = exports.fromChannel = exports.fromAsyncIterable = exports.forever = exports.flattenTake = exports.flattenParUnboundedBuffer = exports.flattenParUnbounded = exports.flattenParBuffer = exports.flattenPar = void 0;\nexports.takeRight = exports.take = exports.sync = exports.suspend = exports.succeed = exports.splitOnChunk = exports.split = exports.someOrFail = exports.someOrElse = exports.some = exports.slidingSize = exports.sliding = exports.serviceWithStream = exports.serviceWithEffect = exports.serviceWith = exports.service = exports.scoped = exports.scheduleWith = exports.scheduleEither = exports.schedule = exports.scanReduceEffect = exports.scanReduce = exports.scanEffect = exports.scan = exports.runSum = exports.runScoped = exports.runLast = exports.runIntoQueueScoped = exports.runIntoQueueElementsScoped = exports.runIntoQueue = exports.runIntoHubScoped = exports.runIntoHub = exports.runHead = exports.runForEachWhileScoped = exports.runForEachWhile = exports.runForEachScoped = exports.runForEachChunkScoped = exports.runForEachChunk = exports.runForEach = exports.runFoldWhileScopedEffect = exports.runFoldWhileScoped = exports.runFoldWhileEffect = exports.runFoldWhile = exports.runFoldScopedEffect = exports.runFoldScoped = exports.runFoldEffect = exports.runFold = exports.runDrain = exports.runCount = exports.runCollect = exports.run = exports.rightOrFail = exports.right = exports.retry = exports.repeatWith = exports.repeatValue = exports.repeatElementsWith = exports.repeatElementsEither = exports.repeatElements = exports.repeatEither = exports.repeatEffectWithSchedule = exports.repeatEffectOption = exports.repeatEffectChunkOption = exports.repeatEffectChunk = exports.repeatEffect = exports.repeat = exports.refineOrDieWith = exports.refineOrDie = exports.rechunk = exports.range = exports.provideSomeLayer = exports.provideServiceStream = exports.provideServiceEffect = exports.provideService = exports.provideLayer = exports.provideContext = exports.prepend = exports.pipeThroughChannelOrFail = exports.pipeThroughChannel = exports.pipeThrough = exports.peel = exports.partitionEitherBuffer = exports.partitionEither = exports.partitionBuffer = exports.partition = exports.paginateEffect = exports.paginateChunkEffect = exports.paginateChunk = exports.paginate = exports.orElseSucceed = exports.orElseOptional = exports.orElseIfEmptyStream = exports.orElseIfEmptyChunk = exports.orElseIfEmpty = exports.orElseFail = exports.orElseEither = exports.orElse = exports.orDieWith = exports.orDie = exports.onError = void 0;\nexports.zipWithPreviousAndNext = exports.zipWithPrevious = exports.zipWithNext = exports.zipWithIndex = exports.zipWithChunks = exports.zipWith = exports.zipRight = exports.zipLeft = exports.zipLatestWith = exports.zipLatest = exports.zipFlatten = exports.zipAllWith = exports.zipAllSortedByKeyWith = exports.zipAllSortedByKeyRight = exports.zipAllSortedByKeyLeft = exports.zipAllSortedByKey = exports.zipAllRight = exports.zipAllLeft = exports.zipAll = exports.zip = exports.whenEffect = exports.whenCaseEffect = exports.whenCase = exports.when = exports.updateService = exports.unwrapScoped = exports.unwrap = exports.unit = exports.unfoldEffect = exports.unfoldChunkEffect = exports.unfoldChunk = exports.unfold = exports.transduce = exports.toQueueUnbounded = exports.toQueueSlidingCapacity = exports.toQueueSliding = exports.toQueueOfElementsCapacity = exports.toQueueOfElements = exports.toQueueDroppingCapacity = exports.toQueueDropping = exports.toQueueCapacity = exports.toQueue = exports.toPull = exports.toHub = exports.toChannel = exports.timeoutTo = exports.timeoutFailCause = exports.timeoutFail = exports.timeout = exports.tick = exports.throttleShapeEffectBurst = exports.throttleShapeEffect = exports.throttleShapeBurst = exports.throttleShape = exports.throttleEnforceEffectBurst = exports.throttleEnforceEffect = exports.throttleEnforceBurst = exports.throttleEnforce = exports.tapSink = exports.tapErrorCause = exports.tapError = exports.tap = exports.takeWhile = exports.takeUntilEffect = exports.takeUntil = void 0;\nvar _groupBy = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/stream/internal/groupBy\"));\nvar internal = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/stream/internal/stream\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/**\n * @since 1.0.0\n * @category symbols\n */\nconst StreamTypeId = internal.StreamTypeId;\n/**\n * The default chunk size used by the various combinators and constructors of\n * `Stream`.\n *\n * @since 1.0.0\n * @category constants\n */\nexports.StreamTypeId = StreamTypeId;\nconst DefaultChunkSize = internal.DefaultChunkSize;\n/**\n * Submerges the error case of an `Either` into the `Stream`.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.DefaultChunkSize = DefaultChunkSize;\nconst absolve = internal.absolve;\n/**\n * Creates a stream from a single value that will get cleaned up after the\n * stream is consumed.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.absolve = absolve;\nconst acquireRelease = internal.acquireRelease;\n/**\n * Aggregates elements of this stream using the provided sink for as long as\n * the downstream operators on the stream are busy.\n *\n * This operator divides the stream into two asynchronous \"islands\". Operators\n * upstream of this operator run on one fiber, while downstream operators run\n * on another. Whenever the downstream fiber is busy processing elements, the\n * upstream fiber will feed elements into the sink until it signals\n * completion.\n *\n * Any sink can be used here, but see `Sink.foldWeightedEffect` and\n * `Sink.foldUntilEffect` for sinks that cover the common usecases.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.acquireRelease = acquireRelease;\nconst aggregate = internal.aggregate;\n/**\n * Like `aggregateWithinEither`, but only returns the `Right` results.\n *\n * @param sink A `Sink` used to perform the aggregation.\n * @param schedule A `Schedule` used to signal when to stop the aggregation.\n * @since 1.0.0\n * @category utils\n */\nexports.aggregate = aggregate;\nconst aggregateWithin = internal.aggregateWithin;\n/**\n * Aggregates elements using the provided sink until it completes, or until\n * the delay signalled by the schedule has passed.\n *\n * This operator divides the stream into two asynchronous islands. Operators\n * upstream of this operator run on one fiber, while downstream operators run\n * on another. Elements will be aggregated by the sink until the downstream\n * fiber pulls the aggregated value, or until the schedule's delay has passed.\n *\n * Aggregated elements will be fed into the schedule to determine the delays\n * between pulls.\n *\n * @param sink A `Sink` used to perform the aggregation.\n * @param schedule A `Schedule` used to signal when to stop the aggregation.\n * @since 1.0.0\n * @category utils\n */\nexports.aggregateWithin = aggregateWithin;\nconst aggregateWithinEither = internal.aggregateWithinEither;\n/**\n * Maps the success values of this stream to the specified constant value.\n *\n * @since 1.0.0\n * @category mapping\n */\nexports.aggregateWithinEither = aggregateWithinEither;\nconst as = internal.as;\nexports.as = as;\nconst _async = internal._async;\nexports.async = _async;\n/**\n * Creates a stream from an asynchronous callback that can be called multiple\n * times The registration of the callback itself returns an effect. The\n * optionality of the error type `E` can be used to signal the end of the\n * stream, by setting it to `None`.\n *\n * @since 1.0.0\n * @category constructors\n */\nconst asyncEffect = internal.asyncEffect;\n/**\n * Creates a stream from an asynchronous callback that can be called multiple\n * times. The registration of the callback returns either a canceler or\n * synchronously returns a stream. The optionality of the error type `E` can\n * be used to signal the end of the stream, by setting it to `None`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.asyncEffect = asyncEffect;\nconst asyncInterrupt = internal.asyncInterrupt;\n/**\n * Creates a stream from an asynchronous callback that can be called multiple\n * times. The registration of the callback can possibly return the stream\n * synchronously. The optionality of the error type `E` can be used to signal\n * the end of the stream, by setting it to `None`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.asyncInterrupt = asyncInterrupt;\nconst asyncOption = internal.asyncOption;\n/**\n * Creates a stream from an asynchronous callback that can be called multiple\n * times. The registration of the callback itself returns an a scoped\n * resource. The optionality of the error type `E` can be used to signal the\n * end of the stream, by setting it to `None`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.asyncOption = asyncOption;\nconst asyncScoped = internal.asyncScoped;\n/**\n * Returns a `Stream` that first collects `n` elements from the input `Stream`,\n * and then creates a new `Stream` using the specified function, and sends all\n * the following elements through that.\n *\n * @since 1.0.0\n * @category sequencing\n */\nexports.asyncScoped = asyncScoped;\nconst branchAfter = internal.branchAfter;\n/**\n * Fan out the stream, producing a list of streams that have the same elements\n * as this stream. The driver stream will only ever advance the `maximumLag`\n * chunks before the slowest downstream stream.\n *\n * @macro traced\n * @since 1.0.0\n * @category utils\n */\nexports.branchAfter = branchAfter;\nconst broadcast = internal.broadcast;\n/**\n * Fan out the stream, producing a dynamic number of streams that have the\n * same elements as this stream. The driver stream will only ever advance the\n * `maximumLag` chunks before the slowest downstream stream.\n *\n * @macro traced\n * @since 1.0.0\n * @category utils\n */\nexports.broadcast = broadcast;\nconst broadcastDynamic = internal.broadcastDynamic;\n/**\n * Converts the stream to a scoped list of queues. Every value will be\n * replicated to every queue with the slowest queue being allowed to buffer\n * `maximumLag` chunks before the driver is back pressured.\n *\n * Queues can unsubscribe from upstream by shutting down.\n *\n * @macro traced\n * @since 1.0.0\n * @category utils\n */\nexports.broadcastDynamic = broadcastDynamic;\nconst broadcastedQueues = internal.broadcastedQueues;\n/**\n * Converts the stream to a scoped dynamic amount of queues. Every chunk will\n * be replicated to every queue with the slowest queue being allowed to buffer\n * `maximumLag` chunks before the driver is back pressured.\n *\n * Queues can unsubscribe from upstream by shutting down.\n *\n * @macro traced\n * @since 1.0.0\n * @category utils\n */\nexports.broadcastedQueues = broadcastedQueues;\nconst broadcastedQueuesDynamic = internal.broadcastedQueuesDynamic;\n/**\n * Allows a faster producer to progress independently of a slower consumer by\n * buffering up to `capacity` elements in a queue.\n *\n * @note This combinator destroys the chunking structure. It's recommended to\n *       use rechunk afterwards. Additionally, prefer capacities that are powers\n *       of 2 for better performance.\n * @since 1.0.0\n * @category utils\n */\nexports.broadcastedQueuesDynamic = broadcastedQueuesDynamic;\nconst buffer = internal.buffer;\n/**\n * Allows a faster producer to progress independently of a slower consumer by\n * buffering up to `capacity` chunks in a queue.\n *\n * @note Prefer capacities that are powers of 2 for better performance.\n * @since 1.0.0\n * @category utils\n */\nexports.buffer = buffer;\nconst bufferChunks = internal.bufferChunks;\n/**\n * Allows a faster producer to progress independently of a slower consumer by\n * buffering up to `capacity` chunks in a dropping queue.\n *\n * @note Prefer capacities that are powers of 2 for better performance.\n * @since 1.0.0\n * @category utils\n */\nexports.bufferChunks = bufferChunks;\nconst bufferChunksDropping = internal.bufferChunksDropping;\n/**\n * Allows a faster producer to progress independently of a slower consumer by\n * buffering up to `capacity` chunks in a sliding queue.\n *\n * @note Prefer capacities that are powers of 2 for better performance.\n * @since 1.0.0\n * @category utils\n */\nexports.bufferChunksDropping = bufferChunksDropping;\nconst bufferChunksSliding = internal.bufferChunksSliding;\n/**\n * Allows a faster producer to progress independently of a slower consumer by\n * buffering up to `capacity` elements in a dropping queue.\n *\n * @note This combinator destroys the chunking structure. It's recommended to\n *       use rechunk afterwards. Additionally, Prefer capacities that are\n *       powers of 2 for better performance.\n * @since 1.0.0\n * @category utils\n */\nexports.bufferChunksSliding = bufferChunksSliding;\nconst bufferDropping = internal.bufferDropping;\n/**\n * Allows a faster producer to progress independently of a slower consumer by\n * buffering up to `capacity` elements in a sliding queue.\n *\n * @note This combinator destroys the chunking structure. It's recommended to\n *       use rechunk afterwards. Additionally, Prefer capacities that are\n *       powers of 2 for better performance.\n * @since 1.0.0\n * @category utils\n */\nexports.bufferDropping = bufferDropping;\nconst bufferSliding = internal.bufferSliding;\n/**\n * Allows a faster producer to progress independently of a slower consumer by\n * buffering chunks into an unbounded queue.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.bufferSliding = bufferSliding;\nconst bufferUnbounded = internal.bufferUnbounded;\n/**\n * Switches over to the stream produced by the provided function in case this\n * one fails with a typed error.\n *\n * @since 1.0.0\n * @category error handling\n */\nexports.bufferUnbounded = bufferUnbounded;\nconst catchAll = internal.catchAll;\n/**\n * Switches over to the stream produced by the provided function in case this\n * one fails. Allows recovery from all causes of failure, including\n * interruption if the stream is uninterruptible.\n *\n * @since 1.0.0\n * @category error handling\n */\nexports.catchAll = catchAll;\nconst catchAllCause = internal.catchAllCause;\n/**\n * Switches over to the stream produced by the provided function in case this\n * one fails with some typed error.\n *\n * @since 1.0.0\n * @category error handling\n */\nexports.catchAllCause = catchAllCause;\nconst catchSome = internal.catchSome;\n/**\n * Switches over to the stream produced by the provided function in case this\n * one fails with some errors. Allows recovery from all causes of failure,\n * including interruption if the stream is uninterruptible.\n *\n * @since 1.0.0\n * @category error handling\n */\nexports.catchSome = catchSome;\nconst catchSomeCause = internal.catchSomeCause;\n/**\n * Returns a new stream that only emits elements that are not equal to the\n * previous element emitted, using natural equality to determine whether two\n * elements are equal.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.catchSomeCause = catchSomeCause;\nconst changes = internal.changes;\n/**\n * Returns a new stream that only emits elements that are not equal to the\n * previous element emitted, using the specified function to determine whether\n * two elements are equal.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.changes = changes;\nconst changesWith = internal.changesWith;\n/**\n * Returns a new stream that only emits elements that are not equal to the\n * previous element emitted, using the specified effectual function to\n * determine whether two elements are equal.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.changesWith = changesWith;\nconst changesWithEffect = internal.changesWithEffect;\n/**\n * Exposes the underlying chunks of the stream as a stream of chunks of\n * elements.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.changesWithEffect = changesWithEffect;\nconst chunks = internal.chunks;\n/**\n * Performs the specified stream transformation with the chunk structure of\n * the stream exposed.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.chunks = chunks;\nconst chunksWith = internal.chunksWith;\n/**\n * Performs a filter and map in a single step.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.chunksWith = chunksWith;\nconst collect = internal.collect;\n/**\n * Performs an effectful filter and map in a single step.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.collect = collect;\nconst collectEffect = internal.collectEffect;\n/**\n * Filters any `Right` values.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.collectEffect = collectEffect;\nconst collectLeft = internal.collectLeft;\n/**\n * Filters any `Left` values.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.collectLeft = collectLeft;\nconst collectRight = internal.collectRight;\n/**\n * Filters any 'None' values.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.collectRight = collectRight;\nconst collectSome = internal.collectSome;\n/**\n * Filters any `Exit.Failure` values.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.collectSome = collectSome;\nconst collectSuccess = internal.collectSuccess;\n/**\n * Transforms all elements of the stream for as long as the specified partial\n * function is defined.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.collectSuccess = collectSuccess;\nconst collectWhile = internal.collectWhile;\n/**\n * Terminates the stream when encountering the first `Right`.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.collectWhile = collectWhile;\nconst collectWhileLeft = internal.collectWhileLeft;\n/**\n * Terminates the stream when encountering the first `None`.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.collectWhileLeft = collectWhileLeft;\nconst collectWhileSome = internal.collectWhileSome;\n/**\n * Terminates the stream when encountering the first `Left`.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.collectWhileSome = collectWhileSome;\nconst collectWhileRight = internal.collectWhileRight;\n/**\n * Terminates the stream when encountering the first `Exit.Failure`.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.collectWhileRight = collectWhileRight;\nconst collectWhileSuccess = internal.collectWhileSuccess;\n/**\n * Effectfully transforms all elements of the stream for as long as the\n * specified partial function is defined.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.collectWhileSuccess = collectWhileSuccess;\nconst collectWhileEffect = internal.collectWhileEffect;\n/**\n * Combines the elements from this stream and the specified stream by\n * repeatedly applying the function `f` to extract an element using both sides\n * and conceptually \"offer\" it to the destination stream. `f` can maintain\n * some internal state to control the combining process, with the initial\n * state being specified by `s`.\n *\n * Where possible, prefer `Stream.combineChunks` for a more efficient\n * implementation.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.collectWhileEffect = collectWhileEffect;\nconst combine = internal.combine;\n/**\n * Combines the chunks from this stream and the specified stream by repeatedly\n * applying the function `f` to extract a chunk using both sides and\n * conceptually \"offer\" it to the destination stream. `f` can maintain some\n * internal state to control the combining process, with the initial state\n * being specified by `s`.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.combine = combine;\nconst combineChunks = internal.combineChunks;\n/**\n * Concatenates the specified stream with this stream, resulting in a stream\n * that emits the elements from this stream and then the elements from the\n * specified stream.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.combineChunks = combineChunks;\nconst concat = internal.concat;\n/**\n * Concatenates all of the streams in the chunk to one stream.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.concat = concat;\nconst concatAll = internal.concatAll;\n/**\n * Composes this stream with the specified stream to create a cartesian\n * product of elements. The `that` stream would be run multiple times, for\n * every element in the `this` stream.\n *\n * See also `Stream.zip` for the more common point-wise variant.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.concatAll = concatAll;\nconst cross = internal.cross;\n/**\n * Composes this stream with the specified stream to create a cartesian\n * product of elements, but keeps only elements from this stream. The `that`\n * stream would be run multiple times, for every element in the `this` stream.\n *\n * See also `Stream.zipLeft` for the more common point-wise variant.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.cross = cross;\nconst crossLeft = internal.crossLeft;\n/**\n * Composes this stream with the specified stream to create a cartesian\n * product of elements, but keeps only elements from the other stream. The\n * `that` stream would be run multiple times, for every element in the `this`\n * stream.\n *\n * See also `Stream.zipRight` for the more common point-wise variant.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.crossLeft = crossLeft;\nconst crossRight = internal.crossRight;\n/**\n * Composes this stream with the specified stream to create a cartesian\n * product of elements with a specified function. The `that` stream would be\n * run multiple times, for every element in the `this` stream.\n *\n * See also `Stream.zipWith` for the more common point-wise variant.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.crossRight = crossRight;\nconst crossWith = internal.crossWith;\n/**\n * Delays the emission of values by holding new values for a set duration. If\n * no new values arrive during that time the value is emitted, however if a\n * new value is received during the holding period the previous value is\n * discarded and the process is repeated with the new value.\n *\n * This operator is useful if you have a stream of \"bursty\" events which\n * eventually settle down and you only need the final event of the burst. For\n * example, a search engine may only want to initiate a search after a user\n * has paused typing so as to not prematurely recommend results.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.crossWith = crossWith;\nconst debounce = internal.debounce;\n/**\n * The stream that dies with the specified defect.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.debounce = debounce;\nconst die = internal.die;\n/**\n * The stream that dies with the specified lazily evaluated defect.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.die = die;\nconst dieSync = internal.dieSync;\n/**\n * The stream that dies with an exception described by `message`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.dieSync = dieSync;\nconst dieMessage = internal.dieMessage;\n/**\n * More powerful version of `Stream.broadcast`. Allows to provide a function\n * that determines what queues should receive which elements. The decide\n * function will receive the indices of the queues in the resulting list.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.dieMessage = dieMessage;\nconst distributedWith = internal.distributedWith;\n/**\n * More powerful version of `Stream.distributedWith`. This returns a function\n * that will produce new queues and corresponding indices. You can also\n * provide a function that will be executed after the final events are\n * enqueued in all queues. Shutdown of the queues is handled by the driver.\n * Downstream users can also shutdown queues manually. In this case the driver\n * will continue but no longer backpressure on them.\n *\n * @macro traced\n * @since 1.0.0\n * @category utils\n */\nexports.distributedWith = distributedWith;\nconst distributedWithDynamic = internal.distributedWithDynamic;\n/**\n * The stream that ends with the specified `Exit` value.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.distributedWithDynamic = distributedWithDynamic;\nconst done = internal.done;\n/**\n * Converts this stream to a stream that executes its effects but emits no\n * elements. Useful for sequencing effects using streams:\n *\n * @since 1.0.0\n * @category utils\n */\nexports.done = done;\nconst drain = internal.drain;\n/**\n * Drains the provided stream in the background for as long as this stream is\n * running. If this stream ends before `other`, `other` will be interrupted.\n * If `other` fails, this stream will fail with that error.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.drain = drain;\nconst drainFork = internal.drainFork;\n/**\n * Drops the specified number of elements from this stream.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.drainFork = drainFork;\nconst drop = internal.drop;\n/**\n * Drops the last specified number of elements from this stream.\n *\n * @note This combinator keeps `n` elements in memory. Be careful with big\n *       numbers.\n * @since 1.0.0\n * @category utils\n */\nexports.drop = drop;\nconst dropRight = internal.dropRight;\n/**\n * Drops all elements of the stream until the specified predicate evaluates to\n * `true`.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.dropRight = dropRight;\nconst dropUntil = internal.dropUntil;\n/**\n * Drops all elements of the stream until the specified effectful predicate\n * evaluates to `true`.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.dropUntil = dropUntil;\nconst dropUntilEffect = internal.dropUntilEffect;\n/**\n * Drops all elements of the stream for as long as the specified predicate\n * evaluates to `true`.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.dropUntilEffect = dropUntilEffect;\nconst dropWhile = internal.dropWhile;\n/**\n * Drops all elements of the stream for as long as the specified predicate\n * produces an effect that evalutates to `true`\n *\n * @since 1.0.0\n * @category utils\n */\nexports.dropWhile = dropWhile;\nconst dropWhileEffect = internal.dropWhileEffect;\n/**\n * Returns a stream whose failures and successes have been lifted into an\n * `Either`. The resulting stream cannot fail, because the failures have been\n * exposed as part of the `Either` success case.\n *\n * @note The stream will end as soon as the first error occurs.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.dropWhileEffect = dropWhileEffect;\nconst either = internal.either;\n/**\n * The empty stream.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.either = either;\nconst empty = internal.empty;\n/**\n * Executes the provided finalizer after this stream's finalizers run.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.empty = empty;\nconst ensuring = internal.ensuring;\n/**\n * Accesses the whole context of the stream.\n *\n * @since 1.0.0\n * @category context\n */\nexports.ensuring = ensuring;\nconst context = internal.context;\n/**\n * Accesses the context of the stream.\n *\n * @since 1.0.0\n * @category context\n */\nexports.context = context;\nconst contextWith = internal.contextWith;\n/**\n * Accesses the context of the stream in the context of an effect.\n *\n * @since 1.0.0\n * @category context\n */\nexports.contextWith = contextWith;\nconst contextWithEffect = internal.contextWithEffect;\n/**\n * Accesses the context of the stream in the context of a stream.\n *\n * @since 1.0.0\n * @category context\n */\nexports.contextWithEffect = contextWithEffect;\nconst contextWithStream = internal.contextWithStream;\n/**\n * Creates a stream that executes the specified effect but emits no elements.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.contextWithStream = contextWithStream;\nconst execute = internal.execute;\n/**\n * Terminates with the specified error.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.execute = execute;\nconst fail = internal.fail;\n/**\n * Terminates with the specified lazily evaluated error.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.fail = fail;\nconst failSync = internal.failSync;\n/**\n * The stream that always fails with the specified `Cause`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.failSync = failSync;\nconst failCause = internal.failCause;\n/**\n * The stream that always fails with the specified lazily evaluated `Cause`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.failCause = failCause;\nconst failCauseSync = internal.failCauseSync;\n/**\n * Filters the elements emitted by this stream using the provided function.\n *\n * @since 1.0.0\n * @category filtering\n */\nexports.failCauseSync = failCauseSync;\nconst filter = internal.filter;\n/**\n * Effectfully filters the elements emitted by this stream.\n *\n * @since 1.0.0\n * @category filtering\n */\nexports.filter = filter;\nconst filterEffect = internal.filterEffect;\n/**\n * Creates a one-element stream that never fails and executes the finalizer\n * when it ends.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.filterEffect = filterEffect;\nconst finalizer = internal.finalizer;\n/**\n * Finds the first element emitted by this stream that satisfies the provided\n * predicate.\n *\n * @since 1.0.0\n * @category elements\n */\nexports.finalizer = finalizer;\nconst find = internal.find;\n/**\n * Finds the first element emitted by this stream that satisfies the provided\n * effectful predicate.\n *\n * @since 1.0.0\n * @category elements\n */\nexports.find = find;\nconst findEffect = internal.findEffect;\n/**\n * Returns a stream made of the concatenation in strict order of all the\n * streams produced by passing each element of this stream to `f0`\n *\n * @since 1.0.0\n * @category sequencing\n */\nexports.findEffect = findEffect;\nconst flatMap = internal.flatMap;\n/**\n * Maps each element of this stream to another stream and returns the\n * non-deterministic merge of those streams, executing up to `n` inner streams\n * concurrently. Up to `bufferSize` elements of the produced streams may be\n * buffered in memory by this operator.\n *\n * @since 1.0.0\n * @category sequencing\n */\nexports.flatMap = flatMap;\nconst flatMapPar = internal.flatMapPar;\n/**\n * Like `flatMapPar`, but with a configurable `bufferSize` parameter.\n *\n * @since 1.0.0\n * @category sequencing\n */\nexports.flatMapPar = flatMapPar;\nconst flatMapParBuffer = internal.flatMapParBuffer;\n/**\n * Maps each element of this stream to another stream and returns the\n * non-deterministic merge of those streams, executing up to `n` inner streams\n * concurrently. When a new stream is created from an element of the source\n * stream, the oldest executing stream is cancelled. Up to `bufferSize`\n * elements of the produced streams may be buffered in memory by this\n * operator.\n *\n * @since 1.0.0\n * @category sequencing\n */\nexports.flatMapParBuffer = flatMapParBuffer;\nconst flatMapParSwitch = internal.flatMapParSwitch;\n/**\n * Like `flatMapParSwitch`, but with a configurable `bufferSize` parameter.\n *\n * @since 1.0.0\n * @category sequencing\n */\nexports.flatMapParSwitch = flatMapParSwitch;\nconst flatMapParSwitchBuffer = internal.flatMapParSwitchBuffer;\n/**\n * Flattens this stream-of-streams into a stream made of the concatenation in\n * strict order of all the streams.\n *\n * @since 1.0.0\n * @category sequencing\n */\nexports.flatMapParSwitchBuffer = flatMapParSwitchBuffer;\nconst flatten = internal.flatten;\n/**\n * Submerges the chunks carried by this stream into the stream's structure,\n * while still preserving them.\n *\n * @since 1.0.0\n * @category sequencing\n */\nexports.flatten = flatten;\nconst flattenChunks = internal.flattenChunks;\n/**\n * Flattens `Effect` values into the stream's structure, preserving all\n * information about the effect.\n *\n * @since 1.0.0\n * @category sequencing\n */\nexports.flattenChunks = flattenChunks;\nconst flattenEffect = internal.flattenEffect;\n/**\n * Flattens `Effect` values into the stream's structure, preserving all\n * information about the effect.\n *\n * @since 1.0.0\n * @category sequencing\n */\nexports.flattenEffect = flattenEffect;\nconst flattenEffectPar = internal.flattenEffectPar;\n/**\n * Flattens `Effect` values into the stream's structure, preserving all\n * information about the effect. The element order is\n * not enforced by this combinator, and elements may be reordered.\n *\n * @since 1.0.0\n * @category sequencing\n */\nexports.flattenEffectPar = flattenEffectPar;\nconst flattenEffectParUnordered = internal.flattenEffectParUnordered;\n/**\n * Flattens `Exit` values. `Exit.Failure` values translate to stream\n * failures while `Exit.Success` values translate to stream elements.\n *\n * @since 1.0.0\n * @category sequencing\n */\nexports.flattenEffectParUnordered = flattenEffectParUnordered;\nconst flattenExit = internal.flattenExit;\n/**\n * Unwraps `Exit` values that also signify end-of-stream by failing with `None`.\n *\n * For `Exit` values that do not signal end-of-stream, prefer:\n *\n * ```ts\n * stream.mapZIO(ZIO.done(_))\n * ```\n *\n * @since 1.0.0\n * @category sequencing\n */\nexports.flattenExit = flattenExit;\nconst flattenExitOption = internal.flattenExitOption;\n/**\n * Submerges the iterables carried by this stream into the stream's structure,\n * while still preserving them.\n *\n * @since 1.0.0\n * @category sequencing\n */\nexports.flattenExitOption = flattenExitOption;\nconst flattenIterables = internal.flattenIterables;\n/**\n * Flattens a stream of streams into a stream by executing a non-deterministic\n * concurrent merge. Up to `n` streams may be consumed in parallel and up to\n * `outputBuffer` elements may be buffered by this operator.\n *\n * @since 1.0.0\n * @category sequencing\n */\nexports.flattenIterables = flattenIterables;\nconst flattenPar = internal.flattenPar;\n/**\n * Like `flattenPar`, but with a configurable `bufferSize` parameter.\n *\n * @since 1.0.0\n * @category sequencing\n */\nexports.flattenPar = flattenPar;\nconst flattenParBuffer = internal.flattenParBuffer;\n/**\n * Like `Stream.flattenPar`, but executes all streams concurrently.\n *\n * @since 1.0.0\n * @category sequencing\n */\nexports.flattenParBuffer = flattenParBuffer;\nconst flattenParUnbounded = internal.flattenParUnbounded;\n/**\n * Like `Stream.flattenParUnbounded`, but with `bufferSize` parameter.\n *\n * @since 1.0.0\n * @category sequencing\n */\nexports.flattenParUnbounded = flattenParUnbounded;\nconst flattenParUnboundedBuffer = internal.flattenParUnboundedBuffer;\n/**\n * Unwraps `Exit` values and flatten chunks that also signify end-of-stream\n * by failing with `None`.\n *\n * @since 1.0.0\n * @category sequencing\n */\nexports.flattenParUnboundedBuffer = flattenParUnboundedBuffer;\nconst flattenTake = internal.flattenTake;\n/**\n * Repeats this stream forever.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.flattenTake = flattenTake;\nconst forever = internal.forever;\n/**\n * Creates a stream from an `AsyncIterable`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.forever = forever;\nconst fromAsyncIterable = internal.fromAsyncIterable;\n/**\n * Creates a stream from a `Channel`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.fromAsyncIterable = fromAsyncIterable;\nconst fromChannel = internal.fromChannel;\n/**\n * Creates a channel from a `Stream`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.fromChannel = fromChannel;\nconst toChannel = internal.toChannel;\n/**\n * Creates a stream from a `Chunk` of values.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.toChannel = toChannel;\nconst fromChunk = internal.fromChunk;\n/**\n * Creates a stream from a subscription to a `Hub`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.fromChunk = fromChunk;\nconst fromChunkHub = internal.fromChunkHub;\n/**\n * Creates a stream from a subscription to a `Hub` in the context of a scoped\n * effect. The scoped effect describes subscribing to receive messages from\n * the hub while the stream describes taking messages from the hub.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.fromChunkHub = fromChunkHub;\nconst fromChunkHubScoped = internal.fromChunkHubScoped;\n/**\n * Creates a stream from a subscription to a `Hub`.\n *\n * The hub will be shut down once the stream is closed.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.fromChunkHubScoped = fromChunkHubScoped;\nconst fromChunkHubWithShutdown = internal.fromChunkHubWithShutdown;\n/**\n * Creates a stream from a subscription to a `Hub` in the context of a scoped\n * effect. The scoped effect describes subscribing to receive messages from\n * the hub while the stream describes taking messages from the hub.\n *\n * The hub will be shut down once the stream is closed.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.fromChunkHubWithShutdown = fromChunkHubWithShutdown;\nconst fromChunkHubScopedWithShutdown = internal.fromChunkHubScopedWithShutdown;\n/**\n * Creates a stream from a `Queue` of values.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.fromChunkHubScopedWithShutdown = fromChunkHubScopedWithShutdown;\nconst fromChunkQueue = internal.fromChunkQueue;\n/**\n * Creates a stream from a `Queue` of values.\n *\n * The queue will be shutdown once the stream is closed.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.fromChunkQueue = fromChunkQueue;\nconst fromChunkQueueWithShutdown = internal.fromChunkQueueWithShutdown;\n/**\n * Creates a stream from an arbitrary number of chunks.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.fromChunkQueueWithShutdown = fromChunkQueueWithShutdown;\nconst fromChunks = internal.fromChunks;\n/**\n * Either emits the success value of this effect or terminates the stream\n * with the failure value of this effect.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.fromChunks = fromChunks;\nconst fromEffect = internal.fromEffect;\n/**\n * Creates a stream from an effect producing a value of type `A` or an empty\n * `Stream`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.fromEffect = fromEffect;\nconst fromEffectOption = internal.fromEffectOption;\n/**\n * Creates a stream from a subscription to a `Hub`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.fromEffectOption = fromEffectOption;\nconst fromHub = internal.fromHub;\n/**\n * Creates a stream from a subscription to a `Hub` in the context of a scoped\n * effect. The scoped effect describes subscribing to receive messages from\n * the hub while the stream describes taking messages from the hub.\n *\n * @macro traced\n * @since 1.0.0\n * @category constructors\n */\nexports.fromHub = fromHub;\nconst fromHubScoped = internal.fromHubScoped;\n/**\n * Creates a stream from a subscription to a `Hub`.\n *\n * The hub will be shut down once the stream is closed.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.fromHubScoped = fromHubScoped;\nconst fromHubWithShutdown = internal.fromHubWithShutdown;\n/**\n * Creates a stream from a subscription to a `Hub` in the context of a scoped\n * effect. The scoped effect describes subscribing to receive messages from\n * the hub while the stream describes taking messages from the hub.\n *\n * The hub will be shut down once the stream is closed.\n *\n * @macro traced\n * @since 1.0.0\n * @category constructors\n */\nexports.fromHubWithShutdown = fromHubWithShutdown;\nconst fromHubScopedWithShutdown = internal.fromHubScopedWithShutdown;\n/**\n * Creates a stream from an `Iterable` collection of values.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.fromHubScopedWithShutdown = fromHubScopedWithShutdown;\nconst fromIterable = internal.fromIterable;\n/**\n * Creates a stream from an effect producing a value of type `Iterable<A>`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.fromIterable = fromIterable;\nconst fromIterableEffect = internal.fromIterableEffect;\n/**\n * Creates a stream from an iterator\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.fromIterableEffect = fromIterableEffect;\nconst fromIteratorSucceed = internal.fromIteratorSucceed;\n/**\n * Creates a stream from an effect that pulls elements from another stream.\n *\n * See `Stream.toPull` for reference.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.fromIteratorSucceed = fromIteratorSucceed;\nconst fromPull = internal.fromPull;\n/**\n * Creates a stream from a queue of values\n *\n * @param maxChunkSize The maximum number of queued elements to put in one chunk in the stream\n * @since 1.0.0\n * @category constructors\n */\nexports.fromPull = fromPull;\nconst fromQueue = internal.fromQueue;\n/**\n * Creates a stream from a queue of values. The queue will be shutdown once\n * the stream is closed.\n *\n * @param maxChunkSize The maximum number of queued elements to put in one chunk in the stream\n * @since 1.0.0\n * @category constructors\n */\nexports.fromQueue = fromQueue;\nconst fromQueueWithShutdown = internal.fromQueueWithShutdown;\n/**\n * Creates a stream from a `Schedule` that does not require any further\n * input. The stream will emit an element for each value output from the\n * schedule, continuing for as long as the schedule continues.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.fromQueueWithShutdown = fromQueueWithShutdown;\nconst fromSchedule = internal.fromSchedule;\n/**\n * Creates a pipeline that groups on adjacent keys, calculated by the\n * specified function.\n *\n * @since 1.0.0\n * @category grouping\n */\nexports.fromSchedule = fromSchedule;\nconst groupAdjacentBy = internal.groupAdjacentBy;\n/**\n * More powerful version of `Stream.groupByKey`.\n *\n * @since 1.0.0\n * @category grouping\n */\nexports.groupAdjacentBy = groupAdjacentBy;\nconst groupBy = _groupBy.groupBy;\n/**\n * Like `groupBy`, but with a configurable `bufferSize` parameter.\n *\n * @since 1.0.0\n * @category grouping\n */\nexports.groupBy = groupBy;\nconst groupByBuffer = _groupBy.groupByBuffer;\n/**\n * Partition a stream using a function and process each stream individually.\n * This returns a data structure that can be used to further filter down which\n * groups shall be processed.\n *\n * After calling apply on the GroupBy object, the remaining groups will be\n * processed in parallel and the resulting streams merged in a\n * nondeterministic fashion.\n *\n * Up to `buffer` elements may be buffered in any group stream before the\n * producer is backpressured. Take care to consume from all streams in order\n * to prevent deadlocks.\n *\n * For example, to collect the first 2 words for every starting letter from a\n * stream of words:\n *\n * ```ts\n * import * as GroupBy from \"@effect/stream/GroupBy\"\n * import * as Stream from \"@effect/stream/Stream\"\n * import { pipe } from \"@effect/data/Function\"\n *\n * pipe(\n *   Stream.fromIterable([\"hello\", \"world\", \"hi\", \"holla\"]),\n *   Stream.groupByKey((word) => word[0]),\n *   GroupBy.evaluate((key, stream) =>\n *     pipe(\n *       stream,\n *       Stream.take(2),\n *       Stream.map((words) => [key, words] as const)\n *     )\n *   )\n * )\n * ```\n *\n * @since 1.0.0\n * @category utils\n */\nexports.groupByBuffer = groupByBuffer;\nconst groupByKey = _groupBy.groupByKey;\n/**\n * Like `groupByKey`, but with a configurable `bufferSize` parameter.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.groupByKey = groupByKey;\nconst groupByKeyBuffer = _groupBy.groupByKeyBuffer;\n/**\n * Partitions the stream with specified `chunkSize`.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.groupByKeyBuffer = groupByKeyBuffer;\nconst grouped = internal.grouped;\n/**\n * Partitions the stream with the specified `chunkSize` or until the specified\n * `duration` has passed, whichever is satisfied first.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.grouped = grouped;\nconst groupedWithin = internal.groupedWithin;\n/**\n * Specialized version of haltWhen which halts the evaluation of this stream\n * after the given duration.\n *\n * An element in the process of being pulled will not be interrupted when the\n * given duration completes. See `interruptAfter` for this behavior.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.groupedWithin = groupedWithin;\nconst haltAfter = internal.haltAfter;\n/**\n * Halts the evaluation of this stream when the provided effect completes. The\n * given effect will be forked as part of the returned stream, and its success\n * will be discarded.\n *\n * An element in the process of being pulled will not be interrupted when the\n * effect completes. See `interruptWhen` for this behavior.\n *\n * If the effect completes with a failure, the stream will emit that failure.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.haltAfter = haltAfter;\nconst haltWhen = internal.haltWhen;\n/**\n * Halts the evaluation of this stream when the provided promise resolves.\n *\n * If the promise completes with a failure, the stream will emit that failure.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.haltWhen = haltWhen;\nconst haltWhenDeferred = internal.haltWhenDeferred;\n/**\n * The identity pipeline, which does not modify streams in any way.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.haltWhenDeferred = haltWhenDeferred;\nconst identity = internal.identityStream;\n/**\n * Interleaves this stream and the specified stream deterministically by\n * alternating pulling values from this stream and the specified stream. When\n * one stream is exhausted all remaining values in the other stream will be\n * pulled.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.identity = identity;\nconst interleave = internal.interleave;\n/**\n * Combines this stream and the specified stream deterministically using the\n * stream of boolean values `pull` to control which stream to pull from next.\n * A value of `true` indicates to pull from this stream and a value of `false`\n * indicates to pull from the specified stream. Only consumes as many elements\n * as requested by the `pull` stream. If either this stream or the specified\n * stream are exhausted further requests for values from that stream will be\n * ignored.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.interleave = interleave;\nconst interleaveWith = internal.interleaveWith;\n/**\n * Intersperse stream with provided `element`.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.interleaveWith = interleaveWith;\nconst intersperse = internal.intersperse;\n/**\n * Intersperse the specified element, also adding a prefix and a suffix.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.intersperse = intersperse;\nconst intersperseAffixes = internal.intersperseAffixes;\n/**\n * Specialized version of `Stream.interruptWhen` which interrupts the\n * evaluation of this stream after the given `Duration`.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.intersperseAffixes = intersperseAffixes;\nconst interruptAfter = internal.interruptAfter;\n/**\n * Interrupts the evaluation of this stream when the provided effect\n * completes. The given effect will be forked as part of this stream, and its\n * success will be discarded. This combinator will also interrupt any\n * in-progress element being pulled from upstream.\n *\n * If the effect completes with a failure before the stream completes, the\n * returned stream will emit that failure.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.interruptAfter = interruptAfter;\nconst interruptWhen = internal.interruptWhen;\n/**\n * Interrupts the evaluation of this stream when the provided promise\n * resolves. This combinator will also interrupt any in-progress element being\n * pulled from upstream.\n *\n * If the promise completes with a failure, the stream will emit that failure.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.interruptWhen = interruptWhen;\nconst interruptWhenDeferred = internal.interruptWhenDeferred;\n/**\n * The infinite stream of iterative function application: a, f(a), f(f(a)),\n * f(f(f(a))), ...\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.interruptWhenDeferred = interruptWhenDeferred;\nconst iterate = internal.iterate;\n/**\n * Logs the specified message at the current log level.\n *\n * @since 1.0.0\n * @category logging\n */\nexports.iterate = iterate;\nconst log = internal.log;\n/**\n * Logs the specified message at the debug log level.\n *\n * @since 1.0.0\n * @category logging\n */\nexports.log = log;\nconst logDebug = internal.logDebug;\n/**\n * Logs the specified `Cause` at the debug log level.\n *\n * @since 1.0.0\n * @category logging\n */\nexports.logDebug = logDebug;\nconst logDebugCause = internal.logDebugCause;\n/**\n * Logs the specified message and `Cause` at the debug log level.\n *\n * @since 1.0.0\n * @category logging\n */\nexports.logDebugCause = logDebugCause;\nconst logDebugCauseMessage = internal.logDebugCauseMessage;\n/**\n * Logs the specified message at the error log level.\n *\n * @since 1.0.0\n * @category logging\n */\nexports.logDebugCauseMessage = logDebugCauseMessage;\nconst logError = internal.logError;\n/**\n * Logs the specified `Cause` at the error log level.\n *\n * @since 1.0.0\n * @category logging\n */\nexports.logError = logError;\nconst logErrorCause = internal.logErrorCause;\n/**\n * Logs the specified message and `Cause` at the error log level.\n *\n * @since 1.0.0\n * @category logging\n */\nexports.logErrorCause = logErrorCause;\nconst logErrorCauseMessage = internal.logErrorCauseMessage;\n/**\n * Logs the specified message at the fatal log level.\n *\n * @since 1.0.0\n * @category logging\n */\nexports.logErrorCauseMessage = logErrorCauseMessage;\nconst logFatal = internal.logFatal;\n/**\n * Logs the specified `Cause` at the fatal log level.\n *\n * @since 1.0.0\n * @category logging\n */\nexports.logFatal = logFatal;\nconst logFatalCause = internal.logFatalCause;\n/**\n * Logs the specified message and `Cause` at the fatal log level.\n *\n * @since 1.0.0\n * @category logging\n */\nexports.logFatalCause = logFatalCause;\nconst logFatalCauseMessage = internal.logFatalCauseMessage;\n/**\n * Logs the specified message at the info log level.\n *\n * @since 1.0.0\n * @category logging\n */\nexports.logFatalCauseMessage = logFatalCauseMessage;\nconst logInfo = internal.logInfo;\n/**\n * Logs the specified `Cause` at the info log level.\n *\n * @since 1.0.0\n * @category logging\n */\nexports.logInfo = logInfo;\nconst logInfoCause = internal.logInfoCause;\n/**\n * Logs the specified message and `Cause` at the info log level.\n *\n * @since 1.0.0\n * @category logging\n */\nexports.logInfoCause = logInfoCause;\nconst logInfoCauseMessage = internal.logInfoCauseMessage;\n/**\n * Logs the specified message at the warning log level.\n *\n * @since 1.0.0\n * @category logging\n */\nexports.logInfoCauseMessage = logInfoCauseMessage;\nconst logWarning = internal.logWarning;\n/**\n * Logs the specified `Cause` at the warning log level.\n *\n * @since 1.0.0\n * @category logging\n */\nexports.logWarning = logWarning;\nconst logWarningCause = internal.logWarningCause;\n/**\n * Logs the specified message and `Cause` at the warning log level.\n *\n * @since 1.0.0\n * @category logging\n */\nexports.logWarningCause = logWarningCause;\nconst logWarningCauseMessage = internal.logWarningCauseMessage;\n/**\n * Logs the specified message at the trace log level.\n *\n * @since 1.0.0\n * @category logging\n */\nexports.logWarningCauseMessage = logWarningCauseMessage;\nconst logTrace = internal.logTrace;\n/**\n * Logs the specified `Cause` at the trace log level.\n *\n * @since 1.0.0\n * @category logging\n */\nexports.logTrace = logTrace;\nconst logTraceCause = internal.logTraceCause;\n/**\n * Logs the specified message and `Cause` at the trace log level.\n *\n * @since 1.0.0\n * @category logging\n */\nexports.logTraceCause = logTraceCause;\nconst logTraceCauseMessage = internal.logTraceCauseMessage;\n/**\n * Creates a stream from an sequence of values.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.logTraceCauseMessage = logTraceCauseMessage;\nconst make = internal.make;\n/**\n * Transforms the elements of this stream using the supplied function.\n *\n * @since 1.0.0\n * @category mapping\n */\nexports.make = make;\nconst map = internal.map;\n/**\n * Statefully maps over the elements of this stream to produce new elements.\n *\n * @since 1.0.0\n * @category mapping\n */\nexports.map = map;\nconst mapAccum = internal.mapAccum;\n/**\n * Statefully and effectfully maps over the elements of this stream to produce\n * new elements.\n *\n * @since 1.0.0\n * @category mapping\n */\nexports.mapAccum = mapAccum;\nconst mapAccumEffect = internal.mapAccumEffect;\n/**\n * Returns a stream whose failure and success channels have been mapped by the\n * specified pair of functions, `f` and `g`.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.mapAccumEffect = mapAccumEffect;\nconst mapBoth = internal.mapBoth;\n/**\n * Transforms the chunks emitted by this stream.\n *\n * @since 1.0.0\n * @category mapping\n */\nexports.mapBoth = mapBoth;\nconst mapChunks = internal.mapChunks;\n/**\n * Effectfully transforms the chunks emitted by this stream.\n *\n * @since 1.0.0\n * @category mapping\n */\nexports.mapChunks = mapChunks;\nconst mapChunksEffect = internal.mapChunksEffect;\n/**\n * Maps each element to an iterable, and flattens the iterables into the\n * output of this stream.\n *\n * @since 1.0.0\n * @category mapping\n */\nexports.mapChunksEffect = mapChunksEffect;\nconst mapConcat = internal.mapConcat;\n/**\n * Maps each element to a chunk, and flattens the chunks into the output of\n * this stream.\n *\n * @since 1.0.0\n * @category mapping\n */\nexports.mapConcat = mapConcat;\nconst mapConcatChunk = internal.mapConcatChunk;\n/**\n * Effectfully maps each element to a chunk, and flattens the chunks into the\n * output of this stream.\n *\n * @since 1.0.0\n * @category mapping\n */\nexports.mapConcatChunk = mapConcatChunk;\nconst mapConcatChunkEffect = internal.mapConcatChunkEffect;\n/**\n * Effectfully maps each element to an iterable, and flattens the iterables\n * into the output of this stream.\n *\n * @since 1.0.0\n * @category mapping\n */\nexports.mapConcatChunkEffect = mapConcatChunkEffect;\nconst mapConcatEffect = internal.mapConcatEffect;\n/**\n * Maps over elements of the stream with the specified effectful function.\n *\n * @since 1.0.0\n * @category mapping\n */\nexports.mapConcatEffect = mapConcatEffect;\nconst mapEffect = internal.mapEffect;\n/**\n * Transforms the errors emitted by this stream using `f`.\n *\n * @since 1.0.0\n * @category mapping\n */\nexports.mapEffect = mapEffect;\nconst mapError = internal.mapError;\n/**\n * Transforms the full causes of failures emitted by this stream.\n *\n * @since 1.0.0\n * @category mapping\n */\nexports.mapError = mapError;\nconst mapErrorCause = internal.mapErrorCause;\n/**\n * Maps over elements of the stream with the specified effectful function,\n * executing up to `n` invocations of `f` concurrently. Transformed elements\n * will be emitted in the original order.\n *\n * @note This combinator destroys the chunking structure. It's recommended to use\n *       rechunk afterwards.\n * @since 1.0.0\n * @category mapping\n */\nexports.mapErrorCause = mapErrorCause;\nconst mapEffectPar = internal.mapEffectPar;\n/**\n * Maps over elements of the stream with the specified effectful function,\n * partitioned by `p` executing invocations of `f` concurrently. The number of\n * concurrent invocations of `f` is determined by the number of different\n * outputs of type `K`. Up to `buffer` elements may be buffered per partition.\n * Transformed elements may be reordered but the order within a partition is\n * maintained.\n *\n * @since 1.0.0\n * @category mapping\n */\nexports.mapEffectPar = mapEffectPar;\nconst mapEffectParByKey = _groupBy.mapEffectParByKey;\n/**\n * Like `mapEffectParByKey`, but with a `bufferSize` parameter.\n *\n * @since 1.0.0\n * @category mapping\n */\nexports.mapEffectParByKey = mapEffectParByKey;\nconst mapEffectParByKeyBuffer = _groupBy.mapEffectParByKeyBuffer;\n/**\n * Maps over elements of the stream with the specified effectful function,\n * executing up to `n` invocations of `f` concurrently. The element order is\n * not enforced by this combinator, and elements may be reordered.\n *\n * @since 1.0.0\n * @category mapping\n */\nexports.mapEffectParByKeyBuffer = mapEffectParByKeyBuffer;\nconst mapEffectParUnordered = internal.mapEffectParUnordered;\n/**\n * Merges this stream and the specified stream together.\n *\n * New produced stream will terminate when both specified stream terminate if\n * no termination strategy is specified.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.mapEffectParUnordered = mapEffectParUnordered;\nconst merge = internal.merge;\n/**\n * Like `merge`, but with a configurable `strategy` parameter.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.merge = merge;\nconst mergeHaltStrategy = internal.mergeHaltStrategy;\n/**\n * Merges a variable list of streams in a non-deterministic fashion. Up to `n`\n * streams may be consumed in parallel and up to `outputBuffer` chunks may be\n * buffered by this operator.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.mergeHaltStrategy = mergeHaltStrategy;\nconst mergeAll = internal.mergeAll;\n/**\n * Like `Stream.mergeAll`, but runs all streams concurrently.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.mergeAll = mergeAll;\nconst mergeAllUnbounded = internal.mergeAllUnbounded;\n/**\n * Merges this stream and the specified stream together to a common element\n * type with the specified mapping functions.\n *\n * New produced stream will terminate when both specified stream terminate if\n * no termination strategy is specified.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.mergeAllUnbounded = mergeAllUnbounded;\nconst mergeWith = internal.mergeWith;\n/**\n * Like `mergeWith`, but with a configurable `strategy` parameter.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.mergeWith = mergeWith;\nconst mergeWithHaltStrategy = internal.mergeWithHaltStrategy;\n/**\n * Merges this stream and the specified stream together. New produced stream\n * will terminate when either stream terminates.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.mergeWithHaltStrategy = mergeWithHaltStrategy;\nconst mergeHaltEither = internal.mergeHaltEither;\n/**\n * Merges this stream and the specified stream together. New produced stream\n * will terminate when this stream terminates.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.mergeHaltEither = mergeHaltEither;\nconst mergeHaltLeft = internal.mergeHaltLeft;\n/**\n * Merges this stream and the specified stream together. New produced stream\n * will terminate when the specified stream terminates.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.mergeHaltLeft = mergeHaltLeft;\nconst mergeHaltRight = internal.mergeHaltRight;\n/**\n * Merges this stream and the specified stream together to produce a stream of\n * eithers.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.mergeHaltRight = mergeHaltRight;\nconst mergeEither = internal.mergeEither;\n/**\n * Merges this stream and the specified stream together, discarding the values\n * from the right stream.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.mergeEither = mergeEither;\nconst mergeLeft = internal.mergeLeft;\n/**\n * Merges this stream and the specified stream together, discarding the values\n * from the left stream.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.mergeLeft = mergeLeft;\nconst mergeRight = internal.mergeRight;\n/**\n * Returns a combined string resulting from concatenating each of the values\n * from the stream.\n *\n * @macro traced\n * @since 1.0.0\n * @category utils\n */\nexports.mergeRight = mergeRight;\nconst mkString = internal.mkString;\n/**\n * The stream that never produces any value or fails with any error.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.mkString = mkString;\nconst never = internal.never;\n/**\n * Runs the specified effect if this stream fails, providing the error to the\n * effect if it exists.\n *\n * Note: Unlike `Effect.onError` there is no guarantee that the provided\n * effect will not be interrupted.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.never = never;\nconst onError = internal.onError;\n/**\n * Runs the specified effect if this stream ends.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.onError = onError;\nconst onDone = internal.onDone;\n/**\n * Translates any failure into a stream termination, making the stream\n * infallible and all failures unchecked.\n *\n * @since 1.0.0\n * @category error handling\n */\nexports.onDone = onDone;\nconst orDie = internal.orDie;\n/**\n * Keeps none of the errors, and terminates the stream with them, using the\n * specified function to convert the `E` into a defect.\n *\n * @since 1.0.0\n * @category error handling\n */\nexports.orDie = orDie;\nconst orDieWith = internal.orDieWith;\n/**\n * Switches to the provided stream in case this one fails with a typed error.\n *\n * See also `Stream.catchAll`.\n *\n * @since 1.0.0\n * @category error handling\n */\nexports.orDieWith = orDieWith;\nconst orElse = internal.orElse;\n/**\n * Switches to the provided stream in case this one fails with a typed error.\n *\n * See also `Stream.catchAll`.\n *\n * @since 1.0.0\n * @category error handling\n */\nexports.orElse = orElse;\nconst orElseEither = internal.orElseEither;\n/**\n * Fails with given error in case this one fails with a typed error.\n *\n * See also `Stream.catchAll`.\n *\n * @since 1.0.0\n * @category error handling\n */\nexports.orElseEither = orElseEither;\nconst orElseFail = internal.orElseFail;\n/**\n * Produces the specified element if this stream is empty.\n *\n * @since 1.0.0\n * @category error handling\n */\nexports.orElseFail = orElseFail;\nconst orElseIfEmpty = internal.orElseIfEmpty;\n/**\n * Produces the specified chunk if this stream is empty.\n *\n * @since 1.0.0\n * @category error handling\n */\nexports.orElseIfEmpty = orElseIfEmpty;\nconst orElseIfEmptyChunk = internal.orElseIfEmptyChunk;\n/**\n * Switches to the provided stream in case this one is empty.\n *\n * @since 1.0.0\n * @category error handling\n */\nexports.orElseIfEmptyChunk = orElseIfEmptyChunk;\nconst orElseIfEmptyStream = internal.orElseIfEmptyStream;\n/**\n * Switches to the provided stream in case this one fails with the `None`\n * value.\n *\n * See also `Stream.catchAll`.\n *\n * @since 1.0.0\n * @category error handling\n */\nexports.orElseIfEmptyStream = orElseIfEmptyStream;\nconst orElseOptional = internal.orElseOptional;\n/**\n * Succeeds with the specified value if this one fails with a typed error.\n *\n * @since 1.0.0\n * @category error handling\n */\nexports.orElseOptional = orElseOptional;\nconst orElseSucceed = internal.orElseSucceed;\n/**\n * Like `Stream.unfold`, but allows the emission of values to end one step further\n * than the unfolding of the state. This is useful for embedding paginated\n * APIs, hence the name.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.orElseSucceed = orElseSucceed;\nconst paginate = internal.paginate;\n/**\n * Like `Stream.unfoldChunk`, but allows the emission of values to end one step\n * further than the unfolding of the state. This is useful for embedding\n * paginated APIs, hence the name.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.paginate = paginate;\nconst paginateChunk = internal.paginateChunk;\n/**\n * Like `Stream.unfoldChunkEffect`, but allows the emission of values to end one step\n * further than the unfolding of the state. This is useful for embedding\n * paginated APIs, hence the name.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.paginateChunk = paginateChunk;\nconst paginateChunkEffect = internal.paginateChunkEffect;\n/**\n * Like `Stream.unfoldEffect` but allows the emission of values to end one step\n * further than the unfolding of the state. This is useful for embedding\n * paginated APIs, hence the name.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.paginateChunkEffect = paginateChunkEffect;\nconst paginateEffect = internal.paginateEffect;\n/**\n * Partition a stream using a predicate. The first stream will contain all\n * element evaluated to true and the second one will contain all element\n * evaluated to false. The faster stream may advance by up to buffer elements\n * further than the slower one.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.paginateEffect = paginateEffect;\nconst partition = internal.partition;\n/**\n * Like `partition`, but with a configurable `bufferSize` parameter.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.partition = partition;\nconst partitionBuffer = internal.partitionBuffer;\n/**\n * Split a stream by an effectful predicate. The faster stream may advance by\n * up to buffer elements further than the slower one.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.partitionBuffer = partitionBuffer;\nconst partitionEither = internal.partitionEither;\n/**\n * Like `partitionEither`, but with a configurable `bufferSize` parameter.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.partitionEither = partitionEither;\nconst partitionEitherBuffer = internal.partitionEitherBuffer;\n/**\n * Peels off enough material from the stream to construct a `Z` using the\n * provided `Sink` and then returns both the `Z` and the rest of the\n * `Stream` in a scope. Like all scoped values, the provided stream is\n * valid only within the scope.\n *\n * @macro traced\n * @since 1.0.0\n * @category utils\n */\nexports.partitionEitherBuffer = partitionEitherBuffer;\nconst peel = internal.peel;\n/**\n * Pipes all of the values from this stream through the provided sink.\n *\n * See also `Stream.transduce`.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.peel = peel;\nconst pipeThrough = internal.pipeThrough;\n/**\n * Pipes all the values from this stream through the provided channel.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.pipeThrough = pipeThrough;\nconst pipeThroughChannel = internal.pipeThroughChannel;\n/**\n * Pipes all values from this stream through the provided channel, passing\n * through any error emitted by this stream unchanged.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.pipeThroughChannel = pipeThroughChannel;\nconst pipeThroughChannelOrFail = internal.pipeThroughChannelOrFail;\n/**\n * Emits the provided chunk before emitting any other value.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.pipeThroughChannelOrFail = pipeThroughChannelOrFail;\nconst prepend = internal.prepend;\n/**\n * Provides the stream with its required context, which eliminates its\n * dependency on `R`.\n *\n * @since 1.0.0\n * @category context\n */\nexports.prepend = prepend;\nconst provideContext = internal.provideContext;\n/**\n * Provides a `Layer` to the stream, which translates it to another level.\n *\n * @since 1.0.0\n * @category context\n */\nexports.provideContext = provideContext;\nconst provideLayer = internal.provideLayer;\n/**\n * Provides the stream with the single service it requires. If the stream\n * requires more than one service use `Stream.provideContext` instead.\n *\n * @since 1.0.0\n * @category context\n */\nexports.provideLayer = provideLayer;\nconst provideService = internal.provideService;\n/**\n * Provides the stream with the single service it requires. If the stream\n * requires more than one service use `Stream.provideContext` instead.\n *\n * @since 1.0.0\n * @category context\n */\nexports.provideService = provideService;\nconst provideServiceEffect = internal.provideServiceEffect;\n/**\n * Provides the stream with the single service it requires. If the stream\n * requires more than one service use `Stream.provideContext` instead.\n *\n * @since 1.0.0\n * @category context\n */\nexports.provideServiceEffect = provideServiceEffect;\nconst provideServiceStream = internal.provideServiceStream;\n/**\n * Transforms the context being provided to the stream with the specified\n * function.\n *\n * @since 1.0.0\n * @category context\n */\nexports.provideServiceStream = provideServiceStream;\nconst contramapContext = internal.contramapContext;\n/**\n * Splits the context into two parts, providing one part using the\n * specified layer and leaving the remainder `R0`.\n *\n * @since 1.0.0\n * @category context\n */\nexports.contramapContext = contramapContext;\nconst provideSomeLayer = internal.provideSomeLayer;\n/**\n * Constructs a stream from a range of integers (lower bound included, upper\n * bound not included).\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.provideSomeLayer = provideSomeLayer;\nconst range = internal.range;\n/**\n * Re-chunks the elements of the stream into chunks of `n` elements each. The\n * last chunk might contain less than `n` elements.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.range = range;\nconst rechunk = internal.rechunk;\n/**\n * Keeps some of the errors, and terminates the fiber with the rest\n *\n * @since 1.0.0\n * @category error handling\n */\nexports.rechunk = rechunk;\nconst refineOrDie = internal.refineOrDie;\n/**\n * Keeps some of the errors, and terminates the fiber with the rest, using the\n * specified function to convert the `E` into a defect.\n *\n * @since 1.0.0\n * @category error handling\n */\nexports.refineOrDie = refineOrDie;\nconst refineOrDieWith = internal.refineOrDieWith;\n/**\n * Repeats the entire stream using the specified schedule. The stream will\n * execute normally, and then repeat again according to the provided schedule.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.refineOrDieWith = refineOrDieWith;\nconst repeat = internal.repeat;\n/**\n * Creates a stream from an effect producing a value of type `A` which repeats\n * forever.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.repeat = repeat;\nconst repeatEffect = internal.repeatEffect;\n/**\n * Creates a stream from an effect producing chunks of `A` values which\n * repeats forever.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.repeatEffect = repeatEffect;\nconst repeatEffectChunk = internal.repeatEffectChunk;\n/**\n * Creates a stream from an effect producing chunks of `A` values until it\n * fails with `None`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.repeatEffectChunk = repeatEffectChunk;\nconst repeatEffectChunkOption = internal.repeatEffectChunkOption;\n/**\n * Creates a stream from an effect producing values of type `A` until it fails\n * with `None`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.repeatEffectChunkOption = repeatEffectChunkOption;\nconst repeatEffectOption = internal.repeatEffectOption;\n/**\n * Creates a stream from an effect producing a value of type `A`, which is\n * repeated using the specified schedule.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.repeatEffectOption = repeatEffectOption;\nconst repeatEffectWithSchedule = internal.repeatEffectWithSchedule;\n/**\n * Repeats the entire stream using the specified schedule. The stream will\n * execute normally, and then repeat again according to the provided schedule.\n * The schedule output will be emitted at the end of each repetition.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.repeatEffectWithSchedule = repeatEffectWithSchedule;\nconst repeatEither = internal.repeatEither;\n/**\n * Repeats each element of the stream using the provided schedule. Repetitions\n * are done in addition to the first execution, which means using\n * `Schedule.recurs(1)` actually results in the original effect, plus an\n * additional recurrence, for a total of two repetitions of each value in the\n * stream.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.repeatEither = repeatEither;\nconst repeatElements = internal.repeatElements;\n/**\n * Repeats each element of the stream using the provided schedule. When the\n * schedule is finished, then the output of the schedule will be emitted into\n * the stream. Repetitions are done in addition to the first execution, which\n * means using `Schedule.recurs(1)` actually results in the original effect,\n * plus an additional recurrence, for a total of two repetitions of each value\n * in the stream.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.repeatElements = repeatElements;\nconst repeatElementsEither = internal.repeatElementsEither;\n/**\n * Repeats each element of the stream using the provided schedule. When the\n * schedule is finished, then the output of the schedule will be emitted into\n * the stream. Repetitions are done in addition to the first execution, which\n * means using `Schedule.recurs(1)` actually results in the original effect,\n * plus an additional recurrence, for a total of two repetitions of each value\n * in the stream.\n *\n * This function accepts two conversion functions, which allow the output of\n * this stream and the output of the provided schedule to be unified into a\n * single type. For example, `Either` or similar data type.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.repeatElementsEither = repeatElementsEither;\nconst repeatElementsWith = internal.repeatElementsWith;\n/**\n * Repeats the provided value infinitely.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.repeatElementsWith = repeatElementsWith;\nconst repeatValue = internal.repeatValue;\n/**\n * Repeats the entire stream using the specified schedule. The stream will\n * execute normally, and then repeat again according to the provided schedule.\n * The schedule output will be emitted at the end of each repetition and can\n * be unified with the stream elements using the provided functions.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.repeatValue = repeatValue;\nconst repeatWith = internal.repeatWith;\n/**\n * When the stream fails, retry it according to the given schedule\n *\n * This retries the entire stream, so will re-execute all of the stream's\n * acquire operations.\n *\n * The schedule is reset as soon as the first element passes through the\n * stream again.\n *\n * @param schedule A `Schedule` receiving as input the errors of the stream.\n * @since 1.0.0\n * @category utils\n */\nexports.repeatWith = repeatWith;\nconst retry = internal.retry;\n/**\n * Fails with the error `None` if value is `Left`.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.retry = retry;\nconst right = internal.right;\n/**\n * Fails with given error 'e' if value is `Left`.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.right = right;\nconst rightOrFail = internal.rightOrFail;\n/**\n * Runs the sink on the stream to produce either the sink's result or an error.\n *\n * @macro traced\n * @since 1.0.0\n * @category destructors\n */\nexports.rightOrFail = rightOrFail;\nconst run = internal.run;\n/**\n * Runs the stream and collects all of its elements to a chunk.\n *\n * @macro traced\n * @since 1.0.0\n * @category destructors\n */\nexports.run = run;\nconst runCollect = internal.runCollect;\n/**\n * Runs the stream and emits the number of elements processed\n *\n * @macro traced\n * @since 1.0.0\n * @category destructors\n */\nexports.runCollect = runCollect;\nconst runCount = internal.runCount;\n/**\n * Runs the stream only for its effects. The emitted elements are discarded.\n *\n * @macro traced\n * @since 1.0.0\n * @category destructors\n */\nexports.runCount = runCount;\nconst runDrain = internal.runDrain;\n/**\n * Executes a pure fold over the stream of values - reduces all elements in\n * the stream to a value of type `S`.\n *\n * @macro traced\n * @since 1.0.0\n * @category destructors\n */\nexports.runDrain = runDrain;\nconst runFold = internal.runFold;\n/**\n * Executes an effectful fold over the stream of values.\n *\n * @macro traced\n * @since 1.0.0\n * @category destructors\n */\nexports.runFold = runFold;\nconst runFoldEffect = internal.runFoldEffect;\n/**\n * Executes a pure fold over the stream of values. Returns a scoped value that\n * represents the scope of the stream.\n *\n * @macro traced\n * @since 1.0.0\n * @category destructors\n */\nexports.runFoldEffect = runFoldEffect;\nconst runFoldScoped = internal.runFoldScoped;\n/**\n * Executes an effectful fold over the stream of values. Returns a scoped\n * value that represents the scope of the stream.\n *\n * @macro traced\n * @since 1.0.0\n * @category destructors\n */\nexports.runFoldScoped = runFoldScoped;\nconst runFoldScopedEffect = internal.runFoldScopedEffect;\n/**\n * Reduces the elements in the stream to a value of type `S`. Stops the fold\n * early when the condition is not fulfilled. Example:\n *\n * @macro traced\n * @since 1.0.0\n * @category destructors\n */\nexports.runFoldScopedEffect = runFoldScopedEffect;\nconst runFoldWhile = internal.runFoldWhile;\n/**\n * Executes an effectful fold over the stream of values. Stops the fold early\n * when the condition is not fulfilled.\n *\n * @macro traced\n * @since 1.0.0\n * @category destructors\n */\nexports.runFoldWhile = runFoldWhile;\nconst runFoldWhileEffect = internal.runFoldWhileEffect;\n/**\n * Executes a pure fold over the stream of values. Returns a scoped value that\n * represents the scope of the stream. Stops the fold early when the condition\n * is not fulfilled.\n *\n * @macro traced\n * @since 1.0.0\n * @category destructors\n */\nexports.runFoldWhileEffect = runFoldWhileEffect;\nconst runFoldWhileScoped = internal.runFoldWhileScoped;\n/**\n * Executes an effectful fold over the stream of values. Returns a scoped\n * value that represents the scope of the stream. Stops the fold early when\n * the condition is not fulfilled.\n *\n * @macro traced\n * @since 1.0.0\n * @category destructors\n */\nexports.runFoldWhileScoped = runFoldWhileScoped;\nconst runFoldWhileScopedEffect = internal.runFoldWhileScopedEffect;\n/**\n * Consumes all elements of the stream, passing them to the specified\n * callback.\n *\n * @macro traced\n * @since 1.0.0\n * @category destructors\n */\nexports.runFoldWhileScopedEffect = runFoldWhileScopedEffect;\nconst runForEach = internal.runForEach;\n/**\n * Consumes all elements of the stream, passing them to the specified\n * callback.\n *\n * @macro traced\n * @since 1.0.0\n * @category destructors\n */\nexports.runForEach = runForEach;\nconst runForEachChunk = internal.runForEachChunk;\n/**\n * Like `Stream.runForEachChunk`, but returns a scoped effect so the\n * finalization order can be controlled.\n *\n * @macro traced\n * @since 1.0.0\n * @category destructors\n */\nexports.runForEachChunk = runForEachChunk;\nconst runForEachChunkScoped = internal.runForEachChunkScoped;\n/**\n * Like `Stream.forEach`, but returns a scoped effect so the finalization\n * order can be controlled.\n *\n * @macro traced\n * @since 1.0.0\n * @category destructors\n */\nexports.runForEachChunkScoped = runForEachChunkScoped;\nconst runForEachScoped = internal.runForEachScoped;\n/**\n * Consumes elements of the stream, passing them to the specified callback,\n * and terminating consumption when the callback returns `false`.\n *\n * @macro traced\n * @since 1.0.0\n * @category destructors\n */\nexports.runForEachScoped = runForEachScoped;\nconst runForEachWhile = internal.runForEachWhile;\n/**\n * Like `Stream.runForEachWhile`, but returns a scoped effect so the\n * finalization order can be controlled.\n *\n * @macro traced\n * @since 1.0.0\n * @category destructors\n */\nexports.runForEachWhile = runForEachWhile;\nconst runForEachWhileScoped = internal.runForEachWhileScoped;\n/**\n * Runs the stream to completion and yields the first value emitted by it,\n * discarding the rest of the elements.\n *\n * @macro traced\n * @since 1.0.0\n * @category destructors\n */\nexports.runForEachWhileScoped = runForEachWhileScoped;\nconst runHead = internal.runHead;\n/**\n * Publishes elements of this stream to a hub. Stream failure and ending will\n * also be signalled.\n *\n * @macro traced\n * @since 1.0.0\n * @category destructors\n */\nexports.runHead = runHead;\nconst runIntoHub = internal.runIntoHub;\n/**\n * Like `Stream.runIntoHub`, but provides the result as a scoped effect to\n * allow for scope composition.\n *\n * @macro traced\n * @since 1.0.0\n * @category destructors\n */\nexports.runIntoHub = runIntoHub;\nconst runIntoHubScoped = internal.runIntoHubScoped;\n/**\n * Enqueues elements of this stream into a queue. Stream failure and ending\n * will also be signalled.\n *\n * @macro traced\n * @since 1.0.0\n * @category destructors\n */\nexports.runIntoHubScoped = runIntoHubScoped;\nconst runIntoQueue = internal.runIntoQueue;\n/**\n * Like `Stream.runIntoQueue`, but provides the result as a scoped [[ZIO]]\n * to allow for scope composition.\n *\n * @macro traced\n * @since 1.0.0\n * @category destructors\n */\nexports.runIntoQueue = runIntoQueue;\nconst runIntoQueueElementsScoped = internal.runIntoQueueElementsScoped;\n/**\n * Like `Stream.runIntoQueue`, but provides the result as a scoped effect\n * to allow for scope composition.\n *\n * @macro traced\n * @since 1.0.0\n * @category destructors\n */\nexports.runIntoQueueElementsScoped = runIntoQueueElementsScoped;\nconst runIntoQueueScoped = internal.runIntoQueueScoped;\n/**\n * Runs the stream to completion and yields the last value emitted by it,\n * discarding the rest of the elements.\n *\n * @macro traced\n * @since 1.0.0\n * @category destructors\n */\nexports.runIntoQueueScoped = runIntoQueueScoped;\nconst runLast = internal.runLast;\n/**\n * @macro traced\n * @since 1.0.0\n * @category destructors\n */\nexports.runLast = runLast;\nconst runScoped = internal.runScoped;\n/**\n * Runs the stream to a sink which sums elements, provided they are Numeric.\n *\n * @macro traced\n * @since 1.0.0\n * @category destructors\n */\nexports.runScoped = runScoped;\nconst runSum = internal.runSum;\n/**\n * Statefully maps over the elements of this stream to produce all\n * intermediate results of type `S` given an initial S.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.runSum = runSum;\nconst scan = internal.scan;\n/**\n * Statefully and effectfully maps over the elements of this stream to produce\n * all intermediate results of type `S` given an initial S.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.scan = scan;\nconst scanEffect = internal.scanEffect;\n/**\n * Statefully maps over the elements of this stream to produce all\n * intermediate results.\n *\n * See also `Stream.scan`.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.scanEffect = scanEffect;\nconst scanReduce = internal.scanReduce;\n/**\n * Statefully and effectfully maps over the elements of this stream to produce\n * all intermediate results.\n *\n * See also `Stream.scanEffect`.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.scanReduce = scanReduce;\nconst scanReduceEffect = internal.scanReduceEffect;\n/**\n * Schedules the output of the stream using the provided `schedule`.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.scanReduceEffect = scanReduceEffect;\nconst schedule = internal.schedule;\n/**\n * Schedules the output of the stream using the provided `schedule` and emits\n * its output at the end (if `schedule` is finite).\n *\n * @since 1.0.0\n * @category utils\n */\nexports.schedule = schedule;\nconst scheduleEither = internal.scheduleEither;\n/**\n * Schedules the output of the stream using the provided `schedule` and emits\n * its output at the end (if `schedule` is finite). Uses the provided function\n * to align the stream and schedule outputs on the same type.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.scheduleEither = scheduleEither;\nconst scheduleWith = internal.scheduleWith;\n/**\n * Creates a single-valued stream from a scoped resource.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.scheduleWith = scheduleWith;\nconst scoped = internal.scoped;\n/**\n * Accesses the specified service in the context of the effect.\n *\n * @since 1.0.0\n * @category context\n */\nexports.scoped = scoped;\nconst service = internal.service;\n/**\n * Accesses the specified service in the context of the stream.\n *\n * @since 1.0.0\n * @category context\n */\nexports.service = service;\nconst serviceWith = internal.serviceWith;\n/**\n * Accesses the specified service in the context of the stream in the\n * context of an effect.\n *\n * @since 1.0.0\n * @category context\n */\nexports.serviceWith = serviceWith;\nconst serviceWithEffect = internal.serviceWithEffect;\n/**\n * Accesses the specified service in the context of the stream in the\n * context of a stream.\n *\n * @since 1.0.0\n * @category context\n */\nexports.serviceWithEffect = serviceWithEffect;\nconst serviceWithStream = internal.serviceWithStream;\n/**\n * Emits a sliding window of `n` elements.\n *\n * ```ts\n * import * as Stream from \"@effect/stream/Stream\"\n * import { pipe } from \"@effect/data/Function\"\n *\n * pipe(\n *   Stream.make(1, 2, 3, 4),\n *   Stream.sliding(2),\n *   Stream.runCollect\n * )\n * // => Chunk(Chunk(1, 2), Chunk(2, 3), Chunk(3, 4))\n * ```\n *\n * @since 1.0.0\n * @category utils\n */\nexports.serviceWithStream = serviceWithStream;\nconst sliding = internal.sliding;\n/**\n * Like `sliding`, but with a configurable `stepSize` parameter.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.sliding = sliding;\nconst slidingSize = internal.slidingSize;\n/**\n * Converts an option on values into an option on errors.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.slidingSize = slidingSize;\nconst some = internal.some;\n/**\n * Extracts the optional value, or returns the given 'default'.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.some = some;\nconst someOrElse = internal.someOrElse;\n/**\n * Extracts the optional value, or fails with the given error 'e'.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.someOrElse = someOrElse;\nconst someOrFail = internal.someOrFail;\n/**\n * Splits elements based on a predicate.\n *\n * ```ts\n * import * as Stream from \"@effect/stream/Stream\"\n * import { pipe } from \"@effect/data/Function\"\n *\n * pipe(\n *   Stream.range(1, 10),\n *   Stream.split((n) => n % 4 === 0),\n *   Stream.runCollect\n * )\n * // => Chunk(Chunk(1, 2, 3), Chunk(5, 6, 7), Chunk(9))\n * ```\n *\n * @since 1.0.0\n * @category utils\n */\nexports.someOrFail = someOrFail;\nconst split = internal.split;\n/**\n * Splits elements on a delimiter and transforms the splits into desired output.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.split = split;\nconst splitOnChunk = internal.splitOnChunk;\n/**\n * Creates a single-valued pure stream.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.splitOnChunk = splitOnChunk;\nconst succeed = internal.succeed;\n/**\n * Creates a single-valued pure stream.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.succeed = succeed;\nconst sync = internal.sync;\n/**\n * Returns a lazily constructed stream.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.sync = sync;\nconst suspend = internal.suspend;\n/**\n * Takes the specified number of elements from this stream.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.suspend = suspend;\nconst take = internal.take;\n/**\n * Takes the last specified number of elements from this stream.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.take = take;\nconst takeRight = internal.takeRight;\n/**\n * Takes all elements of the stream until the specified predicate evaluates to\n * `true`.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.takeRight = takeRight;\nconst takeUntil = internal.takeUntil;\n/**\n * Takes all elements of the stream until the specified effectual predicate\n * evaluates to `true`.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.takeUntil = takeUntil;\nconst takeUntilEffect = internal.takeUntilEffect;\n/**\n * Takes all elements of the stream for as long as the specified predicate\n * evaluates to `true`.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.takeUntilEffect = takeUntilEffect;\nconst takeWhile = internal.takeWhile;\n/**\n * Adds an effect to consumption of every element of the stream.\n *\n * @since 1.0.0\n * @category sequencing\n */\nexports.takeWhile = takeWhile;\nconst tap = internal.tap;\n/**\n * Returns a stream that effectfully \"peeks\" at the failure of the stream.\n *\n * @since 1.0.0\n * @category sequencing\n */\nexports.tap = tap;\nconst tapError = internal.tapError;\n/**\n * Returns a stream that effectfully \"peeks\" at the cause of failure of the\n * stream.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.tapError = tapError;\nconst tapErrorCause = internal.tapErrorCause;\n/**\n * Sends all elements emitted by this stream to the specified sink in addition\n * to emitting them.\n *\n * @since 1.0.0\n * @category sequencing\n */\nexports.tapErrorCause = tapErrorCause;\nconst tapSink = internal.tapSink;\n/**\n * Throttles the chunks of this stream according to the given bandwidth\n * parameters using the token bucket algorithm. Allows for burst in the\n * processing of elements by allowing the token bucket to accumulate tokens up\n * to a `units + burst` threshold. Chunks that do not meet the bandwidth\n * constraints are dropped. The weight of each chunk is determined by the\n * `costFn` function.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.tapSink = tapSink;\nconst throttleEnforce = internal.throttleEnforce;\n/**\n * Like `throttleEnforce`, but with a configurable `burst` parameter.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.throttleEnforce = throttleEnforce;\nconst throttleEnforceBurst = internal.throttleEnforceBurst;\n/**\n * Throttles the chunks of this stream according to the given bandwidth\n * parameters using the token bucket algorithm. Allows for burst in the\n * processing of elements by allowing the token bucket to accumulate tokens up\n * to a `units + burst` threshold. Chunks that do not meet the bandwidth\n * constraints are dropped. The weight of each chunk is determined by the\n * `costFn` effectful function.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.throttleEnforceBurst = throttleEnforceBurst;\nconst throttleEnforceEffect = internal.throttleEnforceEffect;\n/**\n * Like `throttleEnforceEffect`, but with a configurable `burst` parameter.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.throttleEnforceEffect = throttleEnforceEffect;\nconst throttleEnforceEffectBurst = internal.throttleEnforceEffectBurst;\n/**\n * Delays the chunks of this stream according to the given bandwidth\n * parameters using the token bucket algorithm. Allows for burst in the\n * processing of elements by allowing the token bucket to accumulate tokens up\n * to a `units + burst` threshold. The weight of each chunk is determined by\n * the `costFn` function.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.throttleEnforceEffectBurst = throttleEnforceEffectBurst;\nconst throttleShape = internal.throttleShape;\n/**\n * Like `throttleShape`, but with a configurable `burst` parameter.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.throttleShape = throttleShape;\nconst throttleShapeBurst = internal.throttleShapeBurst;\n/**\n * Delays the chunks of this stream according to the given bandwidth\n * parameters using the token bucket algorithm. Allows for burst in the\n * processing of elements by allowing the token bucket to accumulate tokens up\n * to a `units + burst` threshold. The weight of each chunk is determined by\n * the `costFn` effectful function.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.throttleShapeBurst = throttleShapeBurst;\nconst throttleShapeEffect = internal.throttleShapeEffect;\n/**\n * Like `throttleShapeEffect`, but with a configurable `burst` parameter.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.throttleShapeEffect = throttleShapeEffect;\nconst throttleShapeEffectBurst = internal.throttleShapeEffectBurst;\n/**\n * A stream that emits Unit values spaced by the specified duration.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.throttleShapeEffectBurst = throttleShapeEffectBurst;\nconst tick = internal.tick;\n/**\n * Ends the stream if it does not produce a value after the specified duration.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.tick = tick;\nconst timeout = internal.timeout;\n/**\n * Fails the stream with given error if it does not produce a value after d\n * duration.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.timeout = timeout;\nconst timeoutFail = internal.timeoutFail;\n/**\n * Fails the stream with given cause if it does not produce a value after d\n * duration.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.timeoutFail = timeoutFail;\nconst timeoutFailCause = internal.timeoutFailCause;\n/**\n * Switches the stream if it does not produce a value after the specified\n * duration.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.timeoutFailCause = timeoutFailCause;\nconst timeoutTo = internal.timeoutTo;\n/**\n * Converts the stream to a scoped hub of chunks. After the scope is closed,\n * the hub will never again produce values and should be discarded.\n *\n * @macro traced\n * @since 1.0.0\n * @category destructors\n */\nexports.timeoutTo = timeoutTo;\nconst toHub = internal.toHub;\n/**\n * Returns in a scope a ZIO effect that can be used to repeatedly pull chunks\n * from the stream. The pull effect fails with None when the stream is\n * finished, or with Some error if it fails, otherwise it returns a chunk of\n * the stream's output.\n *\n * @macro traced\n * @since 1.0.0\n * @category destructors\n */\nexports.toHub = toHub;\nconst toPull = internal.toPull;\n/**\n * Converts the stream to a scoped queue of chunks. After the scope is closed,\n * the queue will never again produce values and should be discarded.\n *\n * @macro traced\n * @since 1.0.0\n * @category destructors\n */\nexports.toPull = toPull;\nconst toQueue = internal.toQueue;\n/**\n * Like `toQueue`, but with a configurable `capacity` parameter.\n *\n * @macro traced\n * @since 1.0.0\n * @category destructors\n */\nexports.toQueue = toQueue;\nconst toQueueCapacity = internal.toQueueCapacity;\n/**\n * Converts the stream to a dropping scoped queue of chunks. After the scope\n * is closed, the queue will never again produce values and should be\n * discarded.\n *\n * @macro traced\n * @since 1.0.0\n * @category destructors\n */\nexports.toQueueCapacity = toQueueCapacity;\nconst toQueueDropping = internal.toQueueDropping;\n/**\n * Like `toQueueDropping`, but with a configurable `capacity` parameter.\n *\n * @macro traced\n * @since 1.0.0\n * @category destructors\n */\nexports.toQueueDropping = toQueueDropping;\nconst toQueueDroppingCapacity = internal.toQueueDroppingCapacity;\n/**\n * Converts the stream to a scoped queue of elements. After the scope is\n * closed, the queue will never again produce values and should be discarded.\n *\n * @macro traced\n * @since 1.0.0\n * @category destructors\n */\nexports.toQueueDroppingCapacity = toQueueDroppingCapacity;\nconst toQueueOfElements = internal.toQueueOfElements;\n/**\n * Like `toQueueOfElements`, but with a configurable `capacity` parameter.\n *\n * @macro traced\n * @since 1.0.0\n * @category destructors\n */\nexports.toQueueOfElements = toQueueOfElements;\nconst toQueueOfElementsCapacity = internal.toQueueOfElementsCapacity;\n/**\n * Converts the stream to a sliding scoped queue of chunks. After the scope is\n * closed, the queue will never again produce values and should be discarded.\n *\n * @macro traced\n * @since 1.0.0\n * @category destructors\n */\nexports.toQueueOfElementsCapacity = toQueueOfElementsCapacity;\nconst toQueueSliding = internal.toQueueSliding;\n/**\n * Like `toQueueSliding`, but with a configurable `capacity` parameter.\n *\n * @macro traced\n * @since 1.0.0\n * @category destructors\n */\nexports.toQueueSliding = toQueueSliding;\nconst toQueueSlidingCapacity = internal.toQueueSlidingCapacity;\n/**\n * Converts the stream into an unbounded scoped queue. After the scope is\n * closed, the queue will never again produce values and should be discarded.\n *\n * @macro traced\n * @since 1.0.0\n * @category destructors\n */\nexports.toQueueSlidingCapacity = toQueueSlidingCapacity;\nconst toQueueUnbounded = internal.toQueueUnbounded;\n/**\n * Applies the transducer to the stream and emits its outputs.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.toQueueUnbounded = toQueueUnbounded;\nconst transduce = internal.transduce;\n/**\n * Creates a stream by peeling off the \"layers\" of a value of type `S`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.transduce = transduce;\nconst unfold = internal.unfold;\n/**\n * Creates a stream by peeling off the \"layers\" of a value of type `S`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.unfold = unfold;\nconst unfoldChunk = internal.unfoldChunk;\n/**\n * Creates a stream by effectfully peeling off the \"layers\" of a value of type\n * `S`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.unfoldChunk = unfoldChunk;\nconst unfoldChunkEffect = internal.unfoldChunkEffect;\n/**\n * Creates a stream by effectfully peeling off the \"layers\" of a value of type\n * `S`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.unfoldChunkEffect = unfoldChunkEffect;\nconst unfoldEffect = internal.unfoldEffect;\n/**\n * A stream that contains a single `Unit` value.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.unfoldEffect = unfoldEffect;\nconst unit = internal.unit;\n/**\n * Creates a stream produced from an `Effect`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.unit = unit;\nconst unwrap = internal.unwrap;\n/**\n * Creates a stream produced from a scoped `Effect`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.unwrap = unwrap;\nconst unwrapScoped = internal.unwrapScoped;\n/**\n * Updates the specified service within the context of the `Stream`.\n *\n * @since 1.0.0\n * @category context\n */\nexports.unwrapScoped = unwrapScoped;\nconst updateService = internal.updateService;\n/**\n * Returns the specified stream if the given condition is satisfied, otherwise\n * returns an empty stream.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.updateService = updateService;\nconst when = internal.when;\n/**\n * Returns the resulting stream when the given `PartialFunction` is defined\n * for the given value, otherwise returns an empty stream.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.when = when;\nconst whenCase = internal.whenCase;\n/**\n * Returns the stream when the given partial function is defined for the given\n * effectful value, otherwise returns an empty stream.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.whenCase = whenCase;\nconst whenCaseEffect = internal.whenCaseEffect;\n/**\n * Returns the stream if the given effectful condition is satisfied, otherwise\n * returns an empty stream.\n *\n * @since 1.0.0\n * @category utils\n */\nexports.whenCaseEffect = whenCaseEffect;\nconst whenEffect = internal.whenEffect;\n/**\n * Zips this stream with another point-wise and emits tuples of elements from\n * both streams.\n *\n * The new stream will end when one of the sides ends.\n *\n * @since 1.0.0\n * @category zipping\n */\nexports.whenEffect = whenEffect;\nconst zip = internal.zip;\n/**\n * Zips this stream with another point-wise and emits tuples of elements from\n * both streams.\n *\n * The new stream will end when one of the sides ends.\n *\n * @since 1.0.0\n * @category zipping\n */\nexports.zip = zip;\nconst zipFlatten = internal.zipFlatten;\n/**\n * Zips this stream with another point-wise, creating a new stream of pairs of\n * elements from both sides.\n *\n * The defaults `defaultLeft` and `defaultRight` will be used if the streams\n * have different lengths and one of the streams has ended before the other.\n *\n * @since 1.0.0\n * @category zipping\n */\nexports.zipFlatten = zipFlatten;\nconst zipAll = internal.zipAll;\n/**\n * Zips this stream with another point-wise, and keeps only elements from this\n * stream.\n *\n * The provided default value will be used if the other stream ends before\n * this one.\n *\n * @since 1.0.0\n * @category zipping\n */\nexports.zipAll = zipAll;\nconst zipAllLeft = internal.zipAllLeft;\n/**\n * Zips this stream with another point-wise, and keeps only elements from the\n * other stream.\n *\n * The provided default value will be used if this stream ends before the\n * other one.\n *\n * @since 1.0.0\n * @category zipping\n */\nexports.zipAllLeft = zipAllLeft;\nconst zipAllRight = internal.zipAllRight;\n/**\n * Zips this stream that is sorted by distinct keys and the specified stream\n * that is sorted by distinct keys to produce a new stream that is sorted by\n * distinct keys. Combines values associated with each key into a tuple,\n * using the specified values `defaultLeft` and `defaultRight` to fill in\n * missing values.\n *\n * This allows zipping potentially unbounded streams of data by key in\n * constant space but the caller is responsible for ensuring that the\n * streams are sorted by distinct keys.\n *\n * @since 1.0.0\n * @category zipping\n */\nexports.zipAllRight = zipAllRight;\nconst zipAllSortedByKey = internal.zipAllSortedByKey;\n/**\n * Zips this stream that is sorted by distinct keys and the specified stream\n * that is sorted by distinct keys to produce a new stream that is sorted by\n * distinct keys. Keeps only values from this stream, using the specified\n * value `default` to fill in missing values.\n *\n * This allows zipping potentially unbounded streams of data by key in\n * constant space but the caller is responsible for ensuring that the\n * streams are sorted by distinct keys.\n *\n * @since 1.0.0\n * @category zipping\n */\nexports.zipAllSortedByKey = zipAllSortedByKey;\nconst zipAllSortedByKeyLeft = internal.zipAllSortedByKeyLeft;\n/**\n * Zips this stream that is sorted by distinct keys and the specified stream\n * that is sorted by distinct keys to produce a new stream that is sorted by\n * distinct keys. Keeps only values from that stream, using the specified\n * value `default` to fill in missing values.\n *\n * This allows zipping potentially unbounded streams of data by key in\n * constant space but the caller is responsible for ensuring that the\n * streams are sorted by distinct keys.\n *\n * @since 1.0.0\n * @category zipping\n */\nexports.zipAllSortedByKeyLeft = zipAllSortedByKeyLeft;\nconst zipAllSortedByKeyRight = internal.zipAllSortedByKeyRight;\n/**\n * Zips this stream that is sorted by distinct keys and the specified stream\n * that is sorted by distinct keys to produce a new stream that is sorted by\n * distinct keys. Uses the functions `left`, `right`, and `both` to handle\n * the cases where a key and value exist in this stream, that stream, or\n * both streams.\n *\n * This allows zipping potentially unbounded streams of data by key in\n * constant space but the caller is responsible for ensuring that the\n * streams are sorted by distinct keys.\n *\n * @since 1.0.0\n * @category zipping\n */\nexports.zipAllSortedByKeyRight = zipAllSortedByKeyRight;\nconst zipAllSortedByKeyWith = internal.zipAllSortedByKeyWith;\n/**\n * Zips this stream with another point-wise. The provided functions will be\n * used to create elements for the composed stream.\n *\n * The functions `left` and `right` will be used if the streams have different\n * lengths and one of the streams has ended before the other.\n *\n * @since 1.0.0\n * @category zipping\n */\nexports.zipAllSortedByKeyWith = zipAllSortedByKeyWith;\nconst zipAllWith = internal.zipAllWith;\n/**\n * Zips the two streams so that when a value is emitted by either of the two\n * streams, it is combined with the latest value from the other stream to\n * produce a result.\n *\n * Note: tracking the latest value is done on a per-chunk basis. That means\n * that emitted elements that are not the last value in chunks will never be\n * used for zipping.\n *\n * @since 1.0.0\n * @category zipping\n */\nexports.zipAllWith = zipAllWith;\nconst zipLatest = internal.zipLatest;\n/**\n * Zips the two streams so that when a value is emitted by either of the two\n * streams, it is combined with the latest value from the other stream to\n * produce a result.\n *\n * Note: tracking the latest value is done on a per-chunk basis. That means\n * that emitted elements that are not the last value in chunks will never be\n * used for zipping.\n *\n * @since 1.0.0\n * @category zipping\n */\nexports.zipLatest = zipLatest;\nconst zipLatestWith = internal.zipLatestWith;\n/**\n * Zips this stream with another point-wise, but keeps only the outputs of\n * this stream.\n *\n * The new stream will end when one of the sides ends.\n *\n * @since 1.0.0\n * @category zipping\n */\nexports.zipLatestWith = zipLatestWith;\nconst zipLeft = internal.zipLeft;\n/**\n * Zips this stream with another point-wise, but keeps only the outputs of the\n * other stream.\n *\n * The new stream will end when one of the sides ends.\n *\n * @since 1.0.0\n * @category zipping\n */\nexports.zipLeft = zipLeft;\nconst zipRight = internal.zipRight;\n/**\n * Zips this stream with another point-wise and applies the function to the\n * paired elements.\n *\n * The new stream will end when one of the sides ends.\n *\n * @since 1.0.0\n * @category zipping\n */\nexports.zipRight = zipRight;\nconst zipWith = internal.zipWith;\n/**\n * Zips this stream with another point-wise and applies the function to the\n * paired elements.\n *\n * The new stream will end when one of the sides ends.\n *\n * @since 1.0.0\n * @category zipping\n */\nexports.zipWith = zipWith;\nconst zipWithChunks = internal.zipWithChunks;\n/**\n * Zips each element with the next element if present.\n *\n * @since 1.0.0\n * @category zipping\n */\nexports.zipWithChunks = zipWithChunks;\nconst zipWithNext = internal.zipWithNext;\n/**\n * Zips each element with the previous element. Initially accompanied by\n * `None`.\n *\n * @since 1.0.0\n * @category zipping\n */\nexports.zipWithNext = zipWithNext;\nconst zipWithPrevious = internal.zipWithPrevious;\n/**\n * Zips each element with both the previous and next element.\n *\n * @since 1.0.0\n * @category zipping\n */\nexports.zipWithPrevious = zipWithPrevious;\nconst zipWithPreviousAndNext = internal.zipWithPreviousAndNext;\n/**\n * Zips this stream together with the index of elements.\n *\n * @since 1.0.0\n * @category zipping\n */\nexports.zipWithPreviousAndNext = zipWithPreviousAndNext;\nconst zipWithIndex = internal.zipWithIndex;\nexports.zipWithIndex = zipWithIndex;\n//# sourceMappingURL=Stream.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.match = exports.isRight = exports.isLeft = exports.isEither = exports.isBoth = exports.Right = exports.Left = exports.Either = exports.Both = void 0;\nvar internal = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/stream/internal/stream/haltStrategy\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/**\n * @since 1.0.0\n */\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nconst Left = internal.Left;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexports.Left = Left;\nconst Right = internal.Right;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexports.Right = Right;\nconst Both = internal.Both;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexports.Both = Both;\nconst Either = internal.Either;\n/**\n * @since 1.0.0\n * @category refinements\n */\nexports.Either = Either;\nconst isLeft = internal.isLeft;\n/**\n * @since 1.0.0\n * @category refinements\n */\nexports.isLeft = isLeft;\nconst isRight = internal.isRight;\n/**\n * @since 1.0.0\n * @category refinements\n */\nexports.isRight = isRight;\nconst isBoth = internal.isBoth;\n/**\n * @since 1.0.0\n * @category refinements\n */\nexports.isBoth = isBoth;\nconst isEither = internal.isEither;\n/**\n * @since 1.0.0\n * @category folding\n */\nexports.isEither = isEither;\nconst match = internal.match;\nexports.match = match;\n//# sourceMappingURL=HaltStrategy.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.zipRight = exports.zipParRight = exports.zipParLeft = exports.zipPar = exports.zipLeft = exports.zip = exports.writeChunk = exports.writeAll = exports.updateService = exports.unwrapScoped = exports.unwrap = exports.toQueue = exports.toPull = exports.toHub = exports.serviceWithEffect = exports.serviceWithChannel = exports.serviceWith = exports.service = exports.scoped = exports.runDrain = exports.runCollect = exports.run = exports.repeated = exports.read = exports.provideSomeLayer = exports.provideService = exports.provideLayer = exports.pipeToOrFail = exports.orElse = exports.orDieWith = exports.orDie = exports.never = exports.mergeWith = exports.mergeOutWith = exports.mergeOut = exports.mergeMapStrategy = exports.mergeMapBufferStrategy = exports.mergeMapBuffer = exports.mergeMap = exports.mergeAllWith = exports.mergeAllUnboundedWith = exports.mergeAllUnbounded = exports.mergeAll = exports.mapOutEffectPar = exports.mapOutEffect = exports.mapOut = exports.mapErrorCause = exports.mapError = exports.mapEffect = exports.map = exports.isChannelException = exports.interruptWhenDeferred = exports.interruptWhen = exports.identityChannel = exports.fromQueue = exports.fromOption = exports.fromInput = exports.fromHubScoped = exports.fromHub = exports.fromEither = exports.foldChannel = exports.flatten = exports.ensuring = exports.emitCollect = exports.drain = exports.doneCollect = exports.contramapInEffect = exports.contramapIn = exports.contramapErrorEffect = exports.contramapError = exports.contramapEffect = exports.contramapContext = exports.contramap = exports.contextWithEffect = exports.contextWithChannel = exports.contextWith = exports.context = exports.concatOut = exports.concatMap = exports.collect = exports.catchAll = exports.bufferChunk = exports.buffer = exports.asUnit = exports.as = exports.acquireUseRelease = exports.ChannelExceptionTypeId = exports.ChannelException = void 0;\nvar Chunk = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Chunk\"));\nvar Context = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Context\"));\nvar Either = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Either\"));\nvar Equal = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Equal\"));\nvar _Function = /*#__PURE__*/require(\"@effect/data/Function\");\nvar Option = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Option\"));\nvar Cause = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Cause\"));\nvar Debug = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Debug\"));\nvar Deferred = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Deferred\"));\nvar Effect = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Effect\"));\nvar Exit = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Exit\"));\nvar Fiber = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Fiber\"));\nvar Hub = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Hub\"));\nvar Layer = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Layer\"));\nvar Queue = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Queue\"));\nvar Ref = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Ref\"));\nvar Scope = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Scope\"));\nvar executor = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/stream/internal/channel/channelExecutor\"));\nvar mergeDecision = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/stream/internal/channel/mergeDecision\"));\nvar mergeState = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/stream/internal/channel/mergeState\"));\nvar _mergeStrategy = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/stream/internal/channel/mergeStrategy\"));\nvar singleProducerAsyncInput = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/stream/internal/channel/singleProducerAsyncInput\"));\nvar core = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/stream/internal/core\"));\nvar ChannelStateOpCodes = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/stream/internal/opCodes/channelState\"));\nvar MergeDecisionOpCodes = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/stream/internal/opCodes/mergeDecision\"));\nvar MergeStateOpCodes = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/stream/internal/opCodes/mergeState\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/** @internal */\nconst acquireUseRelease = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => (acquire, use, release) => core.flatMap(core.fromEffect(Ref.make(() => Effect.unit())), ref => core.ensuringWith(exit => Effect.flatMap(Ref.get(ref), f => f(exit)))(core.flatMap(restore(use))(core.fromEffect(Effect.uninterruptible(Effect.tap(acquire, a => Ref.set(ref, exit => restore(release)(a, exit)))))))).traced(trace));\n/** @internal */\nexports.acquireUseRelease = acquireUseRelease;\nconst as = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, value) => map(self, () => value).traced(trace));\n/** @internal */\nexports.as = as;\nconst asUnit = /*#__PURE__*/Debug.methodWithTrace(trace => self => map(self, _Function.constVoid).traced(trace));\n/** @internal */\nexports.asUnit = asUnit;\nconst buffer = /*#__PURE__*/Debug.methodWithTrace(trace => (empty, isEmpty, ref) => core.suspend(() => {\n  const doBuffer = (empty, isEmpty, ref) => unwrap(Ref.modify(ref, inElem => isEmpty(inElem) ? [core.readWith(input => core.flatMap(core.write(input), () => doBuffer(empty, isEmpty, ref)), error => core.fail(error), done => core.succeedNow(done)), inElem] : [core.flatMap(core.write(inElem), () => doBuffer(empty, isEmpty, ref)), empty]));\n  return doBuffer(empty, isEmpty, ref);\n}).traced(trace));\n/** @internal */\nexports.buffer = buffer;\nconst bufferChunk = /*#__PURE__*/Debug.methodWithTrace(trace => ref => buffer(Chunk.empty(), Chunk.isEmpty, ref).traced(trace));\n/** @internal */\nexports.bufferChunk = bufferChunk;\nconst catchAll = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => core.catchAllCause(self, cause => Either.match(Cause.failureOrCause(cause), restore(f), core.failCause)).traced(trace));\n/** @internal */\nexports.catchAll = catchAll;\nconst concatMap = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => core.concatMapWith(self, restore(f), () => void 0, () => void 0).traced(trace));\n/** @internal */\nexports.concatMap = concatMap;\nconst collect = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, pf) => {\n  const collector = core.readWith(out => Option.match(restore(pf)(out), () => collector, out2 => core.flatMap(core.write(out2), () => collector)), core.fail, core.succeedNow);\n  return core.pipeTo(self, collector).traced(trace);\n});\n/** @internal */\nexports.collect = collect;\nconst concatOut = /*#__PURE__*/Debug.methodWithTrace(trace => self => core.concatAll(self).traced(trace));\n/** @internal */\nexports.concatOut = concatOut;\nconst contramap = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => {\n  const reader = core.readWith(inElem => core.flatMap(core.write(inElem), () => reader), core.fail, done => core.succeedNow(restore(f)(done)));\n  return core.pipeTo(reader, self).traced(trace);\n});\n/** @internal */\nexports.contramap = contramap;\nconst contramapEffect = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => {\n  const reader = core.readWith(inElem => core.flatMap(core.write(inElem), () => reader), core.fail, done => core.fromEffect(restore(f)(done)));\n  return core.pipeTo(reader, self).traced(trace);\n});\n/** @internal */\nexports.contramapEffect = contramapEffect;\nconst contramapError = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => {\n  const reader = core.readWith(inElem => core.flatMap(core.write(inElem), () => reader), error => core.fail(restore(f)(error)), core.succeedNow);\n  return core.pipeTo(reader, self).traced(trace);\n});\n/** @internal */\nexports.contramapError = contramapError;\nconst contramapErrorEffect = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => {\n  const reader = core.readWith(inElem => core.flatMap(core.write(inElem), () => reader), error => core.fromEffect(restore(f)(error)), core.succeedNow);\n  return core.pipeTo(reader, self).traced(trace);\n});\n/** @internal */\nexports.contramapErrorEffect = contramapErrorEffect;\nconst contramapIn = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => {\n  const reader = core.readWith(inElem => core.flatMap(core.write(restore(f)(inElem)), () => reader), core.fail, core.succeedNow);\n  return core.pipeTo(reader, self).traced(trace);\n});\nexports.contramapIn = contramapIn;\nconst contramapInEffect = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => {\n  const reader = core.readWith(inElem => core.flatMap(core.flatMap(core.fromEffect(restore(f)(inElem)), core.write), () => reader), core.fail, core.succeedNow);\n  return core.pipeTo(reader, self).traced(trace);\n});\n/** @internal */\nexports.contramapInEffect = contramapInEffect;\nconst doneCollect = /*#__PURE__*/Debug.methodWithTrace(trace => self => core.suspend(() => {\n  const builder = [];\n  return core.flatMap(outDone => core.succeed([Chunk.unsafeFromArray(builder), outDone]))(core.pipeTo(self, doneCollectReader(builder))).traced(trace);\n}));\n/** @internal */\nexports.doneCollect = doneCollect;\nconst doneCollectReader = builder => {\n  return core.readWith(outElem => core.flatMap(core.sync(() => {\n    builder.push(outElem);\n  }), () => doneCollectReader(builder)), core.fail, core.succeed);\n};\n/** @internal */\nconst drain = /*#__PURE__*/Debug.methodWithTrace(trace => self => {\n  const drainer = core.readWithCause(() => drainer, core.failCause, core.succeed);\n  return core.pipeTo(self, drainer).traced(trace);\n});\n/** @internal */\nexports.drain = drain;\nconst emitCollect = /*#__PURE__*/Debug.methodWithTrace(trace => self => core.flatMap(doneCollect(self), core.write).traced(trace));\n/** @internal */\nexports.emitCollect = emitCollect;\nconst ensuring = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, finalizer) => core.ensuringWith(self, () => finalizer).traced(trace));\n/** @internal */\nexports.ensuring = ensuring;\nconst context = /*#__PURE__*/Debug.methodWithTrace(trace => () => core.fromEffect(Effect.context()).traced(trace));\n/** @internal */\nexports.context = context;\nconst contextWith = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => f => map(context(), restore(f)).traced(trace));\n/** @internal */\nexports.contextWith = contextWith;\nconst contextWithChannel = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => f => core.flatMap(context(), restore(f)).traced(trace));\n/** @internal */\nexports.contextWithChannel = contextWithChannel;\nconst contextWithEffect = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => f => mapEffect(context(), restore(f)).traced(trace));\n/** @internal */\nexports.contextWithEffect = contextWithEffect;\nconst flatten = /*#__PURE__*/Debug.methodWithTrace(trace => self => core.flatMap(self, _Function.identity).traced(trace));\n/** @internal */\nexports.flatten = flatten;\nconst foldChannel = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (self, onError, onSuccess) => core.foldCauseChannel(self, cause => {\n  const either = Cause.failureOrCause(cause);\n  switch (either._tag) {\n    case \"Left\":\n      {\n        return restore(onError)(either.left);\n      }\n    case \"Right\":\n      {\n        return core.failCause(either.right);\n      }\n  }\n}, restore(onSuccess)).traced(trace));\n/** @internal */\nexports.foldChannel = foldChannel;\nconst fromEither = /*#__PURE__*/Debug.methodWithTrace(trace => either => core.suspend(() => Either.match(either, core.fail, core.succeed)).traced(trace));\n/** @internal */\nexports.fromEither = fromEither;\nconst fromInput = /*#__PURE__*/Debug.methodWithTrace(trace => input => unwrap(input.takeWith(core.failCause, elem => core.flatMap(core.write(elem), () => fromInput(input)), core.succeed)).traced(trace));\n/** @internal */\nexports.fromInput = fromInput;\nconst fromHub = /*#__PURE__*/Debug.methodWithTrace(trace => hub => unwrapScoped(Effect.map(Hub.subscribe(hub), fromQueue)).traced(trace));\n/** @internal */\nexports.fromHub = fromHub;\nconst fromHubScoped = /*#__PURE__*/Debug.methodWithTrace(trace => hub => Effect.map(Hub.subscribe(hub), fromQueue).traced(trace));\n/** @internal */\nexports.fromHubScoped = fromHubScoped;\nconst fromOption = /*#__PURE__*/Debug.methodWithTrace(trace => option => core.suspend(() => Option.match(option, () => core.fail(Option.none()), core.succeed)).traced(trace));\n/** @internal */\nexports.fromOption = fromOption;\nconst fromQueue = /*#__PURE__*/Debug.methodWithTrace(trace => queue => core.suspend(() => fromQueueInternal(queue)).traced(trace));\n/** @internal */\nexports.fromQueue = fromQueue;\nconst fromQueueInternal = queue => core.flatMap(Either.match(Exit.match(core.failCause, core.succeedNow), elem => core.flatMap(() => fromQueueInternal(queue))(core.write(elem))))(core.fromEffect(Queue.take(queue)));\n/** @internal */\nconst identityChannel = /*#__PURE__*/Debug.methodWithTrace(trace => () => core.readWith(input => core.flatMap(core.write(input), () => identityChannel()), core.fail, core.succeedNow).traced(trace));\n/** @internal */\nexports.identityChannel = identityChannel;\nconst interruptWhen = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, effect) => mergeWith(self, core.fromEffect(effect), selfDone => mergeDecision.Done(Effect.done(selfDone)), effectDone => mergeDecision.Done(Effect.done(effectDone))).traced(trace));\n/** @internal */\nexports.interruptWhen = interruptWhen;\nconst interruptWhenDeferred = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, deferred) => interruptWhen(self, Deferred.await(deferred)).traced(trace));\n/** @internal */\nexports.interruptWhenDeferred = interruptWhenDeferred;\nconst map = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => core.flatMap(self, a => core.sync(() => restore(f)(a))).traced(trace));\n/** @internal */\nexports.map = map;\nconst mapEffect = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => core.flatMap(self, z => core.fromEffect(restore(f)(z))).traced(trace));\n/** @internal */\nexports.mapEffect = mapEffect;\nconst mapError = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => mapErrorCause(self, Cause.map(restore(f))).traced(trace));\n/** @internal */\nexports.mapError = mapError;\nconst mapErrorCause = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => core.catchAllCause(self, cause => core.failCause(restore(f)(cause))).traced(trace));\n/** @internal */\nexports.mapErrorCause = mapErrorCause;\nconst mapOut = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => {\n  const reader = core.readWith(outElem => core.flatMap(core.write(restore(f)(outElem)), () => reader), core.fail, core.succeedNow);\n  return core.pipeTo(self, reader).traced(trace);\n});\n/** @internal */\nexports.mapOut = mapOut;\nconst mapOutEffect = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => {\n  const reader = core.readWith(outElem => core.flatMap(() => reader)(core.flatMap(core.write)(core.fromEffect(restore(f)(outElem)))), core.fail, core.succeedNow);\n  return core.pipeTo(self, reader).traced(trace);\n});\n/** @internal */\nexports.mapOutEffect = mapOutEffect;\nconst mapOutEffectPar = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restoreTrace) => (self, f, n) => unwrapScoped(Effect.map(queue => {\n  const consumer = unwrap(Effect.matchCause(Effect.flatten(Queue.take(queue)), core.failCause, Either.match(core.succeedNow, outElem => core.flatMap(core.write(outElem), () => consumer))));\n  return consumer;\n})(Effect.gen(function* ($) {\n  const queue = yield* $(Effect.acquireRelease(Queue.bounded(n), Queue.shutdown));\n  const errorSignal = yield* $(Deferred.make());\n  const withPermits = n === Number.POSITIVE_INFINITY ? _ => _Function.identity : (yield* $(Effect.makeSemaphore(n))).withPermits;\n  const pull = yield* $(toPull(self));\n  yield* $(Effect.forkScoped(Effect.interruptible(Effect.forever(Effect.matchCauseEffect(pull, cause => Queue.offer(queue, Effect.failCause(cause)), either => Either.match(either, outDone => {\n    const lock = withPermits(n);\n    return Effect.zipRight(Effect.interruptible(lock(Effect.unit())), Effect.asUnit(Queue.offer(queue, Effect.succeed(Either.left(outDone)))));\n  }, outElem => Effect.gen(function* ($) {\n    const deferred = yield* $(Deferred.make());\n    const latch = yield* $(Deferred.make());\n    yield* $(Effect.asUnit(Queue.offer(queue, Effect.map(Deferred.await(deferred), Either.right))));\n    yield* $(Effect.forkScoped(withPermits(1)(Effect.zipRight(Effect.intoDeferred(deferred)(Effect.tapErrorCause(cause => Deferred.failCause(errorSignal, cause))(Effect.uninterruptibleMask(restore => Effect.flatMap(Effect.done)(Effect.raceFirst(Effect.exit(restore(restoreTrace(f)(outElem))))(Effect.exit(restore(Deferred.await(errorSignal)))))))))(Deferred.succeed(latch, void 0)))));\n    yield* $(Deferred.await(latch));\n  })))))));\n  return queue;\n}))).traced(trace));\n/** @internal */\nexports.mapOutEffectPar = mapOutEffectPar;\nconst mergeAll = /*#__PURE__*/Debug.methodWithTrace(trace => (n, bufferSize = 16, mergeStrategy = _mergeStrategy.BackPressure()) => {\n  return channels => mergeAllWith(n, bufferSize, mergeStrategy)(channels, _Function.constVoid).traced(trace);\n});\n/** @internal */\nexports.mergeAll = mergeAll;\nconst mergeAllUnbounded = /*#__PURE__*/Debug.methodWithTrace(trace => channels => mergeAllWith(Number.POSITIVE_INFINITY)(channels, _Function.constVoid).traced(trace));\n/** @internal */\nexports.mergeAllUnbounded = mergeAllUnbounded;\nconst mergeAllUnboundedWith = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => (channels, f) => mergeAllWith(Number.POSITIVE_INFINITY)(channels, restore(f)).traced(trace));\n/** @internal */\nexports.mergeAllUnboundedWith = mergeAllUnboundedWith;\nconst mergeAllWith = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => (n, bufferSize = 16, mergeStrategy = _mergeStrategy.BackPressure()) => (channels, f) => unwrapScoped(Effect.map(([queue, input]) => {\n  const consumer = unwrap(Effect.matchCause(core.failCause, Either.match(core.succeedNow, outElem => core.flatMap(core.write(outElem), () => consumer)))(Effect.flatten(Queue.take(queue))));\n  return core.embedInput(consumer, input);\n})(Effect.gen(function* ($) {\n  const input = yield* $(singleProducerAsyncInput.make());\n  const queueReader = fromInput(input);\n  const queue = yield* $(Effect.acquireRelease(Queue.bounded(bufferSize), Queue.shutdown));\n  const cancelers = yield* $(Effect.acquireRelease(Queue.unbounded(), Queue.shutdown));\n  const lastDone = yield* $(Ref.make(Option.none()));\n  const errorSignal = yield* $(Deferred.make());\n  const withPermits = n === Number.POSITIVE_INFINITY ? _ => _Function.identity : (yield* $(Effect.makeSemaphore(n))).withPermits;\n  const pull = yield* $(toPull(channels));\n  const evaluatePull = pull => Effect.catchAllCause(cause => Cause.isInterrupted(cause) ? Effect.failCause(cause) : Effect.asUnit(Effect.zipRight(Deferred.succeed(errorSignal, void 0))(Queue.offer(queue, Effect.failCause(cause)))))(Effect.flatMap(Option.match(() => Effect.unit(), outDone => Ref.update(lastDone, Option.match(() => Option.some(outDone), lastDone => Option.some(f(lastDone, outDone))))))(Effect.repeatUntil(Option.isSome)(Effect.flatMap(Either.match(done => Effect.succeed(Option.some(done)), outElem => Effect.as(Option.none())(Queue.offer(queue, Effect.succeed(Either.right(outElem))))))(pull))));\n  yield* $(Effect.forkScoped(Effect.repeatWhileEquals(true)(Effect.matchCauseEffect(pull, cause => Effect.zipRight(Effect.succeed(false))(Queue.offer(queue, Effect.failCause(cause))), Either.match(outDone => Effect.raceWith(withPermits(n)(Effect.unit()), (_, permitAcquisition) => Effect.as(false)(Fiber.interrupt(permitAcquisition)), (_, failureAwait) => Effect.zipRight(Effect.as(false)(Effect.flatMap(Option.match(() => Queue.offer(queue, Effect.succeed(Either.left(outDone))), lastDone => Queue.offer(queue, Effect.succeed(Either.left(restore(f)(lastDone, outDone))))))(Ref.get(lastDone))))(Fiber.interrupt(failureAwait)))(Deferred.await(errorSignal)), channel => _mergeStrategy.match(() => Effect.gen(function* ($) {\n    const latch = yield* $(Deferred.make());\n    const raceEffects = Effect.scoped(Effect.flatMap(pull => Effect.raceAwait(Deferred.await(errorSignal))(evaluatePull(pull)))(toPull(core.pipeTo(channel)(queueReader))));\n    yield* $(Effect.forkScoped(withPermits(1)(Effect.zipRight(raceEffects)(Deferred.succeed(latch, void 0)))));\n    yield* $(Deferred.await(latch));\n    const errored = yield* $(Deferred.isDone(errorSignal));\n    return !errored;\n  }), () => Effect.gen(function* ($) {\n    const canceler = yield* $(Deferred.make());\n    const latch = yield* $(Deferred.make());\n    const size = yield* $(Queue.size(cancelers));\n    yield* $(Effect.when(() => size >= n)(Effect.flatMap(_ => Deferred.succeed(_, void 0))(Queue.take(cancelers))));\n    yield* $(Queue.offer(cancelers, canceler));\n    const raceEffects = Effect.scoped(Effect.flatMap(pull => Effect.raceAwait(Deferred.await(canceler))(Effect.raceAwait(Deferred.await(errorSignal))(evaluatePull(pull))))(toPull(core.pipeTo(channel)(queueReader))));\n    yield* $(Effect.forkScoped(withPermits(1)(Effect.zipRight(raceEffects)(Deferred.succeed(latch, void 0)))));\n    yield* $(Deferred.await(latch));\n    const errored = yield* $(Deferred.isDone(errorSignal));\n    return !errored;\n  }))(mergeStrategy))))));\n  return [queue, input];\n}))).traced(trace));\n/** @internal */\nexports.mergeAllWith = mergeAllWith;\nconst mergeMap = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (self, f, n) => mergeMapBufferStrategy(self, restore(f), n, 16, _mergeStrategy.BackPressure()).traced(trace));\n/** @internal */\nexports.mergeMap = mergeMap;\nconst mergeMapBuffer = /*#__PURE__*/Debug.dualWithTrace(4, (trace, restore) => (self, f, n, bufferSize) => mergeMapBufferStrategy(self, restore(f), n, bufferSize, _mergeStrategy.BackPressure()).traced(trace));\n/** @internal */\nexports.mergeMapBuffer = mergeMapBuffer;\nconst mergeMapStrategy = /*#__PURE__*/Debug.dualWithTrace(4, (trace, restore) => (self, f, n, mergeStrategy) => mergeMapBufferStrategy(self, restore(f), n, 16, mergeStrategy).traced(trace));\n/** @internal */\nexports.mergeMapStrategy = mergeMapStrategy;\nconst mergeMapBufferStrategy = /*#__PURE__*/Debug.dualWithTrace(5, (trace, restore) => (self, f, n, bufferSize, mergeStrategy) => mergeAll(n, bufferSize, mergeStrategy)(mapOut(self, restore(f))).traced(trace));\n/** @internal */\nexports.mergeMapBufferStrategy = mergeMapBufferStrategy;\nconst mergeOut = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, n) => mergeAll(n)(mapOut(self, _Function.identity)).traced(trace));\n/** @internal */\nexports.mergeOut = mergeOut;\nconst mergeOutWith = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (self, n, f) => mergeAllWith(n)(mapOut(self, _Function.identity), restore(f)).traced(trace));\n/** @internal */\nexports.mergeOutWith = mergeOutWith;\nconst mergeWith = /*#__PURE__*/Debug.dualWithTrace(4, (trace, restore) => (self, that, leftDone, rightDone) => unwrapScoped(Effect.flatMap(input => {\n  const queueReader = fromInput(input);\n  return Effect.map(Effect.zip(toPull(core.pipeTo(queueReader, self)), toPull(core.pipeTo(queueReader, that))), ([pullL, pullR]) => {\n    const handleSide = (exit, fiber, pull) => (done, both, single) => {\n      const onDecision = decision => {\n        const op = decision;\n        if (op._tag === MergeDecisionOpCodes.OP_DONE) {\n          return Effect.succeed(core.fromEffect(Effect.zipRight(Fiber.interrupt(fiber), op.effect)));\n        }\n        return Effect.map(Fiber.await(fiber), Exit.match(cause => core.fromEffect(op.f(Exit.failCause(cause))), Either.match(done => core.fromEffect(op.f(Exit.succeed(done))), elem => zipRight(core.write(elem), go(single(op.f))))));\n      };\n      return Exit.match(exit, cause => onDecision(done(Exit.failCause(cause))), Either.match(z => onDecision(done(Exit.succeed(z))), elem => Effect.succeed(core.flatMap(core.write(elem), () => core.flatMap(core.fromEffect(Effect.forkDaemon(pull)), leftFiber => go(both(leftFiber, fiber)))))));\n    };\n    const go = state => {\n      switch (state._tag) {\n        case MergeStateOpCodes.OP_BOTH_RUNNING:\n          {\n            const leftJoin = Effect.interruptible(Fiber.join(state.left));\n            const rightJoin = Effect.interruptible(Fiber.join(state.right));\n            return unwrap(Effect.raceWith(leftJoin, rightJoin, (leftExit, rf) => Effect.zipRight(Fiber.interrupt(rf), handleSide(leftExit, state.right, pullL)(restore(leftDone), mergeState.BothRunning, f => mergeState.LeftDone(f))), (rightExit, lf) => Effect.zipRight(Fiber.interrupt(lf), handleSide(rightExit, state.left, pullR)(restore(rightDone), (left, right) => mergeState.BothRunning(right, left), f => mergeState.RightDone(f)))));\n          }\n        case MergeStateOpCodes.OP_LEFT_DONE:\n          {\n            return unwrap(Effect.map(Effect.exit(pullR), Exit.match(cause => core.fromEffect(state.f(Exit.failCause(cause))), Either.match(done => core.fromEffect(state.f(Exit.succeed(done))), elem => core.flatMap(core.write(elem), () => go(mergeState.LeftDone(state.f)))))));\n          }\n        case MergeStateOpCodes.OP_RIGHT_DONE:\n          {\n            return unwrap(Effect.map(Effect.exit(pullL), Exit.match(cause => core.fromEffect(state.f(Exit.failCause(cause))), Either.match(done => core.fromEffect(state.f(Exit.succeed(done))), elem => core.flatMap(core.write(elem), () => go(mergeState.RightDone(state.f)))))));\n          }\n      }\n    };\n    return core.embedInput(input)(core.flatMap(go)(core.fromEffect(Effect.zipWith(Effect.forkDaemon(pullL), Effect.forkDaemon(pullR), (left, right) => mergeState.BothRunning(left, right)))));\n  });\n})(singleProducerAsyncInput.make())).traced(trace));\n/** @internal */\nexports.mergeWith = mergeWith;\nconst never = /*#__PURE__*/Debug.methodWithTrace(trace => () => core.fromEffect(Effect.never()).traced(trace));\n/** @internal */\nexports.never = never;\nconst orDie = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, error) => orDieWith(self, restore(error)).traced(trace));\n/** @internal */\nexports.orDie = orDie;\nconst orDieWith = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => catchAll(self, e => {\n  throw restore(f)(e);\n}).traced(trace));\n/** @internal */\nexports.orDieWith = orDieWith;\nconst orElse = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, that) => catchAll(self, that).traced(trace));\n/** @internal */\nexports.orElse = orElse;\nconst pipeToOrFail = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, that) => core.suspend(() => {\n  let channelException = undefined;\n  const reader = core.readWith(outElem => core.flatMap(core.write(outElem), () => reader), outErr => {\n    channelException = ChannelException(outErr);\n    return core.failCause(Cause.die(channelException));\n  }, core.succeedNow);\n  const writer = core.readWithCause(outElem => core.flatMap(() => writer)(core.write(outElem)), annotatedCause => {\n    const unannotated = Cause.unannotate(annotatedCause);\n    return Cause.isDieType(unannotated) && isChannelException(unannotated.defect) && Equal.equals(unannotated.defect, channelException) ? core.fail(unannotated.defect.error) : core.failCause(annotatedCause);\n  }, core.succeedNow);\n  return core.pipeTo(core.pipeTo(core.pipeTo(self, reader), that), writer).traced(trace);\n}));\n/** @internal */\nexports.pipeToOrFail = pipeToOrFail;\nconst provideService = /*#__PURE__*/Debug.dualWithTrace(3, trace => (self, tag, service) => {\n  return core.flatMap(context(), context => core.provideContext(self, Context.add(context, tag, service))).traced(trace);\n});\n/** @internal */\nexports.provideService = provideService;\nconst provideLayer = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, layer) => unwrapScoped(Effect.map(Layer.build(layer), env => core.provideContext(self, env))).traced(trace));\n/** @internal */\nexports.provideLayer = provideLayer;\nconst contramapContext = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => contextWithChannel(context => core.provideContext(self, restore(f)(context))).traced(trace));\n/** @internal */\nexports.contramapContext = contramapContext;\nconst provideSomeLayer = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, layer) =>\n// @ts-expect-error\nprovideLayer(self, Layer.merge(Layer.context(), layer)).traced(trace));\n/** @internal */\nexports.provideSomeLayer = provideSomeLayer;\nconst read = /*#__PURE__*/Debug.methodWithTrace(trace => () => core.readOrFail(Option.none()).traced(trace));\n/** @internal */\nexports.read = read;\nconst repeated = /*#__PURE__*/Debug.methodWithTrace(trace => self => core.flatMap(self, () => repeated(self)).traced(trace));\n/** @internal */\nexports.repeated = repeated;\nconst run = /*#__PURE__*/Debug.methodWithTrace(trace => self => Effect.scoped(executor.runScoped(self)).traced(trace));\n/** @internal */\nexports.run = run;\nconst runCollect = /*#__PURE__*/Debug.methodWithTrace(trace => self => executor.run(core.collectElements(self)).traced(trace));\n/** @internal */\nexports.runCollect = runCollect;\nconst runDrain = /*#__PURE__*/Debug.methodWithTrace(trace => self => executor.run(drain(self)).traced(trace));\n/** @internal */\nexports.runDrain = runDrain;\nconst scoped = /*#__PURE__*/Debug.methodWithTrace(trace => effect => unwrap(Effect.uninterruptibleMask(restore => Effect.map(Scope.make(), scope => core.acquireReleaseOut(Effect.tapErrorCause(restore(Scope.extend(scope)(effect)), cause => Scope.close(scope, Exit.failCause(cause))), (_, exit) => Scope.close(scope, exit))))).traced(trace));\n/** @internal */\nexports.scoped = scoped;\nconst service = /*#__PURE__*/Debug.methodWithTrace(trace => tag => core.fromEffect(Effect.service(tag)).traced(trace));\n/** @internal */\nexports.service = service;\nconst serviceWith = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => tag => f => map(service(tag), restore(f)).traced(trace));\n/** @internal */\nexports.serviceWith = serviceWith;\nconst serviceWithChannel = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => tag => f => core.flatMap(service(tag), restore(f)).traced(trace));\n/** @internal */\nexports.serviceWithChannel = serviceWithChannel;\nconst serviceWithEffect = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => tag => f => mapEffect(service(tag), restore(f)).traced(trace));\n/** @internal */\nexports.serviceWithEffect = serviceWithEffect;\nconst toHub = /*#__PURE__*/Debug.methodWithTrace(trace => hub => toQueue(hub).traced(trace));\n/** @internal */\nexports.toHub = toHub;\nconst toPull = /*#__PURE__*/Debug.methodWithTrace(trace => self => Effect.map(Effect.acquireRelease(Effect.sync(() => new executor.ChannelExecutor(self, void 0, _Function.identity)), (exec, exit) => {\n  const finalize = exec.close(exit);\n  return finalize === undefined ? Effect.unit() : finalize;\n}), exec => Effect.suspend(() => interpretToPull(exec.run(), exec))).traced(trace));\n/** @internal */\nexports.toPull = toPull;\nconst interpretToPull = (channelState, exec) => {\n  const state = channelState;\n  switch (state._tag) {\n    case ChannelStateOpCodes.OP_DONE:\n      {\n        return Exit.match(exec.getDone(), Effect.failCause, done => Effect.succeed(Either.left(done)));\n      }\n    case ChannelStateOpCodes.OP_EMIT:\n      {\n        return Effect.succeed(Either.right(exec.getEmit()));\n      }\n    case ChannelStateOpCodes.OP_FROM_EFFECT:\n      {\n        return Effect.flatMap(() => interpretToPull(exec.run(), exec))(state.effect);\n      }\n    case ChannelStateOpCodes.OP_READ:\n      {\n        return executor.readUpstream(state, () => interpretToPull(exec.run(), exec), cause => Effect.failCause(cause));\n      }\n  }\n};\n/** @internal */\nconst toQueue = /*#__PURE__*/Debug.methodWithTrace(trace => queue => core.suspend(() => toQueueInternal(queue)).traced(trace));\n/** @internal */\nexports.toQueue = toQueue;\nconst toQueueInternal = queue => {\n  return core.readWithCause(elem => core.flatMap(core.fromEffect(Queue.offer(queue, Either.right(elem))), () => toQueueInternal(queue)), cause => core.fromEffect(Queue.offer(queue, Either.left(Exit.failCause(cause)))), done => core.fromEffect(Queue.offer(queue, Either.left(Exit.succeed(done)))));\n};\n/** @internal */\nconst unwrap = /*#__PURE__*/Debug.methodWithTrace(trace => channel => flatten(core.fromEffect(channel)).traced(trace));\n/** @internal */\nexports.unwrap = unwrap;\nconst unwrapScoped = /*#__PURE__*/Debug.methodWithTrace(trace => self => core.concatAllWith(scoped(self), (d, _) => d, (d, _) => d).traced(trace));\n/** @internal */\nexports.unwrapScoped = unwrapScoped;\nconst updateService = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (self, tag, f) => contramapContext(self, context => Context.merge(context, Context.make(tag, restore(f)(Context.unsafeGet(context, tag))))).traced(trace));\n/** @internal */\nexports.updateService = updateService;\nconst writeAll = /*#__PURE__*/Debug.methodWithTrace(trace => (...outs) => writeChunk(Chunk.fromIterable(outs)).traced(trace));\n/** @internal */\nexports.writeAll = writeAll;\nconst writeChunk = /*#__PURE__*/Debug.methodWithTrace(trace => outs => writeChunkWriter(0, outs.length, outs).traced(trace));\n/** @internal */\nexports.writeChunk = writeChunk;\nconst writeChunkWriter = (idx, len, chunk) => {\n  return idx === len ? core.unit() : core.flatMap(() => writeChunkWriter(idx + 1, len, chunk))(core.write(Chunk.unsafeGet(idx)(chunk)));\n};\n/** @internal */\nconst zip = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, that) => core.flatMap(self, a => map(b => [a, b])(that)).traced(trace));\n/** @internal */\nexports.zip = zip;\nconst zipLeft = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, that) => core.flatMap(self, z => as(that, z)).traced(trace));\n/** @internal */\nexports.zipLeft = zipLeft;\nconst zipRight = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, that) => core.flatMap(self, () => that).traced(trace));\n/** @internal */\nexports.zipRight = zipRight;\nconst zipPar = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, that) => mergeWith(self, that, exit1 => mergeDecision.Await(exit2 => Effect.done(Exit.zip(exit1, exit2))), exit2 => mergeDecision.Await(exit1 => Effect.done(Exit.zip(exit1, exit2)))).traced(trace));\n/** @internal */\nexports.zipPar = zipPar;\nconst zipParLeft = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, that) => map(zipPar(self, that), tuple => tuple[0]).traced(trace));\n/** @internal */\nexports.zipParLeft = zipParLeft;\nconst zipParRight = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, that) => map(zipPar(self, that), tuple => tuple[1]).traced(trace));\n/** @internal */\nexports.zipParRight = zipParRight;\nconst ChannelExceptionTypeId = /*#__PURE__*/Symbol.for(\"@effect/stream/Channel/errors/ChannelException\");\n/** @internal */\nexports.ChannelExceptionTypeId = ChannelExceptionTypeId;\nconst ChannelException = error => ({\n  _tag: \"ChannelException\",\n  [ChannelExceptionTypeId]: ChannelExceptionTypeId,\n  error\n});\n/** @internal */\nexports.ChannelException = ChannelException;\nconst isChannelException = u => typeof u === \"object\" && u != null && ChannelExceptionTypeId in u;\nexports.isChannelException = isChannelException;\n//# sourceMappingURL=channel.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.runScoped = exports.run = exports.readUpstream = exports.ChannelExecutor = void 0;\nvar Chunk = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Chunk\"));\nvar _Function = /*#__PURE__*/require(\"@effect/data/Function\");\nvar MRef = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/MutableRef\"));\nvar Option = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Option\"));\nvar Cause = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Cause\"));\nvar Debug = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Debug\"));\nvar Deferred = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Deferred\"));\nvar Effect = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Effect\"));\nvar ExecutionStrategy = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/ExecutionStrategy\"));\nvar Exit = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Exit\"));\nvar Fiber = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Fiber\"));\nvar Scope = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Scope\"));\nvar ChannelState = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/stream/internal/channel/channelState\"));\nvar Continuation = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/stream/internal/channel/continuation\"));\nvar Subexecutor = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/stream/internal/channel/subexecutor\"));\nvar upstreamPullRequest = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/stream/internal/channel/upstreamPullRequest\"));\nvar core = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/stream/internal/core\"));\nvar ChannelOpCodes = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/stream/internal/opCodes/channel\"));\nvar ChannelStateOpCodes = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/stream/internal/opCodes/channelState\"));\nvar ChildExecutorDecisionOpCodes = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/stream/internal/opCodes/childExecutorDecision\"));\nvar ContinuationOpCodes = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/stream/internal/opCodes/continuation\"));\nvar UpstreamPullStrategyOpCodes = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/stream/internal/opCodes/upstreamPullStrategy\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\nclass ChannelExecutor {\n  constructor(initialChannel, providedEnv, executeCloseLastSubstream) {\n    this._activeSubexecutor = undefined;\n    this._cancelled = undefined;\n    this._closeLastSubstream = undefined;\n    this._done = undefined;\n    this._doneStack = [];\n    this._emitted = undefined;\n    this._traceStack = [];\n    this._input = undefined;\n    this._inProgressFinalizer = undefined;\n    this._currentChannel = initialChannel;\n    this._executeCloseLastSubstream = executeCloseLastSubstream;\n    this._providedEnv = providedEnv;\n  }\n  run() {\n    let result = undefined;\n    while (result === undefined) {\n      if (this._cancelled !== undefined) {\n        result = this.processCancellation();\n      } else if (this._activeSubexecutor !== undefined) {\n        result = this.runSubexecutor();\n      } else {\n        try {\n          if (this._currentChannel === undefined) {\n            result = ChannelState.Done();\n          } else {\n            switch (this._currentChannel._tag) {\n              case ChannelOpCodes.OP_BRACKET_OUT:\n                {\n                  result = this.runBracketOut(this._currentChannel);\n                  break;\n                }\n              case ChannelOpCodes.OP_BRIDGE:\n                {\n                  const bridgeInput = this._currentChannel.input;\n                  // PipeTo(left, Bridge(queue, channel))\n                  // In a fiber: repeatedly run left and push its outputs to the queue\n                  // Add a finalizer to interrupt the fiber and close the executor\n                  this._currentChannel = this._currentChannel.channel;\n                  if (this._input !== undefined) {\n                    const inputExecutor = this._input;\n                    this._input = undefined;\n                    const drainer = () => Effect.flatMap(bridgeInput.awaitRead(), () => Effect.suspend(() => {\n                      const state = inputExecutor.run();\n                      switch (state._tag) {\n                        case ChannelStateOpCodes.OP_DONE:\n                          {\n                            return Exit.match(inputExecutor.getDone(), cause => bridgeInput.error(cause), value => bridgeInput.done(value));\n                          }\n                        case ChannelStateOpCodes.OP_EMIT:\n                          {\n                            return Effect.flatMap(bridgeInput.emit(inputExecutor.getEmit()), () => drainer());\n                          }\n                        case ChannelStateOpCodes.OP_FROM_EFFECT:\n                          {\n                            return Effect.matchCauseEffect(state.effect, cause => bridgeInput.error(cause), () => drainer());\n                          }\n                        case ChannelStateOpCodes.OP_READ:\n                          {\n                            return readUpstream(state, () => drainer(), cause => bridgeInput.error(cause));\n                          }\n                      }\n                    }));\n                    result = ChannelState.FromEffect(Effect.flatMap(Effect.forkDaemon(drainer()), fiber => Effect.sync(() => this.addFinalizer(exit => Effect.flatMap(Fiber.interrupt(fiber), () => Effect.suspend(() => {\n                      const effect = this.restorePipe(exit, inputExecutor);\n                      return effect !== undefined ? effect : Effect.unit();\n                    }))))));\n                  }\n                  break;\n                }\n              case ChannelOpCodes.OP_CONCAT_ALL:\n                {\n                  const executor = new ChannelExecutor(this._currentChannel.value(), this._providedEnv, effect => Effect.sync(() => {\n                    const prevLastClose = this._closeLastSubstream === undefined ? Effect.unit() : this._closeLastSubstream;\n                    this._closeLastSubstream = Effect.zipRight(effect)(prevLastClose);\n                  }));\n                  executor._input = this._input;\n                  const channel = this._currentChannel;\n                  this._activeSubexecutor = new Subexecutor.PullFromUpstream(executor, value => channel.k(value), undefined, [], (x, y) => channel.combineInners(x, y), (x, y) => channel.combineAll(x, y), request => channel.onPull(request), value => channel.onEmit(value));\n                  this._closeLastSubstream = undefined;\n                  this._currentChannel = undefined;\n                  break;\n                }\n              case ChannelOpCodes.OP_EMIT:\n                {\n                  this._emitted = this._currentChannel.out;\n                  this._currentChannel = this._activeSubexecutor !== undefined ? undefined : core.unit();\n                  result = ChannelState.Emit();\n                  break;\n                }\n              case ChannelOpCodes.OP_ENSURING:\n                {\n                  this.runEnsuring(this._currentChannel);\n                  break;\n                }\n              case ChannelOpCodes.OP_FAIL:\n                {\n                  result = this.doneHalt(this._currentChannel.error());\n                  break;\n                }\n              case ChannelOpCodes.OP_FOLD:\n                {\n                  this._doneStack.push(this._currentChannel.k);\n                  this._currentChannel = this._currentChannel.channel;\n                  break;\n                }\n              case ChannelOpCodes.OP_FROM_EFFECT:\n                {\n                  const effect = this._providedEnv === undefined ? this._currentChannel.effect() : Effect.provideContext(this._providedEnv)(this._currentChannel.effect());\n                  result = ChannelState.FromEffect(Effect.matchCauseEffect(cause => {\n                    const state = this.doneHalt(cause);\n                    return state !== undefined && ChannelState.isFromEffect(state) ? state.effect : Effect.unit();\n                  }, value => {\n                    const state = this.doneSucceed(value);\n                    return state !== undefined && ChannelState.isFromEffect(state) ? state.effect : Effect.unit();\n                  })(effect));\n                  break;\n                }\n              case ChannelOpCodes.OP_PIPE_TO:\n                {\n                  const previousInput = this._input;\n                  const leftExec = new ChannelExecutor(this._currentChannel.left(), this._providedEnv, effect => this._executeCloseLastSubstream(effect));\n                  leftExec._input = previousInput;\n                  this._input = leftExec;\n                  this.addFinalizer(exit => {\n                    const effect = this.restorePipe(exit, previousInput);\n                    return effect !== undefined ? effect : Effect.unit();\n                  });\n                  this._currentChannel = this._currentChannel.right();\n                  break;\n                }\n              case ChannelOpCodes.OP_PROVIDE:\n                {\n                  const previousEnv = this._providedEnv;\n                  this._providedEnv = this._currentChannel.context();\n                  this._currentChannel = this._currentChannel.inner;\n                  this.addFinalizer(() => Effect.sync(() => {\n                    this._providedEnv = previousEnv;\n                  }));\n                  break;\n                }\n              case ChannelOpCodes.OP_READ:\n                {\n                  const read = this._currentChannel;\n                  result = ChannelState.Read(this._input, _Function.identity, emitted => {\n                    this._currentChannel = read.more(emitted);\n                    return undefined;\n                  }, exit => {\n                    const onExit = exit => {\n                      return read.done.onExit(exit);\n                    };\n                    this._currentChannel = onExit(exit);\n                    return undefined;\n                  });\n                  break;\n                }\n              case ChannelOpCodes.OP_SUCCEED:\n                {\n                  result = this.doneSucceed(this._currentChannel.evaluate());\n                  break;\n                }\n              case ChannelOpCodes.OP_SUCCEED_NOW:\n                {\n                  result = this.doneSucceed(this._currentChannel.terminal);\n                  break;\n                }\n              case ChannelOpCodes.OP_SUSPEND:\n                {\n                  this._currentChannel = this._currentChannel.channel();\n                  break;\n                }\n              case ChannelOpCodes.OP_TRACED:\n                {\n                  this._traceStack.push(this._currentChannel.trace);\n                  this.addFinalizer(() => Effect.sync(() => {\n                    this._traceStack.pop();\n                  }));\n                  this._currentChannel = this._currentChannel.channel;\n                  break;\n                }\n              default:\n                {\n                  // @ts-expect-error\n                  this._currentChannel._tag;\n                }\n            }\n          }\n        } catch (error) {\n          this._currentChannel = core.failCause(Cause.die(error));\n        }\n      }\n    }\n    return result;\n  }\n  stackToLines() {\n    if (this._traceStack.length === 0) {\n      return Chunk.empty();\n    }\n    const lines = [];\n    let current = this._traceStack.length - 1;\n    while (current >= 0 && lines.length < Debug.runtimeDebug.traceStackLimit) {\n      const value = this._traceStack[current];\n      lines.push(value);\n      current = current - 1;\n    }\n    return Chunk.unsafeFromArray(lines);\n  }\n  getDone() {\n    return this._done;\n  }\n  getEmit() {\n    return this._emitted;\n  }\n  cancelWith(exit) {\n    this._cancelled = exit;\n  }\n  clearInProgressFinalizer() {\n    this._inProgressFinalizer = undefined;\n  }\n  storeInProgressFinalizer(finalizer) {\n    this._inProgressFinalizer = finalizer;\n  }\n  popAllFinalizers(exit) {\n    return Debug.untraced(() => {\n      const finalizers = [];\n      let next = this._doneStack.pop();\n      while (next) {\n        if (next._tag === \"ContinuationFinalizer\") {\n          finalizers.push(next.finalizer);\n        }\n        next = this._doneStack.pop();\n      }\n      const effect = finalizers.length === 0 ? Effect.unit() : runFinalizers(finalizers, exit);\n      this.storeInProgressFinalizer(effect);\n      return effect;\n    });\n  }\n  popNextFinalizers() {\n    const builder = [];\n    while (this._doneStack.length !== 0) {\n      const cont = this._doneStack[this._doneStack.length - 1];\n      if (cont._tag === ContinuationOpCodes.OP_CONTINUATION_K) {\n        return builder;\n      }\n      builder.push(cont);\n      this._doneStack.pop();\n    }\n    return builder;\n  }\n  restorePipe(exit, prev) {\n    return Debug.untraced(() => {\n      const currInput = this._input;\n      this._input = prev;\n      if (currInput !== undefined) {\n        const effect = currInput.close(exit);\n        return effect;\n      }\n      return Effect.unit();\n    });\n  }\n  close(exit) {\n    return Debug.untraced(() => {\n      let runInProgressFinalizers = undefined;\n      const finalizer = this._inProgressFinalizer;\n      if (finalizer !== undefined) {\n        runInProgressFinalizers = Effect.ensuring(Effect.sync(() => this.clearInProgressFinalizer()))(finalizer);\n      }\n      let closeSelf = undefined;\n      const selfFinalizers = this.popAllFinalizers(exit);\n      if (selfFinalizers !== undefined) {\n        closeSelf = Effect.ensuring(Effect.sync(() => this.clearInProgressFinalizer()))(selfFinalizers);\n      }\n      const closeSubexecutors = this._activeSubexecutor === undefined ? undefined : this._activeSubexecutor.close(exit);\n      if (closeSubexecutors === undefined && runInProgressFinalizers === undefined && closeSelf === undefined) {\n        return undefined;\n      }\n      return Effect.flatMap(Effect.done)(Effect.uninterruptible(Effect.map(([[exit1, exit2], exit3]) => Exit.zipRight(exit3)(Exit.zipRight(exit2)(exit1)))(Effect.zip(Effect.exit(ifNotNull(closeSelf)))(Effect.zip(Effect.exit(ifNotNull(runInProgressFinalizers)))(Effect.exit(ifNotNull(closeSubexecutors)))))));\n    });\n  }\n  doneSucceed(value) {\n    if (this._doneStack.length === 0) {\n      this._done = Exit.succeed(value);\n      this._currentChannel = undefined;\n      return ChannelState.Done();\n    }\n    const head = this._doneStack[this._doneStack.length - 1];\n    if (head._tag === ContinuationOpCodes.OP_CONTINUATION_K) {\n      this._doneStack.pop();\n      this._currentChannel = head.onSuccess(value);\n      return undefined;\n    }\n    const finalizers = this.popNextFinalizers();\n    if (this._doneStack.length === 0) {\n      this._doneStack = finalizers.reverse();\n      this._done = Exit.succeed(value);\n      this._currentChannel = undefined;\n      return ChannelState.Done();\n    }\n    const finalizerEffect = runFinalizers(finalizers.map(f => f.finalizer), Exit.succeed(value));\n    this.storeInProgressFinalizer(finalizerEffect);\n    const effect = Effect.flatMap(() => Effect.sync(() => this.doneSucceed(value)))(Effect.uninterruptible(Effect.ensuring(Effect.sync(() => this.clearInProgressFinalizer()))(finalizerEffect)));\n    return ChannelState.FromEffect(effect);\n  }\n  annotate(_cause) {\n    let cause = _cause;\n    if (Cause.isAnnotatedType(cause) && Cause.isStackAnnotation(cause.annotation)) {\n      const stack = cause.annotation.stack;\n      const currentStack = this.stackToLines();\n      cause = Cause.annotated(cause.cause, new Cause.StackAnnotation(Chunk.take(Debug.runtimeDebug.traceStackLimit)(Chunk.dedupeAdjacent(stack.length === 0 ? currentStack : currentStack.length === 0 ? stack : Chunk.unsafeLast(stack) === Chunk.unsafeLast(currentStack) ? stack : Chunk.concat(currentStack)(stack))), cause.annotation.seq));\n    } else {\n      cause = Cause.annotated(cause, new Cause.StackAnnotation(this.stackToLines(), MRef.getAndIncrement(Cause.globalErrorSeq)));\n    }\n    return cause;\n  }\n  doneHalt(cause) {\n    if (this._doneStack.length === 0) {\n      this._done = Exit.failCause(cause);\n      this._currentChannel = undefined;\n      return ChannelState.Done();\n    }\n    const head = this._doneStack[this._doneStack.length - 1];\n    if (head._tag === ContinuationOpCodes.OP_CONTINUATION_K) {\n      this._doneStack.pop();\n      this._currentChannel = head.onHalt(cause);\n      return undefined;\n    }\n    const finalizers = this.popNextFinalizers();\n    if (this._doneStack.length === 0) {\n      this._doneStack = finalizers.reverse();\n      this._done = Exit.failCause(cause);\n      this._currentChannel = undefined;\n      return ChannelState.Done();\n    }\n    const finalizerEffect = runFinalizers(finalizers.map(f => f.finalizer), Exit.failCause(cause));\n    this.storeInProgressFinalizer(finalizerEffect);\n    const effect = Effect.flatMap(() => Effect.sync(() => this.doneHalt(cause)))(Effect.uninterruptible(Effect.ensuring(Effect.sync(() => this.clearInProgressFinalizer()))(finalizerEffect)));\n    return ChannelState.FromEffect(effect);\n  }\n  processCancellation() {\n    this._currentChannel = undefined;\n    this._done = this._cancelled;\n    this._cancelled = undefined;\n    return ChannelState.Done();\n  }\n  runBracketOut(bracketOut) {\n    const effect = Effect.uninterruptible(Effect.matchCauseEffect(cause => Effect.sync(() => {\n      this._currentChannel = core.failCause(cause);\n    }), out => Effect.sync(() => {\n      this.addFinalizer(exit => this.provide(bracketOut.finalizer(out, exit)));\n      this._currentChannel = core.write(out);\n    }))(this.provide(bracketOut.acquire())));\n    return ChannelState.FromEffect(effect);\n  }\n  provide(effect) {\n    if (this._providedEnv === undefined) {\n      return effect;\n    }\n    return Effect.provideContext(this._providedEnv)(effect);\n  }\n  runEnsuring(ensuring) {\n    this.addFinalizer(ensuring.finalizer);\n    this._currentChannel = ensuring.channel;\n  }\n  addFinalizer(f) {\n    this._doneStack.push(new Continuation.ContinuationFinalizerImpl(f));\n  }\n  runSubexecutor() {\n    const subexecutor = this._activeSubexecutor;\n    switch (subexecutor._tag) {\n      case Subexecutor.OP_PULL_FROM_CHILD:\n        {\n          return this.pullFromChild(subexecutor.childExecutor, subexecutor.parentSubexecutor, subexecutor.onEmit, subexecutor);\n        }\n      case Subexecutor.OP_PULL_FROM_UPSTREAM:\n        {\n          return this.pullFromUpstream(subexecutor);\n        }\n      case Subexecutor.OP_DRAIN_CHILD_EXECUTORS:\n        {\n          return this.drainChildExecutors(subexecutor);\n        }\n      case Subexecutor.OP_EMIT:\n        {\n          this._emitted = subexecutor.value;\n          this._activeSubexecutor = subexecutor.next;\n          return ChannelState.Emit();\n        }\n    }\n  }\n  replaceSubexecutor(nextSubExec) {\n    this._currentChannel = undefined;\n    this._activeSubexecutor = nextSubExec;\n  }\n  finishWithExit(exit) {\n    return Debug.untraced(() => {\n      const state = Exit.match(cause => this.doneHalt(cause), value => this.doneSucceed(value))(exit);\n      this._activeSubexecutor = undefined;\n      return state === undefined ? Effect.unit() : ChannelState.effect(state);\n    });\n  }\n  finishSubexecutorWithCloseEffect(subexecutorDone, ...closeFuncs) {\n    this.addFinalizer(() => Effect.forEachDiscard(closeFunc => Effect.flatMap(closeEffect => closeEffect !== undefined ? closeEffect : Effect.unit())(Effect.sync(() => closeFunc(subexecutorDone))))(closeFuncs));\n    const state = Exit.match(cause => this.doneHalt(cause), value => this.doneSucceed(value))(subexecutorDone);\n    this._activeSubexecutor = undefined;\n    return state;\n  }\n  applyUpstreamPullStrategy(upstreamFinished, queue, strategy) {\n    switch (strategy._tag) {\n      case UpstreamPullStrategyOpCodes.OP_PULL_AFTER_NEXT:\n        {\n          const shouldPrepend = !upstreamFinished || queue.some(subexecutor => subexecutor !== undefined);\n          return [strategy.emitSeparator, shouldPrepend ? [undefined, ...queue] : queue];\n        }\n      case UpstreamPullStrategyOpCodes.OP_PULL_AFTER_ALL_ENQUEUED:\n        {\n          const shouldEnqueue = !upstreamFinished || queue.some(subexecutor => subexecutor !== undefined);\n          return [strategy.emitSeparator, shouldEnqueue ? [...queue, undefined] : queue];\n        }\n    }\n  }\n  pullFromChild(childExecutor, parentSubexecutor, onEmitted, subexecutor) {\n    return ChannelState.Read(childExecutor, _Function.identity, emitted => {\n      const childExecutorDecision = onEmitted(emitted);\n      switch (childExecutorDecision._tag) {\n        case ChildExecutorDecisionOpCodes.OP_CONTINUE:\n          {\n            break;\n          }\n        case ChildExecutorDecisionOpCodes.OP_CLOSE:\n          {\n            this.finishWithDoneValue(childExecutor, parentSubexecutor, childExecutorDecision.value);\n            break;\n          }\n        case ChildExecutorDecisionOpCodes.OP_YIELD:\n          {\n            const modifiedParent = parentSubexecutor.enqueuePullFromChild(subexecutor);\n            this.replaceSubexecutor(modifiedParent);\n            break;\n          }\n      }\n      this._activeSubexecutor = new Subexecutor.Emit(emitted, this._activeSubexecutor);\n      return undefined;\n    }, Exit.match(cause => {\n      const state = this.handleSubexecutorFailure(childExecutor, parentSubexecutor, cause);\n      return state === undefined ? undefined : ChannelState.effectOrUndefinedIgnored(state);\n    }, doneValue => {\n      this.finishWithDoneValue(childExecutor, parentSubexecutor, doneValue);\n      return undefined;\n    }));\n  }\n  finishWithDoneValue(childExecutor, parentSubexecutor, doneValue) {\n    const subexecutor = parentSubexecutor;\n    switch (subexecutor._tag) {\n      case Subexecutor.OP_PULL_FROM_UPSTREAM:\n        {\n          const modifiedParent = new Subexecutor.PullFromUpstream(subexecutor.upstreamExecutor, subexecutor.createChild, subexecutor.lastDone !== undefined ? subexecutor.combineChildResults(subexecutor.lastDone, doneValue) : doneValue, subexecutor.activeChildExecutors, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull, subexecutor.onEmit);\n          this._closeLastSubstream = childExecutor.close(Exit.succeed(doneValue));\n          this.replaceSubexecutor(modifiedParent);\n          break;\n        }\n      case Subexecutor.OP_DRAIN_CHILD_EXECUTORS:\n        {\n          const modifiedParent = new Subexecutor.DrainChildExecutors(subexecutor.upstreamExecutor, subexecutor.lastDone !== undefined ? subexecutor.combineChildResults(subexecutor.lastDone, doneValue) : doneValue, subexecutor.activeChildExecutors, subexecutor.upstreamDone, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull);\n          this._closeLastSubstream = childExecutor.close(Exit.succeed(doneValue));\n          this.replaceSubexecutor(modifiedParent);\n          break;\n        }\n      default:\n        {\n          break;\n        }\n    }\n  }\n  handleSubexecutorFailure(childExecutor, parentSubexecutor, cause) {\n    return this.finishSubexecutorWithCloseEffect(Exit.failCause(cause), exit => parentSubexecutor.close(exit), exit => childExecutor.close(exit));\n  }\n  pullFromUpstream(subexecutor) {\n    if (subexecutor.activeChildExecutors.length === 0) {\n      return this.performPullFromUpstream(subexecutor);\n    }\n    const activeChild = subexecutor.activeChildExecutors[0];\n    const parentSubexecutor = new Subexecutor.PullFromUpstream(subexecutor.upstreamExecutor, subexecutor.createChild, subexecutor.lastDone, subexecutor.activeChildExecutors.slice(1), subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull, subexecutor.onEmit);\n    if (activeChild === undefined) {\n      return this.performPullFromUpstream(parentSubexecutor);\n    }\n    this.replaceSubexecutor(new Subexecutor.PullFromChild(activeChild.childExecutor, parentSubexecutor, activeChild.onEmit));\n    return undefined;\n  }\n  performPullFromUpstream(subexecutor) {\n    return ChannelState.Read(subexecutor.upstreamExecutor, effect => {\n      const closeLastSubstream = this._closeLastSubstream === undefined ? Effect.unit() : this._closeLastSubstream;\n      this._closeLastSubstream = undefined;\n      return Effect.zipRight(effect)(this._executeCloseLastSubstream(closeLastSubstream));\n    }, emitted => {\n      if (this._closeLastSubstream !== undefined) {\n        const closeLastSubstream = this._closeLastSubstream;\n        this._closeLastSubstream = undefined;\n        return Effect.map(() => {\n          const childExecutor = new ChannelExecutor(subexecutor.createChild(emitted), this._providedEnv, this._executeCloseLastSubstream);\n          childExecutor._input = this._input;\n          const [emitSeparator, updatedChildExecutors] = this.applyUpstreamPullStrategy(false, subexecutor.activeChildExecutors, subexecutor.onPull(upstreamPullRequest.Pulled(emitted)));\n          this._activeSubexecutor = new Subexecutor.PullFromChild(childExecutor, new Subexecutor.PullFromUpstream(subexecutor.upstreamExecutor, subexecutor.createChild, subexecutor.lastDone, updatedChildExecutors, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull, subexecutor.onEmit), subexecutor.onEmit);\n          if (Option.isSome(emitSeparator)) {\n            this._activeSubexecutor = new Subexecutor.Emit(emitSeparator.value, this._activeSubexecutor);\n          }\n          return undefined;\n        })(this._executeCloseLastSubstream(closeLastSubstream));\n      }\n      const childExecutor = new ChannelExecutor(subexecutor.createChild(emitted), this._providedEnv, this._executeCloseLastSubstream);\n      childExecutor._input = this._input;\n      const [emitSeparator, updatedChildExecutors] = this.applyUpstreamPullStrategy(false, subexecutor.activeChildExecutors, subexecutor.onPull(upstreamPullRequest.Pulled(emitted)));\n      this._activeSubexecutor = new Subexecutor.PullFromChild(childExecutor, new Subexecutor.PullFromUpstream(subexecutor.upstreamExecutor, subexecutor.createChild, subexecutor.lastDone, updatedChildExecutors, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull, subexecutor.onEmit), subexecutor.onEmit);\n      if (Option.isSome(emitSeparator)) {\n        this._activeSubexecutor = new Subexecutor.Emit(emitSeparator.value, this._activeSubexecutor);\n      }\n      return undefined;\n    }, exit => {\n      if (subexecutor.activeChildExecutors.some(subexecutor => subexecutor !== undefined)) {\n        const drain = new Subexecutor.DrainChildExecutors(subexecutor.upstreamExecutor, subexecutor.lastDone, [undefined, ...subexecutor.activeChildExecutors], subexecutor.upstreamExecutor.getDone(), subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull);\n        if (this._closeLastSubstream !== undefined) {\n          const closeLastSubstream = this._closeLastSubstream;\n          this._closeLastSubstream = undefined;\n          return Effect.map(() => this.replaceSubexecutor(drain))(this._executeCloseLastSubstream(closeLastSubstream));\n        }\n        this.replaceSubexecutor(drain);\n        return undefined;\n      }\n      const closeLastSubstream = this._closeLastSubstream;\n      const state = this.finishSubexecutorWithCloseEffect(Exit.map(a => subexecutor.combineWithChildResult(subexecutor.lastDone, a))(exit), () => closeLastSubstream, exit => subexecutor.upstreamExecutor.close(exit));\n      return state === undefined ? undefined :\n      // NOTE: assuming finalizers cannot fail\n      ChannelState.effectOrUndefinedIgnored(state);\n    });\n  }\n  drainChildExecutors(subexecutor) {\n    if (subexecutor.activeChildExecutors.length === 0) {\n      const lastClose = this._closeLastSubstream;\n      if (lastClose !== undefined) {\n        this.addFinalizer(() => Effect.succeed(lastClose));\n      }\n      return this.finishSubexecutorWithCloseEffect(subexecutor.upstreamDone, () => lastClose, exit => subexecutor.upstreamExecutor.close(exit));\n    }\n    const activeChild = subexecutor.activeChildExecutors[0];\n    const rest = subexecutor.activeChildExecutors.slice(1);\n    if (activeChild === undefined) {\n      const [emitSeparator, remainingExecutors] = this.applyUpstreamPullStrategy(true, rest, subexecutor.onPull(upstreamPullRequest.NoUpstream(rest.reduce((n, curr) => curr !== undefined ? n + 1 : n, 0))));\n      this.replaceSubexecutor(new Subexecutor.DrainChildExecutors(subexecutor.upstreamExecutor, subexecutor.lastDone, remainingExecutors, subexecutor.upstreamDone, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull));\n      if (Option.isSome(emitSeparator)) {\n        this._emitted = emitSeparator.value;\n        return ChannelState.Emit();\n      }\n      return undefined;\n    }\n    const parentSubexecutor = new Subexecutor.DrainChildExecutors(subexecutor.upstreamExecutor, subexecutor.lastDone, rest, subexecutor.upstreamDone, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull);\n    this.replaceSubexecutor(new Subexecutor.PullFromChild(activeChild.childExecutor, parentSubexecutor, activeChild.onEmit));\n    return undefined;\n  }\n}\nexports.ChannelExecutor = ChannelExecutor;\nconst ifNotNull = /*#__PURE__*/Debug.untracedMethod(() => effect => effect !== undefined ? effect : Effect.unit());\nconst runFinalizers = /*#__PURE__*/Debug.untracedMethod(() => (finalizers, exit) => {\n  return Effect.flatMap(exit => Effect.done(exit))(Effect.map(exits => Option.getOrElse(() => Exit.unit())(Exit.collectAll(exits)))(Effect.forEach(finalizers, fin => Effect.exit(fin(exit)))));\n});\n/**\n * @internal\n */\nconst readUpstream = /*#__PURE__*/Debug.methodWithTrace(trace => (r, onSuccess, onFailure) => {\n  const readStack = [r];\n  const read = () => {\n    const current = readStack.pop();\n    if (current === undefined || current.upstream === undefined) {\n      return Effect.dieMessage(\"Unexpected end of input for channel execution\");\n    }\n    const state = current.upstream.run();\n    switch (state._tag) {\n      case ChannelStateOpCodes.OP_EMIT:\n        {\n          const emitEffect = current.onEmit(current.upstream.getEmit());\n          if (readStack.length === 0) {\n            if (emitEffect === undefined) {\n              return Effect.suspend(onSuccess);\n            }\n            return Effect.matchCauseEffect(onFailure, onSuccess)(emitEffect).traced(trace);\n          }\n          if (emitEffect === undefined) {\n            return Effect.suspend(() => read()).traced(trace);\n          }\n          return Effect.matchCauseEffect(onFailure, () => read())(emitEffect).traced(trace);\n        }\n      case ChannelStateOpCodes.OP_DONE:\n        {\n          const doneEffect = current.onDone(current.upstream.getDone());\n          if (readStack.length === 0) {\n            if (doneEffect === undefined) {\n              return Effect.suspend(onSuccess).traced(trace);\n            }\n            return Effect.matchCauseEffect(onFailure, () => onSuccess())(doneEffect).traced(trace);\n          }\n          if (doneEffect === undefined) {\n            return Effect.suspend(() => read()).traced(trace);\n          }\n          return Effect.matchCauseEffect(onFailure, () => read())(doneEffect).traced(trace);\n        }\n      case ChannelStateOpCodes.OP_FROM_EFFECT:\n        {\n          readStack.push(current);\n          return Effect.matchCauseEffect(onFailure, () => read())(Effect.catchAllCause(cause => Effect.suspend(() => {\n            const doneEffect = current.onDone(Exit.failCause(cause));\n            return doneEffect === undefined ? Effect.unit() : doneEffect;\n          }))(current.onEffect(state.effect))).traced(trace);\n        }\n      case ChannelStateOpCodes.OP_READ:\n        {\n          readStack.push(current);\n          readStack.push(state);\n          return Effect.suspend(() => read()).traced(trace);\n        }\n    }\n  };\n  return read();\n});\n/** @internal */\nexports.readUpstream = readUpstream;\nconst run = /*#__PURE__*/Debug.methodWithTrace(trace => self => Effect.scoped(runScoped(self)).traced(trace));\n/** @internal */\nexports.run = run;\nconst runScoped = self => {\n  const run = (deferred, scope) => Effect.acquireUseRelease(Effect.sync(() => new ChannelExecutor(self, void 0, _Function.identity)), exec => Effect.suspend(() => Effect.zipLeft(Effect.never())(Effect.zipRight(Deferred.await(deferred))(Effect.intoDeferred(deferred)(runScopedInterpret(exec.run(), exec))))), (exec, exit) => {\n    const finalize = exec.close(exit);\n    if (finalize === undefined) {\n      return Effect.unit();\n    }\n    return Effect.tapErrorCause(finalize, cause => Scope.addFinalizer(scope, Effect.failCause(cause)));\n  });\n  return Effect.flatMap(Effect.scope(), parent => Effect.flatMap(Scope.fork(parent, ExecutionStrategy.sequential), child => Effect.flatMap(Deferred.make(), deferred => Effect.flatMap(Effect.forkScoped(run(deferred, child)), fiber => Effect.zipLeft(Deferred.await(deferred), Fiber.inheritAll(fiber))))));\n};\n/** @internal */\nexports.runScoped = runScoped;\nconst runScopedInterpret = (channelState, exec) => {\n  const op = channelState;\n  switch (op._tag) {\n    case ChannelStateOpCodes.OP_FROM_EFFECT:\n      {\n        return Effect.flatMap(() => runScopedInterpret(exec.run(), exec))(op.effect);\n      }\n    case ChannelStateOpCodes.OP_EMIT:\n      {\n        // Can't really happen because Out <:< Nothing. So just skip ahead.\n        return runScopedInterpret(exec.run(), exec);\n      }\n    case ChannelStateOpCodes.OP_DONE:\n      {\n        return Effect.done(exec.getDone());\n      }\n    case ChannelStateOpCodes.OP_READ:\n      {\n        return readUpstream(op, () => runScopedInterpret(exec.run(), exec), Effect.failCause);\n      }\n  }\n};\n//# sourceMappingURL=channelExecutor.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isRead = exports.isFromEffect = exports.isEmit = exports.isDone = exports.isChannelState = exports.effectOrUndefinedIgnored = exports.effect = exports.Read = exports.FromEffect = exports.Emit = exports.Done = exports.ChannelStateTypeId = void 0;\nvar Effect = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Effect\"));\nvar OpCodes = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/stream/internal/opCodes/channelState\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/** @internal */\nconst ChannelStateTypeId = /*#__PURE__*/Symbol.for(\"@effect/stream/Channel/State\");\n/** @internal */\nexports.ChannelStateTypeId = ChannelStateTypeId;\nconst channelStateVariance = {\n  _R: _ => _,\n  _E: _ => _\n};\n/** @internal */\nconst proto = {\n  [ChannelStateTypeId]: channelStateVariance\n};\n/** @internal */\nconst Done = () => {\n  const op = Object.create(proto);\n  op._tag = OpCodes.OP_DONE;\n  return op;\n};\n/** @internal */\nexports.Done = Done;\nconst Emit = () => {\n  const op = Object.create(proto);\n  op._tag = OpCodes.OP_EMIT;\n  return op;\n};\n/** @internal */\nexports.Emit = Emit;\nconst FromEffect = effect => {\n  const op = Object.create(proto);\n  op._tag = OpCodes.OP_FROM_EFFECT;\n  op.effect = effect;\n  return op;\n};\n/** @internal */\nexports.FromEffect = FromEffect;\nconst Read = (upstream, onEffect, onEmit, onDone) => {\n  const op = Object.create(proto);\n  op._tag = OpCodes.OP_READ;\n  op.upstream = upstream;\n  op.onEffect = onEffect;\n  op.onEmit = onEmit;\n  op.onDone = onDone;\n  return op;\n};\n/** @internal */\nexports.Read = Read;\nconst isChannelState = u => typeof u === \"object\" && u != null && ChannelStateTypeId in u;\n/** @internal */\nexports.isChannelState = isChannelState;\nconst isDone = self => self._tag === OpCodes.OP_DONE;\n/** @internal */\nexports.isDone = isDone;\nconst isEmit = self => self._tag === OpCodes.OP_EMIT;\n/** @internal */\nexports.isEmit = isEmit;\nconst isFromEffect = self => self._tag === OpCodes.OP_FROM_EFFECT;\n/** @internal */\nexports.isFromEffect = isFromEffect;\nconst isRead = self => self._tag === OpCodes.OP_READ;\n/** @internal */\nexports.isRead = isRead;\nconst effect = self => isFromEffect(self) ? self.effect : Effect.unit();\n/** @internal */\nexports.effect = effect;\nconst effectOrUndefinedIgnored = self => isFromEffect(self) ? Effect.ignore(self.effect) : undefined;\nexports.effectOrUndefinedIgnored = effectOrUndefinedIgnored;\n//# sourceMappingURL=channelState.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.match = exports.isYield = exports.isContinue = exports.isClose = exports.isChildExecutorDecision = exports.Yield = exports.Continue = exports.Close = exports.ChildExecutorDecisionTypeId = void 0;\nvar _Function = /*#__PURE__*/require(\"@effect/data/Function\");\nvar OpCodes = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/stream/internal/opCodes/childExecutorDecision\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/** @internal */\nconst ChildExecutorDecisionSymbolKey = \"@effect/stream/Channel/ChildExecutorDecision\";\n/** @internal */\nconst ChildExecutorDecisionTypeId = /*#__PURE__*/Symbol.for(ChildExecutorDecisionSymbolKey);\n/** @internal */\nexports.ChildExecutorDecisionTypeId = ChildExecutorDecisionTypeId;\nconst proto = {\n  [ChildExecutorDecisionTypeId]: ChildExecutorDecisionTypeId\n};\n/** @internal */\nconst Continue = _ => {\n  const op = Object.create(proto);\n  op._tag = OpCodes.OP_CONTINUE;\n  return op;\n};\n/** @internal */\nexports.Continue = Continue;\nconst Close = value => {\n  const op = Object.create(proto);\n  op._tag = OpCodes.OP_CLOSE;\n  op.value = value;\n  return op;\n};\n/** @internal */\nexports.Close = Close;\nconst Yield = _ => {\n  const op = Object.create(proto);\n  op._tag = OpCodes.OP_YIELD;\n  return op;\n};\n/** @internal */\nexports.Yield = Yield;\nconst isChildExecutorDecision = u => typeof u === \"object\" && u != null && ChildExecutorDecisionTypeId in u;\n/** @internal */\nexports.isChildExecutorDecision = isChildExecutorDecision;\nconst isContinue = self => self._tag === OpCodes.OP_CONTINUE;\n/** @internal */\nexports.isContinue = isContinue;\nconst isClose = self => self._tag === OpCodes.OP_CLOSE;\n/** @internal */\nexports.isClose = isClose;\nconst isYield = self => self._tag === OpCodes.OP_YIELD;\n/** @internal */\nexports.isYield = isYield;\nconst match = /*#__PURE__*/(0, _Function.dual)(4, (self, onContinue, onClose, onYield) => {\n  switch (self._tag) {\n    case OpCodes.OP_CONTINUE:\n      {\n        return onContinue();\n      }\n    case OpCodes.OP_CLOSE:\n      {\n        return onClose(self.value);\n      }\n    case OpCodes.OP_YIELD:\n      {\n        return onYield();\n      }\n  }\n});\nexports.match = match;\n//# sourceMappingURL=childExecutorDecision.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ContinuationTypeId = exports.ContinuationKImpl = exports.ContinuationFinalizerImpl = void 0;\nvar Exit = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Exit\"));\nvar OpCodes = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/stream/internal/opCodes/continuation\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\nvar _a, _b;\n/** @internal */\nconst ContinuationTypeId = /*#__PURE__*/Symbol.for(\"@effect/stream/Channel/Continuation\");\n/** @internal */\nexports.ContinuationTypeId = ContinuationTypeId;\nconst continuationVariance = {\n  _Env: _ => _,\n  _InErr: _ => _,\n  _InElem: _ => _,\n  _InDone: _ => _,\n  _OutErr: _ => _,\n  _OutDone: _ => _,\n  _OutErr2: _ => _,\n  _OutElem: _ => _,\n  _OutDone2: _ => _\n};\n/** @internal */\nclass ContinuationKImpl {\n  constructor(onSuccess, onHalt) {\n    this.onSuccess = onSuccess;\n    this.onHalt = onHalt;\n    this._tag = OpCodes.OP_CONTINUATION_K;\n    this[_a] = continuationVariance;\n  }\n  onExit(exit) {\n    return Exit.isFailure(exit) ? this.onHalt(exit.cause) : this.onSuccess(exit.value);\n  }\n}\nexports.ContinuationKImpl = ContinuationKImpl;\n_a = ContinuationTypeId;\n/** @internal */\nclass ContinuationFinalizerImpl {\n  constructor(finalizer) {\n    this.finalizer = finalizer;\n    this._tag = OpCodes.OP_CONTINUATION_FINALIZER;\n    this[_b] = continuationVariance;\n  }\n}\nexports.ContinuationFinalizerImpl = ContinuationFinalizerImpl;\n_b = ContinuationTypeId;\n//# sourceMappingURL=continuation.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.match = exports.isMergeDecision = exports.MergeDecisionTypeId = exports.Done = exports.AwaitConst = exports.Await = void 0;\nvar _Function = /*#__PURE__*/require(\"@effect/data/Function\");\nvar OpCodes = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/stream/internal/opCodes/mergeDecision\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/** @internal */\nconst MergeDecisionSymbolKey = \"@effect/stream/Channel/MergeDecision\";\n/** @internal */\nconst MergeDecisionTypeId = /*#__PURE__*/Symbol.for(MergeDecisionSymbolKey);\n/** @internal */\nexports.MergeDecisionTypeId = MergeDecisionTypeId;\nconst proto = {\n  [MergeDecisionTypeId]: {\n    _R: _ => _,\n    _E0: _ => _,\n    _Z0: _ => _,\n    _E: _ => _,\n    _Z: _ => _\n  }\n};\n/** @internal */\nconst Done = effect => {\n  const op = Object.create(proto);\n  op._tag = OpCodes.OP_DONE;\n  op.effect = effect;\n  return op;\n};\n/** @internal */\nexports.Done = Done;\nconst Await = f => {\n  const op = Object.create(proto);\n  op._tag = OpCodes.OP_AWAIT;\n  op.f = f;\n  return op;\n};\n/** @internal */\nexports.Await = Await;\nconst AwaitConst = effect => Await(() => effect);\n/** @internal */\nexports.AwaitConst = AwaitConst;\nconst isMergeDecision = u => typeof u === \"object\" && u != null && MergeDecisionTypeId in u;\n/** @internal */\nexports.isMergeDecision = isMergeDecision;\nconst match = /*#__PURE__*/(0, _Function.dual)(3, (self, onDone, onAwait) => {\n  const op = self;\n  switch (op._tag) {\n    case OpCodes.OP_DONE:\n      {\n        return onDone(op.effect);\n      }\n    case OpCodes.OP_AWAIT:\n      {\n        return onAwait(op.f);\n      }\n  }\n});\nexports.match = match;\n//# sourceMappingURL=mergeDecision.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.match = exports.isRightDone = exports.isMergeState = exports.isLeftDone = exports.isBothRunning = exports.RightDone = exports.MergeStateTypeId = exports.LeftDone = exports.BothRunning = void 0;\nvar _Function = /*#__PURE__*/require(\"@effect/data/Function\");\nvar OpCodes = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/stream/internal/opCodes/mergeState\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/** @internal */\nconst MergeStateSymbolKey = \"@effect/stream/Channel/MergeState\";\n/** @internal */\nconst MergeStateTypeId = /*#__PURE__*/Symbol.for(MergeStateSymbolKey);\n/** @internal */\nexports.MergeStateTypeId = MergeStateTypeId;\nconst proto = {\n  [MergeStateTypeId]: MergeStateTypeId\n};\n/** @internal */\nconst BothRunning = (left, right) => {\n  const op = Object.create(proto);\n  op._tag = OpCodes.OP_BOTH_RUNNING;\n  op.left = left;\n  op.right = right;\n  return op;\n};\n/** @internal */\nexports.BothRunning = BothRunning;\nconst LeftDone = f => {\n  const op = Object.create(proto);\n  op._tag = OpCodes.OP_LEFT_DONE;\n  op.f = f;\n  return op;\n};\n/** @internal */\nexports.LeftDone = LeftDone;\nconst RightDone = f => {\n  const op = Object.create(proto);\n  op._tag = OpCodes.OP_RIGHT_DONE;\n  op.f = f;\n  return op;\n};\n/** @internal */\nexports.RightDone = RightDone;\nconst isMergeState = u => {\n  return typeof u === \"object\" && u != null && MergeStateTypeId in u;\n};\n/** @internal */\nexports.isMergeState = isMergeState;\nconst isBothRunning = self => {\n  return self._tag === OpCodes.OP_BOTH_RUNNING;\n};\n/** @internal */\nexports.isBothRunning = isBothRunning;\nconst isLeftDone = self => {\n  return self._tag === OpCodes.OP_LEFT_DONE;\n};\n/** @internal */\nexports.isLeftDone = isLeftDone;\nconst isRightDone = self => {\n  return self._tag === OpCodes.OP_RIGHT_DONE;\n};\n/** @internal */\nexports.isRightDone = isRightDone;\nconst match = /*#__PURE__*/(0, _Function.dual)(4, (self, onBothRunning, onLeftDone, onRightDone) => {\n  switch (self._tag) {\n    case OpCodes.OP_BOTH_RUNNING:\n      {\n        return onBothRunning(self.left, self.right);\n      }\n    case OpCodes.OP_LEFT_DONE:\n      {\n        return onLeftDone(self.f);\n      }\n    case OpCodes.OP_RIGHT_DONE:\n      {\n        return onRightDone(self.f);\n      }\n  }\n});\nexports.match = match;\n//# sourceMappingURL=mergeState.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.match = exports.isMergeStrategy = exports.isBufferSliding = exports.isBackPressure = exports.MergeStrategyTypeId = exports.BufferSliding = exports.BackPressure = void 0;\nvar _Function = /*#__PURE__*/require(\"@effect/data/Function\");\nvar OpCodes = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/stream/internal/opCodes/mergeStrategy\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/** @internal */\nconst MergeStrategySymbolKey = \"@effect/stream/Channel/MergeStrategy\";\n/** @internal */\nconst MergeStrategyTypeId = /*#__PURE__*/Symbol.for(MergeStrategySymbolKey);\n/** @internal */\nexports.MergeStrategyTypeId = MergeStrategyTypeId;\nconst proto = {\n  [MergeStrategyTypeId]: MergeStrategyTypeId\n};\n/** @internal */\nconst BackPressure = _ => {\n  const op = Object.create(proto);\n  op._tag = OpCodes.OP_BACK_PRESSURE;\n  return op;\n};\n/** @internal */\nexports.BackPressure = BackPressure;\nconst BufferSliding = _ => {\n  const op = Object.create(proto);\n  op._tag = OpCodes.OP_BUFFER_SLIDING;\n  return op;\n};\n/** @internal */\nexports.BufferSliding = BufferSliding;\nconst isMergeStrategy = u => typeof u === \"object\" && u != null && MergeStrategyTypeId in u;\n/** @internal */\nexports.isMergeStrategy = isMergeStrategy;\nconst isBackPressure = self => self._tag === OpCodes.OP_BACK_PRESSURE;\n/** @internal */\nexports.isBackPressure = isBackPressure;\nconst isBufferSliding = self => self._tag === OpCodes.OP_BUFFER_SLIDING;\n/** @internal */\nexports.isBufferSliding = isBufferSliding;\nconst match = /*#__PURE__*/(0, _Function.dual)(3, (self, onBackPressure, onBufferSliding) => {\n  switch (self._tag) {\n    case OpCodes.OP_BACK_PRESSURE:\n      {\n        return onBackPressure();\n      }\n    case OpCodes.OP_BUFFER_SLIDING:\n      {\n        return onBufferSliding();\n      }\n  }\n});\nexports.match = match;\n//# sourceMappingURL=mergeStrategy.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.make = void 0;\nvar Either = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Either\"));\nvar Cause = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Cause\"));\nvar _Debug = /*#__PURE__*/require(\"@effect/io/Debug\");\nvar Deferred = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Deferred\"));\nvar Effect = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Effect\"));\nvar Exit = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Exit\"));\nvar Ref = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Ref\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/** @internal */\nconst OP_STATE_EMPTY = \"Empty\";\n/** @internal */\nconst OP_STATE_EMIT = \"Emit\";\n/** @internal */\nconst OP_STATE_ERROR = \"Error\";\n/** @internal */\nconst OP_STATE_DONE = \"Done\";\n/** @internal */\nconst stateEmpty = notifyProducer => ({\n  _tag: OP_STATE_EMPTY,\n  notifyProducer\n});\n/** @internal */\nconst stateEmit = notifyConsumers => ({\n  _tag: OP_STATE_EMIT,\n  notifyConsumers\n});\n/** @internal */\nconst stateError = cause => ({\n  _tag: OP_STATE_ERROR,\n  cause\n});\n/** @internal */\nconst stateDone = done => ({\n  _tag: OP_STATE_DONE,\n  done\n});\n/** @internal */\nclass SingleProducerAsyncInputImpl {\n  constructor(ref) {\n    this.ref = ref;\n  }\n  awaitRead() {\n    return (0, _Debug.bodyWithTrace)(trace => {\n      return Effect.flatten(Ref.modify(this.ref, state => state._tag === OP_STATE_EMPTY ? [Deferred.await(state.notifyProducer), state] : [Effect.unit(), state])).traced(trace);\n    });\n  }\n  close() {\n    return (0, _Debug.bodyWithTrace)(trace => {\n      return Effect.fiberIdWith(fiberId => this.error(Cause.interrupt(fiberId))).traced(trace);\n    });\n  }\n  done(value) {\n    return (0, _Debug.bodyWithTrace)(trace => {\n      return Effect.flatten(Ref.modify(this.ref, state => {\n        switch (state._tag) {\n          case OP_STATE_EMPTY:\n            {\n              return [Deferred.await(state.notifyProducer), state];\n            }\n          case OP_STATE_EMIT:\n            {\n              return [Effect.forEachDiscard(deferred => Deferred.succeed(deferred, Either.left(value)))(state.notifyConsumers), stateDone(value)];\n            }\n          case OP_STATE_ERROR:\n            {\n              return [Effect.interrupt(), state];\n            }\n          case OP_STATE_DONE:\n            {\n              return [Effect.interrupt(), state];\n            }\n        }\n      })).traced(trace);\n    });\n  }\n  emit(element) {\n    return (0, _Debug.bodyWithTrace)(trace => {\n      return Effect.flatMap(deferred => Effect.flatten(Ref.modify(this.ref, state => {\n        switch (state._tag) {\n          case OP_STATE_EMPTY:\n            {\n              return [Deferred.await(state.notifyProducer), state];\n            }\n          case OP_STATE_EMIT:\n            {\n              const notifyConsumer = state.notifyConsumers[0];\n              const notifyConsumers = state.notifyConsumers.slice(1);\n              if (notifyConsumer !== undefined) {\n                return [Deferred.succeed(notifyConsumer, Either.right(element)), notifyConsumers.length === 0 ? stateEmpty(deferred) : stateEmit(notifyConsumers)];\n              }\n              throw new Error(\"Bug: Channel.SingleProducerAsyncInput.emit - Queue was empty! Please report an issue at https://github.com/Effect-TS/stream/issues\");\n            }\n          case OP_STATE_ERROR:\n            {\n              return [Effect.interrupt(), state];\n            }\n          case OP_STATE_DONE:\n            {\n              return [Effect.interrupt(), state];\n            }\n        }\n      })))(Deferred.make()).traced(trace);\n    });\n  }\n  error(cause) {\n    return (0, _Debug.bodyWithTrace)(trace => {\n      return Effect.flatten(Ref.modify(this.ref, state => {\n        switch (state._tag) {\n          case OP_STATE_EMPTY:\n            {\n              return [Deferred.await(state.notifyProducer), state];\n            }\n          case OP_STATE_EMIT:\n            {\n              return [Effect.forEachDiscard(state.notifyConsumers, deferred => Deferred.failCause(deferred, cause)), stateError(cause)];\n            }\n          case OP_STATE_ERROR:\n            {\n              return [Effect.interrupt(), state];\n            }\n          case OP_STATE_DONE:\n            {\n              return [Effect.interrupt(), state];\n            }\n        }\n      })).traced(trace);\n    });\n  }\n  take() {\n    return (0, _Debug.bodyWithTrace)(trace => {\n      return this.takeWith(cause => Exit.failCause(Cause.map(cause, Either.left)), elem => Exit.succeed(elem), done => Exit.fail(Either.right(done))).traced(trace);\n    });\n  }\n  takeWith(onError, onElement, onDone) {\n    return (0, _Debug.bodyWithTrace)(trace => {\n      return Effect.flatMap(deferred => Effect.flatten(Ref.modify(this.ref, state => {\n        switch (state._tag) {\n          case OP_STATE_EMPTY:\n            {\n              return [Effect.zipRight(Deferred.succeed(state.notifyProducer, void 0), Effect.matchCause(Deferred.await(deferred), onError, Either.match(onDone, onElement))), stateEmit([deferred])];\n            }\n          case OP_STATE_EMIT:\n            {\n              return [Effect.matchCause(Deferred.await(deferred), onError, Either.match(onDone, onElement)), stateEmit([...state.notifyConsumers, deferred])];\n            }\n          case OP_STATE_ERROR:\n            {\n              return [Effect.succeed(onError(state.cause)), state];\n            }\n          case OP_STATE_DONE:\n            {\n              return [Effect.succeed(onDone(state.done)), state];\n            }\n        }\n      })))(Deferred.make()).traced(trace);\n    });\n  }\n}\n/** @internal */\nconst make = /*#__PURE__*/(0, _Debug.methodWithTrace)(trace => () => Effect.map(ref => new SingleProducerAsyncInputImpl(ref))(Effect.flatMap(deferred => Ref.make(stateEmpty(deferred)))(Deferred.make())).traced(trace));\nexports.make = make;\n//# sourceMappingURL=singleProducerAsyncInput.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PullFromUpstream = exports.PullFromChild = exports.OP_PULL_FROM_UPSTREAM = exports.OP_PULL_FROM_CHILD = exports.OP_EMIT = exports.OP_DRAIN_CHILD_EXECUTORS = exports.Emit = exports.DrainChildExecutors = void 0;\nvar _Debug = /*#__PURE__*/require(\"@effect/io/Debug\");\nvar Effect = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Effect\"));\nvar Exit = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Exit\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/** @internal */\nconst OP_PULL_FROM_CHILD = \"PullFromChild\";\n/** @internal */\nexports.OP_PULL_FROM_CHILD = OP_PULL_FROM_CHILD;\nconst OP_PULL_FROM_UPSTREAM = \"PullFromUpstream\";\n/** @internal */\nexports.OP_PULL_FROM_UPSTREAM = OP_PULL_FROM_UPSTREAM;\nconst OP_DRAIN_CHILD_EXECUTORS = \"DrainChildExecutors\";\n/** @internal */\nexports.OP_DRAIN_CHILD_EXECUTORS = OP_DRAIN_CHILD_EXECUTORS;\nconst OP_EMIT = \"Emit\";\n/**\n * Execute the `childExecutor` and on each emitted value, decide what to do by\n * `onEmit`.\n *\n * @internal\n */\nexports.OP_EMIT = OP_EMIT;\nclass PullFromChild {\n  constructor(childExecutor, parentSubexecutor, onEmit) {\n    this.childExecutor = childExecutor;\n    this.parentSubexecutor = parentSubexecutor;\n    this.onEmit = onEmit;\n    this._tag = OP_PULL_FROM_CHILD;\n  }\n  close(exit) {\n    return (0, _Debug.bodyWithTrace)(trace => {\n      const fin1 = this.childExecutor.close(exit);\n      const fin2 = this.parentSubexecutor.close(exit);\n      if (fin1 !== undefined && fin2 !== undefined) {\n        return Effect.zipWith(Effect.exit(fin2), (exit1, exit2) => Exit.zipRight(exit2)(exit1))(Effect.exit(fin1)).traced(trace);\n      } else if (fin1 !== undefined) {\n        return fin1.traced(trace);\n      } else if (fin2 !== undefined) {\n        return fin2.traced(trace);\n      } else {\n        return undefined;\n      }\n    });\n  }\n  enqueuePullFromChild(_child) {\n    return this;\n  }\n}\n/**\n * Execute `upstreamExecutor` and for each emitted element, spawn a child\n * channel and continue with processing it by `PullFromChild`.\n *\n * @internal\n */\nexports.PullFromChild = PullFromChild;\nclass PullFromUpstream {\n  constructor(upstreamExecutor, createChild, lastDone, activeChildExecutors, combineChildResults, combineWithChildResult, onPull, onEmit) {\n    this.upstreamExecutor = upstreamExecutor;\n    this.createChild = createChild;\n    this.lastDone = lastDone;\n    this.activeChildExecutors = activeChildExecutors;\n    this.combineChildResults = combineChildResults;\n    this.combineWithChildResult = combineWithChildResult;\n    this.onPull = onPull;\n    this.onEmit = onEmit;\n    this._tag = OP_PULL_FROM_UPSTREAM;\n  }\n  close(exit) {\n    return (0, _Debug.bodyWithTrace)(trace => {\n      const fin1 = this.upstreamExecutor.close(exit);\n      const fins = [...this.activeChildExecutors.map(child => child !== undefined ? child.childExecutor.close(exit) : undefined), fin1];\n      const result = fins.reduce((acc, next) => {\n        if (acc !== undefined && next !== undefined) {\n          return Effect.zipWith(Effect.exit(next), (exit1, exit2) => Exit.zipRight(exit2)(exit1))(acc);\n        } else if (acc !== undefined) {\n          return acc;\n        } else if (next !== undefined) {\n          return Effect.exit(next);\n        } else {\n          return undefined;\n        }\n      }, undefined);\n      return result === undefined ? result : result.traced(trace);\n    });\n  }\n  enqueuePullFromChild(child) {\n    return new PullFromUpstream(this.upstreamExecutor, this.createChild, this.lastDone, [...this.activeChildExecutors, child], this.combineChildResults, this.combineWithChildResult, this.onPull, this.onEmit);\n  }\n}\n/**\n * Transformed from `PullFromUpstream` when upstream has finished but there\n * are still active child executors.\n *\n * @internal\n */\nexports.PullFromUpstream = PullFromUpstream;\nclass DrainChildExecutors {\n  constructor(upstreamExecutor, lastDone, activeChildExecutors, upstreamDone, combineChildResults, combineWithChildResult, onPull) {\n    this.upstreamExecutor = upstreamExecutor;\n    this.lastDone = lastDone;\n    this.activeChildExecutors = activeChildExecutors;\n    this.upstreamDone = upstreamDone;\n    this.combineChildResults = combineChildResults;\n    this.combineWithChildResult = combineWithChildResult;\n    this.onPull = onPull;\n    this._tag = OP_DRAIN_CHILD_EXECUTORS;\n  }\n  close(exit) {\n    return (0, _Debug.bodyWithTrace)(trace => {\n      const fin1 = this.upstreamExecutor.close(exit);\n      const fins = [...this.activeChildExecutors.map(child => child !== undefined ? child.childExecutor.close(exit) : undefined), fin1];\n      const result = fins.reduce((acc, next) => {\n        if (acc !== undefined && next !== undefined) {\n          return Effect.zipWith(Effect.exit(next), (exit1, exit2) => Exit.zipRight(exit2)(exit1))(acc);\n        } else if (acc !== undefined) {\n          return acc;\n        } else if (next !== undefined) {\n          return Effect.exit(next);\n        } else {\n          return undefined;\n        }\n      }, undefined);\n      return result === undefined ? result : result.traced(trace);\n    });\n  }\n  enqueuePullFromChild(child) {\n    return new DrainChildExecutors(this.upstreamExecutor, this.lastDone, [...this.activeChildExecutors, child], this.upstreamDone, this.combineChildResults, this.combineWithChildResult, this.onPull);\n  }\n}\n/** @internal */\nexports.DrainChildExecutors = DrainChildExecutors;\nclass Emit {\n  constructor(value, next) {\n    this.value = value;\n    this.next = next;\n    this._tag = OP_EMIT;\n  }\n  close(exit) {\n    return (0, _Debug.bodyWithTrace)(trace => {\n      const result = this.next.close(exit);\n      return result === undefined ? result : result.traced(trace);\n    });\n  }\n  enqueuePullFromChild(_child) {\n    return this;\n  }\n}\nexports.Emit = Emit;\n//# sourceMappingURL=subexecutor.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.match = exports.isUpstreamPullRequest = exports.isPulled = exports.isNoUpstream = exports.UpstreamPullRequestTypeId = exports.Pulled = exports.NoUpstream = void 0;\nvar _Function = /*#__PURE__*/require(\"@effect/data/Function\");\nvar OpCodes = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/stream/internal/opCodes/upstreamPullRequest\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/** @internal */\nconst UpstreamPullRequestSymbolKey = \"@effect/stream/Channel/UpstreamPullRequest\";\n/** @internal */\nconst UpstreamPullRequestTypeId = /*#__PURE__*/Symbol.for(UpstreamPullRequestSymbolKey);\n/** @internal */\nexports.UpstreamPullRequestTypeId = UpstreamPullRequestTypeId;\nconst upstreamPullRequestVariance = {\n  _A: _ => _\n};\n/** @internal */\nconst proto = {\n  [UpstreamPullRequestTypeId]: upstreamPullRequestVariance\n};\n/** @internal */\nconst Pulled = value => {\n  const op = Object.create(proto);\n  op._tag = OpCodes.OP_PULLED;\n  op.value = value;\n  return op;\n};\n/** @internal */\nexports.Pulled = Pulled;\nconst NoUpstream = activeDownstreamCount => {\n  const op = Object.create(proto);\n  op._tag = OpCodes.OP_NO_UPSTREAM;\n  op.activeDownstreamCount = activeDownstreamCount;\n  return op;\n};\n/** @internal */\nexports.NoUpstream = NoUpstream;\nconst isUpstreamPullRequest = u => typeof u === \"object\" && u != null && UpstreamPullRequestTypeId in u;\n/** @internal */\nexports.isUpstreamPullRequest = isUpstreamPullRequest;\nconst isPulled = self => self._tag === OpCodes.OP_PULLED;\n/** @internal */\nexports.isPulled = isPulled;\nconst isNoUpstream = self => self._tag === OpCodes.OP_NO_UPSTREAM;\n/** @internal */\nexports.isNoUpstream = isNoUpstream;\nconst match = /*#__PURE__*/(0, _Function.dual)(3, (self, onPulled, onNoUpstream) => {\n  switch (self._tag) {\n    case OpCodes.OP_PULLED:\n      {\n        return onPulled(self.value);\n      }\n    case OpCodes.OP_NO_UPSTREAM:\n      {\n        return onNoUpstream(self.activeDownstreamCount);\n      }\n  }\n});\nexports.match = match;\n//# sourceMappingURL=upstreamPullRequest.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.match = exports.isUpstreamPullStrategy = exports.isPullAfterNext = exports.isPullAfterAllEnqueued = exports.UpstreamPullStrategyTypeId = exports.PullAfterNext = exports.PullAfterAllEnqueued = void 0;\nvar _Function = /*#__PURE__*/require(\"@effect/data/Function\");\nvar OpCodes = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/stream/internal/opCodes/upstreamPullStrategy\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/** @internal */\nconst UpstreamPullStrategySymbolKey = \"@effect/stream/Channel/UpstreamPullStrategy\";\n/** @internal */\nconst UpstreamPullStrategyTypeId = /*#__PURE__*/Symbol.for(UpstreamPullStrategySymbolKey);\n/** @internal */\nexports.UpstreamPullStrategyTypeId = UpstreamPullStrategyTypeId;\nconst upstreamPullStrategyVariance = {\n  _A: _ => _\n};\n/** @internal */\nconst proto = {\n  [UpstreamPullStrategyTypeId]: upstreamPullStrategyVariance\n};\n/** @internal */\nconst PullAfterNext = emitSeparator => {\n  const op = Object.create(proto);\n  op._tag = OpCodes.OP_PULL_AFTER_NEXT;\n  op.emitSeparator = emitSeparator;\n  return op;\n};\n/** @internal */\nexports.PullAfterNext = PullAfterNext;\nconst PullAfterAllEnqueued = emitSeparator => {\n  const op = Object.create(proto);\n  op._tag = OpCodes.OP_PULL_AFTER_ALL_ENQUEUED;\n  op.emitSeparator = emitSeparator;\n  return op;\n};\n/** @internal */\nexports.PullAfterAllEnqueued = PullAfterAllEnqueued;\nconst isUpstreamPullStrategy = u => typeof u === \"object\" && u != null && UpstreamPullStrategyTypeId in u;\n/** @internal */\nexports.isUpstreamPullStrategy = isUpstreamPullStrategy;\nconst isPullAfterNext = self => self._tag === OpCodes.OP_PULL_AFTER_NEXT;\n/** @internal */\nexports.isPullAfterNext = isPullAfterNext;\nconst isPullAfterAllEnqueued = self => self._tag === OpCodes.OP_PULL_AFTER_ALL_ENQUEUED;\n/** @internal */\nexports.isPullAfterAllEnqueued = isPullAfterAllEnqueued;\nconst match = /*#__PURE__*/(0, _Function.dual)(3, (self, onPullAfterNext, onPullAfterAllEnqueued) => {\n  switch (self._tag) {\n    case OpCodes.OP_PULL_AFTER_NEXT:\n      {\n        return onPullAfterNext(self.emitSeparator);\n      }\n    case OpCodes.OP_PULL_AFTER_ALL_ENQUEUED:\n      {\n        return onPullAfterAllEnqueued(self.emitSeparator);\n      }\n  }\n});\nexports.match = match;\n//# sourceMappingURL=upstreamPullStrategy.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.write = exports.unit = exports.sync = exports.suspend = exports.succeedNow = exports.succeed = exports.readWithCause = exports.readWith = exports.readOrFail = exports.provideContext = exports.pipeTo = exports.fromEffect = exports.foldCauseChannel = exports.flatMap = exports.failSync = exports.failCauseSync = exports.failCause = exports.fail = exports.ensuringWith = exports.embedInput = exports.concatMapWithCustom = exports.concatMapWith = exports.concatAllWith = exports.concatAll = exports.collectElements = exports.catchAllCause = exports.acquireReleaseOut = exports.ChannelTypeId = void 0;\nvar Chunk = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Chunk\"));\nvar Either = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Either\"));\nvar _Function = /*#__PURE__*/require(\"@effect/data/Function\");\nvar Option = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Option\"));\nvar Cause = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Cause\"));\nvar Debug = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Debug\"));\nvar childExecutorDecision = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/stream/internal/channel/childExecutorDecision\"));\nvar _continuation = /*#__PURE__*/require(\"@effect/stream/internal/channel/continuation\");\nvar upstreamPullStrategy = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/stream/internal/channel/upstreamPullStrategy\"));\nvar OpCodes = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/stream/internal/opCodes/channel\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/** @internal */\nconst ChannelSymbolKey = \"@effect/stream/Channel\";\n/** @internal */\nconst ChannelTypeId = /*#__PURE__*/Symbol.for(ChannelSymbolKey);\n/** @internal */\nexports.ChannelTypeId = ChannelTypeId;\nconst channelVariance = {\n  _Env: _ => _,\n  _InErr: _ => _,\n  _InElem: _ => _,\n  _InDone: _ => _,\n  _OutErr: _ => _,\n  _OutElem: _ => _,\n  _OutDone: _ => _\n};\n/** @internal */\nconst proto = {\n  [ChannelTypeId]: channelVariance,\n  traced(trace) {\n    if (trace) {\n      return Object.create(proto, {\n        _tag: {\n          value: OpCodes.OP_TRACED\n        },\n        channel: {\n          value: this\n        },\n        trace: {\n          value: trace\n        }\n      });\n    }\n    return this;\n  }\n};\n/** @internal */\nconst acquireReleaseOut = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, release) => {\n  const op = Object.create(proto);\n  op._tag = OpCodes.OP_BRACKET_OUT;\n  op.acquire = () => self;\n  op.finalizer = restore(release);\n  return op.traced(trace);\n});\n/** @internal */\nexports.acquireReleaseOut = acquireReleaseOut;\nconst catchAllCause = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => {\n  const op = Object.create(proto);\n  op._tag = OpCodes.OP_FOLD;\n  op.channel = self;\n  op.k = new _continuation.ContinuationKImpl(succeed, restore(f));\n  return op.traced(trace);\n});\n/** @internal */\nexports.catchAllCause = catchAllCause;\nconst collectElements = /*#__PURE__*/Debug.methodWithTrace(trace => self => {\n  return suspend(() => {\n    const builder = [];\n    return flatMap(pipeTo(self, collectElementsReader(builder)), value => sync(() => [Chunk.fromIterable(builder), value]));\n  }).traced(trace);\n});\n/** @internal */\nexports.collectElements = collectElements;\nconst collectElementsReader = builder => {\n  return readWith(outElem => flatMap(sync(() => {\n    builder.push(outElem);\n  }), () => collectElementsReader(builder)), fail, succeedNow);\n};\n/** @internal */\nconst concatAll = /*#__PURE__*/Debug.methodWithTrace(trace => channels => concatAllWith(channels, _Function.constVoid, _Function.constVoid).traced(trace));\n/** @internal */\nexports.concatAll = concatAll;\nconst concatAllWith = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => (channels, f, g) => {\n  const op = Object.create(proto);\n  op._tag = OpCodes.OP_CONCAT_ALL;\n  op.combineInners = restore(f);\n  op.combineAll = restore(g);\n  op.onPull = () => upstreamPullStrategy.PullAfterNext(Option.none());\n  op.onEmit = () => childExecutorDecision.Continue;\n  op.value = () => channels;\n  op.k = _Function.identity;\n  return op.traced(trace);\n});\n/** @internal */\nexports.concatAllWith = concatAllWith;\nconst concatMapWith = /*#__PURE__*/Debug.dualWithTrace(4, (trace, restore) => (self, f, g, h) => {\n  const op = Object.create(proto);\n  op._tag = OpCodes.OP_CONCAT_ALL;\n  op.combineInners = restore(g);\n  op.combineAll = restore(h);\n  op.onPull = () => upstreamPullStrategy.PullAfterNext(Option.none());\n  op.onEmit = () => childExecutorDecision.Continue;\n  op.value = () => self;\n  op.k = restore(f);\n  return op.traced(trace);\n});\n/** @internal */\nexports.concatMapWith = concatMapWith;\nconst concatMapWithCustom = /*#__PURE__*/Debug.dualWithTrace(6, (trace, restore) => (self, f, g, h, onPull, onEmit) => {\n  const op = Object.create(proto);\n  op._tag = OpCodes.OP_CONCAT_ALL;\n  op.combineInners = restore(g);\n  op.combineAll = restore(h);\n  op.onPull = restore(onPull);\n  op.onEmit = restore(onEmit);\n  op.value = () => self;\n  op.k = restore(f);\n  return op.traced(trace);\n});\n/** @internal */\nexports.concatMapWithCustom = concatMapWithCustom;\nconst embedInput = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, input) => {\n  const op = Object.create(proto);\n  op._tag = OpCodes.OP_BRIDGE;\n  op.input = input;\n  op.channel = self;\n  return op.traced(trace);\n});\n/** @internal */\nexports.embedInput = embedInput;\nconst ensuringWith = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, finalizer) => {\n  const op = Object.create(proto);\n  op._tag = OpCodes.OP_ENSURING;\n  op.channel = self;\n  op.finalizer = restore(finalizer);\n  return op.traced(trace);\n});\n/** @internal */\nexports.ensuringWith = ensuringWith;\nconst fail = /*#__PURE__*/Debug.methodWithTrace(trace => error => failCause(Cause.fail(error)).traced(trace));\n/** @internal */\nexports.fail = fail;\nconst failSync = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => evaluate => failCauseSync(() => Cause.fail(restore(evaluate)())).traced(trace));\n/** @internal */\nexports.failSync = failSync;\nconst failCause = /*#__PURE__*/Debug.methodWithTrace(trace => cause => failCauseSync(() => cause).traced(trace));\n/** @internal */\nexports.failCause = failCause;\nconst failCauseSync = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => evaluate => {\n  const op = Object.create(proto);\n  op._tag = OpCodes.OP_FAIL;\n  op.error = restore(evaluate);\n  return op.traced(trace);\n});\n/** @internal */\nexports.failCauseSync = failCauseSync;\nconst flatMap = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => {\n  const op = Object.create(proto);\n  op._tag = OpCodes.OP_FOLD;\n  op.channel = self;\n  op.k = new _continuation.ContinuationKImpl(restore(f), failCause);\n  return op.traced(trace);\n});\n/** @internal */\nexports.flatMap = flatMap;\nconst foldCauseChannel = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (self, onError, onSuccess) => {\n  const op = Object.create(proto);\n  op._tag = OpCodes.OP_FOLD;\n  op.channel = self;\n  op.k = new _continuation.ContinuationKImpl(restore(onSuccess), restore(onError));\n  return op.traced(trace);\n});\n/** @internal */\nexports.foldCauseChannel = foldCauseChannel;\nconst fromEffect = /*#__PURE__*/Debug.methodWithTrace(trace => effect => {\n  const op = Object.create(proto);\n  op._tag = OpCodes.OP_FROM_EFFECT;\n  op.effect = () => effect;\n  return op.traced(trace);\n});\n/** @internal */\nexports.fromEffect = fromEffect;\nconst pipeTo = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, that) => {\n  const op = Object.create(proto);\n  op._tag = OpCodes.OP_PIPE_TO;\n  op.left = () => self;\n  op.right = () => that;\n  return op.traced(trace);\n});\n/** @internal */\nexports.pipeTo = pipeTo;\nconst provideContext = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, env) => {\n  const op = Object.create(proto);\n  op._tag = OpCodes.OP_PROVIDE;\n  op.context = () => env;\n  op.inner = self;\n  return op.traced(trace);\n});\n/** @internal */\nexports.provideContext = provideContext;\nconst readOrFail = /*#__PURE__*/Debug.methodWithTrace(trace => error => {\n  const op = Object.create(proto);\n  op._tag = OpCodes.OP_READ;\n  op.more = succeed;\n  op.done = new _continuation.ContinuationKImpl(() => fail(error), () => fail(error));\n  return op.traced(trace);\n});\n/** @internal */\nexports.readOrFail = readOrFail;\nconst readWith = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => (input, error, done) => readWithCause(restore(input), cause => Either.match(Cause.failureOrCause(cause), restore(error), failCause), restore(done)));\n/** @internal */\nexports.readWith = readWith;\nconst readWithCause = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => (input, halt, done) => {\n  const op = Object.create(proto);\n  op._tag = OpCodes.OP_READ;\n  op.more = restore(input);\n  op.done = new _continuation.ContinuationKImpl(restore(done), restore(halt));\n  return op.traced(trace);\n});\n/** @internal */\nexports.readWithCause = readWithCause;\nconst succeed = /*#__PURE__*/Debug.methodWithTrace(trace => value => sync(() => value).traced(trace));\n/** @internal */\nexports.succeed = succeed;\nconst succeedNow = /*#__PURE__*/Debug.methodWithTrace(trace => result => {\n  const op = Object.create(proto);\n  op._tag = OpCodes.OP_SUCCEED_NOW;\n  op.terminal = result;\n  return op.traced(trace);\n});\n/** @internal */\nexports.succeedNow = succeedNow;\nconst suspend = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => evaluate => {\n  const op = Object.create(proto);\n  op._tag = OpCodes.OP_SUSPEND;\n  op.channel = restore(evaluate);\n  return op.traced(trace);\n});\nexports.suspend = suspend;\nconst sync = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => evaluate => {\n  const op = Object.create(proto);\n  op._tag = OpCodes.OP_SUCCEED;\n  op.evaluate = restore(evaluate);\n  return op.traced(trace);\n});\n/** @internal */\nexports.sync = sync;\nconst unit = /*#__PURE__*/Debug.methodWithTrace(trace => () => succeedNow(void 0).traced(trace));\n/** @internal */\nexports.unit = unit;\nconst write = /*#__PURE__*/Debug.methodWithTrace(trace => out => {\n  const op = Object.create(proto);\n  op._tag = OpCodes.OP_EMIT;\n  op.out = out;\n  return op.traced(trace);\n});\nexports.write = write;\n//# sourceMappingURL=core.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.mapEffectParByKeyBuffer = exports.mapEffectParByKey = exports.make = exports.groupByKeyBuffer = exports.groupByKey = exports.groupByIterable = exports.groupByBuffer = exports.groupBy = exports.first = exports.filter = exports.evaluateBuffer = exports.evaluate = exports.GroupByTypeId = void 0;\nvar Chunk = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Chunk\"));\nvar _Function = /*#__PURE__*/require(\"@effect/data/Function\");\nvar Option = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Option\"));\nvar Cause = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Cause\"));\nvar Deferred = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Deferred\"));\nvar Effect = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Effect\"));\nvar Exit = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Exit\"));\nvar Queue = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Queue\"));\nvar Ref = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Ref\"));\nvar channel = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/stream/internal/channel\"));\nvar channelExecutor = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/stream/internal/channel/channelExecutor\"));\nvar core = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/stream/internal/core\"));\nvar stream = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/stream/internal/stream\"));\nvar take = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/stream/internal/take\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\nvar _a;\n/** @internal */\nconst GroupBySymbolKey = \"@effect/stream/GroupBy\";\n/** @internal */\nconst GroupByTypeId = /*#__PURE__*/Symbol.for(GroupBySymbolKey);\n/** @internal */\nexports.GroupByTypeId = GroupByTypeId;\nconst groupByVariance = {\n  _R: _ => _,\n  _E: _ => _,\n  _K: _ => _,\n  _V: _ => _\n};\n/** @internal */\nconst evaluate = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => evaluateBuffer(self, f, 16));\n/** @internal */\nexports.evaluate = evaluate;\nconst evaluateBuffer = /*#__PURE__*/(0, _Function.dual)(3, (self, f, bufferSize) => stream.flatMapParBuffer(self.grouped, Number.POSITIVE_INFINITY, bufferSize, ([key, queue]) => f(key, stream.flattenTake(stream.fromQueueWithShutdown(queue)))));\n/** @internal */\nexports.evaluateBuffer = evaluateBuffer;\nconst filter = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => make(stream.filterEffect(tuple => {\n  if (predicate(tuple[0])) {\n    return Effect.as(true)(Effect.succeed(tuple));\n  }\n  return Effect.as(false)(Queue.shutdown(tuple[1]));\n})(self.grouped)));\n/** @internal */\nexports.filter = filter;\nconst first = /*#__PURE__*/(0, _Function.dual)(2, (self, n) => make(stream.map(tuple => tuple[0])(stream.filterEffect(tuple => {\n  const index = tuple[1];\n  const queue = tuple[0][1];\n  if (index < n) {\n    return Effect.as(true)(Effect.succeed(tuple));\n  }\n  return Effect.as(false)(Queue.shutdown(queue));\n})(stream.zipWithIndex(self.grouped)))));\n/** @internal */\nexports.first = first;\nconst make = grouped => ({\n  [GroupByTypeId]: groupByVariance,\n  grouped\n});\n// Circular with Stream\n/** @internal */\nexports.make = make;\nconst groupBy = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => groupByBuffer(self, f, 16));\n/** @internal */\nexports.groupBy = groupBy;\nconst groupByBuffer = /*#__PURE__*/(0, _Function.dual)(3, (self, f, bufferSize) => make(stream.unwrapScoped(Effect.gen(function* ($) {\n  const decider = yield* $(Deferred.make());\n  const output = yield* $(Effect.acquireRelease(Queue.bounded(bufferSize), queue => Queue.shutdown(queue)));\n  const ref = yield* $(Ref.make(new Map()));\n  const add = yield* $(stream.distributedWithDynamicCallback(bufferSize, ([key, value]) => Effect.flatMap(f => f(key, value))(Deferred.await(decider)), exit => Queue.offer(output, exit))(stream.mapEffect(self, f)));\n  yield* $(Deferred.succeed(decider, (key, _) => Effect.flatMap(Option.match(() => Effect.flatMap(([index, queue]) => Effect.zipRight(Effect.as(n => n === index)(Queue.offer(output, Exit.succeed([key, mapDequeue(queue, exit => new take.TakeImpl(Exit.map(tuple => Chunk.of(tuple[1]))(exit)))]))))(Ref.update(ref, map => map.set(key, index))))(add), index => Effect.succeed(n => n === index)))(Effect.map(map => Option.fromNullable(map.get(key)))(Ref.get(ref)))));\n  return stream.flattenExitOption(stream.fromQueueWithShutdown(output));\n}))));\nexports.groupByBuffer = groupByBuffer;\nconst mapDequeue = (dequeue, f) => new MapDequeue(dequeue, f);\nclass MapDequeue {\n  constructor(dequeue, f) {\n    this.dequeue = dequeue;\n    this.f = f;\n    this[_a] = {\n      _Out: _ => _\n    };\n  }\n  capacity() {\n    return Queue.capacity(this.dequeue);\n  }\n  size() {\n    return Queue.size(this.dequeue);\n  }\n  awaitShutdown() {\n    return Queue.awaitShutdown(this.dequeue);\n  }\n  isShutdown() {\n    return Queue.isShutdown(this.dequeue);\n  }\n  shutdown() {\n    return Queue.shutdown(this.dequeue);\n  }\n  isFull() {\n    return Queue.isFull(this.dequeue);\n  }\n  isEmpty() {\n    return Queue.isEmpty(this.dequeue);\n  }\n  take() {\n    return Effect.map(a => this.f(a))(Queue.take(this.dequeue));\n  }\n  takeAll() {\n    return Effect.map(Chunk.map(a => this.f(a)))(Queue.takeAll(this.dequeue));\n  }\n  takeUpTo(max) {\n    return Effect.map(Chunk.map(a => this.f(a)))(Queue.takeUpTo(this.dequeue, max));\n  }\n  takeBetween(min, max) {\n    return Effect.map(Chunk.map(a => this.f(a)))(Queue.takeBetween(this.dequeue, min, max));\n  }\n  takeN(n) {\n    return Effect.map(Chunk.map(a => this.f(a)))(Queue.takeN(this.dequeue, n));\n  }\n  poll() {\n    return Effect.map(Option.map(a => this.f(a)))(Queue.poll(this.dequeue));\n  }\n}\n_a = Queue.DequeueTypeId;\n/** @internal */\nconst groupByKey = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => groupByKeyBuffer(self, f, 16));\n/** @internal */\nexports.groupByKey = groupByKey;\nconst groupByKeyBuffer = /*#__PURE__*/(0, _Function.dual)(3, (self, f, bufferSize) => {\n  const loop = (map, outerQueue) => core.readWithCause(input => core.flatMap(() => loop(map, outerQueue))(core.fromEffect(Effect.forEachDiscard(([key, values]) => {\n    const innerQueue = map.get(key);\n    if (innerQueue === undefined) {\n      return Effect.flatMap(innerQueue => Effect.zipRight(Effect.catchSomeCause(cause => Cause.isInterruptedOnly(cause) ? Option.some(Effect.unit()) : Option.none())(Queue.offer(innerQueue, take.chunk(values))))(Effect.zipRight(Queue.offer(outerQueue, take.of([key, innerQueue])))(Effect.sync(() => {\n        map.set(key, innerQueue);\n      }))))(Queue.bounded(bufferSize));\n    }\n    return Effect.catchSomeCause(cause => Cause.isInterruptedOnly(cause) ? Option.some(Effect.unit()) : Option.none())(Queue.offer(innerQueue, take.chunk(values)));\n  })(groupByIterable(f)(input)))), cause => core.fromEffect(Queue.offer(outerQueue, take.failCause(cause))), () => core.fromEffect(Effect.zipRight(Queue.offer(outerQueue, take.end))(Effect.forEachDiscard(([_, innerQueue]) => Effect.catchSomeCause(cause => Cause.isInterruptedOnly(cause) ? Option.some(Effect.unit()) : Option.none())(Queue.offer(innerQueue, take.end)))(map.entries()))));\n  return make(stream.unwrapScoped(Effect.flatMap(map => Effect.flatMap(queue => Effect.as(stream.flattenTake(stream.fromQueueWithShutdown(queue)))(Effect.forkScoped(channelExecutor.runScoped(channel.drain(core.pipeTo(loop(map, queue))(self.channel))))))(Effect.acquireRelease(Queue.unbounded(), queue => Queue.shutdown(queue))))(Effect.sync(() => new Map()))));\n});\n/** @internal */\nexports.groupByKeyBuffer = groupByKeyBuffer;\nconst mapEffectParByKey = /*#__PURE__*/(0, _Function.dual)(3, (self, keyBy, f) => mapEffectParByKeyBuffer(self, keyBy, 16, f));\n/** @internal */\nexports.mapEffectParByKey = mapEffectParByKey;\nconst mapEffectParByKeyBuffer = /*#__PURE__*/(0, _Function.dual)(4, (self, keyBy, bufferSize, f) => evaluate((_, s) => stream.mapEffect(f)(s))(groupByKeyBuffer(self, keyBy, bufferSize)));\n/**\n * A variant of `groupBy` that retains the insertion order of keys.\n *\n * @internal\n */\nexports.mapEffectParByKeyBuffer = mapEffectParByKeyBuffer;\nconst groupByIterable = /*#__PURE__*/(0, _Function.dual)(2, (iterable, f) => {\n  const builder = [];\n  const iterator = iterable[Symbol.iterator]();\n  const map = new Map();\n  let next;\n  while ((next = iterator.next()) && !next.done) {\n    const value = next.value;\n    const key = f(value);\n    if (map.has(key)) {\n      const innerBuilder = map.get(key);\n      innerBuilder.push(value);\n    } else {\n      const innerBuilder = [value];\n      builder.push([key, innerBuilder]);\n      map.set(key, innerBuilder);\n    }\n  }\n  return Chunk.unsafeFromArray(builder.map(tuple => [tuple[0], Chunk.unsafeFromArray(tuple[1])]));\n});\nexports.groupByIterable = groupByIterable;\n//# sourceMappingURL=groupBy.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.OP_TRACED = exports.OP_SUSPEND = exports.OP_SUCCEED_NOW = exports.OP_SUCCEED = exports.OP_READ = exports.OP_PROVIDE = exports.OP_PIPE_TO = exports.OP_FROM_EFFECT = exports.OP_FOLD = exports.OP_FAIL = exports.OP_ENSURING = exports.OP_EMIT = exports.OP_CONCAT_ALL = exports.OP_BRIDGE = exports.OP_BRACKET_OUT = void 0;\n/** @internal */\nconst OP_BRACKET_OUT = \"BracketOut\";\n/** @internal */\nexports.OP_BRACKET_OUT = OP_BRACKET_OUT;\nconst OP_BRIDGE = \"Bridge\";\n/** @internal */\nexports.OP_BRIDGE = OP_BRIDGE;\nconst OP_CONCAT_ALL = \"ConcatAll\";\n/** @internal */\nexports.OP_CONCAT_ALL = OP_CONCAT_ALL;\nconst OP_EMIT = \"Emit\";\n/** @internal */\nexports.OP_EMIT = OP_EMIT;\nconst OP_ENSURING = \"Ensuring\";\n/** @internal */\nexports.OP_ENSURING = OP_ENSURING;\nconst OP_FAIL = \"Fail\";\n/** @internal */\nexports.OP_FAIL = OP_FAIL;\nconst OP_FOLD = \"Fold\";\n/** @internal */\nexports.OP_FOLD = OP_FOLD;\nconst OP_FROM_EFFECT = \"FromEffect\";\n/** @internal */\nexports.OP_FROM_EFFECT = OP_FROM_EFFECT;\nconst OP_PIPE_TO = \"PipeTo\";\n/** @internal */\nexports.OP_PIPE_TO = OP_PIPE_TO;\nconst OP_PROVIDE = \"Provide\";\n/** @internal */\nexports.OP_PROVIDE = OP_PROVIDE;\nconst OP_READ = \"Read\";\n/** @internal */\nexports.OP_READ = OP_READ;\nconst OP_SUCCEED = \"Succeed\";\n/** @internal */\nexports.OP_SUCCEED = OP_SUCCEED;\nconst OP_SUCCEED_NOW = \"SucceedNow\";\n/** @internal */\nexports.OP_SUCCEED_NOW = OP_SUCCEED_NOW;\nconst OP_SUSPEND = \"Suspend\";\n/** @internal */\nexports.OP_SUSPEND = OP_SUSPEND;\nconst OP_TRACED = \"Traced\";\nexports.OP_TRACED = OP_TRACED;\n//# sourceMappingURL=channel.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.OP_READ = exports.OP_FROM_EFFECT = exports.OP_EMIT = exports.OP_DONE = void 0;\n/** @internal */\nconst OP_DONE = \"Done\";\n/** @internal */\nexports.OP_DONE = OP_DONE;\nconst OP_EMIT = \"Emit\";\n/** @internal */\nexports.OP_EMIT = OP_EMIT;\nconst OP_FROM_EFFECT = \"FromEffect\";\n/** @internal */\nexports.OP_FROM_EFFECT = OP_FROM_EFFECT;\nconst OP_READ = \"Read\";\nexports.OP_READ = OP_READ;\n//# sourceMappingURL=channelState.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.OP_YIELD = exports.OP_CONTINUE = exports.OP_CLOSE = void 0;\n/** @internal */\nconst OP_CONTINUE = \"Continue\";\n/** @internal */\nexports.OP_CONTINUE = OP_CONTINUE;\nconst OP_CLOSE = \"Close\";\n/** @internal */\nexports.OP_CLOSE = OP_CLOSE;\nconst OP_YIELD = \"Yield\";\nexports.OP_YIELD = OP_YIELD;\n//# sourceMappingURL=childExecutorDecision.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.OP_CONTINUATION_K = exports.OP_CONTINUATION_FINALIZER = void 0;\n/** @internal */\nconst OP_CONTINUATION_K = \"ContinuationK\";\n/** @internal */\nexports.OP_CONTINUATION_K = OP_CONTINUATION_K;\nconst OP_CONTINUATION_FINALIZER = \"ContinuationFinalizer\";\nexports.OP_CONTINUATION_FINALIZER = OP_CONTINUATION_FINALIZER;\n//# sourceMappingURL=continuation.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.OP_RIGHT = exports.OP_LEFT = exports.OP_EITHER = exports.OP_BOTH = void 0;\n/** @internal */\nconst OP_LEFT = \"Left\";\n/** @internal */\nexports.OP_LEFT = OP_LEFT;\nconst OP_RIGHT = \"Right\";\n/** @internal */\nexports.OP_RIGHT = OP_RIGHT;\nconst OP_BOTH = \"Both\";\n/** @internal */\nexports.OP_BOTH = OP_BOTH;\nconst OP_EITHER = \"Either\";\nexports.OP_EITHER = OP_EITHER;\n//# sourceMappingURL=haltStrategy.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.OP_DONE = exports.OP_AWAIT = void 0;\n/** @internal */\nconst OP_DONE = \"Done\";\n/** @internal */\nexports.OP_DONE = OP_DONE;\nconst OP_AWAIT = \"Await\";\nexports.OP_AWAIT = OP_AWAIT;\n//# sourceMappingURL=mergeDecision.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.OP_RIGHT_DONE = exports.OP_LEFT_DONE = exports.OP_BOTH_RUNNING = void 0;\n/** @internal */\nconst OP_BOTH_RUNNING = \"BothRunning\";\n/** @internal */\nexports.OP_BOTH_RUNNING = OP_BOTH_RUNNING;\nconst OP_LEFT_DONE = \"LeftDone\";\n/** @internal */\nexports.OP_LEFT_DONE = OP_LEFT_DONE;\nconst OP_RIGHT_DONE = \"RightDone\";\nexports.OP_RIGHT_DONE = OP_RIGHT_DONE;\n//# sourceMappingURL=mergeState.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.OP_BUFFER_SLIDING = exports.OP_BACK_PRESSURE = void 0;\n/** @internal */\nconst OP_BACK_PRESSURE = \"BackPressure\";\n/** @internal */\nexports.OP_BACK_PRESSURE = OP_BACK_PRESSURE;\nconst OP_BUFFER_SLIDING = \"BufferSliding\";\nexports.OP_BUFFER_SLIDING = OP_BUFFER_SLIDING;\n//# sourceMappingURL=mergeStrategy.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.OP_PULLED = exports.OP_NO_UPSTREAM = void 0;\n/** @internal */\nconst OP_PULLED = \"Pulled\";\n/** @internal */\nexports.OP_PULLED = OP_PULLED;\nconst OP_NO_UPSTREAM = \"NoUpstream\";\nexports.OP_NO_UPSTREAM = OP_NO_UPSTREAM;\n//# sourceMappingURL=upstreamPullRequest.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.OP_PULL_AFTER_NEXT = exports.OP_PULL_AFTER_ALL_ENQUEUED = void 0;\n/** @internal */\nconst OP_PULL_AFTER_NEXT = \"PullAfterNext\";\n/** @internal */\nexports.OP_PULL_AFTER_NEXT = OP_PULL_AFTER_NEXT;\nconst OP_PULL_AFTER_ALL_ENQUEUED = \"PullAfterAllEnqueued\";\nexports.OP_PULL_AFTER_ALL_ENQUEUED = OP_PULL_AFTER_ALL_ENQUEUED;\n//# sourceMappingURL=upstreamPullStrategy.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.map = exports.logWarningCauseMessage = exports.logWarningCause = exports.logWarning = exports.logTraceCauseMessage = exports.logTraceCause = exports.logTrace = exports.logInfoCauseMessage = exports.logInfoCause = exports.logInfo = exports.logFatalCauseMessage = exports.logFatalCause = exports.logFatal = exports.logErrorCauseMessage = exports.logErrorCause = exports.logError = exports.logDebugCauseMessage = exports.logDebugCause = exports.logDebug = exports.log = exports.leftover = exports.last = exports.ignoreLeftover = exports.head = exports.fromQueueWithShutdown = exports.fromQueue = exports.fromPush = exports.fromHubWithShutdown = exports.fromHub = exports.fromEffect = exports.fromChannel = exports.forEachWhile = exports.forEachChunkWhile = exports.forEachChunk = exports.forEach = exports.foldWeightedEffect = exports.foldWeightedDecomposeEffect = exports.foldWeightedDecompose = exports.foldWeighted = exports.foldUntilEffect = exports.foldUntil = exports.foldSink = exports.foldLeftEffect = exports.foldLeftChunksEffect = exports.foldLeftChunks = exports.foldLeft = exports.foldEffect = exports.foldChunksEffect = exports.foldChunks = exports.fold = exports.flatMap = exports.findEffect = exports.filterInputEffect = exports.filterInput = exports.failSync = exports.failCauseSync = exports.failCause = exports.fail = exports.every = exports.ensuringWith = exports.ensuring = exports.dropWhileEffect = exports.dropWhile = exports.dropUntilEffect = exports.dropUntil = exports.drop = exports.drain = exports.dimapEffect = exports.dimapChunksEffect = exports.dimapChunks = exports.dimap = exports.dieSync = exports.dieMessage = exports.die = exports.count = exports.contramapEffect = exports.contramapChunksEffect = exports.contramapChunks = exports.contramap = exports.contextWithSink = exports.contextWithEffect = exports.contextWith = exports.context = exports.collectLeftover = exports.collectAllWhileWith = exports.collectAllWhileEffect = exports.collectAllWhile = exports.collectAllUntilEffect = exports.collectAllUntil = exports.collectAllToSetN = exports.collectAllToSet = exports.collectAllToMapN = exports.collectAllToMap = exports.collectAllN = exports.collectAllFrom = exports.collectAll = exports.channelToSink = exports.as = exports.SinkTypeId = exports.SinkImpl = void 0;\nexports.zipWithPar = exports.zipWith = exports.zipRight = exports.zipParRight = exports.zipParLeft = exports.zipPar = exports.zipLeft = exports.zip = exports.withDuration = exports.unwrapScoped = exports.unwrap = exports.toChannel = exports.timed = exports.take = exports.sync = exports.suspend = exports.summarized = exports.sum = exports.succeed = exports.splitWhere = exports.some = exports.serviceWithSink = exports.serviceWithEffect = exports.serviceWith = exports.service = exports.refineOrDieWith = exports.refineOrDie = exports.raceWithCapacity = exports.raceWith = exports.raceBothCapacity = exports.raceBoth = exports.race = exports.provideContext = exports.orElse = exports.never = exports.mkString = exports.mapLeftover = exports.mapError = exports.mapEffect = void 0;\nvar Chunk = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Chunk\"));\nvar Duration = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Duration\"));\nvar Either = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Either\"));\nvar _Function = /*#__PURE__*/require(\"@effect/data/Function\");\nvar HashMap = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/HashMap\"));\nvar HashSet = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/HashSet\"));\nvar Option = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Option\"));\nvar ReadonlyArray = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/ReadonlyArray\"));\nvar Cause = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Cause\"));\nvar Clock = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Clock\"));\nvar Effect = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Effect\"));\nvar Exit = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Exit\"));\nvar Hub = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Hub\"));\nvar Queue = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Queue\"));\nvar Ref = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Ref\"));\nvar channel = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/stream/internal/channel\"));\nvar mergeDecision = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/stream/internal/channel/mergeDecision\"));\nvar core = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/stream/internal/core\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\nvar _a;\n/** @internal */\nconst SinkSymbolKey = \"@effect/stream/Sink\";\n/** @internal */\nconst SinkTypeId = /*#__PURE__*/Symbol.for(SinkSymbolKey);\n/** @internal */\nexports.SinkTypeId = SinkTypeId;\nconst sinkVariance = {\n  _R: _ => _,\n  _E: _ => _,\n  _In: _ => _,\n  _L: _ => _,\n  _Z: _ => _\n};\n/** @internal */\nclass SinkImpl {\n  constructor(channel) {\n    this.channel = channel;\n    this[_a] = sinkVariance;\n  }\n}\nexports.SinkImpl = SinkImpl;\n_a = SinkTypeId;\n/** @internal */\nconst as = /*#__PURE__*/(0, _Function.dual)(2, (self, z) => map(() => z)(self));\n/** @internal */\nexports.as = as;\nconst collectAll = () => new SinkImpl(collectAllLoop(Chunk.empty()));\n/** @internal */\nexports.collectAll = collectAll;\nconst collectAllLoop = acc => core.readWithCause(chunk => collectAllLoop(Chunk.concat(chunk)(acc)), core.failCause, () => core.succeed(acc));\n/** @internal */\nconst collectAllN = n => {\n  return flatMap(builder => foldUntil(builder, n, (chunk, input) => Chunk.append(input)(chunk)))(fromEffect(Effect.sync(() => Chunk.empty())));\n};\n/** @internal */\nexports.collectAllN = collectAllN;\nconst collectAllFrom = self => collectAllWhileWith(Chunk.empty(), _Function.constTrue, (chunk, z) => Chunk.append(z)(chunk))(self);\n/** @internal */\nexports.collectAllFrom = collectAllFrom;\nconst collectAllToMap = (key, merge) => {\n  return foldLeftChunks(HashMap.empty(), (map, chunk) => Chunk.reduce(map, (map, input) => {\n    const k = key(input);\n    const v = HashMap.has(k)(map) ? merge(HashMap.unsafeGet(k)(map), input) : input;\n    return HashMap.set(k, v)(map);\n  })(chunk));\n};\n/** @internal */\nexports.collectAllToMap = collectAllToMap;\nconst collectAllToMapN = (n, key, merge) => {\n  return foldWeighted(HashMap.empty(), n, (acc, input) => HashMap.has(key(input))(acc) ? 0 : 1, (acc, input) => {\n    const k = key(input);\n    const v = HashMap.has(k)(acc) ? merge(HashMap.unsafeGet(k)(acc), input) : input;\n    return HashMap.set(k, v)(acc);\n  });\n};\n/** @internal */\nexports.collectAllToMapN = collectAllToMapN;\nconst collectAllToSet = () => foldLeftChunks(HashSet.empty(), (acc, chunk) => Chunk.reduce(acc, (acc, input) => HashSet.add(input)(acc))(chunk));\n/** @internal */\nexports.collectAllToSet = collectAllToSet;\nconst collectAllToSetN = n => foldWeighted(HashSet.empty(), n, (acc, input) => HashSet.has(input)(acc) ? 0 : 1, (acc, input) => HashSet.add(input)(acc));\n/** @internal */\nexports.collectAllToSetN = collectAllToSetN;\nconst collectAllUntil = p => {\n  return map(tuple => tuple[0])(fold([Chunk.empty(), true], tuple => tuple[1], ([chunk, _], input) => [Chunk.append(input)(chunk), !p(input)]));\n};\n/** @internal */\nexports.collectAllUntil = collectAllUntil;\nconst collectAllUntilEffect = p => {\n  return map(tuple => tuple[0])(foldEffect([Chunk.empty(), true], tuple => tuple[1], ([chunk, _], input) => Effect.map(bool => [Chunk.append(input)(chunk), !bool])(p(input))));\n};\n/** @internal */\nexports.collectAllUntilEffect = collectAllUntilEffect;\nconst collectAllWhile = predicate => fromChannel(collectAllWhileReader(predicate, Chunk.empty()));\n/** @internal */\nexports.collectAllWhile = collectAllWhile;\nconst collectAllWhileReader = (predicate, done) => core.readWith(input => {\n  const [collected, leftovers] = ReadonlyArray.span(predicate)(Chunk.toReadonlyArray(input));\n  if (leftovers.length === 0) {\n    return collectAllWhileReader(predicate, Chunk.concat(Chunk.unsafeFromArray(collected))(done));\n  }\n  return channel.zipRight(core.succeed(Chunk.concat(Chunk.unsafeFromArray(collected))(done)))(core.write(Chunk.unsafeFromArray(leftovers)));\n}, core.fail, () => core.succeed(done));\n/** @internal */\nconst collectAllWhileEffect = predicate => fromChannel(collectAllWhileEffectReader(predicate, Chunk.empty()));\n/** @internal */\nexports.collectAllWhileEffect = collectAllWhileEffect;\nconst collectAllWhileEffectReader = (predicate, done) => core.readWith(input => core.flatMap(collected => {\n  const leftovers = Chunk.drop(collected.length)(input);\n  if (Chunk.isEmpty(leftovers)) {\n    return collectAllWhileEffectReader(predicate, Chunk.concat(collected)(done));\n  }\n  return channel.zipRight(core.succeed(Chunk.concat(collected)(done)))(core.write(leftovers));\n})(core.fromEffect(Effect.takeWhile(predicate)(input))), core.fail, () => core.succeed(done));\n/** @internal */\nconst collectAllWhileWith = /*#__PURE__*/(0, _Function.dual)(4, (self, z, p, f) => {\n  const refs = Effect.zip(Ref.make(false))(Ref.make(Chunk.empty()));\n  const newChannel = core.flatMap(([leftoversRef, upstreamDoneRef]) => {\n    const upstreamMarker = core.readWith(input => core.flatMap(() => upstreamMarker)(core.write(input)), core.fail, done => channel.as(done)(core.fromEffect(Ref.set(upstreamDoneRef, true))));\n    return core.pipeTo(collectAllWhileWithLoop(self, leftoversRef, upstreamDoneRef, z, p, f))(core.pipeTo(channel.bufferChunk(leftoversRef))(upstreamMarker));\n  })(core.fromEffect(refs));\n  return new SinkImpl(newChannel);\n});\n/** @internal */\nexports.collectAllWhileWith = collectAllWhileWith;\nconst collectAllWhileWithLoop = (self, leftoversRef, upstreamDoneRef, currentResult, p, f) => {\n  return channel.foldChannel(core.fail, ([leftovers, doneValue]) => p(doneValue) ? core.flatMap(() => core.flatMap(upstreamDone => {\n    const accumulatedResult = f(currentResult, doneValue);\n    return upstreamDone ? channel.as(accumulatedResult)(core.write(Chunk.flatten(leftovers))) : collectAllWhileWithLoop(self, leftoversRef, upstreamDoneRef, accumulatedResult, p, f);\n  })(core.fromEffect(Ref.get(upstreamDoneRef))))(core.fromEffect(Ref.set(leftoversRef, Chunk.flatten(leftovers)))) : channel.as(currentResult)(core.write(Chunk.flatten(leftovers))))(channel.doneCollect(self.channel));\n};\n/** @internal */\nconst collectLeftover = self => new SinkImpl(channel.map(([chunks, z]) => [z, Chunk.flatten(chunks)])(core.collectElements(self.channel)));\n/** @internal */\nexports.collectLeftover = collectLeftover;\nconst contramap = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => contramapChunks(Chunk.map(f))(self));\n/** @internal */\nexports.contramap = contramap;\nconst contramapEffect = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => contramapChunksEffect(Effect.forEach(f))(self));\n/** @internal */\nexports.contramapEffect = contramapEffect;\nconst contramapChunks = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => {\n  const loop = core.readWith(chunk => core.flatMap(() => loop)(core.write(f(chunk))), core.fail, core.succeed);\n  return new SinkImpl(core.pipeTo(self.channel)(loop));\n});\n/** @internal */\nexports.contramapChunks = contramapChunks;\nconst contramapChunksEffect = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => {\n  const loop = core.readWith(chunk => core.flatMap(() => loop)(core.flatMap(core.write)(core.fromEffect(f(chunk)))), core.fail, core.succeed);\n  return new SinkImpl(channel.pipeToOrFail(self.channel)(loop));\n});\n/** @internal */\nexports.contramapChunksEffect = contramapChunksEffect;\nconst count = () => foldLeft(0, (s, _) => s + 1);\n/** @internal */\nexports.count = count;\nconst die = defect => failCause(Cause.die(defect));\n/** @internal */\nexports.die = die;\nconst dieMessage = message => failCause(Cause.die(Cause.RuntimeException(message)));\n/** @internal */\nexports.dieMessage = dieMessage;\nconst dieSync = evaluate => failCauseSync(() => Cause.die(evaluate()));\n/** @internal */\nexports.dieSync = dieSync;\nconst dimap = /*#__PURE__*/(0, _Function.dual)(3, (self, f, g) => map(g)(contramap(f)(self)));\n/** @internal */\nexports.dimap = dimap;\nconst dimapEffect = /*#__PURE__*/(0, _Function.dual)(3, (self, f, g) => mapEffect(g)(contramapEffect(f)(self)));\n/** @internal */\nexports.dimapEffect = dimapEffect;\nconst dimapChunks = /*#__PURE__*/(0, _Function.dual)(3, (self, f, g) => map(g)(contramapChunks(f)(self)));\n/** @internal */\nexports.dimapChunks = dimapChunks;\nconst dimapChunksEffect = /*#__PURE__*/(0, _Function.dual)(3, (self, f, g) => mapEffect(g)(contramapChunksEffect(f)(self)));\n/** @internal */\nexports.dimapChunksEffect = dimapChunksEffect;\nconst drain = () => new SinkImpl(channel.drain(channel.identityChannel()));\n/** @internal */\nexports.drain = drain;\nconst drop = n => suspend(() => new SinkImpl(dropLoop(n)));\n/** @internal */\nexports.drop = drop;\nconst dropLoop = n => core.readWith(input => {\n  const dropped = Chunk.drop(n)(input);\n  const leftover = Math.max(n - input.length, 0);\n  const more = Chunk.isEmpty(input) || leftover > 0;\n  if (more) {\n    return dropLoop(leftover);\n  }\n  return channel.zipRight(channel.identityChannel())(core.write(dropped));\n}, core.fail, core.unit);\n/** @internal */\nconst dropUntil = predicate => new SinkImpl(channel.pipeToOrFail(drop(1).channel)(dropWhile(input => !predicate(input)).channel));\n/** @internal */\nexports.dropUntil = dropUntil;\nconst dropUntilEffect = predicate => suspend(() => new SinkImpl(dropUntilEffectReader(predicate)));\n/** @internal */\nexports.dropUntilEffect = dropUntilEffect;\nconst dropUntilEffectReader = predicate => core.readWith(input => channel.unwrap(Effect.map(leftover => {\n  const more = Chunk.isEmpty(leftover);\n  return more ? dropUntilEffectReader(predicate) : channel.zipRight(channel.identityChannel())(core.write(leftover));\n})(Effect.dropUntil(predicate)(input))), core.fail, core.unit);\n/** @internal */\nconst dropWhile = predicate => new SinkImpl(dropWhileReader(predicate));\n/** @internal */\nexports.dropWhile = dropWhile;\nconst dropWhileReader = predicate => core.readWith(input => {\n  const out = Chunk.dropWhile(predicate)(input);\n  if (Chunk.isEmpty(out)) {\n    return dropWhileReader(predicate);\n  }\n  return channel.zipRight(channel.identityChannel())(core.write(out));\n}, core.fail, core.succeedNow);\n/** @internal */\nconst dropWhileEffect = predicate => suspend(() => new SinkImpl(dropWhileEffectReader(predicate)));\n/** @internal */\nexports.dropWhileEffect = dropWhileEffect;\nconst dropWhileEffectReader = predicate => core.readWith(input => channel.unwrap(Effect.map(leftover => {\n  const more = Chunk.isEmpty(leftover);\n  return more ? dropWhileEffectReader(predicate) : channel.zipRight(channel.identityChannel())(core.write(leftover));\n})(Effect.dropWhile(predicate)(input))), core.fail, core.unit);\n/** @internal */\nconst ensuring = /*#__PURE__*/(0, _Function.dual)(2, (self, finalizer) => new SinkImpl(channel.ensuring(finalizer)(self.channel)));\n/** @internal */\nexports.ensuring = ensuring;\nconst ensuringWith = /*#__PURE__*/(0, _Function.dual)(2, (self, finalizer) => new SinkImpl(core.ensuringWith(finalizer)(self.channel)));\n/** @internal */\nexports.ensuringWith = ensuringWith;\nconst context = () => fromEffect(Effect.context());\n/** @internal */\nexports.context = context;\nconst contextWith = f => map(f)(context());\n/** @internal */\nexports.contextWith = contextWith;\nconst contextWithEffect = f => mapEffect(f)(context());\n/** @internal */\nexports.contextWithEffect = contextWithEffect;\nconst contextWithSink = f => new SinkImpl(channel.unwrap(Effect.contextWith(context => f(context).channel)));\n/** @internal */\nexports.contextWithSink = contextWithSink;\nconst every = predicate => fold(true, _Function.identity, (acc, input) => acc && predicate(input));\n/** @internal */\nexports.every = every;\nconst fail = e => new SinkImpl(core.fail(e));\n/** @internal */\nexports.fail = fail;\nconst failSync = evaluate => new SinkImpl(core.failSync(evaluate));\n/** @internal */\nexports.failSync = failSync;\nconst failCause = cause => new SinkImpl(core.failCause(cause));\n/** @internal */\nexports.failCause = failCause;\nconst failCauseSync = evaluate => new SinkImpl(core.failCauseSync(evaluate));\n/** @internal */\nexports.failCauseSync = failCauseSync;\nconst filterInput = f => {\n  return self => contramapChunks(Chunk.filter(f))(self);\n};\n/** @internal */\nexports.filterInput = filterInput;\nconst filterInputEffect = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => contramapChunksEffect(Effect.filter(f))(self));\n/** @internal */\nexports.filterInputEffect = filterInputEffect;\nconst findEffect = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => {\n  const newChannel = core.flatMap(([leftoversRef, upstreamDoneRef]) => {\n    const upstreamMarker = core.readWith(input => core.flatMap(() => upstreamMarker)(core.write(input)), core.fail, done => channel.as(done)(core.fromEffect(Ref.set(upstreamDoneRef, true))));\n    const loop = channel.foldChannel(core.fail, ([leftovers, doneValue]) => core.flatMap(satisfied => channel.zipRight(core.flatMap(upstreamDone => {\n      if (satisfied) {\n        return channel.as(Option.some(doneValue))(core.write(Chunk.flatten(leftovers)));\n      }\n      if (upstreamDone) {\n        return channel.as(Option.none())(core.write(Chunk.flatten(leftovers)));\n      }\n      return loop;\n    })(core.fromEffect(Ref.get(upstreamDoneRef))))(core.fromEffect(Ref.set(leftoversRef, Chunk.flatten(leftovers)))))(core.fromEffect(f(doneValue))))(core.collectElements(self.channel));\n    return core.pipeTo(loop)(core.pipeTo(channel.bufferChunk(leftoversRef))(upstreamMarker));\n  })(core.fromEffect(Effect.zip(Ref.make(false))(Ref.make(Chunk.empty()))));\n  return new SinkImpl(newChannel);\n});\n/** @internal */\nexports.findEffect = findEffect;\nconst fold = (s, contFn, f) => suspend(() => new SinkImpl(foldReader(s, contFn, f)));\n/** @internal */\nexports.fold = fold;\nconst foldReader = (s, contFn, f) => {\n  if (!contFn(s)) {\n    return core.succeedNow(s);\n  }\n  return core.readWith(input => {\n    const [nextS, leftovers] = foldChunkSplit(s, input, contFn, f, 0, input.length);\n    if (Chunk.isNonEmpty(leftovers)) {\n      return channel.as(nextS)(core.write(leftovers));\n    }\n    return foldReader(nextS, contFn, f);\n  }, core.fail, () => core.succeedNow(s));\n};\n/** @internal */\nconst foldChunkSplit = (s, chunk, contFn, f, index, length) => {\n  if (index === length) {\n    return [s, Chunk.empty()];\n  }\n  const s1 = f(s, Chunk.unsafeGet(index)(chunk));\n  if (contFn(s1)) {\n    return foldChunkSplit(s1, chunk, contFn, f, index + 1, length);\n  }\n  return [s1, Chunk.drop(index + 1)(chunk)];\n};\n/** @internal */\nconst foldSink = /*#__PURE__*/(0, _Function.dual)(3, (self, onFailure, onSuccess) => {\n  const newChannel = channel.foldChannel(error => onFailure(error).channel, ([leftovers, z]) => core.suspend(() => {\n    const leftoversRef = {\n      ref: Chunk.filter(Chunk.isNonEmpty)(leftovers)\n    };\n    const refReader =\n    // This cast is safe because of the L1 >: L <: In1 bound. It follows that\n    // L <: In1 and therefore Chunk[L] can be safely cast to Chunk[In1].\n    core.flatMap(chunk => channel.writeChunk(chunk))(core.sync(() => {\n      const ref = leftoversRef.ref;\n      leftoversRef.ref = Chunk.empty();\n      return ref;\n    }));\n    const passthrough = channel.identityChannel();\n    const continuationSink = core.pipeTo(onSuccess(z).channel)(channel.zipRight(passthrough)(refReader));\n    return core.flatMap(([newLeftovers, z1]) => channel.as(z1)(channel.zipRight(channel.writeChunk(newLeftovers))(core.flatMap(channel.writeChunk)(core.succeed(leftoversRef.ref)))))(core.collectElements(continuationSink));\n  }))(core.collectElements(self.channel));\n  return new SinkImpl(newChannel);\n});\n/** @internal */\nexports.foldSink = foldSink;\nconst foldChunks = (s, contFn, f) => suspend(() => new SinkImpl(foldChunksReader(s, contFn, f)));\n/** @internal */\nexports.foldChunks = foldChunks;\nconst foldChunksReader = (s, contFn, f) => {\n  if (!contFn(s)) {\n    return core.succeedNow(s);\n  }\n  return core.readWith(input => foldChunksReader(f(s, input), contFn, f), core.fail, () => core.succeedNow(s));\n};\n/** @internal */\nconst foldChunksEffect = (s, contFn, f) => suspend(() => new SinkImpl(foldChunksEffectReader(s, contFn, f)));\n/** @internal */\nexports.foldChunksEffect = foldChunksEffect;\nconst foldChunksEffectReader = (s, contFn, f) => {\n  if (!contFn(s)) {\n    return core.succeedNow(s);\n  }\n  return core.readWith(input => core.flatMap(s => foldChunksEffectReader(s, contFn, f))(core.fromEffect(f(s, input))), core.fail, () => core.succeedNow(s));\n};\n/** @internal */\nconst foldEffect = (s, contFn, f) => suspend(() => new SinkImpl(foldEffectReader(s, contFn, f)));\n/** @internal */\nexports.foldEffect = foldEffect;\nconst foldEffectReader = (s, contFn, f) => {\n  if (!contFn(s)) {\n    return core.succeedNow(s);\n  }\n  return core.readWith(input => core.flatMap(([nextS, leftovers]) => Option.match(() => foldEffectReader(nextS, contFn, f), leftover => channel.as(nextS)(core.write(leftover)))(leftovers))(core.fromEffect(foldChunkSplitEffect(s, input, contFn, f))), core.fail, () => core.succeedNow(s));\n};\n/** @internal */\nconst foldChunkSplitEffect = (s, chunk, contFn, f) => foldChunkSplitEffectInternal(s, chunk, 0, chunk.length, contFn, f);\n/** @internal */\nconst foldChunkSplitEffectInternal = (s, chunk, index, length, contFn, f) => {\n  if (index === length) {\n    return Effect.succeed([s, Option.none()]);\n  }\n  return Effect.flatMap(s1 => contFn(s1) ? foldChunkSplitEffectInternal(s1, chunk, index + 1, length, contFn, f) : Effect.succeed([s1, Option.some(Chunk.drop(index + 1)(chunk))]))(f(s, Chunk.unsafeGet(index)(chunk)));\n};\n/** @internal */\nconst foldLeft = (s, f) => ignoreLeftover(fold(s, _Function.constTrue, f));\n/** @internal */\nexports.foldLeft = foldLeft;\nconst foldLeftChunks = (s, f) => foldChunks(s, _Function.constTrue, f);\n/** @internal */\nexports.foldLeftChunks = foldLeftChunks;\nconst foldLeftChunksEffect = (s, f) => ignoreLeftover(foldChunksEffect(s, _Function.constTrue, f));\n/** @internal */\nexports.foldLeftChunksEffect = foldLeftChunksEffect;\nconst foldLeftEffect = (s, f) => foldEffect(s, _Function.constTrue, f);\n/** @internal */\nexports.foldLeftEffect = foldLeftEffect;\nconst foldUntil = (s, max, f) => map(tuple => tuple[0])(fold([s, 0], tuple => tuple[1] < max, ([output, count], input) => [f(output, input), count + 1]));\n/** @internal */\nexports.foldUntil = foldUntil;\nconst foldUntilEffect = (s, max, f) => map(tuple => tuple[0])(foldEffect([s, 0], tuple => tuple[1] < max, ([output, count], input) => Effect.map(s => [s, count + 1])(f(output, input))));\n/** @internal */\nexports.foldUntilEffect = foldUntilEffect;\nconst foldWeighted = (s, max, costFn, f) => foldWeightedDecompose(s, max, costFn, Chunk.of, f);\n/** @internal */\nexports.foldWeighted = foldWeighted;\nconst foldWeightedDecompose = (s, max, costFn, decompose, f) => suspend(() => new SinkImpl(foldWeightedDecomposeLoop(s, 0, false, max, costFn, decompose, f)));\n/** @internal */\nexports.foldWeightedDecompose = foldWeightedDecompose;\nconst foldWeightedDecomposeLoop = (s, cost, dirty, max, costFn, decompose, f) => core.readWith(input => {\n  const [nextS, nextCost, nextDirty, leftovers] = foldWeightedDecomposeFold(input, 0, s, cost, dirty, max, costFn, decompose, f);\n  if (Chunk.isNonEmpty(leftovers)) {\n    return channel.zipRight(core.succeedNow(nextS))(core.write(leftovers));\n  }\n  if (cost > max) {\n    return core.succeedNow(nextS);\n  }\n  return foldWeightedDecomposeLoop(nextS, nextCost, nextDirty, max, costFn, decompose, f);\n}, core.fail, () => core.succeedNow(s));\n/** @internal */\nconst foldWeightedDecomposeFold = (input, index, s, cost, dirty, max, costFn, decompose, f) => {\n  if (index === input.length) {\n    return [s, cost, dirty, Chunk.empty()];\n  }\n  const elem = Chunk.unsafeGet(index)(input);\n  const total = cost + costFn(s, elem);\n  if (total <= max) {\n    return foldWeightedDecomposeFold(input, index + 1, f(s, elem), total, true, max, costFn, decompose, f);\n  }\n  const decomposed = decompose(elem);\n  if (decomposed.length <= 1 && !dirty) {\n    // If `elem` cannot be decomposed, we need to cross the `max` threshold. To\n    // minimize \"injury\", we only allow this when we haven't added anything else\n    // to the aggregate (dirty = false).\n    return [f(s, elem), total, true, Chunk.drop(index + 1)(input)];\n  }\n  if (decomposed.length <= 1 && dirty) {\n    // If the state is dirty and `elem` cannot be decomposed, we stop folding\n    // and include `elem` in the leftovers.\n    return [s, cost, dirty, Chunk.drop(index)(input)];\n  }\n  // `elem` got decomposed, so we will recurse with the decomposed elements pushed\n  // into the chunk we're processing and see if we can aggregate further.\n  const next = Chunk.concat(Chunk.drop(index + 1)(input))(decomposed);\n  return foldWeightedDecomposeFold(next, 0, s, cost, dirty, max, costFn, decompose, f);\n};\n/** @internal */\nconst foldWeightedDecomposeEffect = (s, max, costFn, decompose, f) => suspend(() => new SinkImpl(foldWeightedDecomposeEffectLoop(s, max, costFn, decompose, f, 0, false)));\n/** @internal */\nexports.foldWeightedDecomposeEffect = foldWeightedDecomposeEffect;\nconst foldWeightedEffect = (s, max, costFn, f) => foldWeightedDecomposeEffect(s, max, costFn, input => Effect.succeed(Chunk.of(input)), f);\n/** @internal */\nexports.foldWeightedEffect = foldWeightedEffect;\nconst foldWeightedDecomposeEffectLoop = (s, max, costFn, decompose, f, cost, dirty) => core.readWith(input => core.flatMap(([nextS, nextCost, nextDirty, leftovers]) => {\n  if (Chunk.isNonEmpty(leftovers)) {\n    return channel.zipRight(core.succeedNow(nextS))(core.write(leftovers));\n  }\n  if (cost > max) {\n    return core.succeedNow(nextS);\n  }\n  return foldWeightedDecomposeEffectLoop(nextS, max, costFn, decompose, f, nextCost, nextDirty);\n})(core.fromEffect(foldWeightedDecomposeEffectFold(s, max, costFn, decompose, f, input, dirty, cost, 0))), core.fail, () => core.succeedNow(s));\n/** @internal */\nconst foldWeightedDecomposeEffectFold = (s, max, costFn, decompose, f, input, dirty, cost, index) => {\n  if (index === input.length) {\n    return Effect.succeed([s, cost, dirty, Chunk.empty()]);\n  }\n  const elem = Chunk.unsafeGet(index)(input);\n  return Effect.flatMap(total => {\n    if (total <= max) {\n      return Effect.flatMap(s => foldWeightedDecomposeEffectFold(s, max, costFn, decompose, f, input, true, total, index + 1))(f(s, elem));\n    }\n    return Effect.flatMap(decomposed => {\n      if (decomposed.length <= 1 && !dirty) {\n        // If `elem` cannot be decomposed, we need to cross the `max` threshold. To\n        // minimize \"injury\", we only allow this when we haven't added anything else\n        // to the aggregate (dirty = false).\n        return Effect.map(s => [s, total, true, Chunk.drop(index + 1)(input)])(f(s, elem));\n      }\n      if (decomposed.length <= 1 && dirty) {\n        // If the state is dirty and `elem` cannot be decomposed, we stop folding\n        // and include `elem` in th leftovers.\n        return Effect.succeed([s, cost, dirty, Chunk.drop(index)(input)]);\n      }\n      // `elem` got decomposed, so we will recurse with the decomposed elements pushed\n      // into the chunk we're processing and see if we can aggregate further.\n      const next = Chunk.concat(Chunk.drop(index + 1)(input))(decomposed);\n      return foldWeightedDecomposeEffectFold(s, max, costFn, decompose, f, next, dirty, cost, 0);\n    })(decompose(elem));\n  })(Effect.map(newCost => cost + newCost)(costFn(s, elem)));\n};\n/** @internal */\nconst flatMap = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => foldSink(fail, f)(self));\n/** @internal */\nexports.flatMap = flatMap;\nconst forEach = f => {\n  const process = core.readWithCause(input => core.flatMap(() => process)(core.fromEffect(Effect.forEachDiscard(f)(input))), core.failCause, core.unit);\n  return new SinkImpl(process);\n};\n/** @internal */\nexports.forEach = forEach;\nconst forEachChunk = f => {\n  const process = core.readWithCause(input => core.flatMap(() => process)(core.fromEffect(f(input))), core.failCause, core.unit);\n  return new SinkImpl(process);\n};\n/** @internal */\nexports.forEachChunk = forEachChunk;\nconst forEachWhile = f => {\n  const process = core.readWithCause(input => forEachWhileReader(f, input, 0, input.length, process), core.failCause, core.unit);\n  return new SinkImpl(process);\n};\n/** @internal */\nexports.forEachWhile = forEachWhile;\nconst forEachWhileReader = (f, input, index, length, cont) => {\n  if (index === length) {\n    return cont;\n  }\n  return channel.catchAll(error => channel.zipRight(core.fail(error))(core.write(Chunk.drop(index)(input))))(core.flatMap(bool => bool ? forEachWhileReader(f, input, index + 1, length, cont) : core.write(Chunk.drop(index)(input)))(core.fromEffect(f(Chunk.unsafeGet(index)(input)))));\n};\n/** @internal */\nconst forEachChunkWhile = f => {\n  const reader = core.readWith(input => core.flatMap(cont => cont ? reader : core.unit())(core.fromEffect(f(input))), core.fail, core.unit);\n  return new SinkImpl(reader);\n};\n/** @internal */\nexports.forEachChunkWhile = forEachChunkWhile;\nconst fromChannel = channel => new SinkImpl(channel);\n/** @internal */\nexports.fromChannel = fromChannel;\nconst fromEffect = effect => new SinkImpl(core.fromEffect(effect));\n/** @internal */\nexports.fromEffect = fromEffect;\nconst fromHub = hub => fromQueue(hub);\n/** @internal */\nexports.fromHub = fromHub;\nconst fromHubWithShutdown = hub => fromQueueWithShutdown(hub);\n/** @internal */\nexports.fromHubWithShutdown = fromHubWithShutdown;\nconst fromPush = push => new SinkImpl(channel.unwrapScoped(Effect.map(fromPushPull)(push)));\nexports.fromPush = fromPush;\nconst fromPushPull = push => core.readWith(input => channel.foldChannel(([either, leftovers]) => Either.match(error => channel.zipRight(core.fail(error))(core.write(leftovers)), z => channel.zipRight(core.succeedNow(z))(core.write(leftovers)))(either), () => fromPushPull(push))(core.fromEffect(push(Option.some(input)))), core.fail, () => channel.foldChannel(([either, leftovers]) => Either.match(error => channel.zipRight(core.fail(error))(core.write(leftovers)), z => channel.zipRight(core.succeedNow(z))(core.write(leftovers)))(either), () => core.fromEffect(Effect.dieMessage(\"BUG: Sink.fromPush - please report an issue at https://github.com/Effect-TS/stream/issues\")))(core.fromEffect(push(Option.none()))));\n/** @internal */\nconst fromQueue = queue => forEachChunk(input => Queue.offerAll(queue, input));\n/** @internal */\nexports.fromQueue = fromQueue;\nconst fromQueueWithShutdown = queue => unwrapScoped(Effect.map(fromQueue)(Effect.acquireRelease(Effect.succeed(queue), Queue.shutdown)));\n/** @internal */\nexports.fromQueueWithShutdown = fromQueueWithShutdown;\nconst head = () => fold(Option.none(), Option.isNone, (option, input) => Option.match(() => Option.some(input), () => option)(option));\n/** @internal */\nexports.head = head;\nconst ignoreLeftover = self => new SinkImpl(channel.drain(self.channel));\n/** @internal */\nexports.ignoreLeftover = ignoreLeftover;\nconst last = () => foldLeft(Option.none(), (_, input) => Option.some(input));\n/** @internal */\nexports.last = last;\nconst leftover = chunk => new SinkImpl(core.suspend(() => core.write(chunk)));\n/** @internal */\nexports.leftover = leftover;\nconst log = message => fromEffect(Effect.log(message));\n/** @internal */\nexports.log = log;\nconst logDebug = message => fromEffect(Effect.logDebug(message));\n/** @internal */\nexports.logDebug = logDebug;\nconst logDebugCause = cause => fromEffect(Effect.logDebugCause(cause));\n/** @internal */\nexports.logDebugCause = logDebugCause;\nconst logDebugCauseMessage = (message, cause) => fromEffect(Effect.logDebugCauseMessage(message, cause));\n/** @internal */\nexports.logDebugCauseMessage = logDebugCauseMessage;\nconst logError = message => fromEffect(Effect.logError(message));\n/** @internal */\nexports.logError = logError;\nconst logErrorCause = cause => fromEffect(Effect.logErrorCause(cause));\n/** @internal */\nexports.logErrorCause = logErrorCause;\nconst logErrorCauseMessage = (message, cause) => fromEffect(Effect.logErrorCauseMessage(message, cause));\n/** @internal */\nexports.logErrorCauseMessage = logErrorCauseMessage;\nconst logFatal = message => fromEffect(Effect.logFatal(message));\n/** @internal */\nexports.logFatal = logFatal;\nconst logFatalCause = cause => fromEffect(Effect.logFatalCause(cause));\n/** @internal */\nexports.logFatalCause = logFatalCause;\nconst logFatalCauseMessage = (message, cause) => fromEffect(Effect.logFatalCauseMessage(message, cause));\n/** @internal */\nexports.logFatalCauseMessage = logFatalCauseMessage;\nconst logInfo = message => fromEffect(Effect.logInfo(message));\n/** @internal */\nexports.logInfo = logInfo;\nconst logInfoCause = cause => fromEffect(Effect.logInfoCause(cause));\n/** @internal */\nexports.logInfoCause = logInfoCause;\nconst logInfoCauseMessage = (message, cause) => fromEffect(Effect.logInfoCauseMessage(message, cause));\n/** @internal */\nexports.logInfoCauseMessage = logInfoCauseMessage;\nconst logWarning = message => fromEffect(Effect.logWarning(message));\n/** @internal */\nexports.logWarning = logWarning;\nconst logWarningCause = cause => fromEffect(Effect.logWarningCause(cause));\n/** @internal */\nexports.logWarningCause = logWarningCause;\nconst logWarningCauseMessage = (message, cause) => fromEffect(Effect.logWarningCauseMessage(message, cause));\n/** @internal */\nexports.logWarningCauseMessage = logWarningCauseMessage;\nconst logTrace = message => fromEffect(Effect.logTrace(message));\n/** @internal */\nexports.logTrace = logTrace;\nconst logTraceCause = cause => fromEffect(Effect.logTraceCause(cause));\n/** @internal */\nexports.logTraceCause = logTraceCause;\nconst logTraceCauseMessage = (message, cause) => fromEffect(Effect.logTraceCauseMessage(message, cause));\n/** @internal */\nexports.logTraceCauseMessage = logTraceCauseMessage;\nconst map = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => {\n  return new SinkImpl(channel.map(f)(self.channel));\n});\n/** @internal */\nexports.map = map;\nconst mapEffect = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => new SinkImpl(channel.mapEffect(f)(self.channel)));\n/** @internal */\nexports.mapEffect = mapEffect;\nconst mapError = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => new SinkImpl(channel.mapError(f)(self.channel)));\n/** @internal */\nexports.mapError = mapError;\nconst mapLeftover = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => new SinkImpl(channel.mapOut(Chunk.map(f))(self.channel)));\n/** @internal */\nexports.mapLeftover = mapLeftover;\nconst mkString = () => suspend(() => {\n  const strings = [];\n  return map(() => strings.join(\"\"))(foldLeftChunks(void 0, (_, elems) => Chunk.forEach(elems, elem => {\n    strings.push(String(elem));\n  })));\n});\n/** @internal */\nexports.mkString = mkString;\nconst never = () => fromEffect(Effect.never());\n/** @internal */\nexports.never = never;\nconst orElse = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => new SinkImpl(channel.orElse(() => that().channel)(self.channel)));\n/** @internal */\nexports.orElse = orElse;\nconst provideContext = /*#__PURE__*/(0, _Function.dual)(2, (self, context) => new SinkImpl(core.provideContext(context)(self.channel)));\n/** @internal */\nexports.provideContext = provideContext;\nconst race = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => map(Either.merge)(raceBoth(that)(self)));\n/** @internal */\nexports.race = race;\nconst raceBoth = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => raceBothCapacity(self, that, 16));\n/** @internal */\nexports.raceBoth = raceBoth;\nconst raceBothCapacity = /*#__PURE__*/(0, _Function.dual)(3, (self, that, capacity) => {\n  return raceWithCapacity(self, that, selfDone => mergeDecision.Done(Effect.map(Either.left)(Effect.done(selfDone))), thatDone => mergeDecision.Done(Effect.map(Either.right)(Effect.done(thatDone))), capacity);\n});\n/** @internal */\nexports.raceBothCapacity = raceBothCapacity;\nconst raceWith = /*#__PURE__*/(0, _Function.dual)(4, (self, that, leftDone, rightDone) => raceWithCapacity(self, that, leftDone, rightDone, 16));\n/** @internal */\nexports.raceWith = raceWith;\nconst raceWithCapacity = /*#__PURE__*/(0, _Function.dual)(5, (self, that, leftDone, rightDone, capacity) => {\n  const scoped = Effect.gen(function* ($) {\n    const hub = yield* $(Hub.bounded(capacity));\n    const channel1 = yield* $(channel.fromHubScoped(hub));\n    const channel2 = yield* $(channel.fromHubScoped(hub));\n    const reader = channel.toHub(hub);\n    const writer = channel.mergeWith(core.pipeTo(that.channel)(channel2), leftDone, rightDone)(core.pipeTo(self.channel)(channel1));\n    const racedChannel = channel.mergeWith(writer, () => mergeDecision.Await(exit => Effect.done(exit)), done => mergeDecision.Done(Effect.done(done)))(reader);\n    return new SinkImpl(racedChannel);\n  });\n  return unwrapScoped(scoped);\n});\n/** @internal */\nexports.raceWithCapacity = raceWithCapacity;\nconst refineOrDie = /*#__PURE__*/(0, _Function.dual)(2, (self, pf) => refineOrDieWith(pf, _Function.identity)(self));\n/** @internal */\nexports.refineOrDie = refineOrDie;\nconst refineOrDieWith = /*#__PURE__*/(0, _Function.dual)(3, (self, pf, f) => {\n  const newChannel = channel.catchAll(error => Option.match(() => core.failCauseSync(() => Cause.die(f(error))), core.fail)(pf(error)))(self.channel);\n  return new SinkImpl(newChannel);\n});\n/** @internal */\nexports.refineOrDieWith = refineOrDieWith;\nconst service = tag => serviceWith(tag, _Function.identity);\n/** @internal */\nexports.service = service;\nconst serviceWith = (tag, f) => fromEffect(Effect.serviceWith(tag, f));\n/** @internal */\nexports.serviceWith = serviceWith;\nconst serviceWithEffect = (tag, f) => fromEffect(Effect.serviceWithEffect(tag, f));\n/** @internal */\nexports.serviceWithEffect = serviceWithEffect;\nconst serviceWithSink = (tag, f) => new SinkImpl(channel.unwrap(Effect.serviceWith(tag, service => f(service).channel)));\n/** @internal */\nexports.serviceWithSink = serviceWithSink;\nconst some = predicate => fold(false, bool => !bool, (acc, input) => acc || predicate(input));\n/** @internal */\nexports.some = some;\nconst splitWhere = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => {\n  const newChannel = core.flatMap(ref => core.flatMap(([leftovers, z]) => core.flatMap(leftover => channel.zipRight(core.succeed(z))(core.write(Chunk.concat(Chunk.flatten(leftovers))(leftover))))(core.fromEffect(Ref.get(ref))))(core.collectElements(channel.pipeToOrFail(self.channel)(splitWhereSplitter(false, ref, f)))))(core.fromEffect(Ref.make(Chunk.empty())));\n  return new SinkImpl(newChannel);\n});\n/** @internal */\nexports.splitWhere = splitWhere;\nconst splitWhereSplitter = (written, leftovers, f) => core.readWithCause(input => {\n  if (Chunk.isEmpty(input)) {\n    return splitWhereSplitter(written, leftovers, f);\n  }\n  if (written) {\n    const index = indexWhere(input, f);\n    if (index === -1) {\n      return channel.zipRight(splitWhereSplitter(true, leftovers, f))(core.write(input));\n    }\n    const [left, right] = Chunk.splitAt(index)(input);\n    return channel.zipRight(core.fromEffect(Ref.set(leftovers, right)))(core.write(left));\n  }\n  const index = indexWhere(input, f, 1);\n  if (index === -1) {\n    return channel.zipRight(splitWhereSplitter(true, leftovers, f))(core.write(input));\n  }\n  const [left, right] = Chunk.splitAt(Math.max(index, 1))(input);\n  return channel.zipRight(core.fromEffect(Ref.set(leftovers, right)))(core.write(left));\n}, core.failCause, core.succeed);\n/** @internal */\nconst indexWhere = (self, predicate, from = 0) => {\n  const iterator = self[Symbol.iterator]();\n  let index = 0;\n  let result = -1;\n  let next;\n  while (result < 0 && (next = iterator.next()) && !next.done) {\n    const a = next.value;\n    if (index >= from && predicate(a)) {\n      result = index;\n    }\n    index = index + 1;\n  }\n  return result;\n};\n/** @internal */\nconst succeed = z => new SinkImpl(core.succeed(z));\n/** @internal */\nexports.succeed = succeed;\nconst sum = () => foldLeft(0, (a, b) => a + b);\n/** @internal */\nexports.sum = sum;\nconst summarized = /*#__PURE__*/(0, _Function.dual)(3, (self, summary, f) => {\n  const newChannel = core.flatMap(start => core.flatMap(done => channel.map(end => [done, f(start, end)])(core.fromEffect(summary)))(self.channel))(core.fromEffect(summary));\n  return new SinkImpl(newChannel);\n});\n/** @internal */\nexports.summarized = summarized;\nconst suspend = evaluate => new SinkImpl(core.suspend(() => evaluate().channel));\n/** @internal */\nexports.suspend = suspend;\nconst sync = evaluate => new SinkImpl(core.sync(evaluate));\n/** @internal */\nexports.sync = sync;\nconst take = n => flatMap(acc => {\n  const [taken, leftover] = Chunk.splitAt(n)(acc);\n  return new SinkImpl(channel.zipRight(core.succeedNow(taken))(core.write(leftover)));\n})(foldChunks(Chunk.empty(), chunk => chunk.length < n, (acc, chunk) => Chunk.concat(chunk)(acc)));\n/** @internal */\nexports.take = take;\nconst timed = () => map(tuple => tuple[1])(withDuration(drain()));\n/** @internal */\nexports.timed = timed;\nconst toChannel = self => self.channel;\n/** @internal */\nexports.toChannel = toChannel;\nconst unwrap = effect => new SinkImpl(channel.unwrap(Effect.map(sink => sink.channel)(effect)));\n/** @internal */\nexports.unwrap = unwrap;\nconst unwrapScoped = effect => {\n  return new SinkImpl(channel.unwrapScoped(Effect.map(sink => sink.channel)(effect)));\n};\n/** @internal */\nexports.unwrapScoped = unwrapScoped;\nconst withDuration = self => summarized(Clock.currentTimeMillis(), (start, end) => Duration.millis(end - start))(self);\n/** @internal */\nexports.withDuration = withDuration;\nconst zip = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => zipWith(that, (z, z2) => [z, z2])(self));\n/** @internal */\nexports.zip = zip;\nconst zipLeft = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => zipWith(that, (z, _) => z)(self));\n/** @internal */\nexports.zipLeft = zipLeft;\nconst zipRight = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => zipWith(that, (_, z2) => z2)(self));\n/** @internal */\nexports.zipRight = zipRight;\nconst zipWith = /*#__PURE__*/(0, _Function.dual)(3, (self, that, f) => flatMap(z => map(z2 => f(z, z2))(that))(self));\n/** @internal */\nexports.zipWith = zipWith;\nconst zipPar = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => zipWithPar(that, (z, z2) => [z, z2])(self));\n/** @internal */\nexports.zipPar = zipPar;\nconst zipParLeft = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => zipWithPar(that, (z, _) => z)(self));\n/** @internal */\nexports.zipParLeft = zipParLeft;\nconst zipParRight = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => zipWithPar(that, (_, z2) => z2)(self));\n/** @internal */\nexports.zipParRight = zipParRight;\nconst zipWithPar = /*#__PURE__*/(0, _Function.dual)(3, (self, that, f) => {\n  return raceWith(that, Exit.match(cause => mergeDecision.Done(Effect.failCause(cause)), leftZ => mergeDecision.Await(Exit.match(Effect.failCause, rightZ => Effect.succeed(f(leftZ, rightZ))))), Exit.match(cause => mergeDecision.Done(Effect.failCause(cause)), rightZ => mergeDecision.Await(Exit.match(Effect.failCause, leftZ => Effect.succeed(f(leftZ, rightZ))))))(self);\n});\n// Circular with Channel\n/** @internal */\nexports.zipWithPar = zipWithPar;\nconst channelToSink = self => new SinkImpl(self);\nexports.channelToSink = channelToSink;\n//# sourceMappingURL=sink.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.flattenEffectParUnordered = exports.flattenEffectPar = exports.flattenEffect = exports.flattenChunks = exports.flatten = exports.flatMapParSwitchBuffer = exports.flatMapParSwitch = exports.flatMapParBuffer = exports.flatMapPar = exports.flatMap = exports.findEffect = exports.find = exports.finalizer = exports.filterEffect = exports.filter = exports.failSync = exports.failCauseSync = exports.failCause = exports.fail = exports.execute = exports.ensuring = exports.empty = exports.either = exports.dropWhileEffect = exports.dropWhile = exports.dropUntilEffect = exports.dropUntil = exports.dropRight = exports.drop = exports.drainFork = exports.drain = exports.done = exports.distributedWithDynamicCallback = exports.distributedWithDynamic = exports.distributedWith = exports.dieSync = exports.dieMessage = exports.die = exports.debounce = exports.crossWith = exports.crossRight = exports.crossLeft = exports.cross = exports.contramapContext = exports.contextWithStream = exports.contextWithEffect = exports.contextWith = exports.context = exports.concatAll = exports.concat = exports.combineChunks = exports.combine = exports.collectWhileSuccess = exports.collectWhileSome = exports.collectWhileRight = exports.collectWhileLeft = exports.collectWhileEffect = exports.collectWhile = exports.collectSuccess = exports.collectSome = exports.collectRight = exports.collectLeft = exports.collectEffect = exports.collect = exports.chunksWith = exports.chunks = exports.channelToStream = exports.changesWithEffect = exports.changesWith = exports.changes = exports.catchSomeCause = exports.catchSome = exports.catchAllCause = exports.catchAll = exports.bufferUnbounded = exports.bufferSliding = exports.bufferDropping = exports.bufferChunksSliding = exports.bufferChunksDropping = exports.bufferChunks = exports.buffer = exports.broadcastedQueuesDynamic = exports.broadcastedQueues = exports.broadcastDynamic = exports.broadcast = exports.branchAfter = exports.asyncScoped = exports.asyncOption = exports.asyncInterrupt = exports.asyncEffect = exports.as = exports.aggregateWithinEither = exports.aggregateWithin = exports.aggregate = exports.acquireRelease = exports.absolve = exports._async = exports.StreamTypeId = exports.StreamImpl = exports.DefaultChunkSize = void 0;\nexports.orDieWith = exports.orDie = exports.onError = exports.onDone = exports.never = exports.mkString = exports.mergeWithHaltStrategy = exports.mergeWith = exports.mergeRight = exports.mergeLeft = exports.mergeHaltStrategy = exports.mergeHaltRight = exports.mergeHaltLeft = exports.mergeHaltEither = exports.mergeEither = exports.mergeAllUnbounded = exports.mergeAll = exports.merge = exports.mapErrorCause = exports.mapError = exports.mapEffectParUnordered = exports.mapEffectPar = exports.mapEffect = exports.mapConcatEffect = exports.mapConcatChunkEffect = exports.mapConcatChunk = exports.mapConcat = exports.mapChunksEffect = exports.mapChunks = exports.mapBoth = exports.mapAccumEffect = exports.mapAccum = exports.map = exports.make = exports.logWarningCauseMessage = exports.logWarningCause = exports.logWarning = exports.logTraceCauseMessage = exports.logTraceCause = exports.logTrace = exports.logInfoCauseMessage = exports.logInfoCause = exports.logInfo = exports.logFatalCauseMessage = exports.logFatalCause = exports.logFatal = exports.logErrorCauseMessage = exports.logErrorCause = exports.logError = exports.logDebugCauseMessage = exports.logDebugCause = exports.logDebug = exports.log = exports.iterate = exports.intersperseAffixes = exports.intersperse = exports.interruptWhenDeferred = exports.interruptWhen = exports.interruptAfter = exports.interleaveWith = exports.interleave = exports.identityStream = exports.haltWhenDeferred = exports.haltWhen = exports.haltAfter = exports.groupedWithin = exports.grouped = exports.groupAdjacentBy = exports.fromSchedule = exports.fromQueueWithShutdown = exports.fromQueue = exports.fromPull = exports.fromIteratorSucceed = exports.fromIterableEffect = exports.fromIterable = exports.fromHubWithShutdown = exports.fromHubScopedWithShutdown = exports.fromHubScoped = exports.fromHub = exports.fromEffectOption = exports.fromEffect = exports.fromChunks = exports.fromChunkQueueWithShutdown = exports.fromChunkQueue = exports.fromChunkHubWithShutdown = exports.fromChunkHubScopedWithShutdown = exports.fromChunkHubScoped = exports.fromChunkHub = exports.fromChunk = exports.fromChannel = exports.fromAsyncIterable = exports.forever = exports.flattenTake = exports.flattenParUnboundedBuffer = exports.flattenParUnbounded = exports.flattenParBuffer = exports.flattenPar = exports.flattenIterables = exports.flattenExitOption = exports.flattenExit = void 0;\nexports.takeUntilEffect = exports.takeUntil = exports.takeRight = exports.take = exports.sync = exports.suspend = exports.succeed = exports.splitOnChunk = exports.split = exports.someOrFail = exports.someOrElse = exports.some = exports.slidingSize = exports.sliding = exports.serviceWithStream = exports.serviceWithEffect = exports.serviceWith = exports.service = exports.scoped = exports.scheduleWith = exports.scheduleEither = exports.schedule = exports.scanReduceEffect = exports.scanReduce = exports.scanEffect = exports.scan = exports.runSum = exports.runScoped = exports.runLast = exports.runIntoQueueScoped = exports.runIntoQueueElementsScoped = exports.runIntoQueue = exports.runIntoHubScoped = exports.runIntoHub = exports.runHead = exports.runForEachWhileScoped = exports.runForEachWhile = exports.runForEachScoped = exports.runForEachChunkScoped = exports.runForEachChunk = exports.runForEach = exports.runFoldWhileScopedEffect = exports.runFoldWhileScoped = exports.runFoldWhileEffect = exports.runFoldWhile = exports.runFoldScopedEffect = exports.runFoldScoped = exports.runFoldEffect = exports.runFold = exports.runDrain = exports.runCount = exports.runCollect = exports.run = exports.rightOrFail = exports.right = exports.retry = exports.repeatWithSchedule = exports.repeatWith = exports.repeatValue = exports.repeatElementsWith = exports.repeatElementsEither = exports.repeatElements = exports.repeatEither = exports.repeatEffectWithSchedule = exports.repeatEffectOption = exports.repeatEffectChunkOption = exports.repeatEffectChunk = exports.repeatEffect = exports.repeat = exports.refineOrDieWith = exports.refineOrDie = exports.rechunk = exports.range = exports.provideSomeLayer = exports.provideServiceStream = exports.provideServiceEffect = exports.provideService = exports.provideLayer = exports.provideContext = exports.prepend = exports.pipeThroughChannelOrFail = exports.pipeThroughChannel = exports.pipeThrough = exports.peel = exports.partitionEitherBuffer = exports.partitionEither = exports.partitionBuffer = exports.partition = exports.paginateEffect = exports.paginateChunkEffect = exports.paginateChunk = exports.paginate = exports.orElseSucceed = exports.orElseOptional = exports.orElseIfEmptyStream = exports.orElseIfEmptyChunk = exports.orElseIfEmpty = exports.orElseFail = exports.orElseEither = exports.orElse = void 0;\nexports.zipWithPreviousAndNext = exports.zipWithPrevious = exports.zipWithNext = exports.zipWithIndex = exports.zipWithChunks = exports.zipWith = exports.zipRight = exports.zipLeft = exports.zipLatestWith = exports.zipLatest = exports.zipFlatten = exports.zipAllWith = exports.zipAllSortedByKeyWith = exports.zipAllSortedByKeyRight = exports.zipAllSortedByKeyLeft = exports.zipAllSortedByKey = exports.zipAllRight = exports.zipAllLeft = exports.zipAll = exports.zip = exports.whenEffect = exports.whenCaseEffect = exports.whenCase = exports.when = exports.updateService = exports.unwrapScoped = exports.unwrap = exports.unit = exports.unfoldEffect = exports.unfoldChunkEffect = exports.unfoldChunk = exports.unfold = exports.transduce = exports.toQueueUnbounded = exports.toQueueSlidingCapacity = exports.toQueueSliding = exports.toQueueOfElementsCapacity = exports.toQueueOfElements = exports.toQueueDroppingCapacity = exports.toQueueDropping = exports.toQueueCapacity = exports.toQueue = exports.toPull = exports.toHub = exports.toChannel = exports.timeoutTo = exports.timeoutFailCause = exports.timeoutFail = exports.timeout = exports.tick = exports.throttleShapeEffectBurst = exports.throttleShapeEffect = exports.throttleShapeBurst = exports.throttleShape = exports.throttleEnforceEffectBurst = exports.throttleEnforceEffect = exports.throttleEnforceBurst = exports.throttleEnforce = exports.tapSink = exports.tapErrorCause = exports.tapError = exports.tap = exports.takeWhile = void 0;\nvar Chunk = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Chunk\"));\nvar Context = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Context\"));\nvar Duration = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Duration\"));\nvar Either = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Either\"));\nvar Equal = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Equal\"));\nvar _Function = /*#__PURE__*/require(\"@effect/data/Function\");\nvar Option = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Option\"));\nvar Cause = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Cause\"));\nvar Clock = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Clock\"));\nvar _Debug = /*#__PURE__*/require(\"@effect/io/Debug\");\nvar Deferred = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Deferred\"));\nvar Effect = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Effect\"));\nvar Exit = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Exit\"));\nvar Fiber = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Fiber\"));\nvar Hub = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Hub\"));\nvar Layer = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Layer\"));\nvar Queue = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Queue\"));\nvar Ref = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Ref\"));\nvar Runtime = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Runtime\"));\nvar Schedule = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Schedule\"));\nvar MergeDecision = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/stream/Channel/MergeDecision\"));\nvar channel = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/stream/internal/channel\"));\nvar channelExecutor = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/stream/internal/channel/channelExecutor\"));\nvar MergeStrategy = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/stream/internal/channel/mergeStrategy\"));\nvar singleProducerAsyncInput = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/stream/internal/channel/singleProducerAsyncInput\"));\nvar core = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/stream/internal/core\"));\nvar _sink = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/stream/internal/sink\"));\nvar DebounceState = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/stream/internal/stream/debounceState\"));\nvar emit = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/stream/internal/stream/emit\"));\nvar haltStrategy = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/stream/internal/stream/haltStrategy\"));\nvar Handoff = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/stream/internal/stream/handoff\"));\nvar HandoffSignal = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/stream/internal/stream/handoffSignal\"));\nvar pull = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/stream/internal/stream/pull\"));\nvar SinkEndReason = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/stream/internal/stream/sinkEndReason\"));\nvar ZipAllState = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/stream/internal/stream/zipAllState\"));\nvar ZipChunksState = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/stream/internal/stream/zipChunksState\"));\nvar _support = /*#__PURE__*/require(\"@effect/stream/internal/support\");\nvar _take = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/stream/internal/take\"));\nvar HaltStrategy = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/stream/Stream/HaltStrategy\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\nvar _a;\n/** @internal */\nconst StreamSymbolKey = \"@effect/stream/Stream\";\n/** @internal */\nconst StreamTypeId = /*#__PURE__*/Symbol.for(StreamSymbolKey);\n/** @internal */\nexports.StreamTypeId = StreamTypeId;\nconst streamVariance = {\n  _R: _ => _,\n  _E: _ => _,\n  _A: _ => _\n};\n/** @internal */\nclass StreamImpl {\n  constructor(channel) {\n    this.channel = channel;\n    this[_a] = streamVariance;\n  }\n}\nexports.StreamImpl = StreamImpl;\n_a = StreamTypeId;\n/** @internal */\nconst DefaultChunkSize = 4096;\n/** @internal */\nexports.DefaultChunkSize = DefaultChunkSize;\nconst absolve = self => mapEffect(Effect.fromEither)(self);\n/** @internal */\nexports.absolve = absolve;\nconst acquireRelease = (acquire, release) => scoped(Effect.acquireRelease(acquire, release));\n/** @internal */\nexports.acquireRelease = acquireRelease;\nconst aggregate = /*#__PURE__*/(0, _Function.dual)(2, (self, sink) => aggregateWithin(sink, Schedule.forever())(self));\n/** @internal */\nexports.aggregate = aggregate;\nconst aggregateWithin = /*#__PURE__*/(0, _Function.dual)(3, (self, sink, schedule) => collectRight(aggregateWithinEither(sink, schedule)(self)));\n/** @internal */\nexports.aggregateWithin = aggregateWithin;\nconst aggregateWithinEither = /*#__PURE__*/(0, _Function.dual)(3, (self, sink, schedule) => {\n  const layer = Effect.all(Handoff.make(), Ref.make(SinkEndReason.SchedulEnd), Ref.make(Chunk.empty()), Schedule.driver(schedule), Ref.make(false), Ref.make(false));\n  return flatMap(([handoff, sinkEndReason, sinkLeftovers, scheduleDriver, consumed, endAfterEmit]) => {\n    const handoffProducer = core.readWithCause(input => core.flatMap(() => handoffProducer)(core.fromEffect(Effect.when(() => Chunk.isNonEmpty(input))(Handoff.offer(HandoffSignal.emit(input))(handoff)))), cause => core.fromEffect(Handoff.offer(HandoffSignal.halt(cause))(handoff)), () => core.fromEffect(Handoff.offer(HandoffSignal.end(SinkEndReason.UpstreamEnd))(handoff)));\n    const handoffConsumer = channel.unwrap(Effect.flatMap(leftovers => {\n      if (Chunk.isNonEmpty(leftovers)) {\n        return Effect.zipRight(Effect.succeed(core.flatMap(() => handoffConsumer)(core.write(leftovers))))(Ref.set(consumed, true));\n      }\n      return Effect.map(signal => {\n        switch (signal._tag) {\n          case HandoffSignal.OP_EMIT:\n            {\n              return core.flatMap(bool => bool ? core.unit() : handoffConsumer)(channel.zipRight(core.fromEffect(Ref.get(endAfterEmit)))(channel.zipRight(core.write(signal.elements))(core.fromEffect(Ref.set(consumed, true)))));\n            }\n          case HandoffSignal.OP_HALT:\n            {\n              return core.failCause(signal.cause);\n            }\n          case HandoffSignal.OP_END:\n            {\n              if (signal.reason._tag === SinkEndReason.OP_SCHEDULE_END) {\n                return channel.unwrap(Effect.map(bool => bool ? core.fromEffect(Effect.zipRight(Ref.set(endAfterEmit, true))(Ref.set(sinkEndReason, SinkEndReason.SchedulEnd))) : core.flatMap(() => handoffConsumer)(core.fromEffect(Effect.zipRight(Ref.set(endAfterEmit, true))(Ref.set(sinkEndReason, SinkEndReason.SchedulEnd)))))(Ref.get(consumed)));\n              }\n              return core.fromEffect(Effect.zipRight(Ref.set(endAfterEmit, true))(Ref.set(sinkEndReason, signal.reason)));\n            }\n        }\n      })(Handoff.take(handoff));\n    })(Ref.getAndSet(sinkLeftovers, Chunk.empty())));\n    const timeout = lastB => scheduleDriver.next(lastB);\n    const scheduledAggregator = (sinkFiber, scheduleFiber, scope) => {\n      const forkSink = Effect.zipRight(Effect.forkIn(scope)(channelExecutor.run(core.collectElements(channel.pipeToOrFail(sink.channel)(handoffConsumer)))))(Effect.zipRight(Ref.set(endAfterEmit, false))(Ref.set(consumed, false)));\n      const handleSide = (leftovers, b, c) => channel.unwrap(Effect.zipRight(Effect.map(reason => {\n        switch (reason._tag) {\n          case SinkEndReason.OP_SCHEDULE_END:\n            {\n              return channel.unwrap(Effect.map(([wasConsumed, sinkFiber, scheduleFiber]) => {\n                const toWrite = Option.match(() => Chunk.of(Either.right(b)), c => Chunk.make(Either.right(b), Either.left(c)))(c);\n                if (wasConsumed) {\n                  return core.flatMap(() => scheduledAggregator(sinkFiber, scheduleFiber, scope))(core.write(toWrite));\n                }\n                return scheduledAggregator(sinkFiber, scheduleFiber, scope);\n              })(Effect.all(Ref.get(consumed), forkSink, Effect.forkIn(scope)(timeout(Option.some(b))))));\n            }\n          case SinkEndReason.OP_UPSTREAM_END:\n            {\n              return channel.unwrap(Effect.map(wasConsumed => wasConsumed ? core.write(Chunk.of(Either.right(b))) : core.unit())(Ref.get(consumed)));\n            }\n        }\n      })(Ref.get(sinkEndReason)))(Ref.set(sinkLeftovers, Chunk.flatten(leftovers))));\n      return channel.unwrap(Effect.raceWith(Fiber.join(scheduleFiber), (sinkExit, _) => Effect.zipRight(Effect.map(([leftovers, b]) => handleSide(leftovers, b, Option.none()))(Effect.done(sinkExit)))(Fiber.interrupt(scheduleFiber)), (scheduleExit, _) => Effect.matchCauseEffect(cause => Either.match(() => Effect.zipRight(Effect.map(([leftovers, b]) => handleSide(leftovers, b, Option.none()))(Fiber.join(sinkFiber)))(Effect.forkDaemon(Handoff.offer(HandoffSignal.end(SinkEndReason.SchedulEnd))(handoff))), cause => Effect.zipRight(Effect.map(([leftovers, b]) => handleSide(leftovers, b, Option.none()))(Fiber.join(sinkFiber)))(Effect.forkDaemon(Handoff.offer(HandoffSignal.halt(cause))(handoff))))(Cause.failureOrCause(cause)), c => Effect.zipRight(Effect.map(([leftovers, b]) => handleSide(leftovers, b, Option.some(c)))(Fiber.join(sinkFiber)))(Effect.forkDaemon(Handoff.offer(HandoffSignal.end(SinkEndReason.SchedulEnd))(handoff))))(Effect.done(scheduleExit)))(Fiber.join(sinkFiber)));\n    };\n    return unwrapScoped(Effect.zipRight(Effect.flatMap(sinkFiber => Effect.flatMap(scheduleFiber => Effect.map(scope => new StreamImpl(scheduledAggregator(sinkFiber, scheduleFiber, scope)))(Effect.scope()))(Effect.forkScoped(timeout(Option.none()))))(Effect.forkScoped(channelExecutor.run(core.collectElements(channel.pipeToOrFail(sink.channel)(handoffConsumer))))))(Effect.forkScoped(channelExecutor.run(core.pipeTo(handoffProducer)(self.channel)))));\n  })(fromEffect(layer));\n});\n/** @internal */\nexports.aggregateWithinEither = aggregateWithinEither;\nconst as = /*#__PURE__*/(0, _Function.dual)(2, (self, value) => map(() => value)(self));\n/** @internal */\nexports.as = as;\nconst _async = (register, outputBuffer = 16) => asyncOption(cb => {\n  register(cb);\n  return Option.none();\n}, outputBuffer);\n/** @internal */\nexports._async = _async;\nconst asyncEffect = (register, outputBuffer = 16) => fromChannel(channel.unwrapScoped(Effect.flatMap(output => Effect.flatMap(runtime => Effect.map(() => {\n  const loop = channel.unwrap(Effect.match(maybeError => channel.zipRight(Option.match(core.unit, core.fail)(maybeError))(core.fromEffect(Queue.shutdown(output))), chunk => core.flatMap(() => loop)(core.write(chunk)))(Effect.flatMap(_take.done)(Queue.take(output))));\n  return loop;\n})(register(emit.make(k => Runtime.runPromiseExit(runtime)(Effect.asUnit(Effect.flatMap(take => Queue.offer(output, take))(_take.fromPull(k)))).then(exit => {\n  if (Exit.isFailure(exit)) {\n    if (!Cause.isInterrupted(exit.cause)) {\n      throw Cause.squash(exit.cause);\n    }\n  }\n})))))(Effect.runtime()))(Effect.acquireRelease(Queue.bounded(outputBuffer), queue => Queue.shutdown(queue)))));\n/** @internal */\nexports.asyncEffect = asyncEffect;\nconst asyncInterrupt = (register, outputBuffer = 16) => unwrapScoped(Effect.flatMap(output => Effect.flatMap(runtime => Effect.map(Either.match(canceler => {\n  const loop = channel.unwrap(Effect.match(maybeError => channel.zipRight(Option.match(core.unit, core.fail)(maybeError))(core.fromEffect(Queue.shutdown(output))), chunk => core.flatMap(() => loop)(core.write(chunk)))(Effect.flatMap(_take.done)(Queue.take(output))));\n  return ensuring(canceler)(fromChannel(loop));\n}, stream => unwrap(Effect.as(stream)(Queue.shutdown(output)))))(Effect.sync(() => register(emit.make(k => Runtime.runPromiseExit(runtime)(Effect.asUnit(Effect.flatMap(take => Queue.offer(output, take))(_take.fromPull(k)))).then(exit => {\n  if (Exit.isFailure(exit)) {\n    if (!Cause.isInterrupted(exit.cause)) {\n      throw Cause.squash(exit.cause);\n    }\n  }\n}))))))(Effect.runtime()))(Effect.acquireRelease(Queue.bounded(outputBuffer), queue => Queue.shutdown(queue))));\n/** @internal */\nexports.asyncInterrupt = asyncInterrupt;\nconst asyncOption = (register, outputBuffer = 16) => asyncInterrupt(emit => Either.fromOption(Effect.unit)(register(emit)), outputBuffer);\n/** @internal */\nexports.asyncOption = asyncOption;\nconst asyncScoped = (register, outputBuffer = 16) => flatMap(repeatEffectChunkOption)(scoped(Effect.flatMap(output => Effect.flatMap(runtime => Effect.flatMap(ref => Effect.map(isDone => isDone ? pull.end() : Effect.onError(() => Effect.zipRight(Queue.shutdown(output))(Ref.set(ref, true)))(Effect.flatMap(_take.done)(Queue.take(output))))(Ref.get(ref)))(Effect.zipRight(Ref.make(false))(register(emit.make(k => Runtime.runPromiseExit(runtime)(Effect.asUnit(Effect.flatMap(take => Queue.offer(output, take))(_take.fromPull(k)))).then(exit => {\n  if (Exit.isFailure(exit)) {\n    if (!Cause.isInterrupted(exit.cause)) {\n      throw Cause.squash(exit.cause);\n    }\n  }\n}))))))(Effect.runtime()))(Effect.acquireRelease(Queue.bounded(outputBuffer), queue => Queue.shutdown(queue)))));\n/** @internal */\nexports.asyncScoped = asyncScoped;\nconst branchAfter = /*#__PURE__*/(0, _Function.dual)(3, (self, n, f) => suspend(() => {\n  const bufferring = acc => core.readWith(input => {\n    const nextSize = acc.length + input.length;\n    if (nextSize >= n) {\n      const [b1, b2] = Chunk.splitAt(n - acc.length)(input);\n      return running(Chunk.concat(b1)(acc), b2);\n    }\n    return bufferring(Chunk.concat(input)(acc));\n  }, core.fail, () => running(acc, Chunk.empty()));\n  const running = (prefix, leftover) => core.pipeTo(f(prefix).channel)(prepend(leftover).channel);\n  return new StreamImpl(channel.pipeToOrFail(bufferring(Chunk.empty()))(self.channel));\n}));\n/** @internal */\nexports.branchAfter = branchAfter;\nconst broadcast = /*#__PURE__*/(0, _Debug.dualWithTrace)(3, trace => (self, n, maximumLag) => Effect.map(tuple => tuple.map(queue => flattenTake(fromQueueWithShutdown(queue))))(broadcastedQueues(n, maximumLag)(self)).traced(trace));\n/** @internal */\nexports.broadcast = broadcast;\nconst broadcastDynamic = /*#__PURE__*/(0, _Debug.dualWithTrace)(2, trace => (self, maximumLag) => Effect.map(effect => flattenTake(flatMap(fromQueue)(scoped(effect))))(broadcastedQueuesDynamic(maximumLag)(self)).traced(trace));\n/** @internal */\nexports.broadcastDynamic = broadcastDynamic;\nconst broadcastedQueues = /*#__PURE__*/(0, _Debug.dualWithTrace)(3, trace => (self, n, maximumLag) => Effect.flatMap(hub => Effect.tap(() => Effect.forkScoped(runIntoHubScoped(hub)(self)))(Effect.map(chunk => Chunk.toReadonlyArray(chunk))(Effect.collectAll(Array.from({\n  length: n\n}, () => Hub.subscribe(hub))))))(Hub.bounded(maximumLag)).traced(trace));\n/** @internal */\nexports.broadcastedQueues = broadcastedQueues;\nconst broadcastedQueuesDynamic = /*#__PURE__*/(0, _Debug.dualWithTrace)(2, trace => (self, maximumLag) => Effect.map(Hub.subscribe)(toHub(maximumLag)(self)).traced(trace));\n/** @internal */\nexports.broadcastedQueuesDynamic = broadcastedQueuesDynamic;\nconst buffer = /*#__PURE__*/(0, _Function.dual)(2, (self, capacity) => {\n  const queue = toQueueOfElementsCapacity(self, capacity);\n  return new StreamImpl(channel.unwrapScoped(Effect.map(queue => {\n    const process = core.flatMap(Exit.match(cause => Option.match(core.unit, core.failCause)(Cause.flipCauseOption(cause)), value => core.flatMap(() => process)(core.write(Chunk.of(value)))))(core.fromEffect(Queue.take(queue)));\n    return process;\n  })(queue)));\n});\n/** @internal */\nexports.buffer = buffer;\nconst bufferChunks = /*#__PURE__*/(0, _Function.dual)(2, (self, capacity) => {\n  const queue = toQueueCapacity(capacity)(self);\n  return new StreamImpl(channel.unwrapScoped(Effect.map(queue => {\n    const process = core.flatMap(_take.match(core.unit, core.failCause, value => core.flatMap(() => process)(core.write(value))))(core.fromEffect(Queue.take(queue)));\n    return process;\n  })(queue)));\n});\n/** @internal */\nexports.bufferChunks = bufferChunks;\nconst bufferChunksDropping = /*#__PURE__*/(0, _Function.dual)(2, (self, capacity) => {\n  const queue = Effect.acquireRelease(Queue.dropping(capacity), queue => Queue.shutdown(queue));\n  return new StreamImpl(bufferSignal(queue, self.channel));\n});\n/** @internal */\nexports.bufferChunksDropping = bufferChunksDropping;\nconst bufferChunksSliding = /*#__PURE__*/(0, _Function.dual)(2, (self, capacity) => {\n  const queue = Effect.acquireRelease(Queue.sliding(capacity), queue => Queue.shutdown(queue));\n  return new StreamImpl(bufferSignal(queue, self.channel));\n});\n/** @internal */\nexports.bufferChunksSliding = bufferChunksSliding;\nconst bufferDropping = /*#__PURE__*/(0, _Function.dual)(2, (self, capacity) => {\n  const queue = Effect.acquireRelease(Queue.dropping(capacity), queue => Queue.shutdown(queue));\n  return new StreamImpl(bufferSignal(queue, rechunk(1)(self).channel));\n});\n/** @internal */\nexports.bufferDropping = bufferDropping;\nconst bufferSliding = /*#__PURE__*/(0, _Function.dual)(2, (self, capacity) => {\n  const queue = Effect.acquireRelease(Queue.sliding(capacity), queue => Queue.shutdown(queue));\n  return new StreamImpl(bufferSignal(queue, rechunk(1)(self).channel));\n});\n/** @internal */\nexports.bufferSliding = bufferSliding;\nconst bufferUnbounded = self => {\n  const queue = toQueueUnbounded(self);\n  return new StreamImpl(channel.unwrapScoped(Effect.map(queue => {\n    const process = core.flatMap(_take.match(core.unit, core.failCause, value => core.flatMap(() => process)(core.write(value))))(core.fromEffect(Queue.take(queue)));\n    return process;\n  })(queue)));\n};\n/** @internal */\nexports.bufferUnbounded = bufferUnbounded;\nconst bufferSignal = (scoped, bufferChannel) => {\n  const producer = (queue, ref) => {\n    const terminate = take => core.fromEffect(Effect.asUnit(Effect.flatMap(deferred => Effect.zipRight(Deferred.await(deferred))(Effect.zipRight(Ref.set(ref, deferred))(Queue.offer(queue, [take, deferred]))))(Effect.zipRight(Deferred.make())(Effect.tap(Deferred.await)(Ref.get(ref))))));\n    return core.readWithCause(input => core.flatMap(() => producer(queue, ref))(core.fromEffect(Effect.asUnit(Effect.flatMap(deferred => Effect.flatMap(added => Effect.when(() => added)(Ref.set(ref, deferred)))(Queue.offer(queue, [_take.chunk(input), deferred])))(Deferred.make())))), error => terminate(_take.failCause(error)), () => terminate(_take.end));\n  };\n  const consumer = queue => {\n    const process = core.flatMap(([take, deferred]) => channel.zipRight(_take.match(core.unit, core.failCause, value => core.flatMap(() => process)(core.write(value)))(take))(core.fromEffect(Deferred.succeed(deferred, void 0))))(core.fromEffect(Queue.take(queue)));\n    return process;\n  };\n  return channel.unwrapScoped(Effect.flatMap(queue => Effect.flatMap(start => Effect.as(consumer(queue))(Effect.flatMap(ref => Effect.forkScoped(channelExecutor.runScoped(core.pipeTo(producer(queue, ref))(bufferChannel))))(Ref.make(start))))(Effect.tap(start => Deferred.succeed(start, void 0))(Deferred.make())))(scoped));\n};\n/** @internal */\nconst catchAll = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => catchAllCause(cause => Either.match(f, failCause)(Cause.failureOrCause(cause)))(self));\n/** @internal */\nexports.catchAll = catchAll;\nconst catchAllCause = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => new StreamImpl(core.catchAllCause(cause => f(cause).channel)(self.channel)));\n/** @internal */\nexports.catchAllCause = catchAllCause;\nconst catchSome = /*#__PURE__*/(0, _Function.dual)(2, (self, pf) => catchAll(error => Option.getOrElse(() => fail(error))(pf(error)))(self));\n/** @internal */\nexports.catchSome = catchSome;\nconst catchSomeCause = /*#__PURE__*/(0, _Function.dual)(2, (self, pf) => catchAllCause(cause => Option.getOrElse(() => failCause(cause))(pf(cause)))(self));\n/** @internal */\nexports.catchSomeCause = catchSomeCause;\nconst changes = self => changesWith((x, y) => Equal.equals(y)(x))(self);\n/** @internal */\nexports.changes = changes;\nconst changesWith = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => {\n  const writer = last => core.readWithCause(input => {\n    const [newLast, newChunk] = Chunk.reduce([last, Chunk.empty()], ([option, outputs], output) => {\n      if (Option.isSome(option) && f(option.value, output)) {\n        return [Option.some(output), outputs];\n      }\n      return [Option.some(output), Chunk.append(output)(outputs)];\n    })(input);\n    return core.flatMap(() => writer(newLast))(core.write(newChunk));\n  }, core.failCause, core.unit);\n  return new StreamImpl(core.pipeTo(writer(Option.none()))(self.channel));\n});\n/** @internal */\nexports.changesWith = changesWith;\nconst changesWithEffect = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => {\n  const writer = last => core.readWithCause(input => core.flatMap(([newLast, newChunk]) => core.flatMap(() => writer(newLast))(core.write(newChunk)))(core.fromEffect(Effect.reduce([last, Chunk.empty()], ([option, outputs], output) => {\n    if (Option.isSome(option)) {\n      return Effect.map(bool => bool ? [Option.some(output), outputs] : [Option.some(output), Chunk.append(output)(outputs)])(f(option.value, output));\n    }\n    return Effect.succeed([Option.some(output), Chunk.append(output)(outputs)]);\n  })(input))), core.failCause, core.unit);\n  return new StreamImpl(core.pipeTo(writer(Option.none()))(self.channel));\n});\n/** @internal */\nexports.changesWithEffect = changesWithEffect;\nconst chunks = self => mapChunks(Chunk.of)(self);\n/** @internal */\nexports.chunks = chunks;\nconst chunksWith = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => flattenChunks(f(chunks(self))));\n/** @internal */\nexports.chunksWith = chunksWith;\nconst collect = /*#__PURE__*/(0, _Function.dual)(2, (self, pf) => mapChunks(Chunk.filterMap(pf))(self));\n/** @internal */\nexports.collect = collect;\nconst collectEffect = /*#__PURE__*/(0, _Function.dual)(2, (self, pf) => suspend(() => {\n  const loop = iterator => {\n    const next = iterator.next();\n    if (next.done) {\n      return core.readWithCause(input => loop(input[Symbol.iterator]()), core.failCause, core.succeed);\n    } else {\n      return channel.unwrap(Option.match(() => Effect.sync(() => loop(iterator)), Effect.map(a2 => core.flatMap(() => loop(iterator))(core.write(Chunk.of(a2)))))(pf(next.value)));\n    }\n  };\n  return new StreamImpl(core.pipeTo(loop(Chunk.empty()[Symbol.iterator]()))(self.channel));\n}));\n/** @internal */\nexports.collectEffect = collectEffect;\nconst collectLeft = self => collect(either => Either.isLeft(either) ? Option.some(either.left) : Option.none())(self);\n/** @internal */\nexports.collectLeft = collectLeft;\nconst collectSome = self => collect(option => Option.isSome(option) ? Option.some(option.value) : Option.none())(self);\n/** @internal */\nexports.collectSome = collectSome;\nconst collectSuccess = self => collect(exit => Exit.isSuccess(exit) ? Option.some(exit.value) : Option.none())(self);\n/** @internal */\nexports.collectSuccess = collectSuccess;\nconst collectRight = self => collect(either => Either.isRight(either) ? Option.some(either.right) : Option.none())(self);\n/** @internal */\nexports.collectRight = collectRight;\nconst collectWhile = pf => {\n  return self => {\n    const loop = core.readWith(input => {\n      const mapped = Chunk.filterMapWhile(pf)(input);\n      if (mapped.length === input.length) {\n        return core.flatMap(() => loop)(core.write(mapped));\n      }\n      return core.write(mapped);\n    }, core.fail, core.succeed);\n    return new StreamImpl(channel.pipeToOrFail(loop)(self.channel));\n  };\n};\n/** @internal */\nexports.collectWhile = collectWhile;\nconst collectWhileLeft = self => collectWhile(either => Either.isLeft(either) ? Option.some(either.left) : Option.none())(self);\n/** @internal */\nexports.collectWhileLeft = collectWhileLeft;\nconst collectWhileSome = self => collectWhile(option => Option.isSome(option) ? Option.some(option.value) : Option.none())(self);\n/** @internal */\nexports.collectWhileSome = collectWhileSome;\nconst collectWhileRight = self => collectWhile(either => Either.isRight(either) ? Option.some(either.right) : Option.none())(self);\n/** @internal */\nexports.collectWhileRight = collectWhileRight;\nconst collectWhileSuccess = self => collectWhile(exit => Exit.isSuccess(exit) ? Option.some(exit.value) : Option.none())(self);\n/** @internal */\nexports.collectWhileSuccess = collectWhileSuccess;\nconst collectWhileEffect = /*#__PURE__*/(0, _Function.dual)(2, (self, pf) => suspend(() => {\n  const loop = iterator => {\n    const next = iterator.next();\n    if (next.done) {\n      return core.readWithCause(input => loop(input[Symbol.iterator]()), core.failCause, core.succeed);\n    } else {\n      return channel.unwrap(Option.match(() => Effect.succeed(core.unit()), Effect.map(a2 => core.flatMap(() => loop(iterator))(core.write(Chunk.of(a2)))))(pf(next.value)));\n    }\n  };\n  return new StreamImpl(channel.pipeToOrFail(loop(Chunk.empty()[Symbol.iterator]()))(self.channel));\n}));\n/** @internal */\nexports.collectWhileEffect = collectWhileEffect;\nconst combine = /*#__PURE__*/(0, _Function.dual)(4, (self, that, s, f) => {\n  const producer = (handoff, latch) => channel.zipRight(core.readWithCause(input => core.flatMap(() => producer(handoff, latch))(core.fromEffect(Handoff.offer(Exit.succeed(input))(handoff))), cause => core.fromEffect(Handoff.offer(Exit.failCause(Cause.map(Option.some)(cause)))(handoff)), () => core.flatMap(() => producer(handoff, latch))(core.fromEffect(Handoff.offer(Exit.fail(Option.none()))(handoff)))))(core.fromEffect(Handoff.take(latch)));\n  return new StreamImpl(channel.unwrapScoped(Effect.gen(function* ($) {\n    const left = yield* $(Handoff.make());\n    const right = yield* $(Handoff.make());\n    const latchL = yield* $(Handoff.make());\n    const latchR = yield* $(Handoff.make());\n    yield* $(Effect.forkScoped(channelExecutor.runScoped(core.pipeTo(producer(left, latchL))(channel.concatMap(channel.writeChunk)(self.channel)))));\n    yield* $(Effect.forkScoped(channelExecutor.runScoped(core.pipeTo(producer(right, latchR))(channel.concatMap(channel.writeChunk)(that.channel)))));\n    const pullLeft = Effect.zipRight(Effect.flatMap(Effect.done)(Handoff.take(left)))(Handoff.offer(void 0)(latchL));\n    const pullRight = Effect.zipRight(Effect.flatMap(Effect.done)(Handoff.take(right)))(Handoff.offer(void 0)(latchR));\n    return unfoldEffect(s, s => Effect.flatMap(exit => Effect.unsome(Effect.done(exit)))(f(s, pullLeft, pullRight))).channel;\n  })));\n});\n/** @internal */\nexports.combine = combine;\nconst combineChunks = /*#__PURE__*/(0, _Function.dual)(4, (self, that, s, f) => {\n  const producer = (handoff, latch) => channel.zipRight(core.readWithCause(input => core.flatMap(() => producer(handoff, latch))(core.fromEffect(Handoff.offer(_take.chunk(input))(handoff))), cause => core.fromEffect(Handoff.offer(_take.failCause(cause))(handoff)), () => core.flatMap(() => producer(handoff, latch))(core.fromEffect(Handoff.offer(_take.end)(handoff)))))(core.fromEffect(Handoff.take(latch)));\n  return new StreamImpl(channel.unwrapScoped(Effect.map(([left, right, latchL, latchR]) => {\n    const pullLeft = Effect.zipRight(Effect.flatMap(_take.done)(Handoff.take(left)))(Handoff.offer(void 0)(latchL));\n    const pullRight = Effect.zipRight(Effect.flatMap(_take.done)(Handoff.take(right)))(Handoff.offer(void 0)(latchR));\n    return unfoldChunkEffect(s, s => Effect.flatMap(exit => Effect.unsome(Effect.done(exit)))(f(s, pullLeft, pullRight))).channel;\n  })(Effect.tap(([_, right, __, latchR]) => Effect.forkScoped(channelExecutor.runScoped(core.pipeTo(producer(right, latchR))(that.channel))))(Effect.tap(([left, _, latchL]) => Effect.forkScoped(channelExecutor.runScoped(core.pipeTo(producer(left, latchL))(self.channel))))(Effect.all(Handoff.make(), Handoff.make(), Handoff.make(), Handoff.make()))))));\n});\n/** @internal */\nexports.combineChunks = combineChunks;\nconst concat = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => new StreamImpl(channel.zipRight(that.channel)(self.channel)));\n/** @internal */\nexports.concat = concat;\nconst concatAll = streams => suspend(() => Chunk.reduce(empty, (x, y) => concat(y)(x))(streams));\n/** @internal */\nexports.concatAll = concatAll;\nconst cross = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => crossWith(that, (a, a2) => [a, a2])(self));\n/** @internal */\nexports.cross = cross;\nconst crossLeft = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => crossWith(that, (a, _) => a)(self));\n/** @internal */\nexports.crossLeft = crossLeft;\nconst crossRight = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => flatMap(self, () => that));\n/** @internal */\nexports.crossRight = crossRight;\nconst crossWith = /*#__PURE__*/(0, _Function.dual)(3, (self, that, f) => flatMap(a => map(b => f(a, b))(that))(self));\n/** @internal */\nexports.crossWith = crossWith;\nconst debounce = /*#__PURE__*/(0, _Function.dual)(2, (self, duration) => unwrap(Effect.flatMap(input => Effect.transplant(grafter => Effect.map(handoff => {\n  const enqueue = last => Effect.map(fiber => consumer(DebounceState.previous(fiber)))(grafter(Effect.fork(Effect.as(last)(Clock.sleep(duration)))));\n  const producer = core.readWithCause(input => Option.match(() => producer, last => core.flatMap(() => producer)(core.fromEffect(Handoff.offer(HandoffSignal.emit(Chunk.of(last)))(handoff))))(Chunk.last(input)), cause => core.fromEffect(Handoff.offer(HandoffSignal.halt(cause))(handoff)), () => core.fromEffect(Handoff.offer(HandoffSignal.end(SinkEndReason.UpstreamEnd))(handoff)));\n  const consumer = state => {\n    switch (state._tag) {\n      case DebounceState.OP_NOT_STARTED:\n        {\n          return channel.unwrap(Effect.map(signal => {\n            switch (signal._tag) {\n              case HandoffSignal.OP_EMIT:\n                {\n                  return channel.unwrap(enqueue(signal.elements));\n                }\n              case HandoffSignal.OP_HALT:\n                {\n                  return core.failCause(signal.cause);\n                }\n              case HandoffSignal.OP_END:\n                {\n                  return core.unit();\n                }\n            }\n          })(Handoff.take(handoff)));\n        }\n      case DebounceState.OP_PREVIOUS:\n        {\n          return channel.unwrap(Effect.raceWith(Handoff.take(handoff), (leftExit, current) => Exit.match(cause => Effect.as(core.failCause(cause))(Fiber.interrupt(current)), chunk => Effect.succeed(core.flatMap(() => consumer(DebounceState.current(current)))(core.write(chunk))))(leftExit), (rightExit, previous) => Exit.match(cause => Effect.as(core.failCause(cause))(Fiber.interrupt(previous)), signal => {\n            switch (signal._tag) {\n              case HandoffSignal.OP_EMIT:\n                {\n                  return Effect.zipRight(enqueue(signal.elements))(Fiber.interrupt(previous));\n                }\n              case HandoffSignal.OP_HALT:\n                {\n                  return Effect.as(core.failCause(signal.cause))(Fiber.interrupt(previous));\n                }\n              case HandoffSignal.OP_END:\n                {\n                  return Effect.map(chunk => channel.zipRight(core.unit())(core.write(chunk)))(Fiber.join(previous));\n                }\n            }\n          })(rightExit))(Fiber.join(state.fiber)));\n        }\n      case DebounceState.OP_CURRENT:\n        {\n          return channel.unwrap(Effect.map(signal => {\n            switch (signal._tag) {\n              case HandoffSignal.OP_EMIT:\n                {\n                  return channel.unwrap(enqueue(signal.elements));\n                }\n              case HandoffSignal.OP_HALT:\n                {\n                  return core.failCause(signal.cause);\n                }\n              case HandoffSignal.OP_END:\n                {\n                  return core.unit();\n                }\n            }\n          })(Fiber.join(state.fiber)));\n        }\n    }\n  };\n  const debounceChannel = channel.unwrapScoped(Effect.as(core.embedInput(input)(consumer(DebounceState.notStarted)))(Effect.forkScoped(channelExecutor.run(core.pipeTo(producer)(channel.fromInput(input))))));\n  return new StreamImpl(core.pipeTo(debounceChannel)(self.channel));\n})(Handoff.make())))(singleProducerAsyncInput.make())));\n/** @internal */\nexports.debounce = debounce;\nconst die = defect => fromEffect(Effect.die(defect));\n/** @internal */\nexports.die = die;\nconst dieSync = evaluate => fromEffect(Effect.dieSync(evaluate));\n/** @internal */\nexports.dieSync = dieSync;\nconst dieMessage = message => fromEffect(Effect.dieMessage(message));\n/** @internal */\nexports.dieMessage = dieMessage;\nconst distributedWith = /*#__PURE__*/(0, _Function.dual)(4, (self, n, maximumLag, decide) => Effect.flatMap(deferred => Effect.flatMap(next => Effect.flatMap(entries => {\n  const [mappings, queues] = Chunk.reduceRight([new Map(), Chunk.empty()], ([mappings, queues], [mapping, queue]) => [mappings.set(mapping[0], mapping[1]), Chunk.prepend(queue)(queues)])(entries);\n  return Effect.as(Array.from(queues))(Deferred.succeed(deferred, a => Effect.map(decide(a), f => key => f(mappings.get(key)))));\n})(Effect.collectAll(Chunk.map(id => Effect.map(next, ([key, queue]) => [[key, id], queue]))(Chunk.range(0, n - 1)))))(distributedWithDynamic(maximumLag, a => Effect.flatMap(Deferred.await(deferred), f => f(a)))(self)))(Deferred.make()));\n/** @internal */\nexports.distributedWith = distributedWith;\nconst distributedWithDynamicId = {\n  ref: 0\n};\nconst newDistributedWithDynamicId = () => {\n  const current = distributedWithDynamicId.ref;\n  distributedWithDynamicId.ref = current + 1;\n  return current;\n};\n/** @internal */\nconst distributedWithDynamic = /*#__PURE__*/(0, _Debug.dualWithTrace)(3, trace => (self, maximumLag, decide) => distributedWithDynamicCallback(self, maximumLag, decide, () => Effect.unit()).traced(trace));\nexports.distributedWithDynamic = distributedWithDynamic;\nconst distributedWithDynamicCallback = /*#__PURE__*/(0, _Debug.dualWithTrace)(4, trace => (self, maximumLag, decide, done) => Effect.flatMap(queuesRef => Effect.gen(function* ($) {\n  const offer = a => Effect.asUnit(Effect.flatMap(shouldProcess => Effect.flatMap(queues => Effect.flatMap(ids => {\n    if (Chunk.isNonEmpty(ids)) {\n      return Ref.update(queuesRef, map => {\n        for (const id of ids) {\n          map.delete(id);\n        }\n        return map;\n      });\n    }\n    return Effect.unit();\n  })(Effect.reduce(Chunk.empty(), (acc, [id, queue]) => {\n    if (shouldProcess(id)) {\n      return Effect.matchCauseEffect(cause =>\n      // Ignore all downstream queues that were shut\n      // down and remove them later\n      Cause.isInterrupted(cause) ? Effect.succeed(Chunk.prepend(id)(acc)) : Effect.failCause(cause), () => Effect.succeed(acc))(Queue.offer(queue, Exit.succeed(a)));\n    }\n    return Effect.succeed(acc);\n  })(queues.entries())))(Ref.get(queuesRef)))(decide(a)));\n  const queuesLock = yield* $(Effect.makeSemaphore(1));\n  const newQueue = yield* $(Ref.make(Effect.flatMap(queue => {\n    const id = newDistributedWithDynamicId();\n    return Effect.as([id, queue])(Ref.update(queuesRef, map => map.set(id, queue)));\n  })(Queue.bounded(maximumLag))));\n  const finalize = endTake =>\n  // Make sure that no queues are currently being added\n  queuesLock.withPermits(1)(Effect.asUnit(Effect.zipRight(done(endTake))(Effect.zipRight(Effect.flatMap(map => Effect.forEach(queue => Effect.catchSomeCause(cause => Cause.isInterrupted(cause) ? Option.some(Effect.unit()) : Option.none())(Queue.offer(queue, endTake)))(Chunk.fromIterable(map.values())))(Ref.get(queuesRef)))(Ref.set(newQueue, Effect.flatMap(queue => {\n    const id = newDistributedWithDynamicId();\n    return Effect.as([id, queue])(Ref.update(queuesRef, map => map.set(id, queue)));\n  })(Effect.tap(queue => Queue.offer(queue, endTake))(\n  // All newly created queues should end immediately\n  Queue.bounded(1))))))));\n  yield* $(Effect.forkScoped(Effect.matchCauseEffect(cause => finalize(Exit.failCause(Cause.map(Option.some)(cause))), () => finalize(Exit.fail(Option.none())))(runForEachScoped(offer)(self))));\n  return queuesLock.withPermits(1)(Effect.flatten(Ref.get(newQueue)));\n}))(Effect.acquireRelease(Ref.make(new Map()), (ref, _) => Effect.flatMap(queues => Effect.forEach(Queue.shutdown)(queues.values()))(Ref.get(ref)))).traced(trace));\n/** @internal */\nexports.distributedWithDynamicCallback = distributedWithDynamicCallback;\nconst done = exit => fromEffect(Effect.done(exit));\n/** @internal */\nexports.done = done;\nconst drain = self => new StreamImpl(channel.drain(self.channel));\n/** @internal */\nexports.drain = drain;\nconst drainFork = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => flatMap(backgroundDied => crossRight(interruptWhenDeferred(backgroundDied)(self))(scoped(Effect.forkScoped(Effect.catchAllCause(cause => Deferred.failCause(backgroundDied, cause))(runForEachScoped(() => Effect.unit())(that))))))(fromEffect(Deferred.make())));\n/** @internal */\nexports.drainFork = drainFork;\nconst drop = /*#__PURE__*/(0, _Function.dual)(2, (self, n) => {\n  const loop = r => core.readWith(input => {\n    const dropped = Chunk.drop(r)(input);\n    const leftover = Math.max(0, r - input.length);\n    const more = Chunk.isEmpty(input) || leftover > 0;\n    if (more) {\n      return loop(leftover);\n    }\n    return channel.zipRight(channel.identityChannel())(core.write(dropped));\n  }, core.fail, core.unit);\n  return new StreamImpl(channel.pipeToOrFail(loop(n))(self.channel));\n});\n/** @internal */\nexports.drop = drop;\nconst dropRight = /*#__PURE__*/(0, _Function.dual)(2, (self, n) => {\n  if (n <= 0) {\n    return identityStream();\n  }\n  return suspend(() => {\n    const queue = new _support.RingBuffer(n);\n    const reader = core.readWith(input => {\n      const outputs = Chunk.filterMap(elem => {\n        const head = queue.head();\n        queue.put(elem);\n        return head;\n      })(input);\n      return core.flatMap(() => reader)(core.write(outputs));\n    }, core.fail, core.unit);\n    return new StreamImpl(channel.pipeToOrFail(reader)(self.channel));\n  });\n});\n/** @internal */\nexports.dropRight = dropRight;\nconst dropUntil = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => drop(1)(dropWhile(a => !predicate(a))(self)));\n/** @internal */\nexports.dropUntil = dropUntil;\nconst dropUntilEffect = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => {\n  const loop = core.readWith(input => channel.unwrap(Effect.map(leftover => {\n    const more = Chunk.isEmpty(leftover);\n    if (more) {\n      return core.suspend(() => loop);\n    }\n    return channel.zipRight(channel.identityChannel())(core.write(leftover));\n  })(Effect.dropUntil(predicate)(input))), core.fail, core.unit);\n  return new StreamImpl(channel.pipeToOrFail(loop)(self.channel));\n});\n/** @internal */\nexports.dropUntilEffect = dropUntilEffect;\nconst dropWhile = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => {\n  const loop = core.readWith(input => {\n    const output = Chunk.dropWhile(predicate)(input);\n    if (Chunk.isEmpty(output)) {\n      return core.suspend(() => loop);\n    }\n    return channel.zipRight(channel.identityChannel())(core.write(output));\n  }, core.fail, core.succeedNow);\n  return new StreamImpl(channel.pipeToOrFail(loop)(self.channel));\n});\n/** @internal */\nexports.dropWhile = dropWhile;\nconst dropWhileEffect = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => {\n  const loop = core.readWith(input => channel.unwrap(Effect.map(leftover => {\n    const more = Chunk.isEmpty(leftover);\n    if (more) {\n      return core.suspend(() => loop);\n    }\n    return channel.zipRight(channel.identityChannel())(core.write(leftover));\n  })(Effect.dropWhile(predicate)(input))), core.fail, core.unit);\n  return new StreamImpl(channel.pipeToOrFail(loop)(self.channel));\n});\n/** @internal */\nexports.dropWhileEffect = dropWhileEffect;\nconst either = self => catchAll(error => make(Either.left(error)))(map(Either.right)(self));\n/** @internal */\nexports.either = either;\nconst empty = /*#__PURE__*/new StreamImpl( /*#__PURE__*/core.write( /*#__PURE__*/Chunk.empty()));\n/** @internal */\nexports.empty = empty;\nconst ensuring = /*#__PURE__*/(0, _Function.dual)(2, (self, finalizer) => new StreamImpl(channel.ensuring(finalizer)(self.channel)));\n/** @internal */\nexports.ensuring = ensuring;\nconst context = () => fromEffect(Effect.context());\n/** @internal */\nexports.context = context;\nconst contextWith = f => map(f)(context());\n/** @internal */\nexports.contextWith = contextWith;\nconst contextWithEffect = f => mapEffect(f)(context());\n/** @internal */\nexports.contextWithEffect = contextWithEffect;\nconst contextWithStream = f => flatMap(f)(context());\n/** @internal */\nexports.contextWithStream = contextWithStream;\nconst execute = effect => drain(fromEffect(effect));\n/** @internal */\nexports.execute = execute;\nconst fail = error => fromEffectOption(Effect.fail(Option.some(error)));\n/** @internal */\nexports.fail = fail;\nconst failSync = evaluate => fromEffectOption(Effect.failSync(() => Option.some(evaluate())));\n/** @internal */\nexports.failSync = failSync;\nconst failCause = cause => fromEffect(Effect.failCause(cause));\n/** @internal */\nexports.failCause = failCause;\nconst failCauseSync = evaluate => fromEffect(Effect.failCauseSync(evaluate));\n/** @internal */\nexports.failCauseSync = failCauseSync;\nconst filter = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => mapChunks(self, Chunk.filter(predicate)));\n/** @internal */\nexports.filter = filter;\nconst filterEffect = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => {\n  const loop = iterator => {\n    const next = iterator.next();\n    if (next.done) {\n      return core.readWithCause(input => loop(input[Symbol.iterator]()), core.failCause, core.succeed);\n    } else {\n      return channel.unwrap(Effect.map(bool => bool ? core.flatMap(() => loop(iterator))(core.write(Chunk.of(next.value))) : loop(iterator))(f(next.value)));\n    }\n  };\n  return new StreamImpl(core.suspend(() => core.pipeTo(loop(Chunk.empty()[Symbol.iterator]()))(self.channel)));\n});\n/** @internal */\nexports.filterEffect = filterEffect;\nconst finalizer = finalizer => acquireRelease(Effect.unit(), () => finalizer);\n/** @internal */\nexports.finalizer = finalizer;\nconst find = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => {\n  const loop = core.readWith(input => Option.match(() => loop, n => core.write(Chunk.of(n)))(Chunk.findFirst(predicate)(input)), core.fail, core.unit);\n  return new StreamImpl(core.pipeTo(loop)(self.channel));\n});\n/** @internal */\nexports.find = find;\nconst findEffect = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => {\n  const loop = core.readWith(input => channel.unwrap(Effect.map(Option.match(() => loop, n => core.write(Chunk.of(n))))(Effect.find(predicate)(input))), core.fail, core.unit);\n  return new StreamImpl(core.pipeTo(loop)(self.channel));\n});\n/** @internal */\nexports.findEffect = findEffect;\nconst flatMap = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => new StreamImpl(channel.concatMap(as => Chunk.reduce(core.unit(), (left, right) => channel.zipRight(right)(left))(Chunk.map(a => f(a).channel)(as)))(self.channel)));\n/** @internal */\nexports.flatMap = flatMap;\nconst flatMapPar = /*#__PURE__*/(0, _Function.dual)(3, (self, n, f) => flatMapParBuffer(self, n, 16, f));\n/** @internal */\nexports.flatMapPar = flatMapPar;\nconst flatMapParBuffer = /*#__PURE__*/(0, _Function.dual)(4, (self, n, bufferSize, f) => new StreamImpl(channel.mergeMapBuffer(out => f(out).channel, n, bufferSize)(channel.concatMap(channel.writeChunk)(self.channel))));\n/** @internal */\nexports.flatMapParBuffer = flatMapParBuffer;\nconst flatMapParSwitch = /*#__PURE__*/(0, _Function.dual)(3, (self, n, f) => flatMapParSwitchBuffer(self, n, 16, f));\n/** @internal */\nexports.flatMapParSwitch = flatMapParSwitch;\nconst flatMapParSwitchBuffer = /*#__PURE__*/(0, _Function.dual)(4, (self, n, bufferSize, f) => new StreamImpl(channel.mergeMapBufferStrategy(out => f(out).channel, n, bufferSize, MergeStrategy.BufferSliding())(channel.concatMap(channel.writeChunk)(self.channel))));\n/** @internal */\nexports.flatMapParSwitchBuffer = flatMapParSwitchBuffer;\nconst flatten = self => flatMap(_Function.identity)(self);\n/** @internal */\nexports.flatten = flatten;\nconst flattenChunks = self => {\n  const flatten = core.readWithCause(chunks => core.flatMap(() => flatten)(channel.writeChunk(chunks)), core.failCause, core.unit);\n  return new StreamImpl(core.pipeTo(flatten)(self.channel));\n};\n/** @internal */\nexports.flattenChunks = flattenChunks;\nconst flattenEffect = self => mapEffect(_Function.identity)(self);\n/** @internal */\nexports.flattenEffect = flattenEffect;\nconst flattenExit = self => mapEffect(Effect.done)(self);\n/** @internal */\nexports.flattenExit = flattenExit;\nconst flattenExitOption = self => {\n  const processChunk = (chunk, cont) => {\n    const [toEmit, rest] = Chunk.splitWhere(exit => !Exit.isSuccess(exit))(chunk);\n    const next = Option.match(() => cont, Exit.match(cause => Option.match(core.unit, core.failCause)(Cause.flipCauseOption(cause)), core.unit))(Chunk.head(rest));\n    return core.flatMap(() => next)(core.write(Chunk.filterMap(exit => Exit.isSuccess(exit) ? Option.some(exit.value) : Option.none())(toEmit)));\n  };\n  const process = core.readWithCause(chunk => processChunk(chunk, process), cause => core.failCause(cause), () => core.unit());\n  return new StreamImpl(core.pipeTo(process)(self.channel));\n};\n/** @internal */\nexports.flattenExitOption = flattenExitOption;\nconst flattenIterables = self => flattenChunks(map(Chunk.fromIterable)(self));\n/** @internal */\nexports.flattenIterables = flattenIterables;\nconst flattenPar = /*#__PURE__*/(0, _Function.dual)(2, (self, n) => flattenParBuffer(self, n, 16));\n/** @internal */\nexports.flattenPar = flattenPar;\nconst flattenParBuffer = /*#__PURE__*/(0, _Function.dual)(3, (self, n, bufferSize) => flatMapParBuffer(self, n, bufferSize, _Function.identity));\n/** @internal */\nexports.flattenParBuffer = flattenParBuffer;\nconst flattenParUnbounded = self => flattenParUnboundedBuffer(self, 16);\n/** @internal */\nexports.flattenParUnbounded = flattenParUnbounded;\nconst flattenParUnboundedBuffer = /*#__PURE__*/(0, _Function.dual)(2, (self, bufferSize) => flatMapParBuffer(self, Number.POSITIVE_INFINITY, bufferSize, _Function.identity));\n/** @internal */\nexports.flattenParUnboundedBuffer = flattenParUnboundedBuffer;\nconst flattenTake = self => flattenChunks(flattenExitOption(map(take => take.exit)(self)));\n/** @internal */\nexports.flattenTake = flattenTake;\nconst forever = self => new StreamImpl(channel.repeated(self.channel));\n/** @internal */\nexports.forever = forever;\nconst fromAsyncIterable = (iterable, onError) => unwrapScoped(Effect.map(iterator => repeatEffectOption(Effect.flatMap(result => result.done ? Effect.fail(Option.none()) : Effect.succeed(result.value))(Effect.attemptCatchPromise(() => iterator.next(), reason => Option.some(onError(reason))))))(Effect.acquireRelease(Effect.sync(() => iterable[Symbol.asyncIterator]()), iterator => iterator.return ? Effect.promise(() => iterator.return()) : Effect.unit())));\n/** @internal */\nexports.fromAsyncIterable = fromAsyncIterable;\nconst fromChannel = channel => new StreamImpl(channel);\n/** @internal */\nexports.fromChannel = fromChannel;\nconst toChannel = stream => stream.channel;\n/** @internal */\nexports.toChannel = toChannel;\nconst fromChunk = chunk => new StreamImpl(Chunk.isEmpty(chunk) ? core.unit() : core.write(chunk));\n/** @internal */\nexports.fromChunk = fromChunk;\nconst fromChunkHub = hub => flatMap(fromChunkQueue)(scoped(Hub.subscribe(hub)));\n/** @internal */\nexports.fromChunkHub = fromChunkHub;\nconst fromChunkHubScoped = hub => Effect.map(fromChunkQueue)(Hub.subscribe(hub));\n/** @internal */\nexports.fromChunkHubScoped = fromChunkHubScoped;\nconst fromChunkHubWithShutdown = hub => ensuring(Hub.shutdown(hub))(fromChunkHub(hub));\n/** @internal */\nexports.fromChunkHubWithShutdown = fromChunkHubWithShutdown;\nconst fromChunkHubScopedWithShutdown = hub => Effect.map(ensuring(Hub.shutdown(hub)))(fromChunkHubScoped(hub));\n/** @internal */\nexports.fromChunkHubScopedWithShutdown = fromChunkHubScopedWithShutdown;\nconst fromChunkQueue = queue => repeatEffectChunkOption(Effect.catchAllCause(cause => Effect.flatMap(isShutdown => isShutdown && Cause.isInterrupted(cause) ? pull.end() : pull.failCause(cause))(Queue.isShutdown(queue)))(Queue.take(queue)));\n/** @internal */\nexports.fromChunkQueue = fromChunkQueue;\nconst fromChunkQueueWithShutdown = queue => ensuring(Queue.shutdown(queue))(fromChunkQueue(queue));\n/** @internal */\nexports.fromChunkQueueWithShutdown = fromChunkQueueWithShutdown;\nconst fromChunks = (...chunks) => flatMap(fromChunk)(fromIterable(chunks));\n/** @internal */\nexports.fromChunks = fromChunks;\nconst fromEffect = effect => fromEffectOption(Effect.mapError(Option.some)(effect));\n/** @internal */\nexports.fromEffect = fromEffect;\nconst fromEffectOption = effect => new StreamImpl(channel.unwrap(Effect.match(Option.match(core.unit, core.fail), a => core.write(Chunk.of(a)))(effect)));\n/** @internal */\nexports.fromEffectOption = fromEffectOption;\nconst fromHub = (hub, maxChunkSize = DefaultChunkSize) => flatMap(queue => fromQueue(queue, maxChunkSize))(scoped(Hub.subscribe(hub)));\n/** @internal */\nexports.fromHub = fromHub;\nconst fromHubScoped = /*#__PURE__*/(0, _Debug.methodWithTrace)(trace => (hub, maxChunkSize = DefaultChunkSize) => Effect.suspend(() => Effect.map(queue => fromQueueWithShutdown(queue, maxChunkSize))(Hub.subscribe(hub))).traced(trace));\n/** @internal */\nexports.fromHubScoped = fromHubScoped;\nconst fromHubWithShutdown = (hub, maxChunkSize = DefaultChunkSize) => ensuring(Hub.shutdown(hub))(fromHub(hub, maxChunkSize));\n/** @internal */\nexports.fromHubWithShutdown = fromHubWithShutdown;\nconst fromHubScopedWithShutdown = /*#__PURE__*/(0, _Debug.methodWithTrace)(trace => (hub, maxChunkSize = DefaultChunkSize) => Effect.map(ensuring(Hub.shutdown(hub)))(fromHubScoped(hub, maxChunkSize)).traced(trace));\n/** @internal */\nexports.fromHubScopedWithShutdown = fromHubScopedWithShutdown;\nconst fromIterable = iterable => suspend(() => Chunk.isChunk(iterable) ? fromChunk(iterable) : fromIteratorSucceed(iterable[Symbol.iterator]()));\n/** @internal */\nexports.fromIterable = fromIterable;\nconst fromIterableEffect = effect => unwrap(Effect.map(fromIterable)(effect));\n/** @internal */\nexports.fromIterableEffect = fromIterableEffect;\nconst fromIteratorSucceed = (iterator, maxChunkSize = DefaultChunkSize) => {\n  return unwrap(Effect.sync(() => {\n    let builder = [];\n    const loop = iterator => channel.unwrap(Effect.sync(() => {\n      let next = iterator.next();\n      if (maxChunkSize === 1) {\n        if (next.done) {\n          return core.unit();\n        }\n        return core.flatMap(() => loop(iterator))(core.write(Chunk.of(next.value)));\n      }\n      builder = [];\n      let count = 0;\n      while (count < maxChunkSize && !next.done) {\n        builder.push(next.value);\n        next = iterator.next();\n        count = count + 1;\n      }\n      if (count > 0) {\n        return core.flatMap(() => loop(iterator))(core.write(Chunk.unsafeFromArray(builder)));\n      }\n      return core.unit();\n    }));\n    return new StreamImpl(loop(iterator));\n  }));\n};\n/** @internal */\nexports.fromIteratorSucceed = fromIteratorSucceed;\nconst fromPull = effect => unwrapScoped(Effect.map(repeatEffectChunkOption)(effect));\n/** @internal */\nexports.fromPull = fromPull;\nconst fromQueue = (queue, maxChunkSize = DefaultChunkSize) => repeatEffectChunkOption(Effect.catchAllCause(cause => Effect.flatMap(isShutdown => isShutdown && Cause.isInterrupted(cause) ? pull.end() : pull.failCause(cause))(Queue.isShutdown(queue)))(Queue.takeBetween(queue, 1, maxChunkSize)));\n/** @internal */\nexports.fromQueue = fromQueue;\nconst fromQueueWithShutdown = (queue, maxChunkSize = DefaultChunkSize) => ensuring(Queue.shutdown(queue))(fromQueue(queue, maxChunkSize));\n/** @internal */\nexports.fromQueueWithShutdown = fromQueueWithShutdown;\nconst fromSchedule = schedule => unwrap(Effect.map(driver => repeatEffectOption(driver.next(void 0)))(Schedule.driver(schedule)));\n/** @internal */\nexports.fromSchedule = fromSchedule;\nconst groupAdjacentBy = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => {\n  const go = (input, state) => Chunk.reduce([Chunk.empty(), state], ([outputs, option], a) => {\n    if (Option.isSome(option)) {\n      const key = option.value[0];\n      const aggregated = option.value[1];\n      const key2 = f(a);\n      if (Equal.equals(key2)(key)) {\n        return [outputs, Option.some([key, Chunk.append(a)(aggregated)])];\n      }\n      return [Chunk.append(option.value)(outputs), Option.some([key2, Chunk.of(a)])];\n    }\n    return [outputs, Option.some([f(a), Chunk.of(a)])];\n  })(input);\n  const chunkAdjacent = buffer => core.readWithCause(input => {\n    const [outputs, newBuffer] = go(input, buffer);\n    return core.flatMap(() => chunkAdjacent(newBuffer))(core.write(outputs));\n  }, core.failCause, () => Option.match(core.unit, output => core.write(Chunk.of(output)))(buffer));\n  return new StreamImpl(channel.pipeToOrFail(chunkAdjacent(Option.none()))(self.channel));\n});\n/** @internal */\nexports.groupAdjacentBy = groupAdjacentBy;\nconst grouped = /*#__PURE__*/(0, _Function.dual)(2, (self, chunkSize) => chunks(rechunk(chunkSize)(self)));\n/** @internal */\nexports.grouped = grouped;\nconst groupedWithin = /*#__PURE__*/(0, _Function.dual)(3, (self, chunkSize, duration) => aggregateWithin(_sink.collectAllN(chunkSize), Schedule.spaced(duration))(self));\n/** @internal */\nexports.groupedWithin = groupedWithin;\nconst haltWhen = /*#__PURE__*/(0, _Function.dual)(2, (self, effect) => {\n  const writer = fiber => channel.unwrap(Effect.map(Option.match(() => core.readWith(input => core.flatMap(() => writer(fiber))(core.write(input)), core.fail, core.unit), Exit.match(core.failCause, core.unit)))(Fiber.poll(fiber)));\n  return new StreamImpl(channel.unwrapScoped(Effect.map(fiber => core.pipeTo(writer(fiber))(self.channel))(Effect.forkScoped(effect))));\n});\n/** @internal */\nexports.haltWhen = haltWhen;\nconst haltAfter = /*#__PURE__*/(0, _Function.dual)(2, (self, duration) => haltWhen(Clock.sleep(duration))(self));\n/** @internal */\nexports.haltAfter = haltAfter;\nconst haltWhenDeferred = /*#__PURE__*/(0, _Function.dual)(2, (self, deferred) => {\n  const writer = channel.unwrap(Effect.map(Option.match(() => core.readWith(input => core.flatMap(() => writer)(core.write(input)), core.fail, core.unit), effect => channel.unwrap(Effect.match(core.fail, core.unit)(effect))))(Deferred.poll(deferred)));\n  return new StreamImpl(core.pipeTo(writer)(self.channel));\n});\n/** @internal */\nexports.haltWhenDeferred = haltWhenDeferred;\nconst identityStream = () => new StreamImpl(channel.identityChannel());\n/** @internal */\nexports.identityStream = identityStream;\nconst interleave = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => interleaveWith(that, forever(make(true, false)))(self));\n/** @internal */\nexports.interleave = interleave;\nconst interleaveWith = /*#__PURE__*/(0, _Function.dual)(3, (self, that, decider) => {\n  const producer = handoff => core.readWithCause(value => core.flatMap(() => producer(handoff))(core.fromEffect(Handoff.offer(_take.of(value))(handoff))), cause => core.fromEffect(Handoff.offer(_take.failCause(cause))(handoff)), () => core.fromEffect(Handoff.offer(_take.end)(handoff)));\n  return new StreamImpl(channel.unwrapScoped(Effect.map(([left, right]) => {\n    const process = (leftDone, rightDone) => core.readWithCause(bool => {\n      if (bool && !leftDone) {\n        return core.flatMap(_take.match(() => rightDone ? core.unit() : process(true, rightDone), core.failCause, chunk => core.flatMap(() => process(leftDone, rightDone))(core.write(chunk))))(core.fromEffect(Handoff.take(left)));\n      }\n      if (!bool && !rightDone) {\n        return core.flatMap(_take.match(() => leftDone ? core.unit() : process(leftDone, true), core.failCause, chunk => core.flatMap(() => process(leftDone, rightDone))(core.write(chunk))))(core.fromEffect(Handoff.take(right)));\n      }\n      return process(leftDone, rightDone);\n    }, core.failCause, core.unit);\n    return core.pipeTo(process(false, false))(channel.concatMap(channel.writeChunk)(decider.channel));\n  })(Effect.tap(([_, right]) => Effect.forkScoped(channelExecutor.runScoped(core.pipeTo(producer(right))(channel.concatMap(channel.writeChunk)(that.channel)))))(Effect.tap(([left]) => Effect.forkScoped(channelExecutor.runScoped(core.pipeTo(producer(left))(channel.concatMap(channel.writeChunk)(self.channel)))))(Effect.zip(Handoff.make())(Handoff.make()))))));\n});\n/** @internal */\nexports.interleaveWith = interleaveWith;\nconst intersperse = /*#__PURE__*/(0, _Function.dual)(2, (self, element) => new StreamImpl(channel.pipeToOrFail(core.suspend(() => {\n  const writer = isFirst => core.readWithCause(chunk => {\n    const builder = [];\n    let flagResult = isFirst;\n    for (const output of chunk) {\n      if (flagResult) {\n        flagResult = false;\n        builder.push(output);\n      } else {\n        builder.push(element);\n        builder.push(output);\n      }\n    }\n    return core.flatMap(() => writer(flagResult))(core.write(Chunk.unsafeFromArray(builder)));\n  }, core.failCause, core.unit);\n  return writer(true);\n}))(self.channel)));\n/** @internal */\nexports.intersperse = intersperse;\nconst intersperseAffixes = /*#__PURE__*/(0, _Function.dual)(4, (self, start, middle, end) => concat(make(end))(concat(intersperse(middle)(self))(make(start))));\n/** @internal */\nexports.intersperseAffixes = intersperseAffixes;\nconst interruptAfter = /*#__PURE__*/(0, _Function.dual)(2, (self, duration) => interruptWhen(Clock.sleep(duration))(self));\n/** @internal */\nexports.interruptAfter = interruptAfter;\nconst interruptWhen = /*#__PURE__*/(0, _Function.dual)(2, (self, effect) => new StreamImpl(channel.interruptWhen(effect)(self.channel)));\n/** @internal */\nexports.interruptWhen = interruptWhen;\nconst interruptWhenDeferred = /*#__PURE__*/(0, _Function.dual)(2, (self, deferred) => new StreamImpl(channel.interruptWhenDeferred(deferred)(self.channel)));\n/** @internal */\nexports.interruptWhenDeferred = interruptWhenDeferred;\nconst iterate = (value, next) => unfold(value, a => Option.some([a, next(a)]));\n/** @internal */\nexports.iterate = iterate;\nconst log = message => fromEffect(Effect.log(message));\n/** @internal */\nexports.log = log;\nconst logDebug = message => fromEffect(Effect.logDebug(message));\n/** @internal */\nexports.logDebug = logDebug;\nconst logDebugCause = cause => fromEffect(Effect.logDebugCause(cause));\n/** @internal */\nexports.logDebugCause = logDebugCause;\nconst logDebugCauseMessage = (message, cause) => fromEffect(Effect.logDebugCauseMessage(message, cause));\n/** @internal */\nexports.logDebugCauseMessage = logDebugCauseMessage;\nconst logError = message => fromEffect(Effect.logError(message));\n/** @internal */\nexports.logError = logError;\nconst logErrorCause = cause => fromEffect(Effect.logErrorCause(cause));\n/** @internal */\nexports.logErrorCause = logErrorCause;\nconst logErrorCauseMessage = (message, cause) => fromEffect(Effect.logErrorCauseMessage(message, cause));\n/** @internal */\nexports.logErrorCauseMessage = logErrorCauseMessage;\nconst logFatal = message => fromEffect(Effect.logFatal(message));\n/** @internal */\nexports.logFatal = logFatal;\nconst logFatalCause = cause => fromEffect(Effect.logFatalCause(cause));\n/** @internal */\nexports.logFatalCause = logFatalCause;\nconst logFatalCauseMessage = (message, cause) => fromEffect(Effect.logFatalCauseMessage(message, cause));\n/** @internal */\nexports.logFatalCauseMessage = logFatalCauseMessage;\nconst logInfo = message => fromEffect(Effect.logInfo(message));\n/** @internal */\nexports.logInfo = logInfo;\nconst logInfoCause = cause => fromEffect(Effect.logInfoCause(cause));\n/** @internal */\nexports.logInfoCause = logInfoCause;\nconst logInfoCauseMessage = (message, cause) => fromEffect(Effect.logInfoCauseMessage(message, cause));\n/** @internal */\nexports.logInfoCauseMessage = logInfoCauseMessage;\nconst logWarning = message => fromEffect(Effect.logWarning(message));\n/** @internal */\nexports.logWarning = logWarning;\nconst logWarningCause = cause => fromEffect(Effect.logWarningCause(cause));\n/** @internal */\nexports.logWarningCause = logWarningCause;\nconst logWarningCauseMessage = (message, cause) => fromEffect(Effect.logWarningCauseMessage(message, cause));\n/** @internal */\nexports.logWarningCauseMessage = logWarningCauseMessage;\nconst logTrace = message => fromEffect(Effect.logTrace(message));\n/** @internal */\nexports.logTrace = logTrace;\nconst logTraceCause = cause => fromEffect(Effect.logTraceCause(cause));\n/** @internal */\nexports.logTraceCause = logTraceCause;\nconst logTraceCauseMessage = (message, cause) => fromEffect(Effect.logTraceCauseMessage(message, cause));\n/** @internal */\nexports.logTraceCauseMessage = logTraceCauseMessage;\nconst make = (...as) => fromIterable(as);\n/** @internal */\nexports.make = make;\nconst map = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => new StreamImpl(channel.mapOut(Chunk.map(f))(self.channel)));\n/** @internal */\nexports.map = map;\nconst mapAccum = /*#__PURE__*/(0, _Function.dual)(3, (self, s, f) => {\n  const accumulator = s => core.readWith(input => {\n    const [nextS, chunk] = Chunk.mapAccum(s, f)(input);\n    return core.flatMap(() => accumulator(nextS))(core.write(chunk));\n  }, core.fail, core.unit);\n  return new StreamImpl(core.pipeTo(accumulator(s))(self.channel));\n});\n/** @internal */\nexports.mapAccum = mapAccum;\nconst mapAccumEffect = /*#__PURE__*/(0, _Function.dual)(3, (self, s, f) => suspend(() => {\n  const accumulator = s => core.readWith(input => channel.unwrap(Effect.suspend(() => {\n    const outputs = [];\n    const emit = output => Effect.sync(() => {\n      outputs.push(output);\n    });\n    return Effect.match(error => {\n      if (outputs.length !== 0) {\n        return channel.zipRight(core.fail(error))(core.write(Chunk.unsafeFromArray(outputs)));\n      }\n      return core.fail(error);\n    }, s => core.flatMap(() => accumulator(s))(core.write(Chunk.unsafeFromArray(outputs))))(Effect.reduce(s, (s, a) => Effect.flatMap(([s, a]) => Effect.as(s)(emit(a)))(f(s, a)))(input));\n  })), core.fail, core.unit);\n  return new StreamImpl(channel.pipeToOrFail(accumulator(s))(self.channel));\n}));\n/** @internal */\nexports.mapAccumEffect = mapAccumEffect;\nconst mapBoth = /*#__PURE__*/(0, _Function.dual)(3, (self, f, g) => map(g)(mapError(f)(self)));\n/** @internal */\nexports.mapBoth = mapBoth;\nconst mapChunks = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => new StreamImpl(channel.mapOut(f)(self.channel)));\n/** @internal */\nexports.mapChunks = mapChunks;\nconst mapChunksEffect = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => new StreamImpl(channel.mapOutEffect(f)(self.channel)));\n/** @internal */\nexports.mapChunksEffect = mapChunksEffect;\nconst mapConcat = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => mapConcatChunk(a => Chunk.fromIterable(f(a)))(self));\n/** @internal */\nexports.mapConcat = mapConcat;\nconst mapConcatChunk = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => mapChunks(Chunk.flatMap(f))(self));\n/** @internal */\nexports.mapConcatChunk = mapConcatChunk;\nconst mapConcatChunkEffect = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => mapConcatChunk(_Function.identity)(mapEffect(f)(self)));\n/** @internal */\nexports.mapConcatChunkEffect = mapConcatChunkEffect;\nconst mapConcatEffect = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => mapConcatChunk(_Function.identity)(mapEffect(a => Effect.map(Chunk.fromIterable)(f(a)))(self)));\n/** @internal */\nexports.mapConcatEffect = mapConcatEffect;\nconst mapEffect = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => {\n  const loop = iterator => {\n    const next = iterator.next();\n    if (next.done) {\n      return core.readWithCause(elem => loop(elem[Symbol.iterator]()), core.failCause, core.succeed);\n    } else {\n      const value = next.value;\n      return channel.unwrap(Effect.map(f(value), a2 => core.flatMap(core.write(Chunk.of(a2)), () => loop(iterator))));\n    }\n  };\n  return new StreamImpl(core.pipeTo(core.suspend(() => loop(Chunk.empty()[Symbol.iterator]())))(self.channel));\n});\n/** @internal */\nexports.mapEffect = mapEffect;\nconst mapEffectPar = /*#__PURE__*/(0, _Function.dual)(3, (self, n, f) => new StreamImpl(channel.mapOut(Chunk.of)(channel.mapOutEffectPar(f, n)(channel.concatMap(channel.writeChunk)(self.channel)))));\n/** @internal */\nexports.mapEffectPar = mapEffectPar;\nconst flattenEffectPar = /*#__PURE__*/(0, _Function.dual)(2, (self, n) => new StreamImpl(channel.mapOut(Chunk.of)(channel.mapOutEffectPar(_Function.identity, n)(channel.concatMap(channel.writeChunk)(self.channel)))));\n/** @internal */\nexports.flattenEffectPar = flattenEffectPar;\nconst flattenEffectParUnordered = /*#__PURE__*/(0, _Function.dual)(2, (self, n) => flatMapPar(self, n, a => fromEffect(a)));\n/** @internal */\nexports.flattenEffectParUnordered = flattenEffectParUnordered;\nconst mapEffectParUnordered = /*#__PURE__*/(0, _Function.dual)(3, (self, n, f) => flatMapPar(self, n, a => fromEffect(f(a))));\n/** @internal */\nexports.mapEffectParUnordered = mapEffectParUnordered;\nconst mapError = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => new StreamImpl(channel.mapError(f)(self.channel)));\n/** @internal */\nexports.mapError = mapError;\nconst mapErrorCause = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => new StreamImpl(channel.mapErrorCause(f)(self.channel)));\n/** @internal */\nexports.mapErrorCause = mapErrorCause;\nconst merge = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => mergeHaltStrategy(self, that, HaltStrategy.Both));\n/** @internal */\nexports.merge = merge;\nconst mergeHaltStrategy = /*#__PURE__*/(0, _Function.dual)(3, (self, that, strategy) => mergeWithHaltStrategy(self, that, _Function.identity, _Function.identity, strategy));\n/** @internal */\nexports.mergeHaltStrategy = mergeHaltStrategy;\nconst mergeAll = (n, bufferSize = 16) => {\n  return (...streams) => flattenParBuffer(n, bufferSize)(fromIterable(streams));\n};\n/** @internal */\nexports.mergeAll = mergeAll;\nconst mergeAllUnbounded = (bufferSize = 16) => {\n  return (...streams) => flattenParBuffer(Number.POSITIVE_INFINITY, bufferSize)(fromIterable(streams));\n};\n/** @internal */\nexports.mergeAllUnbounded = mergeAllUnbounded;\nconst mergeHaltEither = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => mergeHaltStrategy(self, that, haltStrategy.Either));\n/** @internal */\nexports.mergeHaltEither = mergeHaltEither;\nconst mergeHaltLeft = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => mergeHaltStrategy(self, that, haltStrategy.Left));\n/** @internal */\nexports.mergeHaltLeft = mergeHaltLeft;\nconst mergeHaltRight = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => mergeHaltStrategy(self, that, haltStrategy.Right));\n/** @internal */\nexports.mergeHaltRight = mergeHaltRight;\nconst mergeEither = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => mergeWith(self, that, Either.left, Either.right));\n/** @internal */\nexports.mergeEither = mergeEither;\nconst mergeLeft = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => merge(drain(that))(self));\n/** @internal */\nexports.mergeLeft = mergeLeft;\nconst mergeRight = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => merge(that)(drain(self)));\n/** @internal */\nexports.mergeRight = mergeRight;\nconst mergeWith = /*#__PURE__*/(0, _Function.dual)(4, (self, that, left, right) => mergeWithHaltStrategy(self, that, left, right, HaltStrategy.Both));\n/** @internal */\nexports.mergeWith = mergeWith;\nconst mergeWithHaltStrategy = /*#__PURE__*/(0, _Function.dual)(5, (self, that, left, right, strategy) => {\n  const handler = terminate => exit => terminate || !Exit.isSuccess(exit) ? MergeDecision.Done(Effect.done(exit)) : MergeDecision.Await(Effect.done);\n  return new StreamImpl(channel.mergeWith(map(self, left).channel, map(that, right).channel, handler(strategy._tag === \"Either\" || strategy._tag === \"Left\"), handler(strategy._tag === \"Either\" || strategy._tag === \"Right\")));\n});\n/** @internal */\nexports.mergeWithHaltStrategy = mergeWithHaltStrategy;\nconst mkString = /*#__PURE__*/(0, _Debug.methodWithTrace)(trace => self => run(_sink.mkString())(self).traced(trace));\n/** @internal */\nexports.mkString = mkString;\nconst never = () => fromEffect(Effect.never());\n/** @internal */\nexports.never = never;\nconst onError = /*#__PURE__*/(0, _Function.dual)(2, (self, cleanup) => catchAllCause(cause => fromEffect(Effect.zipRight(Effect.failCause(cause))(cleanup(cause))))(self));\n/** @internal */\nexports.onError = onError;\nconst onDone = /*#__PURE__*/(0, _Function.dual)(2, (self, cleanup) => new StreamImpl(core.ensuringWith(exit => Exit.isSuccess(exit) ? cleanup() : Effect.unit())(self.channel)));\n/** @internal */\nexports.onDone = onDone;\nconst orDie = self => orDieWith(_Function.identity)(self);\n/** @internal */\nexports.orDie = orDie;\nconst orDieWith = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => new StreamImpl(channel.orDieWith(f)(self.channel)));\n/** @internal */\nexports.orDieWith = orDieWith;\nconst orElse = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => new StreamImpl(channel.orElse(() => that().channel)(self.channel)));\n/** @internal */\nexports.orElse = orElse;\nconst orElseEither = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => orElse(() => map(Either.right)(that()))(map(Either.left)(self)));\n/** @internal */\nexports.orElseEither = orElseEither;\nconst orElseFail = /*#__PURE__*/(0, _Function.dual)(2, (self, error) => orElse(() => failSync(error))(self));\n/** @internal */\nexports.orElseFail = orElseFail;\nconst orElseIfEmpty = /*#__PURE__*/(0, _Function.dual)(2, (self, element) => orElseIfEmptyChunk(() => Chunk.of(element()))(self));\n/** @internal */\nexports.orElseIfEmpty = orElseIfEmpty;\nconst orElseIfEmptyChunk = /*#__PURE__*/(0, _Function.dual)(2, (self, chunk) => orElseIfEmptyStream(() => new StreamImpl(core.write(chunk())))(self));\n/** @internal */\nexports.orElseIfEmptyChunk = orElseIfEmptyChunk;\nconst orElseIfEmptyStream = /*#__PURE__*/(0, _Function.dual)(2, (self, stream) => {\n  const writer = core.readWith(input => {\n    if (Chunk.isEmpty(input)) {\n      return core.suspend(() => writer);\n    }\n    return channel.zipRight(channel.identityChannel())(core.write(input));\n  }, core.fail, () => core.suspend(() => stream().channel));\n  return new StreamImpl(core.pipeTo(writer)(self.channel));\n});\n/** @internal */\nexports.orElseIfEmptyStream = orElseIfEmptyStream;\nconst orElseOptional = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => catchAll(Option.match(that, error => fail(Option.some(error))))(self));\n/** @internal */\nexports.orElseOptional = orElseOptional;\nconst orElseSucceed = /*#__PURE__*/(0, _Function.dual)(2, (self, value) => orElse(() => sync(value))(self));\n/** @internal */\nexports.orElseSucceed = orElseSucceed;\nconst paginate = (s, f) => paginateChunk(s, s => {\n  const page = f(s);\n  return [Chunk.of(page[0]), page[1]];\n});\n/** @internal */\nexports.paginate = paginate;\nconst paginateChunk = (s, f) => {\n  const loop = s => {\n    const page = f(s);\n    return Option.match(() => channel.zipRight(core.unit())(core.write(page[0])), s => core.flatMap(() => loop(s))(core.write(page[0])))(page[1]);\n  };\n  return new StreamImpl(core.suspend(() => loop(s)));\n};\n/** @internal */\nexports.paginateChunk = paginateChunk;\nconst paginateChunkEffect = (s, f) => {\n  const loop = s => channel.unwrap(Effect.map(([chunk, option]) => Option.match(() => channel.zipRight(core.unit())(core.write(chunk)), s => core.flatMap(() => loop(s))(core.write(chunk)))(option))(f(s)));\n  return new StreamImpl(core.suspend(() => loop(s)));\n};\n/** @internal */\nexports.paginateChunkEffect = paginateChunkEffect;\nconst paginateEffect = (s, f) => paginateChunkEffect(s, s => Effect.map(([a, s]) => [Chunk.of(a), s])(f(s)));\n/** @internal */\nexports.paginateEffect = paginateEffect;\nconst peel = /*#__PURE__*/(0, _Debug.dualWithTrace)(2, trace => (self, sink) => {\n  const OP_EMIT = \"Emit\";\n  const OP_HALT = \"Halt\";\n  const OP_END = \"End\";\n  return Effect.flatten(Effect.flatMap(deferred => Effect.map(handoff => {\n    const consumer = _sink.foldSink(error => _sink.zipRight(_sink.fail(error))(_sink.fromEffect(Deferred.fail(deferred, error))), ([z, leftovers]) => {\n      const loop = core.readWithCause(elements => core.flatMap(() => loop)(core.fromEffect(Handoff.offer({\n        _tag: OP_EMIT,\n        elements\n      })(handoff))), cause => channel.zipRight(core.failCause(cause))(core.fromEffect(Handoff.offer({\n        _tag: OP_HALT,\n        cause\n      })(handoff))), _ => channel.zipRight(core.unit())(core.fromEffect(Handoff.offer({\n        _tag: OP_END\n      })(handoff))));\n      return _sink.fromChannel(channel.zipRight(loop)(channel.zipRight(core.fromEffect(Handoff.offer({\n        _tag: OP_EMIT,\n        elements: leftovers\n      })(handoff)))(core.fromEffect(Deferred.succeed(deferred, z)))));\n    })(_sink.collectLeftover(sink));\n    const producer = channel.unwrap(Effect.map(signal => {\n      switch (signal._tag) {\n        case OP_EMIT:\n          {\n            return core.flatMap(() => producer)(core.write(signal.elements));\n          }\n        case OP_HALT:\n          {\n            return core.failCause(signal.cause);\n          }\n        case OP_END:\n          {\n            return core.unit();\n          }\n      }\n    })(Handoff.take(handoff)));\n    return Effect.map(z => [z, new StreamImpl(producer)])(Effect.zipRight(Deferred.await(deferred))(Effect.forkScoped(run(consumer)(tapErrorCause(cause => Deferred.failCause(deferred, cause))(self)))));\n  })(Handoff.make()))(Deferred.make())).traced(trace);\n});\n/** @internal */\nexports.peel = peel;\nconst partition = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => partitionBuffer(self, predicate, 16));\n/** @internal */\nexports.partition = partition;\nconst partitionBuffer = /*#__PURE__*/(0, _Function.dual)(3, (self, predicate, bufferSize) => partitionEitherBuffer(a => predicate(a) ? Effect.succeed(Either.left(a)) : Effect.succeed(Either.right(a)), bufferSize)(self));\n/** @internal */\nexports.partitionBuffer = partitionBuffer;\nconst partitionEither = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => partitionEitherBuffer(self, predicate, 16));\n/** @internal */\nexports.partitionEither = partitionEither;\nconst partitionEitherBuffer = /*#__PURE__*/(0, _Function.dual)(3, (self, predicate, bufferSize) => Effect.flatMap(([queue1, queue2]) => Effect.succeed([collectLeft(flattenExitOption(fromQueueWithShutdown(queue1))), collectRight(flattenExitOption(fromQueueWithShutdown(queue2)))]))(distributedWith(2, bufferSize, Either.match(() => Effect.succeed(n => n === 0), () => Effect.succeed(n => n === 1)))(mapEffect(predicate)(self))));\n/** @internal */\nexports.partitionEitherBuffer = partitionEitherBuffer;\nconst pipeThrough = /*#__PURE__*/(0, _Function.dual)(2, (self, sink) => new StreamImpl(channel.pipeToOrFail(sink.channel)(self.channel)));\n/** @internal */\nexports.pipeThrough = pipeThrough;\nconst pipeThroughChannel = /*#__PURE__*/(0, _Function.dual)(2, (self, channel) => new StreamImpl(core.pipeTo(channel)(self.channel)));\n/** @internal */\nexports.pipeThroughChannel = pipeThroughChannel;\nconst pipeThroughChannelOrFail = /*#__PURE__*/(0, _Function.dual)(2, (self, chan) => new StreamImpl(channel.pipeToOrFail(chan)(self.channel)));\n/** @internal */\nexports.pipeThroughChannelOrFail = pipeThroughChannelOrFail;\nconst prepend = values => new StreamImpl(channel.zipRight(channel.identityChannel())(core.write(values)));\n/** @internal */\nexports.prepend = prepend;\nconst provideContext = /*#__PURE__*/(0, _Function.dual)(2, (self, context) => new StreamImpl(core.provideContext(context)(self.channel)));\n/** @internal */\nexports.provideContext = provideContext;\nconst provideLayer = /*#__PURE__*/(0, _Function.dual)(2, (self, layer) => new StreamImpl(channel.unwrapScoped(Effect.map(env => core.provideContext(env)(self.channel))(Layer.build(layer)))));\n/** @internal */\nexports.provideLayer = provideLayer;\nconst provideService = /*#__PURE__*/(0, _Function.dual)(3, (self, tag, resource) => provideServiceEffect(self, tag, Effect.succeed(resource)));\n/** @internal */\nexports.provideService = provideService;\nconst provideServiceEffect = /*#__PURE__*/(0, _Function.dual)(3, (self, tag, effect) => provideServiceStream(self, tag, fromEffect(effect)));\n/** @internal */\nexports.provideServiceEffect = provideServiceEffect;\nconst provideServiceStream = /*#__PURE__*/(0, _Function.dual)(3, (self, tag, stream) => contextWithStream(env => flatMap(stream, service => provideContext(Context.add(env, tag, service))(self))));\n/** @internal */\nexports.provideServiceStream = provideServiceStream;\nconst contramapContext = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => contextWithStream(env => provideContext(f(env))(self)));\n/** @internal */\nexports.contramapContext = contramapContext;\nconst provideSomeLayer = /*#__PURE__*/(0, _Function.dual)(2, (self, layer) => // @ts-expect-error\nprovideLayer(Layer.merge(layer)(Layer.context()))(self));\n/** @internal */\nexports.provideSomeLayer = provideSomeLayer;\nconst range = (min, max, chunkSize = DefaultChunkSize) => suspend(() => {\n  if (min >= max) {\n    return empty;\n  }\n  const go = (min, max, chunkSize) => {\n    const remaining = max - min;\n    if (remaining > chunkSize) {\n      return core.flatMap(() => go(min + chunkSize, max, chunkSize))(core.write(Chunk.range(min, min + chunkSize - 1)));\n    }\n    return core.write(Chunk.range(min, min + remaining - 1));\n  };\n  return new StreamImpl(go(min, max, chunkSize));\n});\n/** @internal */\nexports.range = range;\nconst rechunk = /*#__PURE__*/(0, _Function.dual)(2, (self, n) => suspend(() => {\n  const target = Math.max(n, 1);\n  const process = rechunkProcess(new StreamRechunker(target), target);\n  return new StreamImpl(core.pipeTo(process)(self.channel));\n}));\n/** @internal */\nexports.rechunk = rechunk;\nconst rechunkProcess = (rechunker, target) => core.readWithCause(chunk => {\n  if (chunk.length === target && rechunker.isEmpty()) {\n    return core.flatMap(() => rechunkProcess(rechunker, target))(core.write(chunk));\n  }\n  if (chunk.length > 0) {\n    const chunks = [];\n    let result = undefined;\n    let index = 0;\n    while (index < chunk.length) {\n      while (index < chunk.length && result === undefined) {\n        result = rechunker.write(Chunk.unsafeGet(index)(chunk));\n        index = index + 1;\n      }\n      if (result !== undefined) {\n        chunks.push(result);\n        result = undefined;\n      }\n    }\n    return core.flatMap(() => rechunkProcess(rechunker, target))(channel.writeAll(...chunks));\n  }\n  return core.suspend(() => rechunkProcess(rechunker, target));\n}, cause => channel.zipRight(core.failCause(cause))(rechunker.emitIfNotEmpty()), () => rechunker.emitIfNotEmpty());\n/** @internal */\nclass StreamRechunker {\n  constructor(n) {\n    this.n = n;\n    this.builder = [];\n    this.pos = 0;\n  }\n  isEmpty() {\n    return this.pos === 0;\n  }\n  write(elem) {\n    this.builder.push(elem);\n    this.pos += 1;\n    if (this.pos === this.n) {\n      const result = Chunk.unsafeFromArray(this.builder);\n      this.builder = [];\n      this.pos = 0;\n      return result;\n    }\n    return undefined;\n  }\n  emitIfNotEmpty() {\n    if (this.pos !== 0) {\n      return core.write(Chunk.unsafeFromArray(this.builder));\n    }\n    return core.unit();\n  }\n}\n/** @internal */\nconst refineOrDie = /*#__PURE__*/(0, _Function.dual)(2, (self, pf) => refineOrDieWith(pf, _Function.identity)(self));\n/** @internal */\nexports.refineOrDie = refineOrDie;\nconst refineOrDieWith = /*#__PURE__*/(0, _Function.dual)(3, (self, pf, f) => new StreamImpl(channel.catchAll(error => Option.match(() => core.failCause(Cause.die(f(error))), core.fail)(pf(error)))(self.channel)));\n/** @internal */\nexports.refineOrDieWith = refineOrDieWith;\nconst repeat = /*#__PURE__*/(0, _Function.dual)(2, (self, schedule) => collectRight(repeatEither(schedule)(self)));\n/** @internal */\nexports.repeat = repeat;\nconst repeatEffect = effect => repeatEffectOption(Effect.mapError(Option.some)(effect));\n/** @internal */\nexports.repeatEffect = repeatEffect;\nconst repeatEffectChunk = effect => repeatEffectChunkOption(Effect.mapError(Option.some)(effect));\n/** @internal */\nexports.repeatEffectChunk = repeatEffectChunk;\nconst repeatEffectChunkOption = effect => unfoldChunkEffect(effect, effect => Effect.catchAll(Option.match(Effect.succeedNone, Effect.fail))(Effect.map(chunk => Option.some([chunk, effect]))(effect)));\n/** @internal */\nexports.repeatEffectChunkOption = repeatEffectChunkOption;\nconst repeatEffectOption = effect => repeatEffectChunkOption(Effect.map(Chunk.of)(effect));\n/** @internal */\nexports.repeatEffectOption = repeatEffectOption;\nconst repeatEither = /*#__PURE__*/(0, _Function.dual)(2, (self, schedule) => repeatWith(schedule, a => Either.right(a), Either.left)(self));\n/** @internal */\nexports.repeatEither = repeatEither;\nconst repeatElements = /*#__PURE__*/(0, _Function.dual)(2, (self, schedule) => collectRight(repeatElementsEither(schedule)(self)));\n/** @internal */\nexports.repeatElements = repeatElements;\nconst repeatElementsEither = /*#__PURE__*/(0, _Function.dual)(2, (self, schedule) => repeatElementsWith(schedule, a => Either.right(a), Either.left)(self));\n/** @internal */\nexports.repeatElementsEither = repeatElementsEither;\nconst repeatElementsWith = /*#__PURE__*/(0, _Function.dual)(4, (self, schedule, f, g) => {\n  const driver = channel.unwrap(Effect.map(driver => {\n    const feed = input => Option.match(() => loop, a => channel.zipRight(step(Chunk.drop(1)(input), a))(core.write(Chunk.of(f(a)))))(Chunk.head(input));\n    const step = (input, a) => {\n      const advance = Effect.as(core.flatMap(() => step(input, a))(core.write(Chunk.of(f(a)))))(driver.next(a));\n      const reset = Effect.flatMap(b => Effect.map(() => channel.zipRight(feed(input))(core.write(Chunk.of(g(b)))))(driver.reset()))(Effect.orDie(driver.last()));\n      return channel.unwrap(Effect.orElse(() => reset)(advance));\n    };\n    const loop = core.readWith(feed, core.fail, core.unit);\n    return loop;\n  })(Schedule.driver(schedule)));\n  return new StreamImpl(core.pipeTo(driver)(self.channel));\n});\n/** @internal */\nexports.repeatElementsWith = repeatElementsWith;\nconst repeatValue = value => new StreamImpl(channel.repeated(core.write(Chunk.of(value))));\n/** @internal */\nexports.repeatValue = repeatValue;\nconst repeatWith = /*#__PURE__*/(0, _Function.dual)(4, (self, schedule, f, g) => {\n  return unwrap(Effect.map(driver => {\n    const scheduleOutput = Effect.map(g)(Effect.orDie(driver.last()));\n    const process = map(f)(self).channel;\n    const loop = channel.unwrap(Effect.match(core.unit, () => channel.zipRight(channel.unwrap(Effect.map(c => core.flatMap(() => loop)(core.write(Chunk.of(c))))(scheduleOutput)))(process))(driver.next(void 0)));\n    return new StreamImpl(channel.zipRight(loop)(process));\n  })(Schedule.driver(schedule)));\n});\n/**\n * Repeats the value using the provided schedule.\n *\n * @since 1.0.0\n * @category constructors\n */\nexports.repeatWith = repeatWith;\nconst repeatWithSchedule = (value, schedule) => repeatEffectWithSchedule(Effect.succeed(value), schedule);\n/** @internal */\nexports.repeatWithSchedule = repeatWithSchedule;\nconst repeatEffectWithSchedule = (effect, schedule) => flatMap(([a, driver]) => concat(unfoldEffect(a, s => Effect.matchEffect(Effect.succeed, () => Effect.map(nextA => Option.some([nextA, nextA]))(effect))(driver.next(s))))(succeed(a)))(fromEffect(Effect.zip(Schedule.driver(schedule))(effect)));\n/** @internal */\nexports.repeatEffectWithSchedule = repeatEffectWithSchedule;\nconst retry = /*#__PURE__*/(0, _Function.dual)(2, (self, schedule) => unwrap(Effect.map(driver => {\n  const loop = catchAll(error => unwrap(Effect.matchEffect(() => Effect.fail(error), () => Effect.succeed(tap(() => driver.reset())(loop)))(driver.next(error))))(self);\n  return loop;\n})(Schedule.driver(schedule))));\n/** @internal */\nexports.retry = retry;\nconst right = self => rightOrFail(() => Option.none())(mapError(Option.some)(self));\n/** @internal */\nexports.right = right;\nconst rightOrFail = /*#__PURE__*/(0, _Function.dual)(2, (self, error) => mapEffect(Either.match(() => Effect.failSync(error), Effect.succeed))(self));\n/** @internal */\nexports.rightOrFail = rightOrFail;\nconst run = /*#__PURE__*/(0, _Debug.dualWithTrace)(2, trace => (self, sink) => channel.runDrain(channel.pipeToOrFail(sink.channel)(self.channel)).traced(trace));\n/** @internal */\nexports.run = run;\nconst runCollect = /*#__PURE__*/(0, _Debug.methodWithTrace)(trace => self => run(_sink.collectAll())(self).traced(trace));\n/** @internal */\nexports.runCollect = runCollect;\nconst runCount = /*#__PURE__*/(0, _Debug.methodWithTrace)(trace => self => run(_sink.count())(self).traced(trace));\n/** @internal */\nexports.runCount = runCount;\nconst runDrain = /*#__PURE__*/(0, _Debug.methodWithTrace)(trace => self => run(_sink.drain())(self).traced(trace));\n/** @internal */\nexports.runDrain = runDrain;\nconst runFold = /*#__PURE__*/(0, _Debug.dualWithTrace)(3, trace => (self, s, f) => Effect.scoped(runFoldWhileScoped(s, _Function.constTrue, f)(self)).traced(trace));\n/** @internal */\nexports.runFold = runFold;\nconst runFoldEffect = /*#__PURE__*/(0, _Debug.dualWithTrace)(3, trace => (self, s, f) => Effect.scoped(runFoldWhileScopedEffect(s, _Function.constTrue, f)(self)).traced(trace));\n/** @internal */\nexports.runFoldEffect = runFoldEffect;\nconst runFoldScoped = /*#__PURE__*/(0, _Debug.dualWithTrace)(3, trace => (self, s, f) => runFoldWhileScoped(s, _Function.constTrue, f)(self).traced(trace));\n/** @internal */\nexports.runFoldScoped = runFoldScoped;\nconst runFoldScopedEffect = /*#__PURE__*/(0, _Debug.dualWithTrace)(3, trace => (self, s, f) => runFoldWhileScopedEffect(s, _Function.constTrue, f)(self).traced(trace));\n/** @internal */\nexports.runFoldScopedEffect = runFoldScopedEffect;\nconst runFoldWhile = /*#__PURE__*/(0, _Debug.dualWithTrace)(4, trace => (self, s, cont, f) => Effect.scoped(runFoldWhileScoped(s, cont, f)(self)).traced(trace));\n/** @internal */\nexports.runFoldWhile = runFoldWhile;\nconst runFoldWhileEffect = /*#__PURE__*/(0, _Debug.dualWithTrace)(4, trace => (self, s, cont, f) => Effect.scoped(runFoldWhileScopedEffect(s, cont, f)(self)).traced(trace));\n/** @internal */\nexports.runFoldWhileEffect = runFoldWhileEffect;\nconst runFoldWhileScoped = /*#__PURE__*/(0, _Debug.dualWithTrace)(4, trace => (self, s, cont, f) => runScoped(_sink.fold(s, cont, f))(self).traced(trace));\n/** @internal */\nexports.runFoldWhileScoped = runFoldWhileScoped;\nconst runFoldWhileScopedEffect = /*#__PURE__*/(0, _Debug.dualWithTrace)(4, trace => (self, s, cont, f) => runScoped(_sink.foldEffect(s, cont, f))(self).traced(trace));\n/** @internal */\nexports.runFoldWhileScopedEffect = runFoldWhileScopedEffect;\nconst runForEach = /*#__PURE__*/(0, _Debug.dualWithTrace)(2, trace => (self, f) => run(_sink.forEach(f))(self).traced(trace));\n/** @internal */\nexports.runForEach = runForEach;\nconst runForEachChunk = /*#__PURE__*/(0, _Debug.dualWithTrace)(2, trace => (self, f) => run(_sink.forEachChunk(f))(self).traced(trace));\n/** @internal */\nexports.runForEachChunk = runForEachChunk;\nconst runForEachChunkScoped = /*#__PURE__*/(0, _Debug.dualWithTrace)(2, trace => (self, f) => runScoped(_sink.forEachChunk(f))(self).traced(trace));\n/** @internal */\nexports.runForEachChunkScoped = runForEachChunkScoped;\nconst runForEachScoped = /*#__PURE__*/(0, _Debug.dualWithTrace)(2, trace => (self, f) => runScoped(_sink.forEach(f))(self).traced(trace));\n/** @internal */\nexports.runForEachScoped = runForEachScoped;\nconst runForEachWhile = /*#__PURE__*/(0, _Debug.dualWithTrace)(2, trace => (self, f) => run(_sink.forEachWhile(f))(self).traced(trace));\n/** @internal */\nexports.runForEachWhile = runForEachWhile;\nconst runForEachWhileScoped = /*#__PURE__*/(0, _Debug.dualWithTrace)(2, trace => (self, f) => runScoped(_sink.forEachWhile(f))(self).traced(trace));\n/** @internal */\nexports.runForEachWhileScoped = runForEachWhileScoped;\nconst runHead = /*#__PURE__*/(0, _Debug.methodWithTrace)(trace => self => run(_sink.head())(self).traced(trace));\n/** @internal */\nexports.runHead = runHead;\nconst runIntoHub = /*#__PURE__*/(0, _Debug.dualWithTrace)(2, trace => (self, hub) => runIntoQueue(hub)(self).traced(trace));\n/** @internal */\nexports.runIntoHub = runIntoHub;\nconst runIntoHubScoped = /*#__PURE__*/(0, _Debug.dualWithTrace)(2, trace => (self, hub) => runIntoQueueScoped(hub)(self).traced(trace));\n/** @internal */\nexports.runIntoHubScoped = runIntoHubScoped;\nconst runIntoQueue = /*#__PURE__*/(0, _Debug.dualWithTrace)(2, trace => (self, queue) => Effect.scoped(runIntoQueueScoped(queue)(self)).traced(trace));\n/** @internal */\nexports.runIntoQueue = runIntoQueue;\nconst runIntoQueueElementsScoped = /*#__PURE__*/(0, _Debug.dualWithTrace)(2, trace => (self, queue) => {\n  const writer = core.readWithCause(input => core.flatMap(() => writer)(Chunk.reduce(core.unit(), (acc, a) => channel.zipRight(core.write(Exit.succeed(a)))(acc))(input)), cause => core.write(Exit.failCause(Cause.map(Option.some)(cause))), () => core.write(Exit.fail(Option.none())));\n  return Effect.asUnit(channelExecutor.runScoped(channel.drain(channel.mapOutEffect(exit => Queue.offer(queue, exit))(core.pipeTo(writer)(self.channel))))).traced(trace);\n});\n/** @internal */\nexports.runIntoQueueElementsScoped = runIntoQueueElementsScoped;\nconst runIntoQueueScoped = /*#__PURE__*/(0, _Debug.dualWithTrace)(2, trace => (self, queue) => {\n  const writer = core.readWithCause(input => core.flatMap(() => writer)(core.write(_take.chunk(input))), cause => core.write(_take.failCause(cause)), () => core.write(_take.end));\n  return Effect.asUnit(channelExecutor.runScoped(channel.drain(channel.mapOutEffect(take => Queue.offer(queue, take))(core.pipeTo(writer)(self.channel))))).traced(trace);\n});\n/** @internal */\nexports.runIntoQueueScoped = runIntoQueueScoped;\nconst runLast = /*#__PURE__*/(0, _Debug.methodWithTrace)(trace => self => run(_sink.last())(self).traced(trace));\n/** @internal */\nexports.runLast = runLast;\nconst runScoped = /*#__PURE__*/(0, _Debug.dualWithTrace)(2, trace => (self, sink) => channelExecutor.runScoped(channel.drain(channel.pipeToOrFail(sink.channel)(self.channel))).traced(trace));\n/** @internal */\nexports.runScoped = runScoped;\nconst runSum = /*#__PURE__*/(0, _Debug.methodWithTrace)(trace => self => run(_sink.sum())(self).traced(trace));\n/** @internal */\nexports.runSum = runSum;\nconst scan = /*#__PURE__*/(0, _Function.dual)(3, (self, s, f) => scanEffect(s, (s, a) => Effect.succeed(f(s, a)))(self));\n/** @internal */\nexports.scan = scan;\nconst scanReduce = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => scanReduceEffect((a2, a) => Effect.succeed(f(a2, a)))(self));\n/** @internal */\nexports.scanReduce = scanReduce;\nconst scanReduceEffect = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => mapAccumEffect(Option.none(), (option, a) => {\n  switch (option._tag) {\n    case \"None\":\n      {\n        return Effect.succeed([Option.some(a), a]);\n      }\n    case \"Some\":\n      {\n        return Effect.map(b => [Option.some(b), b])(f(option.value, a));\n      }\n  }\n})(self));\n/** @internal */\nexports.scanReduceEffect = scanReduceEffect;\nconst schedule = /*#__PURE__*/(0, _Function.dual)(2, (self, schedule) => collectRight(scheduleEither(schedule)(self)));\n/** @internal */\nexports.schedule = schedule;\nconst scheduleEither = /*#__PURE__*/(0, _Function.dual)(2, (self, schedule) => scheduleWith(schedule, a => Either.right(a), Either.left)(self));\n/** @internal */\nexports.scheduleEither = scheduleEither;\nconst scheduleWith = /*#__PURE__*/(0, _Function.dual)(4, (self, schedule, f, g) => {\n  const loop = (driver, iterator) => {\n    const next = iterator.next();\n    if (next.done) {\n      return core.readWithCause(chunk => loop(driver, chunk[Symbol.iterator]()), core.failCause, core.succeedNow);\n    }\n    return channel.unwrap(Effect.matchEffect(() => Effect.zipLeft(driver.reset())(Effect.map(b => core.flatMap(() => loop(driver, iterator))(core.write(Chunk.make(f(next.value), g(b)))))(Effect.orDie(driver.last()))), () => Effect.succeed(core.flatMap(() => loop(driver, iterator))(core.write(Chunk.of(f(next.value))))))(driver.next(next.value)));\n  };\n  return new StreamImpl(core.flatMap(driver => core.pipeTo(loop(driver, Chunk.empty()[Symbol.iterator]()))(self.channel))(core.fromEffect(Schedule.driver(schedule))));\n});\n/** @internal */\nexports.scheduleWith = scheduleWith;\nconst scanEffect = /*#__PURE__*/(0, _Function.dual)(3, (self, s, f) => new StreamImpl(core.flatMap(() => mapAccumEffect(s, (s, a) => Effect.map(s => [s, s])(f(s, a)))(self).channel)(core.write(Chunk.of(s)))));\n/** @internal */\nexports.scanEffect = scanEffect;\nconst scoped = effect => new StreamImpl(channel.ensuring(channel.scoped(Effect.map(Chunk.of)(effect)), Effect.unit()));\n/** @internal */\nexports.scoped = scoped;\nconst service = tag => serviceWith(tag, _Function.identity);\n/** @internal */\nexports.service = service;\nconst serviceWith = (tag, f) => fromEffect(Effect.serviceWith(tag, f));\n/** @internal */\nexports.serviceWith = serviceWith;\nconst serviceWithEffect = (tag, f) => fromEffect(Effect.serviceWithEffect(tag, f));\n/** @internal */\nexports.serviceWithEffect = serviceWithEffect;\nconst serviceWithStream = (tag, f) => flatMap(service(tag), f);\n/** @internal */\nexports.serviceWithStream = serviceWithStream;\nconst some = self => someOrFail(() => Option.none())(mapError(Option.some)(self));\n/** @internal */\nexports.some = some;\nconst someOrElse = /*#__PURE__*/(0, _Function.dual)(2, (self, fallback) => map(Option.getOrElse(fallback))(self));\n/** @internal */\nexports.someOrElse = someOrElse;\nconst someOrFail = /*#__PURE__*/(0, _Function.dual)(2, (self, error) => mapEffect(Option.match(() => Effect.failSync(error), Effect.succeed))(self));\n/** @internal */\nexports.someOrFail = someOrFail;\nconst sliding = /*#__PURE__*/(0, _Function.dual)(2, (self, chunkSize) => slidingSize(self, chunkSize, 1));\n/** @internal */\nexports.sliding = sliding;\nconst slidingSize = /*#__PURE__*/(0, _Function.dual)(3, (self, chunkSize, stepSize) => {\n  if (chunkSize <= 0 || stepSize <= 0) {\n    return die(Cause.IllegalArgumentException(\"Invalid bounds - `chunkSize` and `stepSize` must be greater than zero\"));\n  }\n  return new StreamImpl(core.suspend(() => {\n    const queue = new _support.RingBuffer(chunkSize);\n    const emitOnStreamEnd = (queueSize, channelEnd) => {\n      if (queueSize < chunkSize) {\n        const items = queue.toChunk();\n        const result = Chunk.isEmpty(items) ? Chunk.empty() : Chunk.of(items);\n        return core.flatMap(() => channelEnd)(core.write(result));\n      }\n      const lastEmitIndex = queueSize - (queueSize - chunkSize) % stepSize;\n      if (lastEmitIndex === queueSize) {\n        return channelEnd;\n      }\n      const leftovers = queueSize - (lastEmitIndex - chunkSize + stepSize);\n      const lastItems = Chunk.takeRight(leftovers)(queue.toChunk());\n      const result = Chunk.isEmpty(lastItems) ? Chunk.empty() : Chunk.of(lastItems);\n      return core.flatMap(() => channelEnd)(core.write(result));\n    };\n    const reader = queueSize => core.readWithCause(input => core.flatMap(() => reader(queueSize + input.length))(core.write(Chunk.filterMap(([element, index]) => {\n      queue.put(element);\n      const currentIndex = queueSize + index + 1;\n      if (currentIndex < chunkSize || (currentIndex - chunkSize) % stepSize > 0) {\n        return Option.none();\n      }\n      return Option.some(queue.toChunk());\n    })(Chunk.zipWithIndex(input)))), cause => emitOnStreamEnd(queueSize, core.failCause(cause)), () => emitOnStreamEnd(queueSize, core.unit()));\n    return core.pipeTo(reader(0))(self.channel);\n  }));\n});\n/** @internal */\nexports.slidingSize = slidingSize;\nconst split = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => {\n  const split = (leftovers, input) => {\n    const [chunk, remaining] = Chunk.splitWhere(predicate)(Chunk.concat(input)(leftovers));\n    if (Chunk.isEmpty(chunk) || Chunk.isEmpty(remaining)) {\n      return loop(Chunk.concat(Chunk.drop(1)(remaining))(chunk));\n    }\n    return core.flatMap(() => split(Chunk.empty(), Chunk.drop(1)(remaining)))(core.write(Chunk.of(chunk)));\n  };\n  const loop = leftovers => core.readWith(input => split(leftovers, input), core.fail, () => {\n    if (Chunk.isEmpty(leftovers)) {\n      return core.unit();\n    }\n    if (Option.isNone(Chunk.findFirst(predicate)(leftovers))) {\n      return channel.zipRight(core.unit())(core.write(Chunk.of(leftovers)));\n    }\n    return channel.zipRight(core.unit())(split(Chunk.empty(), leftovers));\n  });\n  return new StreamImpl(core.pipeTo(loop(Chunk.empty()))(self.channel));\n});\n/** @internal */\nexports.split = split;\nconst splitOnChunk = /*#__PURE__*/(0, _Function.dual)(2, (self, delimiter) => {\n  const next = (leftover, delimiterIndex) => core.readWithCause(inputChunk => {\n    let buffer;\n    const [carry, delimiterCursor] = Chunk.reduce([Option.getOrElse(() => Chunk.empty())(leftover), delimiterIndex], ([carry, delimiterCursor], a) => {\n      const concatenated = Chunk.append(a)(carry);\n      if (delimiterCursor < delimiter.length && Equal.equals(a, Chunk.unsafeGet(delimiterCursor)(delimiter))) {\n        if (delimiterCursor + 1 === delimiter.length) {\n          if (buffer === undefined) {\n            buffer = [];\n          }\n          buffer.push(Chunk.take(concatenated.length - delimiter.length)(concatenated));\n          return [Chunk.empty(), 0];\n        }\n        return [concatenated, delimiterCursor + 1];\n      }\n      return [concatenated, Equal.equals(a, Chunk.unsafeGet(0)(delimiter)) ? 1 : 0];\n    })(inputChunk);\n    const output = buffer === undefined ? Chunk.empty() : Chunk.unsafeFromArray(buffer);\n    return core.flatMap(() => next(Chunk.isNonEmpty(carry) ? Option.some(carry) : Option.none(), delimiterCursor))(core.write(output));\n  }, cause => Option.match(() => core.failCause(cause), chunk => channel.zipRight(core.failCause(cause))(core.write(Chunk.of(chunk))))(leftover), done => Option.match(() => core.succeed(done), chunk => channel.zipRight(core.succeed(done))(core.write(Chunk.of(chunk))))(leftover));\n  return new StreamImpl(core.pipeTo(next(Option.none(), 0))(self.channel));\n});\n/** @internal */\nexports.splitOnChunk = splitOnChunk;\nconst succeed = value => fromChunk(Chunk.of(value));\n/** @internal */\nexports.succeed = succeed;\nconst sync = evaluate => suspend(() => fromChunk(Chunk.of(evaluate())));\n/** @internal */\nexports.sync = sync;\nconst suspend = stream => new StreamImpl(core.suspend(() => stream().channel));\n/** @internal */\nexports.suspend = suspend;\nconst take = /*#__PURE__*/(0, _Function.dual)(2, (self, n) => {\n  if (!Number.isInteger(n)) {\n    return die(Cause.IllegalArgumentException(`${n} must be an integer`));\n  }\n  const loop = n => core.readWith(input => {\n    const taken = Chunk.take(Math.min(n, Number.POSITIVE_INFINITY))(input);\n    const leftover = Math.max(0, n - taken.length);\n    const more = leftover > 0;\n    if (more) {\n      return core.flatMap(() => loop(leftover))(core.write(taken));\n    }\n    return core.write(taken);\n  }, core.fail, core.succeed);\n  return new StreamImpl(channel.pipeToOrFail(0 < n ? loop(n) : core.unit())(self.channel));\n});\n/** @internal */\nexports.take = take;\nconst takeRight = /*#__PURE__*/(0, _Function.dual)(2, (self, n) => {\n  if (n <= 0) {\n    return empty;\n  }\n  return new StreamImpl(channel.unwrap(Effect.map(queue => {\n    const reader = core.readWith(input => {\n      for (const element of input) {\n        queue.put(element);\n      }\n      return reader;\n    }, core.fail, () => channel.zipRight(core.unit())(core.write(queue.toChunk())));\n    return core.pipeTo(reader)(self.channel);\n  })(Effect.succeed(new _support.RingBuffer(n)))));\n});\n/** @internal */\nexports.takeRight = takeRight;\nconst takeUntil = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => {\n  const loop = core.readWith(input => {\n    const taken = Chunk.takeWhile(a => !predicate(a))(input);\n    const last = Chunk.take(1)(Chunk.drop(taken.length)(input));\n    if (Chunk.isEmpty(last)) {\n      return core.flatMap(() => loop)(core.write(taken));\n    }\n    return core.write(Chunk.concat(last)(taken));\n  }, core.fail, core.succeed);\n  return new StreamImpl(channel.pipeToOrFail(loop)(self.channel));\n});\n/** @internal */\nexports.takeUntil = takeUntil;\nconst takeUntilEffect = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => {\n  const loop = iterator => {\n    const next = iterator.next();\n    if (next.done) {\n      return core.readWithCause(elem => loop(elem[Symbol.iterator]()), core.failCause, core.succeed);\n    }\n    return channel.unwrap(Effect.map(bool => bool ? core.write(Chunk.of(next.value)) : core.flatMap(() => loop(iterator))(core.write(Chunk.of(next.value))))(predicate(next.value)));\n  };\n  return new StreamImpl(core.pipeTo(loop(Chunk.empty()[Symbol.iterator]()))(self.channel));\n});\n/** @internal */\nexports.takeUntilEffect = takeUntilEffect;\nconst takeWhile = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => {\n  const loop = core.readWith(input => {\n    const taken = Chunk.takeWhile(predicate)(input);\n    const more = taken.length === input.length;\n    if (more) {\n      return core.flatMap(() => loop)(core.write(taken));\n    }\n    return core.write(taken);\n  }, core.fail, core.succeed);\n  return new StreamImpl(channel.pipeToOrFail(loop)(self.channel));\n});\n/** @internal */\nexports.takeWhile = takeWhile;\nconst tap = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => mapEffect(self, a => Effect.as(f(a), a)));\n/** @internal */\nexports.tap = tap;\nconst tapError = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => catchAll(error => fromEffect(Effect.zipRight(Effect.fail(error))(f(error))))(self));\n/** @internal */\nexports.tapError = tapError;\nconst tapErrorCause = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => catchAllCause(cause => fromEffect(Effect.zipRight(Effect.failCause(cause))(f(cause))))(self));\n/** @internal */\nexports.tapErrorCause = tapErrorCause;\nconst tapSink = /*#__PURE__*/(0, _Function.dual)(2, (self, sink) => flatMap(queue => {\n  const right = flattenTake(fromQueue(queue, 1));\n  const loop = core.readWithCause(chunk => core.flatMap(() => loop)(channel.zipRight(core.write(chunk))(core.fromEffect(Queue.offer(queue, _take.chunk(chunk))))), cause => core.fromEffect(Queue.offer(queue, _take.failCause(cause))), () => core.fromEffect(Queue.offer(queue, _take.end)));\n  return mergeHaltStrategy(execute(run(sink)(right)), haltStrategy.Both)(new StreamImpl(core.pipeTo(loop)(self.channel)));\n})(fromEffect(Queue.bounded(1))));\n/** @internal */\nexports.tapSink = tapSink;\nconst throttleEnforce = /*#__PURE__*/(0, _Function.dual)(4, (self, costFn, units, duration) => throttleEnforceBurst(self, costFn, units, duration, 0));\n/** @internal */\nexports.throttleEnforce = throttleEnforce;\nconst throttleEnforceBurst = /*#__PURE__*/(0, _Function.dual)(5, (self, costFn, units, duration, burst) => throttleEnforceEffectBurst(self, chunk => Effect.succeed(costFn(chunk)), units, duration, burst));\n/** @internal */\nexports.throttleEnforceBurst = throttleEnforceBurst;\nconst throttleEnforceEffect = /*#__PURE__*/(0, _Function.dual)(4, (self, costFn, units, duration) => throttleEnforceEffectBurst(self, costFn, units, duration, 0));\n/** @internal */\nexports.throttleEnforceEffect = throttleEnforceEffect;\nconst throttleEnforceEffectBurst = /*#__PURE__*/(0, _Function.dual)(5, (self, costFn, units, duration, burst) => {\n  const loop = (tokens, timestampMillis) => core.readWithCause(input => channel.unwrap(Effect.map(([weight, currentTimeMillis]) => {\n    const elapsed = currentTimeMillis - timestampMillis;\n    const cycles = elapsed / duration.millis;\n    const sum = tokens + cycles * units;\n    const max = units + burst < 0 ? Number.POSITIVE_INFINITY : units + burst;\n    const available = sum < 0 ? max : Math.min(sum, max);\n    if (weight <= available) {\n      return core.flatMap(() => loop(available - weight, currentTimeMillis))(core.write(input));\n    }\n    return loop(available, currentTimeMillis);\n  })(Effect.zip(Clock.currentTimeMillis())(costFn(input)))), core.failCause, core.unit);\n  const throttled = channel.unwrap(Effect.map(currentTimeMillis => loop(units, currentTimeMillis))(Clock.currentTimeMillis()));\n  return new StreamImpl(channel.pipeToOrFail(throttled)(self.channel));\n});\n/** @internal */\nexports.throttleEnforceEffectBurst = throttleEnforceEffectBurst;\nconst throttleShape = /*#__PURE__*/(0, _Function.dual)(4, (self, costFn, units, duration) => throttleShapeBurst(self, costFn, units, duration, 0));\n/** @internal */\nexports.throttleShape = throttleShape;\nconst throttleShapeBurst = /*#__PURE__*/(0, _Function.dual)(5, (self, costFn, units, duration, burst) => throttleShapeEffectBurst(self, chunk => Effect.succeed(costFn(chunk)), units, duration, burst));\n/** @internal */\nexports.throttleShapeBurst = throttleShapeBurst;\nconst throttleShapeEffect = /*#__PURE__*/(0, _Function.dual)(4, (self, costFn, units, duration) => throttleShapeEffectBurst(self, costFn, units, duration, 0));\n/** @internal */\nexports.throttleShapeEffect = throttleShapeEffect;\nconst throttleShapeEffectBurst = /*#__PURE__*/(0, _Function.dual)(5, (self, costFn, units, duration, burst) => {\n  const loop = (tokens, timestampMillis) => core.readWithCause(input => channel.unwrap(Effect.map(([weight, currentTimeMillis]) => {\n    const elapsed = currentTimeMillis - timestampMillis;\n    const cycles = elapsed / duration.millis;\n    const sum = tokens + cycles * units;\n    const max = units + burst < 0 ? Number.POSITIVE_INFINITY : units + burst;\n    const available = sum < 0 ? max : Math.min(sum, max);\n    const remaining = available - weight;\n    const waitCycles = remaining >= 0 ? 0 : -remaining / units;\n    const delay = Duration.millis(Math.max(0, waitCycles * duration.millis));\n    if (Duration.greaterThan(Duration.zero)(delay)) {\n      return core.flatMap(() => loop(remaining, currentTimeMillis))(channel.zipRight(core.write(input))(core.fromEffect(Clock.sleep(delay))));\n    }\n    return core.flatMap(() => loop(remaining, currentTimeMillis))(core.write(input));\n  })(Effect.zip(Clock.currentTimeMillis())(costFn(input)))), core.failCause, core.unit);\n  const throttled = channel.unwrap(Effect.map(currentTimeMillis => loop(units, currentTimeMillis))(Clock.currentTimeMillis()));\n  return new StreamImpl(channel.pipeToOrFail(throttled)(self.channel));\n});\n/** @internal */\nexports.throttleShapeEffectBurst = throttleShapeEffectBurst;\nconst tick = interval => repeatWithSchedule(void 0, Schedule.spaced(interval));\n/** @internal */\nexports.tick = tick;\nconst timeout = /*#__PURE__*/(0, _Function.dual)(2, (self, duration) => fromPull(Effect.map(Effect.timeoutFail(() => Option.none(), duration))(toPull(self))));\n/** @internal */\nexports.timeout = timeout;\nconst timeoutFail = /*#__PURE__*/(0, _Function.dual)(3, (self, error, duration) => timeoutTo(duration, failSync(error))(self));\n/** @internal */\nexports.timeoutFail = timeoutFail;\nconst timeoutFailCause = /*#__PURE__*/(0, _Function.dual)(3, (self, cause, duration) => fromPull(Effect.map(Effect.timeoutFailCause(() => Cause.map(Option.some)(cause()), duration))(toPull(self))));\n/** @internal */\nexports.timeoutFailCause = timeoutFailCause;\nconst timeoutTo = /*#__PURE__*/(0, _Function.dual)(3, (self, duration, that) => {\n  const StreamTimeout = Cause.RuntimeException(\"Stream Timeout\");\n  return catchSomeCause(annotatedCause => {\n    const cause = Cause.unannotate(annotatedCause);\n    return Cause.isDieType(cause) && Cause.isRuntimeException(cause.defect) && cause.defect.message !== undefined && cause.defect.message === \"Stream Timeout\" ? Option.some(that) : Option.none();\n  })(timeoutFailCause(() => Cause.die(StreamTimeout), duration)(self));\n});\n/** @internal */\nexports.timeoutTo = timeoutTo;\nconst toHub = /*#__PURE__*/(0, _Debug.dualWithTrace)(2, trace => (self, capacity) => Effect.tap(hub => Effect.forkScoped(runIntoHubScoped(hub)(self)))(Effect.acquireRelease(Hub.bounded(capacity), hub => Hub.shutdown(hub))).traced(trace));\n/** @internal */\nexports.toHub = toHub;\nconst toPull = /*#__PURE__*/(0, _Debug.methodWithTrace)(trace => self => Effect.map(pull => Effect.flatMap(Either.match(() => Effect.fail(Option.none()), Effect.succeed))(Effect.mapError(Option.some)(pull)))(channel.toPull(self.channel)).traced(trace));\n/** @internal */\nexports.toPull = toPull;\nconst toQueue = /*#__PURE__*/(0, _Debug.methodWithTrace)(trace => self => toQueueCapacity(self, 2).traced(trace));\n/** @internal */\nexports.toQueue = toQueue;\nconst toQueueCapacity = /*#__PURE__*/(0, _Debug.dualWithTrace)(2, trace => (self, capacity) => Effect.tap(queue => Effect.forkScoped(runIntoQueueScoped(queue)(self)))(Effect.acquireRelease(Queue.bounded(capacity), queue => Queue.shutdown(queue))).traced(trace));\n/** @internal */\nexports.toQueueCapacity = toQueueCapacity;\nconst toQueueDropping = /*#__PURE__*/(0, _Debug.methodWithTrace)(trace => self => toQueueDroppingCapacity(self, 2).traced(trace));\n/** @internal */\nexports.toQueueDropping = toQueueDropping;\nconst toQueueDroppingCapacity = /*#__PURE__*/(0, _Debug.dualWithTrace)(2, trace => (self, capacity) => Effect.tap(queue => Effect.forkScoped(runIntoQueueScoped(queue)(self)))(Effect.acquireRelease(Queue.dropping(capacity), queue => Queue.shutdown(queue))).traced(trace));\n/** @internal */\nexports.toQueueDroppingCapacity = toQueueDroppingCapacity;\nconst toQueueOfElements = /*#__PURE__*/(0, _Debug.methodWithTrace)(trace => self => toQueueOfElementsCapacity(self, 2).traced(trace));\n/** @internal */\nexports.toQueueOfElements = toQueueOfElements;\nconst toQueueOfElementsCapacity = /*#__PURE__*/(0, _Debug.dualWithTrace)(2, trace => (self, capacity) => Effect.tap(queue => Effect.forkScoped(runIntoQueueElementsScoped(queue)(self)))(Effect.acquireRelease(Queue.bounded(capacity), queue => Queue.shutdown(queue))).traced(trace));\n/** @internal */\nexports.toQueueOfElementsCapacity = toQueueOfElementsCapacity;\nconst toQueueSliding = /*#__PURE__*/(0, _Debug.methodWithTrace)(trace => self => toQueueSlidingCapacity(self, 2).traced(trace));\n/** @internal */\nexports.toQueueSliding = toQueueSliding;\nconst toQueueSlidingCapacity = /*#__PURE__*/(0, _Debug.dualWithTrace)(2, trace => (self, capacity) => Effect.tap(queue => Effect.forkScoped(runIntoQueueScoped(queue)(self)))(Effect.acquireRelease(Queue.sliding(capacity), queue => Queue.shutdown(queue))).traced(trace));\n/** @internal */\nexports.toQueueSlidingCapacity = toQueueSlidingCapacity;\nconst toQueueUnbounded = /*#__PURE__*/(0, _Debug.methodWithTrace)(trace => self => Effect.tap(queue => Effect.forkScoped(runIntoQueueScoped(queue)(self)))(Effect.acquireRelease(Queue.unbounded(), queue => Queue.shutdown(queue))).traced(trace));\n/** @internal */\nexports.toQueueUnbounded = toQueueUnbounded;\nconst transduce = /*#__PURE__*/(0, _Function.dual)(2, (self, sink) => {\n  const newChannel = core.suspend(() => {\n    const leftovers = {\n      ref: Chunk.empty()\n    };\n    const upstreamDone = {\n      ref: false\n    };\n    const buffer = core.suspend(() => {\n      const leftover = leftovers.ref;\n      if (Chunk.isEmpty(leftover)) {\n        return core.readWith(input => core.flatMap(() => buffer)(core.write(input)), core.fail, core.succeedNow);\n      }\n      leftovers.ref = Chunk.empty();\n      return core.flatMap(() => buffer)(channel.writeChunk(leftover));\n    });\n    const concatAndGet = chunk => {\n      const leftover = leftovers.ref;\n      const concatenated = Chunk.concat(Chunk.filter(chunk => chunk.length !== 0)(chunk))(leftover);\n      leftovers.ref = concatenated;\n      return concatenated;\n    };\n    const upstreamMarker = core.readWith(input => core.flatMap(() => upstreamMarker)(core.write(input)), core.fail, done => channel.zipRight(core.succeedNow(done))(core.sync(() => {\n      upstreamDone.ref = true;\n    })));\n    const transducer = core.flatMap(([leftover, z]) => core.flatMap(([done, newLeftovers]) => {\n      const nextChannel = done && Chunk.isEmpty(newLeftovers) ? core.unit() : transducer;\n      return core.flatMap(() => nextChannel)(core.write(Chunk.of(z)));\n    })(core.succeed([upstreamDone.ref, concatAndGet(leftover)])))(core.collectElements(sink.channel));\n    return channel.pipeToOrFail(transducer)(core.pipeTo(buffer)(core.pipeTo(upstreamMarker)(self.channel)));\n  });\n  return new StreamImpl(newChannel);\n});\n/** @internal */\nexports.transduce = transduce;\nconst unfold = (s, f) => unfoldChunk(s, s => Option.map(([a, s]) => [Chunk.of(a), s])(f(s)));\n/** @internal */\nexports.unfold = unfold;\nconst unfoldChunk = (s, f) => {\n  const loop = s => Option.match(core.unit, ([chunk, s]) => core.flatMap(() => loop(s))(core.write(chunk)))(f(s));\n  return new StreamImpl(core.suspend(() => loop(s)));\n};\n/** @internal */\nexports.unfoldChunk = unfoldChunk;\nconst unfoldChunkEffect = (s, f) => suspend(() => {\n  const loop = s => channel.unwrap(Effect.map(Option.match(core.unit, ([chunk, s]) => core.flatMap(() => loop(s))(core.write(chunk))))(f(s)));\n  return new StreamImpl(loop(s));\n});\n/** @internal */\nexports.unfoldChunkEffect = unfoldChunkEffect;\nconst unfoldEffect = (s, f) => unfoldChunkEffect(s, s => Effect.map(Option.map(([a, s]) => [Chunk.of(a), s]))(f(s)));\n/** @internal */\nexports.unfoldEffect = unfoldEffect;\nconst unit = () => succeed(void 0);\n/** @internal */\nexports.unit = unit;\nconst unwrap = effect => flatten(fromEffect(effect));\n/** @internal */\nexports.unwrap = unwrap;\nconst unwrapScoped = effect => flatten(scoped(effect));\n/** @internal */\nexports.unwrapScoped = unwrapScoped;\nconst updateService = /*#__PURE__*/(0, _Function.dual)(3, (self, tag, f) => contramapContext(context => Context.add(tag, f(Context.unsafeGet(tag)(context)))(context))(self));\n/** @internal */\nexports.updateService = updateService;\nconst when = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => whenEffect(Effect.sync(predicate))(self));\n/** @internal */\nexports.when = when;\nconst whenCase = (evaluate, pf) => whenCaseEffect(pf)(Effect.sync(evaluate));\n/** @internal */\nexports.whenCase = whenCase;\nconst whenCaseEffect = /*#__PURE__*/(0, _Function.dual)(2, (self, pf) => flatMap(a => Option.getOrElse(() => empty)(pf(a)))(fromEffect(self)));\n/** @internal */\nexports.whenCaseEffect = whenCaseEffect;\nconst whenEffect = /*#__PURE__*/(0, _Function.dual)(2, (self, effect) => flatMap(bool => bool ? self : empty)(fromEffect(effect)));\n/** @internal */\nexports.whenEffect = whenEffect;\nconst zip = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => zipWith(that, (a, a2) => [a, a2])(self));\n/** @internal */\nexports.zip = zip;\nconst zipFlatten = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => zipWith(that, (a, a2) => [...a, a2])(self));\n/** @internal */\nexports.zipFlatten = zipFlatten;\nconst zipAll = /*#__PURE__*/(0, _Function.dual)(4, (self, that, defaultLeft, defaultRight) => zipAllWith(that, a => [a, defaultRight], a2 => [defaultLeft, a2], (a, a2) => [a, a2])(self));\n/** @internal */\nexports.zipAll = zipAll;\nconst zipAllLeft = /*#__PURE__*/(0, _Function.dual)(3, (self, that, defaultLeft) => zipAllWith(that, _Function.identity, () => defaultLeft, a => a)(self));\n/** @internal */\nexports.zipAllLeft = zipAllLeft;\nconst zipAllRight = /*#__PURE__*/(0, _Function.dual)(3, (self, that, defaultRight) => zipAllWith(that, () => defaultRight, _Function.identity, (_, a2) => a2)(self));\n/** @internal */\nexports.zipAllRight = zipAllRight;\nconst zipAllSortedByKey = /*#__PURE__*/(0, _Function.dual)(5, (self, that, defaultLeft, defaultRight, order) => zipAllSortedByKeyWith(self, that, a => [a, defaultRight], a2 => [defaultLeft, a2], (a, a2) => [a, a2], order));\n/** @internal */\nexports.zipAllSortedByKey = zipAllSortedByKey;\nconst zipAllSortedByKeyLeft = /*#__PURE__*/(0, _Function.dual)(4, (self, that, defaultLeft, order) => zipAllSortedByKeyWith(self, that, _Function.identity, () => defaultLeft, a => a, order));\n/** @internal */\nexports.zipAllSortedByKeyLeft = zipAllSortedByKeyLeft;\nconst zipAllSortedByKeyRight = /*#__PURE__*/(0, _Function.dual)(4, (self, that, defaultRight, order) => zipAllSortedByKeyWith(self, that, () => defaultRight, _Function.identity, (_, a2) => a2, order));\n/** @internal */\nexports.zipAllSortedByKeyRight = zipAllSortedByKeyRight;\nconst zipAllSortedByKeyWith = /*#__PURE__*/(0, _Function.dual)(6, (self, that, left, right, both, order) => {\n  const pull = (state, pullLeft, pullRight) => {\n    switch (state._tag) {\n      case ZipAllState.OP_DRAIN_LEFT:\n        {\n          return Effect.match(Exit.fail, leftChunk => Exit.succeed([Chunk.map(([k, a]) => [k, left(a)])(leftChunk), ZipAllState.DrainLeft]))(pullLeft);\n        }\n      case ZipAllState.OP_DRAIN_RIGHT:\n        {\n          return Effect.match(Exit.fail, rightChunk => Exit.succeed([Chunk.map(([k, a2]) => [k, right(a2)])(rightChunk), ZipAllState.DrainRight]))(pullRight);\n        }\n      case ZipAllState.OP_PULL_BOTH:\n        {\n          return Effect.matchEffect(error => Effect.succeed(Exit.fail(Option.some(error))), ([leftOption, rightOption]) => {\n            if (Option.isSome(leftOption) && Option.isSome(rightOption)) {\n              if (Chunk.isEmpty(leftOption.value) && Chunk.isEmpty(rightOption.value)) {\n                return pull(ZipAllState.PullBoth, pullLeft, pullRight);\n              }\n              if (Chunk.isEmpty(leftOption.value)) {\n                return pull(ZipAllState.PullLeft(rightOption.value), pullLeft, pullRight);\n              }\n              if (Chunk.isEmpty(rightOption.value)) {\n                return pull(ZipAllState.PullRight(leftOption.value), pullLeft, pullRight);\n              }\n              return Effect.succeed(Exit.succeed(merge(leftOption.value, rightOption.value)));\n            }\n            if (Option.isSome(leftOption) && Option.isNone(rightOption)) {\n              if (Chunk.isEmpty(leftOption.value)) {\n                return pull(ZipAllState.DrainLeft, pullLeft, pullRight);\n              }\n              return Effect.succeed(Exit.succeed([Chunk.map(([k, a]) => [k, left(a)])(leftOption.value), ZipAllState.DrainLeft]));\n            }\n            if (Option.isNone(leftOption) && Option.isSome(rightOption)) {\n              if (Chunk.isEmpty(rightOption.value)) {\n                return pull(ZipAllState.DrainRight, pullLeft, pullRight);\n              }\n              return Effect.succeed(Exit.succeed([Chunk.map(([k, a2]) => [k, right(a2)])(rightOption.value), ZipAllState.DrainRight]));\n            }\n            return Effect.succeed(Exit.fail(Option.none()));\n          })(Effect.zipPar(Effect.unsome(pullRight))(Effect.unsome(pullLeft)));\n        }\n      case ZipAllState.OP_PULL_LEFT:\n        {\n          return Effect.matchEffect(Option.match(() => Effect.succeed(Exit.succeed([Chunk.map(([k, a2]) => [k, right(a2)])(state.rightChunk), ZipAllState.DrainRight])), error => Effect.succeed(Exit.fail(Option.some(error)))), leftChunk => Chunk.isEmpty(leftChunk) ? pull(ZipAllState.PullLeft(state.rightChunk), pullLeft, pullRight) : Effect.succeed(Exit.succeed(merge(leftChunk, state.rightChunk))))(pullLeft);\n        }\n      case ZipAllState.OP_PULL_RIGHT:\n        {\n          return Effect.matchEffect(Option.match(() => Effect.succeed(Exit.succeed([Chunk.map(([k, a]) => [k, left(a)])(state.leftChunk), ZipAllState.DrainLeft])), error => Effect.succeed(Exit.fail(Option.some(error)))), rightChunk => Chunk.isEmpty(rightChunk) ? pull(ZipAllState.PullRight(state.leftChunk), pullLeft, pullRight) : Effect.succeed(Exit.succeed(merge(state.leftChunk, rightChunk))))(pullRight);\n        }\n    }\n  };\n  const merge = (leftChunk, rightChunk) => {\n    const hasNext = (chunk, index) => index < chunk.length - 1;\n    const builder = [];\n    let state = undefined;\n    let leftIndex = 0;\n    let rightIndex = 0;\n    let leftTuple = Chunk.unsafeGet(leftIndex)(leftChunk);\n    let rightTuple = Chunk.unsafeGet(rightIndex)(rightChunk);\n    let k1 = leftTuple[0];\n    let a = leftTuple[1];\n    let k2 = rightTuple[0];\n    let a2 = rightTuple[1];\n    let loop = true;\n    while (loop) {\n      const compare = order.compare(k1, k2);\n      if (compare === 0) {\n        builder.push([k1, both(a, a2)]);\n        if (hasNext(leftChunk, leftIndex) && hasNext(rightChunk, rightIndex)) {\n          leftIndex = leftIndex + 1;\n          rightIndex = rightIndex + 1;\n          leftTuple = Chunk.unsafeGet(leftIndex)(leftChunk);\n          rightTuple = Chunk.unsafeGet(rightIndex)(rightChunk);\n          k1 = leftTuple[0];\n          a = leftTuple[1];\n          k2 = rightTuple[0];\n          a2 = rightTuple[1];\n        } else if (hasNext(leftChunk, leftIndex)) {\n          state = ZipAllState.PullRight(Chunk.drop(leftIndex + 1)(leftChunk));\n          loop = false;\n        } else if (hasNext(rightChunk, rightIndex)) {\n          state = ZipAllState.PullLeft(Chunk.drop(rightIndex + 1)(rightChunk));\n          loop = false;\n        } else {\n          state = ZipAllState.PullBoth;\n          loop = false;\n        }\n      } else if (compare < 0) {\n        builder.push([k1, left(a)]);\n        if (hasNext(leftChunk, leftIndex)) {\n          leftIndex = leftIndex + 1;\n          leftTuple = Chunk.unsafeGet(leftIndex)(leftChunk);\n          k1 = leftTuple[0];\n          a = leftTuple[1];\n        } else {\n          const rightBuilder = [];\n          rightBuilder.push(rightTuple);\n          while (hasNext(rightChunk, rightIndex)) {\n            rightIndex = rightIndex + 1;\n            rightTuple = Chunk.unsafeGet(rightIndex)(rightChunk);\n            rightBuilder.push(rightTuple);\n          }\n          state = ZipAllState.PullLeft(Chunk.unsafeFromArray(rightBuilder));\n          loop = false;\n        }\n      } else {\n        builder.push([k2, right(a2)]);\n        if (hasNext(rightChunk, rightIndex)) {\n          rightIndex = rightIndex + 1;\n          rightTuple = Chunk.unsafeGet(rightIndex)(rightChunk);\n          k2 = rightTuple[0];\n          a2 = rightTuple[1];\n        } else {\n          const leftBuilder = [];\n          leftBuilder.push(leftTuple);\n          while (hasNext(leftChunk, leftIndex)) {\n            leftIndex = leftIndex + 1;\n            leftTuple = Chunk.unsafeGet(leftIndex)(leftChunk);\n            leftBuilder.push(leftTuple);\n          }\n          state = ZipAllState.PullRight(Chunk.unsafeFromArray(leftBuilder));\n          loop = false;\n        }\n      }\n    }\n    return [Chunk.unsafeFromArray(builder), state];\n  };\n  return combineChunks(that, ZipAllState.PullBoth, pull)(self);\n});\n/** @internal */\nexports.zipAllSortedByKeyWith = zipAllSortedByKeyWith;\nconst zipAllWith = /*#__PURE__*/(0, _Function.dual)(5, (self, that, left, right, both) => {\n  const pull = (state, pullLeft, pullRight) => {\n    switch (state._tag) {\n      case ZipAllState.OP_DRAIN_LEFT:\n        {\n          return Effect.matchEffect(error => Effect.succeed(Exit.fail(error)), leftChunk => Effect.succeed(Exit.succeed([Chunk.map(left)(leftChunk), ZipAllState.DrainLeft])))(pullLeft);\n        }\n      case ZipAllState.OP_DRAIN_RIGHT:\n        {\n          return Effect.matchEffect(error => Effect.succeed(Exit.fail(error)), rightChunk => Effect.succeed(Exit.succeed([Chunk.map(right)(rightChunk), ZipAllState.DrainRight])))(pullRight);\n        }\n      case ZipAllState.OP_PULL_BOTH:\n        {\n          return Effect.matchEffect(error => Effect.succeed(Exit.fail(Option.some(error))), ([leftOption, rightOption]) => {\n            if (Option.isSome(leftOption) && Option.isSome(rightOption)) {\n              if (Chunk.isEmpty(leftOption.value) && Chunk.isEmpty(rightOption.value)) {\n                return pull(ZipAllState.PullBoth, pullLeft, pullRight);\n              }\n              if (Chunk.isEmpty(leftOption.value)) {\n                return pull(ZipAllState.PullLeft(rightOption.value), pullLeft, pullRight);\n              }\n              if (Chunk.isEmpty(rightOption.value)) {\n                return pull(ZipAllState.PullRight(leftOption.value), pullLeft, pullRight);\n              }\n              return Effect.succeed(Exit.succeed(zip(leftOption.value, rightOption.value, both)));\n            }\n            if (Option.isSome(leftOption) && Option.isNone(rightOption)) {\n              return Effect.succeed(Exit.succeed([Chunk.map(left)(leftOption.value), ZipAllState.DrainLeft]));\n            }\n            if (Option.isNone(leftOption) && Option.isSome(rightOption)) {\n              return Effect.succeed(Exit.succeed([Chunk.map(right)(rightOption.value), ZipAllState.DrainRight]));\n            }\n            return Effect.succeed(Exit.fail(Option.none()));\n          })(Effect.zipPar(Effect.unsome(pullRight))(Effect.unsome(pullLeft)));\n        }\n      case ZipAllState.OP_PULL_LEFT:\n        {\n          return Effect.matchEffect(Option.match(() => Effect.succeed(Exit.succeed([Chunk.map(right)(state.rightChunk), ZipAllState.DrainRight])), error => Effect.succeed(Exit.fail(Option.some(error)))), leftChunk => {\n            if (Chunk.isEmpty(leftChunk)) {\n              return pull(ZipAllState.PullLeft(state.rightChunk), pullLeft, pullRight);\n            }\n            if (Chunk.isEmpty(state.rightChunk)) {\n              return pull(ZipAllState.PullRight(leftChunk), pullLeft, pullRight);\n            }\n            return Effect.succeed(Exit.succeed(zip(leftChunk, state.rightChunk, both)));\n          })(pullLeft);\n        }\n      case ZipAllState.OP_PULL_RIGHT:\n        {\n          return Effect.matchEffect(Option.match(() => Effect.succeed(Exit.succeed([Chunk.map(left)(state.leftChunk), ZipAllState.DrainLeft])), error => Effect.succeed(Exit.fail(Option.some(error)))), rightChunk => {\n            if (Chunk.isEmpty(rightChunk)) {\n              return pull(ZipAllState.PullRight(state.leftChunk), pullLeft, pullRight);\n            }\n            if (Chunk.isEmpty(state.leftChunk)) {\n              return pull(ZipAllState.PullLeft(rightChunk), pullLeft, pullRight);\n            }\n            return Effect.succeed(Exit.succeed(zip(state.leftChunk, rightChunk, both)));\n          })(pullRight);\n        }\n    }\n  };\n  const zip = (leftChunk, rightChunk, f) => {\n    const [output, either] = zipChunks(leftChunk, rightChunk, f);\n    switch (either._tag) {\n      case \"Left\":\n        {\n          if (Chunk.isEmpty(either.left)) {\n            return [output, ZipAllState.PullBoth];\n          }\n          return [output, ZipAllState.PullRight(either.left)];\n        }\n      case \"Right\":\n        {\n          if (Chunk.isEmpty(either.right)) {\n            return [output, ZipAllState.PullBoth];\n          }\n          return [output, ZipAllState.PullLeft(either.right)];\n        }\n    }\n  };\n  return combineChunks(that, ZipAllState.PullBoth, pull)(self);\n});\n/** @internal */\nexports.zipAllWith = zipAllWith;\nconst zipLatest = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => zipLatestWith(that, (a, a2) => [a, a2])(self));\n/** @internal */\nexports.zipLatest = zipLatest;\nconst zipLatestWith = /*#__PURE__*/(0, _Function.dual)(3, (self, that, f) => {\n  const pullNonEmpty = pull => Effect.flatMap(chunk => Chunk.isEmpty(chunk) ? pullNonEmpty(pull) : Effect.succeed(chunk))(pull);\n  return fromPull(Effect.flatMap(([left, right]) => toPull(flatMap(([l, r, leftFirst]) => flatMap(latest => concat(flatMap(fromChunk)(mapEffect(Either.match(leftChunk => Ref.modify(latest, ([_, rightLatest]) => [Chunk.map(a => f(a, rightLatest))(leftChunk), [Chunk.unsafeLast(leftChunk), rightLatest]]), rightChunk => Ref.modify(latest, ([leftLatest, _]) => [Chunk.map(a2 => f(leftLatest, a2))(rightChunk), [leftLatest, Chunk.unsafeLast(rightChunk)]])))(mergeEither(repeatEffectOption(right))(repeatEffectOption(left)))))(fromChunk(leftFirst ? Chunk.map(a2 => f(Chunk.unsafeLast(l), a2))(r) : Chunk.map(a => f(a, Chunk.unsafeLast(r)))(l))))(fromEffect(Ref.make([Chunk.unsafeLast(l), Chunk.unsafeLast(r)]))))(fromEffectOption(Effect.raceWith(right, (leftDone, rightFiber) => Effect.zipWith(Fiber.join(rightFiber), (l, r) => [l, r, true])(Effect.done(leftDone)), (rightDone, leftFiber) => Effect.zipWith(Fiber.join(leftFiber), (l, r) => [r, l, false])(Effect.done(rightDone)))(left)))))(Effect.zip(Effect.map(pullNonEmpty)(toPull(that)))(Effect.map(pullNonEmpty)(toPull(self)))));\n});\n/** @internal */\nexports.zipLatestWith = zipLatestWith;\nconst zipLeft = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => zipWithChunks(that, (left, right) => {\n  if (left.length > right.length) {\n    return [Chunk.take(right.length)(left), Either.left(Chunk.take(right.length)(left))];\n  }\n  return [left, Either.right(Chunk.drop(left.length)(right))];\n})(self));\n/** @internal */\nexports.zipLeft = zipLeft;\nconst zipRight = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => zipWithChunks(that, (left, right) => {\n  if (left.length > right.length) {\n    return [right, Either.left(Chunk.take(right.length)(left))];\n  }\n  return [Chunk.take(left.length)(right), Either.right(Chunk.drop(left.length)(right))];\n})(self));\n/** @internal */\nexports.zipRight = zipRight;\nconst zipWith = /*#__PURE__*/(0, _Function.dual)(3, (self, that, f) => zipWithChunks(that, (leftChunk, rightChunk) => zipChunks(leftChunk, rightChunk, f))(self));\n/** @internal */\nexports.zipWith = zipWith;\nconst zipWithChunks = /*#__PURE__*/(0, _Function.dual)(3, (self, that, f) => {\n  const pull = (state, pullLeft, pullRight) => {\n    switch (state._tag) {\n      case ZipChunksState.OP_PULL_BOTH:\n        {\n          return Effect.matchEffect(error => Effect.succeed(Exit.fail(Option.some(error))), ([leftOption, rightOption]) => {\n            if (Option.isSome(leftOption) && Option.isSome(rightOption)) {\n              if (Chunk.isEmpty(leftOption.value) && Chunk.isEmpty(rightOption.value)) {\n                return pull(ZipChunksState.PullBoth, pullLeft, pullRight);\n              }\n              if (Chunk.isEmpty(leftOption.value)) {\n                return pull(ZipChunksState.PullLeft(rightOption.value), pullLeft, pullRight);\n              }\n              if (Chunk.isEmpty(rightOption.value)) {\n                return pull(ZipChunksState.PullRight(leftOption.value), pullLeft, pullRight);\n              }\n              return Effect.succeed(Exit.succeed(zip(leftOption.value, rightOption.value)));\n            }\n            return Effect.succeed(Exit.fail(Option.none()));\n          })(Effect.zipPar(Effect.unsome(pullRight))(Effect.unsome(pullLeft)));\n        }\n      case ZipChunksState.OP_PULL_LEFT:\n        {\n          return Effect.matchEffect(error => Effect.succeed(Exit.fail(error)), leftChunk => {\n            if (Chunk.isEmpty(leftChunk)) {\n              return pull(ZipChunksState.PullLeft(state.rightChunk), pullLeft, pullRight);\n            }\n            if (Chunk.isEmpty(state.rightChunk)) {\n              return pull(ZipChunksState.PullRight(leftChunk), pullLeft, pullRight);\n            }\n            return Effect.succeed(Exit.succeed(zip(leftChunk, state.rightChunk)));\n          })(pullLeft);\n        }\n      case ZipChunksState.OP_PULL_RIGHT:\n        {\n          return Effect.matchEffect(error => Effect.succeed(Exit.fail(error)), rightChunk => {\n            if (Chunk.isEmpty(rightChunk)) {\n              return pull(ZipChunksState.PullRight(state.leftChunk), pullLeft, pullRight);\n            }\n            if (Chunk.isEmpty(state.leftChunk)) {\n              return pull(ZipChunksState.PullLeft(rightChunk), pullLeft, pullRight);\n            }\n            return Effect.succeed(Exit.succeed(zip(state.leftChunk, rightChunk)));\n          })(pullRight);\n        }\n    }\n  };\n  const zip = (leftChunk, rightChunk) => {\n    const [output, either] = f(leftChunk, rightChunk);\n    switch (either._tag) {\n      case \"Left\":\n        {\n          if (Chunk.isEmpty(either.left)) {\n            return [output, ZipChunksState.PullBoth];\n          }\n          return [output, ZipChunksState.PullRight(either.left)];\n        }\n      case \"Right\":\n        {\n          if (Chunk.isEmpty(either.right)) {\n            return [output, ZipChunksState.PullBoth];\n          }\n          return [output, ZipChunksState.PullLeft(either.right)];\n        }\n    }\n  };\n  return combineChunks(that, ZipChunksState.PullBoth, pull)(self);\n});\n/** @internal */\nexports.zipWithChunks = zipWithChunks;\nconst zipWithIndex = self => mapAccum(0, (index, a) => [index + 1, [a, index]])(self);\n/** @internal */\nexports.zipWithIndex = zipWithIndex;\nconst zipWithNext = self => {\n  const process = last => core.readWithCause(input => {\n    const [newLast, chunk] = Chunk.mapAccum(last, (prev, curr) => [Option.some(curr), Option.map(a => [a, curr])(prev)])(input);\n    const output = Chunk.filterMap(option => Option.isSome(option) ? Option.some([option.value[0], Option.some(option.value[1])]) : Option.none())(chunk);\n    return core.flatMap(() => process(newLast))(core.write(output));\n  }, core.failCause, () => Option.match(core.unit, value => channel.zipRight(core.unit())(core.write(Chunk.of([value, Option.none()]))))(last));\n  return new StreamImpl(channel.pipeToOrFail(process(Option.none()))(self.channel));\n};\n/** @internal */\nexports.zipWithNext = zipWithNext;\nconst zipWithPrevious = self => mapAccum(Option.none(), (prev, curr) => [Option.some(curr), [prev, curr]])(self);\n/** @internal */\nexports.zipWithPrevious = zipWithPrevious;\nconst zipWithPreviousAndNext = self => map(([[prev, curr], next]) => [prev, curr, Option.map(tuple => tuple[1])(next)])(zipWithNext(zipWithPrevious(self)));\n/** @internal */\nexports.zipWithPreviousAndNext = zipWithPreviousAndNext;\nconst zipChunks = (left, right, f) => {\n  if (left.length > right.length) {\n    return [Chunk.zipWith(right, f)(Chunk.take(right.length)(left)), Either.left(Chunk.drop(right.length)(left))];\n  }\n  return [Chunk.zipWith(Chunk.take(left.length)(right), f)(left), Either.right(Chunk.drop(left.length)(right))];\n};\n// Circular with Channel\n/** @internal */\nconst channelToStream = self => {\n  return new StreamImpl(self);\n};\nexports.channelToStream = channelToStream;\n//# sourceMappingURL=stream.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.previous = exports.notStarted = exports.current = exports.OP_PREVIOUS = exports.OP_NOT_STARTED = exports.OP_CURRENT = void 0;\n/** @internal */\nconst OP_NOT_STARTED = \"NotStarted\";\n/** @internal */\nexports.OP_NOT_STARTED = OP_NOT_STARTED;\nconst OP_PREVIOUS = \"Previous\";\n/** @internal */\nexports.OP_PREVIOUS = OP_PREVIOUS;\nconst OP_CURRENT = \"Current\";\n/** @internal */\nexports.OP_CURRENT = OP_CURRENT;\nconst notStarted = {\n  _tag: OP_NOT_STARTED\n};\n/** @internal */\nexports.notStarted = notStarted;\nconst previous = fiber => ({\n  _tag: OP_PREVIOUS,\n  fiber\n});\n/** @internal */\nexports.previous = previous;\nconst current = fiber => ({\n  _tag: OP_CURRENT,\n  fiber\n});\nexports.current = current;\n//# sourceMappingURL=debounceState.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.make = void 0;\nvar Chunk = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Chunk\"));\nvar Option = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Option\"));\nvar Cause = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Cause\"));\nvar Effect = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Effect\"));\nvar Exit = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Exit\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/** @internal */\nconst make = emit => {\n  const ops = {\n    chunk(as) {\n      return this(Effect.succeed(as));\n    },\n    die(defect) {\n      return this(Effect.die(defect));\n    },\n    dieMessage(message) {\n      return this(Effect.dieMessage(message));\n    },\n    done(exit) {\n      return this(Effect.done(Exit.mapBoth(Option.some, Chunk.of)(exit)));\n    },\n    end() {\n      return this(Effect.fail(Option.none()));\n    },\n    fail(e) {\n      return this(Effect.fail(Option.some(e)));\n    },\n    fromEffect(effect) {\n      return this(Effect.mapBoth(Option.some, Chunk.of)(effect));\n    },\n    fromEffectChunk(effect) {\n      return this(Effect.mapError(Option.some)(effect));\n    },\n    halt(cause) {\n      return this(Effect.failCause(Cause.map(Option.some)(cause)));\n    },\n    single(value) {\n      return this(Effect.succeed(Chunk.of(value)));\n    }\n  };\n  return Object.assign(emit, ops);\n};\nexports.make = make;\n//# sourceMappingURL=emit.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.match = exports.isRight = exports.isLeft = exports.isEither = exports.isBoth = exports.Right = exports.Left = exports.Either = exports.Both = void 0;\nvar _Function = /*#__PURE__*/require(\"@effect/data/Function\");\nvar OpCodes = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/stream/internal/opCodes/haltStrategy\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/** @internal */\nconst Left = {\n  _tag: OpCodes.OP_LEFT\n};\n/** @internal */\nexports.Left = Left;\nconst Right = {\n  _tag: OpCodes.OP_RIGHT\n};\n/** @internal */\nexports.Right = Right;\nconst Both = {\n  _tag: OpCodes.OP_BOTH\n};\n/** @internal */\nexports.Both = Both;\nconst Either = {\n  _tag: OpCodes.OP_EITHER\n};\n/** @internal */\nexports.Either = Either;\nconst isLeft = self => self._tag === OpCodes.OP_LEFT;\n/** @internal */\nexports.isLeft = isLeft;\nconst isRight = self => self._tag === OpCodes.OP_RIGHT;\n/** @internal */\nexports.isRight = isRight;\nconst isBoth = self => self._tag === OpCodes.OP_BOTH;\n/** @internal */\nexports.isBoth = isBoth;\nconst isEither = self => self._tag === OpCodes.OP_EITHER;\n/** @internal */\nexports.isEither = isEither;\nconst match = /*#__PURE__*/(0, _Function.dual)(5, (self, onLeft, onRight, onBoth, onEither) => {\n  switch (self._tag) {\n    case OpCodes.OP_LEFT:\n      {\n        return onLeft();\n      }\n    case OpCodes.OP_RIGHT:\n      {\n        return onRight();\n      }\n    case OpCodes.OP_BOTH:\n      {\n        return onBoth();\n      }\n    case OpCodes.OP_EITHER:\n      {\n        return onEither();\n      }\n  }\n});\nexports.match = match;\n//# sourceMappingURL=haltStrategy.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.take = exports.poll = exports.offer = exports.make = exports.OP_HANDOFF_STATE_FULL = exports.OP_HANDOFF_STATE_EMPTY = exports.HandoffTypeId = void 0;\nvar Option = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Option\"));\nvar _Debug = /*#__PURE__*/require(\"@effect/io/Debug\");\nvar Deferred = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Deferred\"));\nvar Effect = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Effect\"));\nvar Ref = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Ref\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/** @internal */\nconst HandoffTypeId = /*#__PURE__*/Symbol.for(\"@effect/stream/Stream/Handoff\");\n/** @internal */\nexports.HandoffTypeId = HandoffTypeId;\nconst OP_HANDOFF_STATE_EMPTY = \"Empty\";\n/** @internal */\nexports.OP_HANDOFF_STATE_EMPTY = OP_HANDOFF_STATE_EMPTY;\nconst OP_HANDOFF_STATE_FULL = \"Full\";\n/** @internal */\nexports.OP_HANDOFF_STATE_FULL = OP_HANDOFF_STATE_FULL;\nconst handoffStateEmpty = notifyConsumer => ({\n  _tag: OP_HANDOFF_STATE_EMPTY,\n  notifyConsumer\n});\n/** @internal */\nconst handoffStateFull = (value, notifyProducer) => ({\n  _tag: OP_HANDOFF_STATE_FULL,\n  value,\n  notifyProducer\n});\n/** @internal */\nconst handoffStateMatch = (onEmpty, onFull) => {\n  return self => {\n    switch (self._tag) {\n      case OP_HANDOFF_STATE_EMPTY:\n        {\n          return onEmpty(self.notifyConsumer);\n        }\n      case OP_HANDOFF_STATE_FULL:\n        {\n          return onFull(self.value, self.notifyProducer);\n        }\n    }\n  };\n};\n/** @internal */\nconst handoffVariance = {\n  _A: _ => _\n};\n/** @internal */\nconst make = /*#__PURE__*/(0, _Debug.methodWithTrace)(trace => () => Effect.map(ref => ({\n  [HandoffTypeId]: handoffVariance,\n  ref\n}))(Effect.flatMap(deferred => Ref.make(handoffStateEmpty(deferred)))(Deferred.make())).traced(trace));\n/**\n * @macro traced\n * @internal\n */\nexports.make = make;\nconst offer = /*#__PURE__*/(0, _Debug.dualWithTrace)(2, trace => (self, value) => {\n  return Effect.flatMap(deferred => Effect.flatten(Ref.modify(self.ref, state => handoffStateMatch(notifyConsumer => [Effect.zipRight(Deferred.await(deferred))(Deferred.succeed(notifyConsumer, void 0)), handoffStateFull(value, deferred)], (_, notifyProducer) => [Effect.flatMap(() => offer(value)(self))(Deferred.await(notifyProducer)), state])(state))))(Deferred.make()).traced(trace);\n});\n/**\n * @macro traced\n * @since 1.0.0\n */\nexports.offer = offer;\nconst take = /*#__PURE__*/(0, _Debug.methodWithTrace)(trace => self => Effect.flatMap(deferred => Effect.flatten(Ref.modify(self.ref, state => handoffStateMatch(notifyConsumer => [Effect.flatMap(() => take(self))(Deferred.await(notifyConsumer)), state], (value, notifyProducer) => [Effect.as(value)(Deferred.succeed(notifyProducer, void 0)), handoffStateEmpty(deferred)])(state))))(Deferred.make()).traced(trace));\n/**\n * @macro traced\n * @internal\n */\nexports.take = take;\nconst poll = /*#__PURE__*/(0, _Debug.methodWithTrace)(trace => self => Effect.flatMap(deferred => Effect.flatten(Ref.modify(self.ref, state => handoffStateMatch(() => [Effect.succeed(Option.none()), state], (value, notifyProducer) => [Effect.as(Option.some(value))(Deferred.succeed(notifyProducer, void 0)), handoffStateEmpty(deferred)])(state))))(Deferred.make()).traced(trace));\nexports.poll = poll;\n//# sourceMappingURL=handoff.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.halt = exports.end = exports.emit = exports.OP_HALT = exports.OP_END = exports.OP_EMIT = void 0;\n/** @internal */\nconst OP_EMIT = \"Emit\";\n/** @internal */\nexports.OP_EMIT = OP_EMIT;\nconst OP_HALT = \"Halt\";\n/** @internal */\nexports.OP_HALT = OP_HALT;\nconst OP_END = \"End\";\n/** @internal */\nexports.OP_END = OP_END;\nconst emit = elements => ({\n  _tag: OP_EMIT,\n  elements\n});\n/** @internal */\nexports.emit = emit;\nconst halt = cause => ({\n  _tag: OP_HALT,\n  cause\n});\n/** @internal */\nexports.halt = halt;\nconst end = reason => ({\n  _tag: OP_END,\n  reason\n});\nexports.end = end;\n//# sourceMappingURL=handoffSignal.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.fromDequeue = exports.failCause = exports.fail = exports.end = exports.empty = exports.emitChunk = exports.emit = void 0;\nvar Chunk = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Chunk\"));\nvar Option = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Option\"));\nvar _Debug = /*#__PURE__*/require(\"@effect/io/Debug\");\nvar Effect = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Effect\"));\nvar Queue = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Queue\"));\nvar take = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/stream/internal/take\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/**\n * @macro traced\n * @internal\n */\nconst emit = /*#__PURE__*/(0, _Debug.methodWithTrace)(trace => value => Effect.succeed(Chunk.of(value)).traced(trace));\n/**\n * @macro traced\n * @internal\n */\nexports.emit = emit;\nconst emitChunk = /*#__PURE__*/(0, _Debug.methodWithTrace)(trace => chunk => Effect.succeed(chunk).traced(trace));\n/**\n * @macro traced\n * @internal\n */\nexports.emitChunk = emitChunk;\nconst empty = /*#__PURE__*/(0, _Debug.methodWithTrace)(trace => () => Effect.succeed(Chunk.empty()).traced(trace));\n/**\n * @macro traced\n * @internal\n */\nexports.empty = empty;\nconst end = /*#__PURE__*/(0, _Debug.methodWithTrace)(trace => () => Effect.fail(Option.none()).traced(trace));\n/**\n * @macro traced\n * @internal\n */\nexports.end = end;\nconst fail = /*#__PURE__*/(0, _Debug.methodWithTrace)(trace => error => Effect.fail(Option.some(error)).traced(trace));\n/**\n * @macro traced\n * @internal\n */\nexports.fail = fail;\nconst failCause = /*#__PURE__*/(0, _Debug.methodWithTrace)(trace => cause => Effect.mapError(Option.some)(Effect.failCause(cause)).traced(trace));\n/**\n * @macro traced\n * @internal\n */\nexports.failCause = failCause;\nconst fromDequeue = /*#__PURE__*/(0, _Debug.methodWithTrace)(trace => dequeue => Effect.flatMap(take.done)(Queue.take(dequeue)).traced(trace));\nexports.fromDequeue = fromDequeue;\n//# sourceMappingURL=pull.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.UpstreamEnd = exports.SchedulEnd = exports.OP_UPSTREAM_END = exports.OP_SCHEDULE_END = void 0;\n/** @internal */\nconst OP_SCHEDULE_END = \"ScheduleEnd\";\n/** @internal */\nexports.OP_SCHEDULE_END = OP_SCHEDULE_END;\nconst OP_UPSTREAM_END = \"UpstreamEnd\";\n/** @internal */\nexports.OP_UPSTREAM_END = OP_UPSTREAM_END;\nconst SchedulEnd = {\n  _tag: OP_SCHEDULE_END\n};\n/** @internal */\nexports.SchedulEnd = SchedulEnd;\nconst UpstreamEnd = {\n  _tag: OP_UPSTREAM_END\n};\nexports.UpstreamEnd = UpstreamEnd;\n//# sourceMappingURL=sinkEndReason.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PullRight = exports.PullLeft = exports.PullBoth = exports.OP_PULL_RIGHT = exports.OP_PULL_LEFT = exports.OP_PULL_BOTH = exports.OP_DRAIN_RIGHT = exports.OP_DRAIN_LEFT = exports.DrainRight = exports.DrainLeft = void 0;\n/** @internal */\nconst OP_DRAIN_LEFT = \"DrainLeft\";\n/** @internal */\nexports.OP_DRAIN_LEFT = OP_DRAIN_LEFT;\nconst OP_DRAIN_RIGHT = \"DrainRight\";\n/** @internal */\nexports.OP_DRAIN_RIGHT = OP_DRAIN_RIGHT;\nconst OP_PULL_BOTH = \"PullBoth\";\n/** @internal */\nexports.OP_PULL_BOTH = OP_PULL_BOTH;\nconst OP_PULL_LEFT = \"PullLeft\";\n/** @internal */\nexports.OP_PULL_LEFT = OP_PULL_LEFT;\nconst OP_PULL_RIGHT = \"PullRight\";\n/** @internal */\nexports.OP_PULL_RIGHT = OP_PULL_RIGHT;\nconst DrainLeft = {\n  _tag: OP_DRAIN_LEFT\n};\n/** @internal */\nexports.DrainLeft = DrainLeft;\nconst DrainRight = {\n  _tag: OP_DRAIN_RIGHT\n};\n/** @internal */\nexports.DrainRight = DrainRight;\nconst PullBoth = {\n  _tag: OP_PULL_BOTH\n};\n/** @internal */\nexports.PullBoth = PullBoth;\nconst PullLeft = rightChunk => ({\n  _tag: OP_PULL_LEFT,\n  rightChunk\n});\n/** @internal */\nexports.PullLeft = PullLeft;\nconst PullRight = leftChunk => ({\n  _tag: OP_PULL_RIGHT,\n  leftChunk\n});\nexports.PullRight = PullRight;\n//# sourceMappingURL=zipAllState.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PullRight = exports.PullLeft = exports.PullBoth = exports.OP_PULL_RIGHT = exports.OP_PULL_LEFT = exports.OP_PULL_BOTH = void 0;\n/** @internal */\nconst OP_PULL_BOTH = \"PullBoth\";\n/** @internal */\nexports.OP_PULL_BOTH = OP_PULL_BOTH;\nconst OP_PULL_LEFT = \"PullLet\";\n/** @internal */\nexports.OP_PULL_LEFT = OP_PULL_LEFT;\nconst OP_PULL_RIGHT = \"PullRight\";\n/** @internal */\nexports.OP_PULL_RIGHT = OP_PULL_RIGHT;\nconst PullBoth = {\n  _tag: OP_PULL_BOTH\n};\n/** @internal */\nexports.PullBoth = PullBoth;\nconst PullLeft = rightChunk => ({\n  _tag: OP_PULL_LEFT,\n  rightChunk\n});\n/** @internal */\nexports.PullLeft = PullLeft;\nconst PullRight = leftChunk => ({\n  _tag: OP_PULL_RIGHT,\n  leftChunk\n});\nexports.PullRight = PullRight;\n//# sourceMappingURL=zipChunksState.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.RingBuffer = void 0;\nvar Chunk = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Chunk\"));\nvar _Function = /*#__PURE__*/require(\"@effect/data/Function\");\nvar Option = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Option\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/** @internal */\nclass RingBuffer {\n  constructor(capacity) {\n    this.capacity = capacity;\n    this.size = 0;\n    this.current = 0;\n    this.array = Array.from({\n      length: capacity\n    }, _Function.constUndefined);\n  }\n  head() {\n    return Option.fromNullable(this.array[this.current]);\n  }\n  lastOrNull() {\n    if (this.size === 0) {\n      return undefined;\n    }\n    const index = this.current === 0 ? this.array.length - 1 : this.current - 1;\n    return this.array[index] ?? undefined;\n  }\n  put(value) {\n    this.array[this.current] = value;\n    this.increment();\n  }\n  dropLast() {\n    if (this.size > 0) {\n      this.decrement();\n      this.array[this.current] = undefined;\n    }\n  }\n  toChunk() {\n    const begin = this.current - this.size;\n    const newArray = begin < 0 ? [...this.array.slice(this.capacity + begin, this.capacity), ...this.array.slice(0, this.current)] : this.array.slice(begin, this.current);\n    return Chunk.fromIterable(newArray);\n  }\n  increment() {\n    if (this.size < this.capacity) {\n      this.size += 1;\n    }\n    this.current = (this.current + 1) % this.capacity;\n  }\n  decrement() {\n    this.size -= 1;\n    if (this.current > 0) {\n      this.current -= 1;\n    } else {\n      this.current = this.capacity - 1;\n    }\n  }\n}\nexports.RingBuffer = RingBuffer;\n//# sourceMappingURL=support.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.tap = exports.of = exports.matchEffect = exports.match = exports.map = exports.make = exports.isSuccess = exports.isFailure = exports.isDone = exports.fromPull = exports.fromExit = exports.fromEffect = exports.failCause = exports.fail = exports.end = exports.done = exports.dieMessage = exports.die = exports.chunk = exports.TakeTypeId = exports.TakeImpl = void 0;\nvar Chunk = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Chunk\"));\nvar _Function = /*#__PURE__*/require(\"@effect/data/Function\");\nvar Option = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/data/Option\"));\nvar Cause = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Cause\"));\nvar _Debug = /*#__PURE__*/require(\"@effect/io/Debug\");\nvar Effect = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Effect\"));\nvar Exit = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Exit\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\nvar _a;\n/** @internal */\nconst TakeSymbolKey = \"@effect/stream/Take\";\n/** @internal */\nconst TakeTypeId = /*#__PURE__*/Symbol.for(TakeSymbolKey);\n/** @internal */\nexports.TakeTypeId = TakeTypeId;\nconst takeVariance = {\n  _E: _ => _,\n  _A: _ => _\n};\n/** @internal */\nclass TakeImpl {\n  constructor(exit) {\n    this.exit = exit;\n    this[_a] = takeVariance;\n  }\n}\nexports.TakeImpl = TakeImpl;\n_a = TakeTypeId;\n/** @internal */\nconst chunk = chunk => new TakeImpl(Exit.succeed(chunk));\n/** @internal */\nexports.chunk = chunk;\nconst die = defect => new TakeImpl(Exit.die(defect));\n/** @internal */\nexports.die = die;\nconst dieMessage = message => new TakeImpl(Exit.die(Cause.RuntimeException(message)));\n/** @internal */\nexports.dieMessage = dieMessage;\nconst done = /*#__PURE__*/(0, _Debug.methodWithTrace)(trace => self => Effect.done(self.exit).traced(trace));\n/** @internal */\nexports.done = done;\nconst end = /*#__PURE__*/new TakeImpl( /*#__PURE__*/Exit.fail( /*#__PURE__*/Option.none()));\n/** @internal */\nexports.end = end;\nconst fail = error => new TakeImpl(Exit.fail(Option.some(error)));\n/** @internal */\nexports.fail = fail;\nconst failCause = cause => new TakeImpl(Exit.failCause(Cause.map(Option.some)(cause)));\n/** @internal */\nexports.failCause = failCause;\nconst fromEffect = /*#__PURE__*/(0, _Debug.methodWithTrace)(trace => effect => Effect.matchCause(failCause, of)(effect).traced(trace));\n/** @internal */\nexports.fromEffect = fromEffect;\nconst fromExit = exit => new TakeImpl(Exit.mapBoth(Option.some, Chunk.of)(exit));\n/** @internal */\nexports.fromExit = fromExit;\nconst fromPull = /*#__PURE__*/(0, _Debug.methodWithTrace)(trace => pull => Effect.matchCause(cause => Option.match(() => end, failCause)(Cause.flipCauseOption(cause)), chunk)(pull).traced(trace));\n/** @internal */\nexports.fromPull = fromPull;\nconst isDone = self => Exit.match(cause => Option.isNone(Cause.flipCauseOption(cause)), _Function.constFalse)(self.exit);\n/** @internal */\nexports.isDone = isDone;\nconst isFailure = self => Exit.match(cause => Option.isSome(Cause.flipCauseOption(cause)), _Function.constFalse)(self.exit);\n/** @internal */\nexports.isFailure = isFailure;\nconst isSuccess = self => Exit.match(_Function.constFalse, _Function.constTrue)(self.exit);\n/** @internal */\nexports.isSuccess = isSuccess;\nconst make = exit => new TakeImpl(exit);\n/** @internal */\nexports.make = make;\nconst match = /*#__PURE__*/(0, _Function.dual)(4, (self, onEnd, onError, onSuccess) => Exit.match(cause => Option.match(onEnd, onError)(Cause.flipCauseOption(cause)), onSuccess)(self.exit));\n/** @internal */\nexports.match = match;\nconst matchEffect = /*#__PURE__*/(0, _Debug.dualWithTrace)(4, trace => (self, onEnd, onError, onSuccess) => Exit.matchEffect(cause => Option.match(onEnd, onError)(Cause.flipCauseOption(cause)), onSuccess)(self.exit).traced(trace));\n/** @internal */\nexports.matchEffect = matchEffect;\nconst map = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => new TakeImpl(Exit.map(Chunk.map(f))(self.exit)));\n/** @internal */\nexports.map = map;\nconst of = value => new TakeImpl(Exit.succeed(Chunk.of(value)));\n/** @internal */\nexports.of = of;\nconst tap = /*#__PURE__*/(0, _Debug.dualWithTrace)(2, trace => (self, f) => Effect.asUnit(Exit.forEachEffect(f)(self.exit)).traced(trace));\nexports.tap = tap;\n//# sourceMappingURL=take.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.runMain = exports.defaultTeardown = void 0;\nvar Cause = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Cause\"));\nvar Effect = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Effect\"));\nvar Exit = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Exit\"));\nvar Fiber = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require(\"@effect/io/Fiber\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\nconst defaultTeardown = (exit, onExit) => {\n  onExit(Exit.isFailure(exit) && !Cause.isInterruptedOnly(exit.cause) ? 1 : 0);\n};\n/**\n * @since 1.0.0\n */\nexports.defaultTeardown = defaultTeardown;\nconst runMain = (effect, teardown = defaultTeardown) => {\n  const fiber = Effect.runFork(effect);\n  fiber.unsafeAddObserver(exit => teardown(exit, code => Effect.runCallback(interruptAll(fiber.id()), () => {\n    process.exit(code);\n  })));\n  function onSigint() {\n    process.removeListener(\"SIGINT\", onSigint);\n    process.removeListener(\"SIGTERM\", onSigint);\n    Effect.runCallback(fiber.interruptAsFork(fiber.id()));\n  }\n  process.once(\"SIGINT\", onSigint);\n  process.once(\"SIGTERM\", onSigint);\n};\nexports.runMain = runMain;\nconst interruptAll = id => Effect.flatMap(Fiber.roots(), roots => {\n  if (roots.length === 0) {\n    return Effect.unit();\n  }\n  return Fiber.interruptAllAs(roots, id);\n});\n//# sourceMappingURL=Runtime.js.map","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(require(\"./src\"));\n//# sourceMappingURL=index.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst fs_1 = require(\"fs\");\nconst debug_1 = __importDefault(require(\"debug\"));\nconst log = debug_1.default('@kwsites/file-exists');\nfunction check(path, isFile, isDirectory) {\n    log(`checking %s`, path);\n    try {\n        const stat = fs_1.statSync(path);\n        if (stat.isFile() && isFile) {\n            log(`[OK] path represents a file`);\n            return true;\n        }\n        if (stat.isDirectory() && isDirectory) {\n            log(`[OK] path represents a directory`);\n            return true;\n        }\n        log(`[FAIL] path represents something other than a file or directory`);\n        return false;\n    }\n    catch (e) {\n        if (e.code === 'ENOENT') {\n            log(`[FAIL] path is not accessible: %o`, e);\n            return false;\n        }\n        log(`[FATAL] %o`, e);\n        throw e;\n    }\n}\n/**\n * Synchronous validation of a path existing either as a file or as a directory.\n *\n * @param {string} path The path to check\n * @param {number} type One or both of the exported numeric constants\n */\nfunction exists(path, type = exports.READABLE) {\n    return check(path, (type & exports.FILE) > 0, (type & exports.FOLDER) > 0);\n}\nexports.exists = exists;\n/**\n * Constant representing a file\n */\nexports.FILE = 1;\n/**\n * Constant representing a folder\n */\nexports.FOLDER = 2;\n/**\n * Constant representing either a file or a folder\n */\nexports.READABLE = exports.FILE + exports.FOLDER;\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createDeferred = exports.deferred = void 0;\n/**\n * Creates a new `DeferredPromise`\n *\n * ```typescript\n import {deferred} from '@kwsites/promise-deferred`;\n ```\n */\nfunction deferred() {\n    let done;\n    let fail;\n    let status = 'pending';\n    const promise = new Promise((_done, _fail) => {\n        done = _done;\n        fail = _fail;\n    });\n    return {\n        promise,\n        done(result) {\n            if (status === 'pending') {\n                status = 'resolved';\n                done(result);\n            }\n        },\n        fail(error) {\n            if (status === 'pending') {\n                status = 'rejected';\n                fail(error);\n            }\n        },\n        get fulfilled() {\n            return status !== 'pending';\n        },\n        get status() {\n            return status;\n        },\n    };\n}\nexports.deferred = deferred;\n/**\n * Alias of the exported `deferred` function, to help consumers wanting to use `deferred` as the\n * local variable name rather than the factory import name, without needing to rename on import.\n *\n * ```typescript\n import {createDeferred} from '@kwsites/promise-deferred`;\n ```\n */\nexports.createDeferred = deferred;\n/**\n * Default export allows use as:\n *\n * ```typescript\n import deferred from '@kwsites/promise-deferred`;\n ```\n */\nexports.default = deferred;\n//# sourceMappingURL=index.js.map","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nconst REGEX_IS_INSTALLATION_LEGACY = /^v1\\./;\nconst REGEX_IS_INSTALLATION = /^ghs_/;\nconst REGEX_IS_USER_TO_SERVER = /^ghu_/;\nasync function auth(token) {\n  const isApp = token.split(/\\./).length === 3;\n  const isInstallation = REGEX_IS_INSTALLATION_LEGACY.test(token) || REGEX_IS_INSTALLATION.test(token);\n  const isUserToServer = REGEX_IS_USER_TO_SERVER.test(token);\n  const tokenType = isApp ? \"app\" : isInstallation ? \"installation\" : isUserToServer ? \"user-to-server\" : \"oauth\";\n  return {\n    type: \"token\",\n    token: token,\n    tokenType\n  };\n}\n\n/**\n * Prefix token for usage in the Authorization header\n *\n * @param token OAuth token or JSON Web Token\n */\nfunction withAuthorizationPrefix(token) {\n  if (token.split(/\\./).length === 3) {\n    return `bearer ${token}`;\n  }\n\n  return `token ${token}`;\n}\n\nasync function hook(token, request, route, parameters) {\n  const endpoint = request.endpoint.merge(route, parameters);\n  endpoint.headers.authorization = withAuthorizationPrefix(token);\n  return request(endpoint);\n}\n\nconst createTokenAuth = function createTokenAuth(token) {\n  if (!token) {\n    throw new Error(\"[@octokit/auth-token] No token passed to createTokenAuth\");\n  }\n\n  if (typeof token !== \"string\") {\n    throw new Error(\"[@octokit/auth-token] Token passed to createTokenAuth is not a string\");\n  }\n\n  token = token.replace(/^(token|bearer) +/i, \"\");\n  return Object.assign(auth.bind(null, token), {\n    hook: hook.bind(null, token)\n  });\n};\n\nexports.createTokenAuth = createTokenAuth;\n//# sourceMappingURL=index.js.map\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar universalUserAgent = require('universal-user-agent');\nvar beforeAfterHook = require('before-after-hook');\nvar request = require('@octokit/request');\nvar graphql = require('@octokit/graphql');\nvar authToken = require('@octokit/auth-token');\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nconst VERSION = \"3.6.0\";\n\nconst _excluded = [\"authStrategy\"];\nclass Octokit {\n  constructor(options = {}) {\n    const hook = new beforeAfterHook.Collection();\n    const requestDefaults = {\n      baseUrl: request.request.endpoint.DEFAULTS.baseUrl,\n      headers: {},\n      request: Object.assign({}, options.request, {\n        // @ts-ignore internal usage only, no need to type\n        hook: hook.bind(null, \"request\")\n      }),\n      mediaType: {\n        previews: [],\n        format: \"\"\n      }\n    }; // prepend default user agent with `options.userAgent` if set\n\n    requestDefaults.headers[\"user-agent\"] = [options.userAgent, `octokit-core.js/${VERSION} ${universalUserAgent.getUserAgent()}`].filter(Boolean).join(\" \");\n\n    if (options.baseUrl) {\n      requestDefaults.baseUrl = options.baseUrl;\n    }\n\n    if (options.previews) {\n      requestDefaults.mediaType.previews = options.previews;\n    }\n\n    if (options.timeZone) {\n      requestDefaults.headers[\"time-zone\"] = options.timeZone;\n    }\n\n    this.request = request.request.defaults(requestDefaults);\n    this.graphql = graphql.withCustomRequest(this.request).defaults(requestDefaults);\n    this.log = Object.assign({\n      debug: () => {},\n      info: () => {},\n      warn: console.warn.bind(console),\n      error: console.error.bind(console)\n    }, options.log);\n    this.hook = hook; // (1) If neither `options.authStrategy` nor `options.auth` are set, the `octokit` instance\n    //     is unauthenticated. The `this.auth()` method is a no-op and no request hook is registered.\n    // (2) If only `options.auth` is set, use the default token authentication strategy.\n    // (3) If `options.authStrategy` is set then use it and pass in `options.auth`. Always pass own request as many strategies accept a custom request instance.\n    // TODO: type `options.auth` based on `options.authStrategy`.\n\n    if (!options.authStrategy) {\n      if (!options.auth) {\n        // (1)\n        this.auth = async () => ({\n          type: \"unauthenticated\"\n        });\n      } else {\n        // (2)\n        const auth = authToken.createTokenAuth(options.auth); // @ts-ignore  \\_()_/\n\n        hook.wrap(\"request\", auth.hook);\n        this.auth = auth;\n      }\n    } else {\n      const {\n        authStrategy\n      } = options,\n            otherOptions = _objectWithoutProperties(options, _excluded);\n\n      const auth = authStrategy(Object.assign({\n        request: this.request,\n        log: this.log,\n        // we pass the current octokit instance as well as its constructor options\n        // to allow for authentication strategies that return a new octokit instance\n        // that shares the same internal state as the current one. The original\n        // requirement for this was the \"event-octokit\" authentication strategy\n        // of https://github.com/probot/octokit-auth-probot.\n        octokit: this,\n        octokitOptions: otherOptions\n      }, options.auth)); // @ts-ignore  \\_()_/\n\n      hook.wrap(\"request\", auth.hook);\n      this.auth = auth;\n    } // apply plugins\n    // https://stackoverflow.com/a/16345172\n\n\n    const classConstructor = this.constructor;\n    classConstructor.plugins.forEach(plugin => {\n      Object.assign(this, plugin(this, options));\n    });\n  }\n\n  static defaults(defaults) {\n    const OctokitWithDefaults = class extends this {\n      constructor(...args) {\n        const options = args[0] || {};\n\n        if (typeof defaults === \"function\") {\n          super(defaults(options));\n          return;\n        }\n\n        super(Object.assign({}, defaults, options, options.userAgent && defaults.userAgent ? {\n          userAgent: `${options.userAgent} ${defaults.userAgent}`\n        } : null));\n      }\n\n    };\n    return OctokitWithDefaults;\n  }\n  /**\n   * Attach a plugin (or many) to your Octokit instance.\n   *\n   * @example\n   * const API = Octokit.plugin(plugin1, plugin2, plugin3, ...)\n   */\n\n\n  static plugin(...newPlugins) {\n    var _a;\n\n    const currentPlugins = this.plugins;\n    const NewOctokit = (_a = class extends this {}, _a.plugins = currentPlugins.concat(newPlugins.filter(plugin => !currentPlugins.includes(plugin))), _a);\n    return NewOctokit;\n  }\n\n}\nOctokit.VERSION = VERSION;\nOctokit.plugins = [];\n\nexports.Octokit = Octokit;\n//# sourceMappingURL=index.js.map\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar isPlainObject = require('is-plain-object');\nvar universalUserAgent = require('universal-user-agent');\n\nfunction lowercaseKeys(object) {\n  if (!object) {\n    return {};\n  }\n\n  return Object.keys(object).reduce((newObj, key) => {\n    newObj[key.toLowerCase()] = object[key];\n    return newObj;\n  }, {});\n}\n\nfunction mergeDeep(defaults, options) {\n  const result = Object.assign({}, defaults);\n  Object.keys(options).forEach(key => {\n    if (isPlainObject.isPlainObject(options[key])) {\n      if (!(key in defaults)) Object.assign(result, {\n        [key]: options[key]\n      });else result[key] = mergeDeep(defaults[key], options[key]);\n    } else {\n      Object.assign(result, {\n        [key]: options[key]\n      });\n    }\n  });\n  return result;\n}\n\nfunction removeUndefinedProperties(obj) {\n  for (const key in obj) {\n    if (obj[key] === undefined) {\n      delete obj[key];\n    }\n  }\n\n  return obj;\n}\n\nfunction merge(defaults, route, options) {\n  if (typeof route === \"string\") {\n    let [method, url] = route.split(\" \");\n    options = Object.assign(url ? {\n      method,\n      url\n    } : {\n      url: method\n    }, options);\n  } else {\n    options = Object.assign({}, route);\n  } // lowercase header names before merging with defaults to avoid duplicates\n\n\n  options.headers = lowercaseKeys(options.headers); // remove properties with undefined values before merging\n\n  removeUndefinedProperties(options);\n  removeUndefinedProperties(options.headers);\n  const mergedOptions = mergeDeep(defaults || {}, options); // mediaType.previews arrays are merged, instead of overwritten\n\n  if (defaults && defaults.mediaType.previews.length) {\n    mergedOptions.mediaType.previews = defaults.mediaType.previews.filter(preview => !mergedOptions.mediaType.previews.includes(preview)).concat(mergedOptions.mediaType.previews);\n  }\n\n  mergedOptions.mediaType.previews = mergedOptions.mediaType.previews.map(preview => preview.replace(/-preview/, \"\"));\n  return mergedOptions;\n}\n\nfunction addQueryParameters(url, parameters) {\n  const separator = /\\?/.test(url) ? \"&\" : \"?\";\n  const names = Object.keys(parameters);\n\n  if (names.length === 0) {\n    return url;\n  }\n\n  return url + separator + names.map(name => {\n    if (name === \"q\") {\n      return \"q=\" + parameters.q.split(\"+\").map(encodeURIComponent).join(\"+\");\n    }\n\n    return `${name}=${encodeURIComponent(parameters[name])}`;\n  }).join(\"&\");\n}\n\nconst urlVariableRegex = /\\{[^}]+\\}/g;\n\nfunction removeNonChars(variableName) {\n  return variableName.replace(/^\\W+|\\W+$/g, \"\").split(/,/);\n}\n\nfunction extractUrlVariableNames(url) {\n  const matches = url.match(urlVariableRegex);\n\n  if (!matches) {\n    return [];\n  }\n\n  return matches.map(removeNonChars).reduce((a, b) => a.concat(b), []);\n}\n\nfunction omit(object, keysToOmit) {\n  return Object.keys(object).filter(option => !keysToOmit.includes(option)).reduce((obj, key) => {\n    obj[key] = object[key];\n    return obj;\n  }, {});\n}\n\n// Based on https://github.com/bramstein/url-template, licensed under BSD\n// TODO: create separate package.\n//\n// Copyright (c) 2012-2014, Bram Stein\n// All rights reserved.\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions\n// are met:\n//  1. Redistributions of source code must retain the above copyright\n//     notice, this list of conditions and the following disclaimer.\n//  2. Redistributions in binary form must reproduce the above copyright\n//     notice, this list of conditions and the following disclaimer in the\n//     documentation and/or other materials provided with the distribution.\n//  3. The name of the author may not be used to endorse or promote products\n//     derived from this software without specific prior written permission.\n// THIS SOFTWARE IS PROVIDED BY THE AUTHOR \"AS IS\" AND ANY EXPRESS OR IMPLIED\n// WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n// EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n// INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n// BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n// EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n/* istanbul ignore file */\nfunction encodeReserved(str) {\n  return str.split(/(%[0-9A-Fa-f]{2})/g).map(function (part) {\n    if (!/%[0-9A-Fa-f]/.test(part)) {\n      part = encodeURI(part).replace(/%5B/g, \"[\").replace(/%5D/g, \"]\");\n    }\n\n    return part;\n  }).join(\"\");\n}\n\nfunction encodeUnreserved(str) {\n  return encodeURIComponent(str).replace(/[!'()*]/g, function (c) {\n    return \"%\" + c.charCodeAt(0).toString(16).toUpperCase();\n  });\n}\n\nfunction encodeValue(operator, value, key) {\n  value = operator === \"+\" || operator === \"#\" ? encodeReserved(value) : encodeUnreserved(value);\n\n  if (key) {\n    return encodeUnreserved(key) + \"=\" + value;\n  } else {\n    return value;\n  }\n}\n\nfunction isDefined(value) {\n  return value !== undefined && value !== null;\n}\n\nfunction isKeyOperator(operator) {\n  return operator === \";\" || operator === \"&\" || operator === \"?\";\n}\n\nfunction getValues(context, operator, key, modifier) {\n  var value = context[key],\n      result = [];\n\n  if (isDefined(value) && value !== \"\") {\n    if (typeof value === \"string\" || typeof value === \"number\" || typeof value === \"boolean\") {\n      value = value.toString();\n\n      if (modifier && modifier !== \"*\") {\n        value = value.substring(0, parseInt(modifier, 10));\n      }\n\n      result.push(encodeValue(operator, value, isKeyOperator(operator) ? key : \"\"));\n    } else {\n      if (modifier === \"*\") {\n        if (Array.isArray(value)) {\n          value.filter(isDefined).forEach(function (value) {\n            result.push(encodeValue(operator, value, isKeyOperator(operator) ? key : \"\"));\n          });\n        } else {\n          Object.keys(value).forEach(function (k) {\n            if (isDefined(value[k])) {\n              result.push(encodeValue(operator, value[k], k));\n            }\n          });\n        }\n      } else {\n        const tmp = [];\n\n        if (Array.isArray(value)) {\n          value.filter(isDefined).forEach(function (value) {\n            tmp.push(encodeValue(operator, value));\n          });\n        } else {\n          Object.keys(value).forEach(function (k) {\n            if (isDefined(value[k])) {\n              tmp.push(encodeUnreserved(k));\n              tmp.push(encodeValue(operator, value[k].toString()));\n            }\n          });\n        }\n\n        if (isKeyOperator(operator)) {\n          result.push(encodeUnreserved(key) + \"=\" + tmp.join(\",\"));\n        } else if (tmp.length !== 0) {\n          result.push(tmp.join(\",\"));\n        }\n      }\n    }\n  } else {\n    if (operator === \";\") {\n      if (isDefined(value)) {\n        result.push(encodeUnreserved(key));\n      }\n    } else if (value === \"\" && (operator === \"&\" || operator === \"?\")) {\n      result.push(encodeUnreserved(key) + \"=\");\n    } else if (value === \"\") {\n      result.push(\"\");\n    }\n  }\n\n  return result;\n}\n\nfunction parseUrl(template) {\n  return {\n    expand: expand.bind(null, template)\n  };\n}\n\nfunction expand(template, context) {\n  var operators = [\"+\", \"#\", \".\", \"/\", \";\", \"?\", \"&\"];\n  return template.replace(/\\{([^\\{\\}]+)\\}|([^\\{\\}]+)/g, function (_, expression, literal) {\n    if (expression) {\n      let operator = \"\";\n      const values = [];\n\n      if (operators.indexOf(expression.charAt(0)) !== -1) {\n        operator = expression.charAt(0);\n        expression = expression.substr(1);\n      }\n\n      expression.split(/,/g).forEach(function (variable) {\n        var tmp = /([^:\\*]*)(?::(\\d+)|(\\*))?/.exec(variable);\n        values.push(getValues(context, operator, tmp[1], tmp[2] || tmp[3]));\n      });\n\n      if (operator && operator !== \"+\") {\n        var separator = \",\";\n\n        if (operator === \"?\") {\n          separator = \"&\";\n        } else if (operator !== \"#\") {\n          separator = operator;\n        }\n\n        return (values.length !== 0 ? operator : \"\") + values.join(separator);\n      } else {\n        return values.join(\",\");\n      }\n    } else {\n      return encodeReserved(literal);\n    }\n  });\n}\n\nfunction parse(options) {\n  // https://fetch.spec.whatwg.org/#methods\n  let method = options.method.toUpperCase(); // replace :varname with {varname} to make it RFC 6570 compatible\n\n  let url = (options.url || \"/\").replace(/:([a-z]\\w+)/g, \"{$1}\");\n  let headers = Object.assign({}, options.headers);\n  let body;\n  let parameters = omit(options, [\"method\", \"baseUrl\", \"url\", \"headers\", \"request\", \"mediaType\"]); // extract variable names from URL to calculate remaining variables later\n\n  const urlVariableNames = extractUrlVariableNames(url);\n  url = parseUrl(url).expand(parameters);\n\n  if (!/^http/.test(url)) {\n    url = options.baseUrl + url;\n  }\n\n  const omittedParameters = Object.keys(options).filter(option => urlVariableNames.includes(option)).concat(\"baseUrl\");\n  const remainingParameters = omit(parameters, omittedParameters);\n  const isBinaryRequest = /application\\/octet-stream/i.test(headers.accept);\n\n  if (!isBinaryRequest) {\n    if (options.mediaType.format) {\n      // e.g. application/vnd.github.v3+json => application/vnd.github.v3.raw\n      headers.accept = headers.accept.split(/,/).map(preview => preview.replace(/application\\/vnd(\\.\\w+)(\\.v3)?(\\.\\w+)?(\\+json)?$/, `application/vnd$1$2.${options.mediaType.format}`)).join(\",\");\n    }\n\n    if (options.mediaType.previews.length) {\n      const previewsFromAcceptHeader = headers.accept.match(/[\\w-]+(?=-preview)/g) || [];\n      headers.accept = previewsFromAcceptHeader.concat(options.mediaType.previews).map(preview => {\n        const format = options.mediaType.format ? `.${options.mediaType.format}` : \"+json\";\n        return `application/vnd.github.${preview}-preview${format}`;\n      }).join(\",\");\n    }\n  } // for GET/HEAD requests, set URL query parameters from remaining parameters\n  // for PATCH/POST/PUT/DELETE requests, set request body from remaining parameters\n\n\n  if ([\"GET\", \"HEAD\"].includes(method)) {\n    url = addQueryParameters(url, remainingParameters);\n  } else {\n    if (\"data\" in remainingParameters) {\n      body = remainingParameters.data;\n    } else {\n      if (Object.keys(remainingParameters).length) {\n        body = remainingParameters;\n      } else {\n        headers[\"content-length\"] = 0;\n      }\n    }\n  } // default content-type for JSON if body is set\n\n\n  if (!headers[\"content-type\"] && typeof body !== \"undefined\") {\n    headers[\"content-type\"] = \"application/json; charset=utf-8\";\n  } // GitHub expects 'content-length: 0' header for PUT/PATCH requests without body.\n  // fetch does not allow to set `content-length` header, but we can set body to an empty string\n\n\n  if ([\"PATCH\", \"PUT\"].includes(method) && typeof body === \"undefined\") {\n    body = \"\";\n  } // Only return body/request keys if present\n\n\n  return Object.assign({\n    method,\n    url,\n    headers\n  }, typeof body !== \"undefined\" ? {\n    body\n  } : null, options.request ? {\n    request: options.request\n  } : null);\n}\n\nfunction endpointWithDefaults(defaults, route, options) {\n  return parse(merge(defaults, route, options));\n}\n\nfunction withDefaults(oldDefaults, newDefaults) {\n  const DEFAULTS = merge(oldDefaults, newDefaults);\n  const endpoint = endpointWithDefaults.bind(null, DEFAULTS);\n  return Object.assign(endpoint, {\n    DEFAULTS,\n    defaults: withDefaults.bind(null, DEFAULTS),\n    merge: merge.bind(null, DEFAULTS),\n    parse\n  });\n}\n\nconst VERSION = \"6.0.12\";\n\nconst userAgent = `octokit-endpoint.js/${VERSION} ${universalUserAgent.getUserAgent()}`; // DEFAULTS has all properties set that EndpointOptions has, except url.\n// So we use RequestParameters and add method as additional required property.\n\nconst DEFAULTS = {\n  method: \"GET\",\n  baseUrl: \"https://api.github.com\",\n  headers: {\n    accept: \"application/vnd.github.v3+json\",\n    \"user-agent\": userAgent\n  },\n  mediaType: {\n    format: \"\",\n    previews: []\n  }\n};\n\nconst endpoint = withDefaults(null, DEFAULTS);\n\nexports.endpoint = endpoint;\n//# sourceMappingURL=index.js.map\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar request = require('@octokit/request');\nvar universalUserAgent = require('universal-user-agent');\n\nconst VERSION = \"4.8.0\";\n\nfunction _buildMessageForResponseErrors(data) {\n  return `Request failed due to following response errors:\\n` + data.errors.map(e => ` - ${e.message}`).join(\"\\n\");\n}\n\nclass GraphqlResponseError extends Error {\n  constructor(request, headers, response) {\n    super(_buildMessageForResponseErrors(response));\n    this.request = request;\n    this.headers = headers;\n    this.response = response;\n    this.name = \"GraphqlResponseError\"; // Expose the errors and response data in their shorthand properties.\n\n    this.errors = response.errors;\n    this.data = response.data; // Maintains proper stack trace (only available on V8)\n\n    /* istanbul ignore next */\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor);\n    }\n  }\n\n}\n\nconst NON_VARIABLE_OPTIONS = [\"method\", \"baseUrl\", \"url\", \"headers\", \"request\", \"query\", \"mediaType\"];\nconst FORBIDDEN_VARIABLE_OPTIONS = [\"query\", \"method\", \"url\"];\nconst GHES_V3_SUFFIX_REGEX = /\\/api\\/v3\\/?$/;\nfunction graphql(request, query, options) {\n  if (options) {\n    if (typeof query === \"string\" && \"query\" in options) {\n      return Promise.reject(new Error(`[@octokit/graphql] \"query\" cannot be used as variable name`));\n    }\n\n    for (const key in options) {\n      if (!FORBIDDEN_VARIABLE_OPTIONS.includes(key)) continue;\n      return Promise.reject(new Error(`[@octokit/graphql] \"${key}\" cannot be used as variable name`));\n    }\n  }\n\n  const parsedOptions = typeof query === \"string\" ? Object.assign({\n    query\n  }, options) : query;\n  const requestOptions = Object.keys(parsedOptions).reduce((result, key) => {\n    if (NON_VARIABLE_OPTIONS.includes(key)) {\n      result[key] = parsedOptions[key];\n      return result;\n    }\n\n    if (!result.variables) {\n      result.variables = {};\n    }\n\n    result.variables[key] = parsedOptions[key];\n    return result;\n  }, {}); // workaround for GitHub Enterprise baseUrl set with /api/v3 suffix\n  // https://github.com/octokit/auth-app.js/issues/111#issuecomment-657610451\n\n  const baseUrl = parsedOptions.baseUrl || request.endpoint.DEFAULTS.baseUrl;\n\n  if (GHES_V3_SUFFIX_REGEX.test(baseUrl)) {\n    requestOptions.url = baseUrl.replace(GHES_V3_SUFFIX_REGEX, \"/api/graphql\");\n  }\n\n  return request(requestOptions).then(response => {\n    if (response.data.errors) {\n      const headers = {};\n\n      for (const key of Object.keys(response.headers)) {\n        headers[key] = response.headers[key];\n      }\n\n      throw new GraphqlResponseError(requestOptions, headers, response.data);\n    }\n\n    return response.data.data;\n  });\n}\n\nfunction withDefaults(request$1, newDefaults) {\n  const newRequest = request$1.defaults(newDefaults);\n\n  const newApi = (query, options) => {\n    return graphql(newRequest, query, options);\n  };\n\n  return Object.assign(newApi, {\n    defaults: withDefaults.bind(null, newRequest),\n    endpoint: request.request.endpoint\n  });\n}\n\nconst graphql$1 = withDefaults(request.request, {\n  headers: {\n    \"user-agent\": `octokit-graphql.js/${VERSION} ${universalUserAgent.getUserAgent()}`\n  },\n  method: \"POST\",\n  url: \"/graphql\"\n});\nfunction withCustomRequest(customRequest) {\n  return withDefaults(customRequest, {\n    method: \"POST\",\n    url: \"/graphql\"\n  });\n}\n\nexports.GraphqlResponseError = GraphqlResponseError;\nexports.graphql = graphql$1;\nexports.withCustomRequest = withCustomRequest;\n//# sourceMappingURL=index.js.map\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nconst VERSION = \"2.21.3\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\n/**\n * Some list response that can be paginated have a different response structure\n *\n * They have a `total_count` key in the response (search also has `incomplete_results`,\n * /installation/repositories also has `repository_selection`), as well as a key with\n * the list of the items which name varies from endpoint to endpoint.\n *\n * Octokit normalizes these responses so that paginated results are always returned following\n * the same structure. One challenge is that if the list response has only one page, no Link\n * header is provided, so this header alone is not sufficient to check wether a response is\n * paginated or not.\n *\n * We check if a \"total_count\" key is present in the response data, but also make sure that\n * a \"url\" property is not, as the \"Get the combined status for a specific ref\" endpoint would\n * otherwise match: https://developer.github.com/v3/repos/statuses/#get-the-combined-status-for-a-specific-ref\n */\nfunction normalizePaginatedListResponse(response) {\n  // endpoints can respond with 204 if repository is empty\n  if (!response.data) {\n    return _objectSpread2(_objectSpread2({}, response), {}, {\n      data: []\n    });\n  }\n\n  const responseNeedsNormalization = \"total_count\" in response.data && !(\"url\" in response.data);\n  if (!responseNeedsNormalization) return response; // keep the additional properties intact as there is currently no other way\n  // to retrieve the same information.\n\n  const incompleteResults = response.data.incomplete_results;\n  const repositorySelection = response.data.repository_selection;\n  const totalCount = response.data.total_count;\n  delete response.data.incomplete_results;\n  delete response.data.repository_selection;\n  delete response.data.total_count;\n  const namespaceKey = Object.keys(response.data)[0];\n  const data = response.data[namespaceKey];\n  response.data = data;\n\n  if (typeof incompleteResults !== \"undefined\") {\n    response.data.incomplete_results = incompleteResults;\n  }\n\n  if (typeof repositorySelection !== \"undefined\") {\n    response.data.repository_selection = repositorySelection;\n  }\n\n  response.data.total_count = totalCount;\n  return response;\n}\n\nfunction iterator(octokit, route, parameters) {\n  const options = typeof route === \"function\" ? route.endpoint(parameters) : octokit.request.endpoint(route, parameters);\n  const requestMethod = typeof route === \"function\" ? route : octokit.request;\n  const method = options.method;\n  const headers = options.headers;\n  let url = options.url;\n  return {\n    [Symbol.asyncIterator]: () => ({\n      async next() {\n        if (!url) return {\n          done: true\n        };\n\n        try {\n          const response = await requestMethod({\n            method,\n            url,\n            headers\n          });\n          const normalizedResponse = normalizePaginatedListResponse(response); // `response.headers.link` format:\n          // '<https://api.github.com/users/aseemk/followers?page=2>; rel=\"next\", <https://api.github.com/users/aseemk/followers?page=2>; rel=\"last\"'\n          // sets `url` to undefined if \"next\" URL is not present or `link` header is not set\n\n          url = ((normalizedResponse.headers.link || \"\").match(/<([^>]+)>;\\s*rel=\"next\"/) || [])[1];\n          return {\n            value: normalizedResponse\n          };\n        } catch (error) {\n          if (error.status !== 409) throw error;\n          url = \"\";\n          return {\n            value: {\n              status: 200,\n              headers: {},\n              data: []\n            }\n          };\n        }\n      }\n\n    })\n  };\n}\n\nfunction paginate(octokit, route, parameters, mapFn) {\n  if (typeof parameters === \"function\") {\n    mapFn = parameters;\n    parameters = undefined;\n  }\n\n  return gather(octokit, [], iterator(octokit, route, parameters)[Symbol.asyncIterator](), mapFn);\n}\n\nfunction gather(octokit, results, iterator, mapFn) {\n  return iterator.next().then(result => {\n    if (result.done) {\n      return results;\n    }\n\n    let earlyExit = false;\n\n    function done() {\n      earlyExit = true;\n    }\n\n    results = results.concat(mapFn ? mapFn(result.value, done) : result.value.data);\n\n    if (earlyExit) {\n      return results;\n    }\n\n    return gather(octokit, results, iterator, mapFn);\n  });\n}\n\nconst composePaginateRest = Object.assign(paginate, {\n  iterator\n});\n\nconst paginatingEndpoints = [\"GET /app/hook/deliveries\", \"GET /app/installations\", \"GET /applications/grants\", \"GET /authorizations\", \"GET /enterprises/{enterprise}/actions/permissions/organizations\", \"GET /enterprises/{enterprise}/actions/runner-groups\", \"GET /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/organizations\", \"GET /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/runners\", \"GET /enterprises/{enterprise}/actions/runners\", \"GET /enterprises/{enterprise}/audit-log\", \"GET /enterprises/{enterprise}/secret-scanning/alerts\", \"GET /enterprises/{enterprise}/settings/billing/advanced-security\", \"GET /events\", \"GET /gists\", \"GET /gists/public\", \"GET /gists/starred\", \"GET /gists/{gist_id}/comments\", \"GET /gists/{gist_id}/commits\", \"GET /gists/{gist_id}/forks\", \"GET /installation/repositories\", \"GET /issues\", \"GET /licenses\", \"GET /marketplace_listing/plans\", \"GET /marketplace_listing/plans/{plan_id}/accounts\", \"GET /marketplace_listing/stubbed/plans\", \"GET /marketplace_listing/stubbed/plans/{plan_id}/accounts\", \"GET /networks/{owner}/{repo}/events\", \"GET /notifications\", \"GET /organizations\", \"GET /orgs/{org}/actions/cache/usage-by-repository\", \"GET /orgs/{org}/actions/permissions/repositories\", \"GET /orgs/{org}/actions/runner-groups\", \"GET /orgs/{org}/actions/runner-groups/{runner_group_id}/repositories\", \"GET /orgs/{org}/actions/runner-groups/{runner_group_id}/runners\", \"GET /orgs/{org}/actions/runners\", \"GET /orgs/{org}/actions/secrets\", \"GET /orgs/{org}/actions/secrets/{secret_name}/repositories\", \"GET /orgs/{org}/audit-log\", \"GET /orgs/{org}/blocks\", \"GET /orgs/{org}/code-scanning/alerts\", \"GET /orgs/{org}/codespaces\", \"GET /orgs/{org}/credential-authorizations\", \"GET /orgs/{org}/dependabot/secrets\", \"GET /orgs/{org}/dependabot/secrets/{secret_name}/repositories\", \"GET /orgs/{org}/events\", \"GET /orgs/{org}/external-groups\", \"GET /orgs/{org}/failed_invitations\", \"GET /orgs/{org}/hooks\", \"GET /orgs/{org}/hooks/{hook_id}/deliveries\", \"GET /orgs/{org}/installations\", \"GET /orgs/{org}/invitations\", \"GET /orgs/{org}/invitations/{invitation_id}/teams\", \"GET /orgs/{org}/issues\", \"GET /orgs/{org}/members\", \"GET /orgs/{org}/migrations\", \"GET /orgs/{org}/migrations/{migration_id}/repositories\", \"GET /orgs/{org}/outside_collaborators\", \"GET /orgs/{org}/packages\", \"GET /orgs/{org}/packages/{package_type}/{package_name}/versions\", \"GET /orgs/{org}/projects\", \"GET /orgs/{org}/public_members\", \"GET /orgs/{org}/repos\", \"GET /orgs/{org}/secret-scanning/alerts\", \"GET /orgs/{org}/settings/billing/advanced-security\", \"GET /orgs/{org}/team-sync/groups\", \"GET /orgs/{org}/teams\", \"GET /orgs/{org}/teams/{team_slug}/discussions\", \"GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments\", \"GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions\", \"GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions\", \"GET /orgs/{org}/teams/{team_slug}/invitations\", \"GET /orgs/{org}/teams/{team_slug}/members\", \"GET /orgs/{org}/teams/{team_slug}/projects\", \"GET /orgs/{org}/teams/{team_slug}/repos\", \"GET /orgs/{org}/teams/{team_slug}/teams\", \"GET /projects/columns/{column_id}/cards\", \"GET /projects/{project_id}/collaborators\", \"GET /projects/{project_id}/columns\", \"GET /repos/{owner}/{repo}/actions/artifacts\", \"GET /repos/{owner}/{repo}/actions/caches\", \"GET /repos/{owner}/{repo}/actions/runners\", \"GET /repos/{owner}/{repo}/actions/runs\", \"GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts\", \"GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/jobs\", \"GET /repos/{owner}/{repo}/actions/runs/{run_id}/jobs\", \"GET /repos/{owner}/{repo}/actions/secrets\", \"GET /repos/{owner}/{repo}/actions/workflows\", \"GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs\", \"GET /repos/{owner}/{repo}/assignees\", \"GET /repos/{owner}/{repo}/branches\", \"GET /repos/{owner}/{repo}/check-runs/{check_run_id}/annotations\", \"GET /repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs\", \"GET /repos/{owner}/{repo}/code-scanning/alerts\", \"GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances\", \"GET /repos/{owner}/{repo}/code-scanning/analyses\", \"GET /repos/{owner}/{repo}/codespaces\", \"GET /repos/{owner}/{repo}/codespaces/devcontainers\", \"GET /repos/{owner}/{repo}/codespaces/secrets\", \"GET /repos/{owner}/{repo}/collaborators\", \"GET /repos/{owner}/{repo}/comments\", \"GET /repos/{owner}/{repo}/comments/{comment_id}/reactions\", \"GET /repos/{owner}/{repo}/commits\", \"GET /repos/{owner}/{repo}/commits/{commit_sha}/comments\", \"GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls\", \"GET /repos/{owner}/{repo}/commits/{ref}/check-runs\", \"GET /repos/{owner}/{repo}/commits/{ref}/check-suites\", \"GET /repos/{owner}/{repo}/commits/{ref}/status\", \"GET /repos/{owner}/{repo}/commits/{ref}/statuses\", \"GET /repos/{owner}/{repo}/contributors\", \"GET /repos/{owner}/{repo}/dependabot/secrets\", \"GET /repos/{owner}/{repo}/deployments\", \"GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses\", \"GET /repos/{owner}/{repo}/environments\", \"GET /repos/{owner}/{repo}/events\", \"GET /repos/{owner}/{repo}/forks\", \"GET /repos/{owner}/{repo}/git/matching-refs/{ref}\", \"GET /repos/{owner}/{repo}/hooks\", \"GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries\", \"GET /repos/{owner}/{repo}/invitations\", \"GET /repos/{owner}/{repo}/issues\", \"GET /repos/{owner}/{repo}/issues/comments\", \"GET /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions\", \"GET /repos/{owner}/{repo}/issues/events\", \"GET /repos/{owner}/{repo}/issues/{issue_number}/comments\", \"GET /repos/{owner}/{repo}/issues/{issue_number}/events\", \"GET /repos/{owner}/{repo}/issues/{issue_number}/labels\", \"GET /repos/{owner}/{repo}/issues/{issue_number}/reactions\", \"GET /repos/{owner}/{repo}/issues/{issue_number}/timeline\", \"GET /repos/{owner}/{repo}/keys\", \"GET /repos/{owner}/{repo}/labels\", \"GET /repos/{owner}/{repo}/milestones\", \"GET /repos/{owner}/{repo}/milestones/{milestone_number}/labels\", \"GET /repos/{owner}/{repo}/notifications\", \"GET /repos/{owner}/{repo}/pages/builds\", \"GET /repos/{owner}/{repo}/projects\", \"GET /repos/{owner}/{repo}/pulls\", \"GET /repos/{owner}/{repo}/pulls/comments\", \"GET /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions\", \"GET /repos/{owner}/{repo}/pulls/{pull_number}/comments\", \"GET /repos/{owner}/{repo}/pulls/{pull_number}/commits\", \"GET /repos/{owner}/{repo}/pulls/{pull_number}/files\", \"GET /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers\", \"GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews\", \"GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments\", \"GET /repos/{owner}/{repo}/releases\", \"GET /repos/{owner}/{repo}/releases/{release_id}/assets\", \"GET /repos/{owner}/{repo}/releases/{release_id}/reactions\", \"GET /repos/{owner}/{repo}/secret-scanning/alerts\", \"GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}/locations\", \"GET /repos/{owner}/{repo}/stargazers\", \"GET /repos/{owner}/{repo}/subscribers\", \"GET /repos/{owner}/{repo}/tags\", \"GET /repos/{owner}/{repo}/teams\", \"GET /repos/{owner}/{repo}/topics\", \"GET /repositories\", \"GET /repositories/{repository_id}/environments/{environment_name}/secrets\", \"GET /search/code\", \"GET /search/commits\", \"GET /search/issues\", \"GET /search/labels\", \"GET /search/repositories\", \"GET /search/topics\", \"GET /search/users\", \"GET /teams/{team_id}/discussions\", \"GET /teams/{team_id}/discussions/{discussion_number}/comments\", \"GET /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}/reactions\", \"GET /teams/{team_id}/discussions/{discussion_number}/reactions\", \"GET /teams/{team_id}/invitations\", \"GET /teams/{team_id}/members\", \"GET /teams/{team_id}/projects\", \"GET /teams/{team_id}/repos\", \"GET /teams/{team_id}/teams\", \"GET /user/blocks\", \"GET /user/codespaces\", \"GET /user/codespaces/secrets\", \"GET /user/emails\", \"GET /user/followers\", \"GET /user/following\", \"GET /user/gpg_keys\", \"GET /user/installations\", \"GET /user/installations/{installation_id}/repositories\", \"GET /user/issues\", \"GET /user/keys\", \"GET /user/marketplace_purchases\", \"GET /user/marketplace_purchases/stubbed\", \"GET /user/memberships/orgs\", \"GET /user/migrations\", \"GET /user/migrations/{migration_id}/repositories\", \"GET /user/orgs\", \"GET /user/packages\", \"GET /user/packages/{package_type}/{package_name}/versions\", \"GET /user/public_emails\", \"GET /user/repos\", \"GET /user/repository_invitations\", \"GET /user/starred\", \"GET /user/subscriptions\", \"GET /user/teams\", \"GET /users\", \"GET /users/{username}/events\", \"GET /users/{username}/events/orgs/{org}\", \"GET /users/{username}/events/public\", \"GET /users/{username}/followers\", \"GET /users/{username}/following\", \"GET /users/{username}/gists\", \"GET /users/{username}/gpg_keys\", \"GET /users/{username}/keys\", \"GET /users/{username}/orgs\", \"GET /users/{username}/packages\", \"GET /users/{username}/projects\", \"GET /users/{username}/received_events\", \"GET /users/{username}/received_events/public\", \"GET /users/{username}/repos\", \"GET /users/{username}/starred\", \"GET /users/{username}/subscriptions\"];\n\nfunction isPaginatingEndpoint(arg) {\n  if (typeof arg === \"string\") {\n    return paginatingEndpoints.includes(arg);\n  } else {\n    return false;\n  }\n}\n\n/**\n * @param octokit Octokit instance\n * @param options Options passed to Octokit constructor\n */\n\nfunction paginateRest(octokit) {\n  return {\n    paginate: Object.assign(paginate.bind(null, octokit), {\n      iterator: iterator.bind(null, octokit)\n    })\n  };\n}\npaginateRest.VERSION = VERSION;\n\nexports.composePaginateRest = composePaginateRest;\nexports.isPaginatingEndpoint = isPaginatingEndpoint;\nexports.paginateRest = paginateRest;\nexports.paginatingEndpoints = paginatingEndpoints;\n//# sourceMappingURL=index.js.map\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nconst Endpoints = {\n  actions: {\n    addCustomLabelsToSelfHostedRunnerForOrg: [\"POST /orgs/{org}/actions/runners/{runner_id}/labels\"],\n    addCustomLabelsToSelfHostedRunnerForRepo: [\"POST /repos/{owner}/{repo}/actions/runners/{runner_id}/labels\"],\n    addSelectedRepoToOrgSecret: [\"PUT /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}\"],\n    approveWorkflowRun: [\"POST /repos/{owner}/{repo}/actions/runs/{run_id}/approve\"],\n    cancelWorkflowRun: [\"POST /repos/{owner}/{repo}/actions/runs/{run_id}/cancel\"],\n    createOrUpdateEnvironmentSecret: [\"PUT /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}\"],\n    createOrUpdateOrgSecret: [\"PUT /orgs/{org}/actions/secrets/{secret_name}\"],\n    createOrUpdateRepoSecret: [\"PUT /repos/{owner}/{repo}/actions/secrets/{secret_name}\"],\n    createRegistrationTokenForOrg: [\"POST /orgs/{org}/actions/runners/registration-token\"],\n    createRegistrationTokenForRepo: [\"POST /repos/{owner}/{repo}/actions/runners/registration-token\"],\n    createRemoveTokenForOrg: [\"POST /orgs/{org}/actions/runners/remove-token\"],\n    createRemoveTokenForRepo: [\"POST /repos/{owner}/{repo}/actions/runners/remove-token\"],\n    createWorkflowDispatch: [\"POST /repos/{owner}/{repo}/actions/workflows/{workflow_id}/dispatches\"],\n    deleteActionsCacheById: [\"DELETE /repos/{owner}/{repo}/actions/caches/{cache_id}\"],\n    deleteActionsCacheByKey: [\"DELETE /repos/{owner}/{repo}/actions/caches{?key,ref}\"],\n    deleteArtifact: [\"DELETE /repos/{owner}/{repo}/actions/artifacts/{artifact_id}\"],\n    deleteEnvironmentSecret: [\"DELETE /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}\"],\n    deleteOrgSecret: [\"DELETE /orgs/{org}/actions/secrets/{secret_name}\"],\n    deleteRepoSecret: [\"DELETE /repos/{owner}/{repo}/actions/secrets/{secret_name}\"],\n    deleteSelfHostedRunnerFromOrg: [\"DELETE /orgs/{org}/actions/runners/{runner_id}\"],\n    deleteSelfHostedRunnerFromRepo: [\"DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}\"],\n    deleteWorkflowRun: [\"DELETE /repos/{owner}/{repo}/actions/runs/{run_id}\"],\n    deleteWorkflowRunLogs: [\"DELETE /repos/{owner}/{repo}/actions/runs/{run_id}/logs\"],\n    disableSelectedRepositoryGithubActionsOrganization: [\"DELETE /orgs/{org}/actions/permissions/repositories/{repository_id}\"],\n    disableWorkflow: [\"PUT /repos/{owner}/{repo}/actions/workflows/{workflow_id}/disable\"],\n    downloadArtifact: [\"GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}/{archive_format}\"],\n    downloadJobLogsForWorkflowRun: [\"GET /repos/{owner}/{repo}/actions/jobs/{job_id}/logs\"],\n    downloadWorkflowRunAttemptLogs: [\"GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/logs\"],\n    downloadWorkflowRunLogs: [\"GET /repos/{owner}/{repo}/actions/runs/{run_id}/logs\"],\n    enableSelectedRepositoryGithubActionsOrganization: [\"PUT /orgs/{org}/actions/permissions/repositories/{repository_id}\"],\n    enableWorkflow: [\"PUT /repos/{owner}/{repo}/actions/workflows/{workflow_id}/enable\"],\n    getActionsCacheList: [\"GET /repos/{owner}/{repo}/actions/caches\"],\n    getActionsCacheUsage: [\"GET /repos/{owner}/{repo}/actions/cache/usage\"],\n    getActionsCacheUsageByRepoForOrg: [\"GET /orgs/{org}/actions/cache/usage-by-repository\"],\n    getActionsCacheUsageForEnterprise: [\"GET /enterprises/{enterprise}/actions/cache/usage\"],\n    getActionsCacheUsageForOrg: [\"GET /orgs/{org}/actions/cache/usage\"],\n    getAllowedActionsOrganization: [\"GET /orgs/{org}/actions/permissions/selected-actions\"],\n    getAllowedActionsRepository: [\"GET /repos/{owner}/{repo}/actions/permissions/selected-actions\"],\n    getArtifact: [\"GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}\"],\n    getEnvironmentPublicKey: [\"GET /repositories/{repository_id}/environments/{environment_name}/secrets/public-key\"],\n    getEnvironmentSecret: [\"GET /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}\"],\n    getGithubActionsDefaultWorkflowPermissionsEnterprise: [\"GET /enterprises/{enterprise}/actions/permissions/workflow\"],\n    getGithubActionsDefaultWorkflowPermissionsOrganization: [\"GET /orgs/{org}/actions/permissions/workflow\"],\n    getGithubActionsDefaultWorkflowPermissionsRepository: [\"GET /repos/{owner}/{repo}/actions/permissions/workflow\"],\n    getGithubActionsPermissionsOrganization: [\"GET /orgs/{org}/actions/permissions\"],\n    getGithubActionsPermissionsRepository: [\"GET /repos/{owner}/{repo}/actions/permissions\"],\n    getJobForWorkflowRun: [\"GET /repos/{owner}/{repo}/actions/jobs/{job_id}\"],\n    getOrgPublicKey: [\"GET /orgs/{org}/actions/secrets/public-key\"],\n    getOrgSecret: [\"GET /orgs/{org}/actions/secrets/{secret_name}\"],\n    getPendingDeploymentsForRun: [\"GET /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments\"],\n    getRepoPermissions: [\"GET /repos/{owner}/{repo}/actions/permissions\", {}, {\n      renamed: [\"actions\", \"getGithubActionsPermissionsRepository\"]\n    }],\n    getRepoPublicKey: [\"GET /repos/{owner}/{repo}/actions/secrets/public-key\"],\n    getRepoSecret: [\"GET /repos/{owner}/{repo}/actions/secrets/{secret_name}\"],\n    getReviewsForRun: [\"GET /repos/{owner}/{repo}/actions/runs/{run_id}/approvals\"],\n    getSelfHostedRunnerForOrg: [\"GET /orgs/{org}/actions/runners/{runner_id}\"],\n    getSelfHostedRunnerForRepo: [\"GET /repos/{owner}/{repo}/actions/runners/{runner_id}\"],\n    getWorkflow: [\"GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}\"],\n    getWorkflowAccessToRepository: [\"GET /repos/{owner}/{repo}/actions/permissions/access\"],\n    getWorkflowRun: [\"GET /repos/{owner}/{repo}/actions/runs/{run_id}\"],\n    getWorkflowRunAttempt: [\"GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}\"],\n    getWorkflowRunUsage: [\"GET /repos/{owner}/{repo}/actions/runs/{run_id}/timing\"],\n    getWorkflowUsage: [\"GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/timing\"],\n    listArtifactsForRepo: [\"GET /repos/{owner}/{repo}/actions/artifacts\"],\n    listEnvironmentSecrets: [\"GET /repositories/{repository_id}/environments/{environment_name}/secrets\"],\n    listJobsForWorkflowRun: [\"GET /repos/{owner}/{repo}/actions/runs/{run_id}/jobs\"],\n    listJobsForWorkflowRunAttempt: [\"GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/jobs\"],\n    listLabelsForSelfHostedRunnerForOrg: [\"GET /orgs/{org}/actions/runners/{runner_id}/labels\"],\n    listLabelsForSelfHostedRunnerForRepo: [\"GET /repos/{owner}/{repo}/actions/runners/{runner_id}/labels\"],\n    listOrgSecrets: [\"GET /orgs/{org}/actions/secrets\"],\n    listRepoSecrets: [\"GET /repos/{owner}/{repo}/actions/secrets\"],\n    listRepoWorkflows: [\"GET /repos/{owner}/{repo}/actions/workflows\"],\n    listRunnerApplicationsForOrg: [\"GET /orgs/{org}/actions/runners/downloads\"],\n    listRunnerApplicationsForRepo: [\"GET /repos/{owner}/{repo}/actions/runners/downloads\"],\n    listSelectedReposForOrgSecret: [\"GET /orgs/{org}/actions/secrets/{secret_name}/repositories\"],\n    listSelectedRepositoriesEnabledGithubActionsOrganization: [\"GET /orgs/{org}/actions/permissions/repositories\"],\n    listSelfHostedRunnersForOrg: [\"GET /orgs/{org}/actions/runners\"],\n    listSelfHostedRunnersForRepo: [\"GET /repos/{owner}/{repo}/actions/runners\"],\n    listWorkflowRunArtifacts: [\"GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts\"],\n    listWorkflowRuns: [\"GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs\"],\n    listWorkflowRunsForRepo: [\"GET /repos/{owner}/{repo}/actions/runs\"],\n    reRunJobForWorkflowRun: [\"POST /repos/{owner}/{repo}/actions/jobs/{job_id}/rerun\"],\n    reRunWorkflow: [\"POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun\"],\n    reRunWorkflowFailedJobs: [\"POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun-failed-jobs\"],\n    removeAllCustomLabelsFromSelfHostedRunnerForOrg: [\"DELETE /orgs/{org}/actions/runners/{runner_id}/labels\"],\n    removeAllCustomLabelsFromSelfHostedRunnerForRepo: [\"DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}/labels\"],\n    removeCustomLabelFromSelfHostedRunnerForOrg: [\"DELETE /orgs/{org}/actions/runners/{runner_id}/labels/{name}\"],\n    removeCustomLabelFromSelfHostedRunnerForRepo: [\"DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}/labels/{name}\"],\n    removeSelectedRepoFromOrgSecret: [\"DELETE /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}\"],\n    reviewPendingDeploymentsForRun: [\"POST /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments\"],\n    setAllowedActionsOrganization: [\"PUT /orgs/{org}/actions/permissions/selected-actions\"],\n    setAllowedActionsRepository: [\"PUT /repos/{owner}/{repo}/actions/permissions/selected-actions\"],\n    setCustomLabelsForSelfHostedRunnerForOrg: [\"PUT /orgs/{org}/actions/runners/{runner_id}/labels\"],\n    setCustomLabelsForSelfHostedRunnerForRepo: [\"PUT /repos/{owner}/{repo}/actions/runners/{runner_id}/labels\"],\n    setGithubActionsDefaultWorkflowPermissionsEnterprise: [\"PUT /enterprises/{enterprise}/actions/permissions/workflow\"],\n    setGithubActionsDefaultWorkflowPermissionsOrganization: [\"PUT /orgs/{org}/actions/permissions/workflow\"],\n    setGithubActionsDefaultWorkflowPermissionsRepository: [\"PUT /repos/{owner}/{repo}/actions/permissions/workflow\"],\n    setGithubActionsPermissionsOrganization: [\"PUT /orgs/{org}/actions/permissions\"],\n    setGithubActionsPermissionsRepository: [\"PUT /repos/{owner}/{repo}/actions/permissions\"],\n    setSelectedReposForOrgSecret: [\"PUT /orgs/{org}/actions/secrets/{secret_name}/repositories\"],\n    setSelectedRepositoriesEnabledGithubActionsOrganization: [\"PUT /orgs/{org}/actions/permissions/repositories\"],\n    setWorkflowAccessToRepository: [\"PUT /repos/{owner}/{repo}/actions/permissions/access\"]\n  },\n  activity: {\n    checkRepoIsStarredByAuthenticatedUser: [\"GET /user/starred/{owner}/{repo}\"],\n    deleteRepoSubscription: [\"DELETE /repos/{owner}/{repo}/subscription\"],\n    deleteThreadSubscription: [\"DELETE /notifications/threads/{thread_id}/subscription\"],\n    getFeeds: [\"GET /feeds\"],\n    getRepoSubscription: [\"GET /repos/{owner}/{repo}/subscription\"],\n    getThread: [\"GET /notifications/threads/{thread_id}\"],\n    getThreadSubscriptionForAuthenticatedUser: [\"GET /notifications/threads/{thread_id}/subscription\"],\n    listEventsForAuthenticatedUser: [\"GET /users/{username}/events\"],\n    listNotificationsForAuthenticatedUser: [\"GET /notifications\"],\n    listOrgEventsForAuthenticatedUser: [\"GET /users/{username}/events/orgs/{org}\"],\n    listPublicEvents: [\"GET /events\"],\n    listPublicEventsForRepoNetwork: [\"GET /networks/{owner}/{repo}/events\"],\n    listPublicEventsForUser: [\"GET /users/{username}/events/public\"],\n    listPublicOrgEvents: [\"GET /orgs/{org}/events\"],\n    listReceivedEventsForUser: [\"GET /users/{username}/received_events\"],\n    listReceivedPublicEventsForUser: [\"GET /users/{username}/received_events/public\"],\n    listRepoEvents: [\"GET /repos/{owner}/{repo}/events\"],\n    listRepoNotificationsForAuthenticatedUser: [\"GET /repos/{owner}/{repo}/notifications\"],\n    listReposStarredByAuthenticatedUser: [\"GET /user/starred\"],\n    listReposStarredByUser: [\"GET /users/{username}/starred\"],\n    listReposWatchedByUser: [\"GET /users/{username}/subscriptions\"],\n    listStargazersForRepo: [\"GET /repos/{owner}/{repo}/stargazers\"],\n    listWatchedReposForAuthenticatedUser: [\"GET /user/subscriptions\"],\n    listWatchersForRepo: [\"GET /repos/{owner}/{repo}/subscribers\"],\n    markNotificationsAsRead: [\"PUT /notifications\"],\n    markRepoNotificationsAsRead: [\"PUT /repos/{owner}/{repo}/notifications\"],\n    markThreadAsRead: [\"PATCH /notifications/threads/{thread_id}\"],\n    setRepoSubscription: [\"PUT /repos/{owner}/{repo}/subscription\"],\n    setThreadSubscription: [\"PUT /notifications/threads/{thread_id}/subscription\"],\n    starRepoForAuthenticatedUser: [\"PUT /user/starred/{owner}/{repo}\"],\n    unstarRepoForAuthenticatedUser: [\"DELETE /user/starred/{owner}/{repo}\"]\n  },\n  apps: {\n    addRepoToInstallation: [\"PUT /user/installations/{installation_id}/repositories/{repository_id}\", {}, {\n      renamed: [\"apps\", \"addRepoToInstallationForAuthenticatedUser\"]\n    }],\n    addRepoToInstallationForAuthenticatedUser: [\"PUT /user/installations/{installation_id}/repositories/{repository_id}\"],\n    checkToken: [\"POST /applications/{client_id}/token\"],\n    createFromManifest: [\"POST /app-manifests/{code}/conversions\"],\n    createInstallationAccessToken: [\"POST /app/installations/{installation_id}/access_tokens\"],\n    deleteAuthorization: [\"DELETE /applications/{client_id}/grant\"],\n    deleteInstallation: [\"DELETE /app/installations/{installation_id}\"],\n    deleteToken: [\"DELETE /applications/{client_id}/token\"],\n    getAuthenticated: [\"GET /app\"],\n    getBySlug: [\"GET /apps/{app_slug}\"],\n    getInstallation: [\"GET /app/installations/{installation_id}\"],\n    getOrgInstallation: [\"GET /orgs/{org}/installation\"],\n    getRepoInstallation: [\"GET /repos/{owner}/{repo}/installation\"],\n    getSubscriptionPlanForAccount: [\"GET /marketplace_listing/accounts/{account_id}\"],\n    getSubscriptionPlanForAccountStubbed: [\"GET /marketplace_listing/stubbed/accounts/{account_id}\"],\n    getUserInstallation: [\"GET /users/{username}/installation\"],\n    getWebhookConfigForApp: [\"GET /app/hook/config\"],\n    getWebhookDelivery: [\"GET /app/hook/deliveries/{delivery_id}\"],\n    listAccountsForPlan: [\"GET /marketplace_listing/plans/{plan_id}/accounts\"],\n    listAccountsForPlanStubbed: [\"GET /marketplace_listing/stubbed/plans/{plan_id}/accounts\"],\n    listInstallationReposForAuthenticatedUser: [\"GET /user/installations/{installation_id}/repositories\"],\n    listInstallations: [\"GET /app/installations\"],\n    listInstallationsForAuthenticatedUser: [\"GET /user/installations\"],\n    listPlans: [\"GET /marketplace_listing/plans\"],\n    listPlansStubbed: [\"GET /marketplace_listing/stubbed/plans\"],\n    listReposAccessibleToInstallation: [\"GET /installation/repositories\"],\n    listSubscriptionsForAuthenticatedUser: [\"GET /user/marketplace_purchases\"],\n    listSubscriptionsForAuthenticatedUserStubbed: [\"GET /user/marketplace_purchases/stubbed\"],\n    listWebhookDeliveries: [\"GET /app/hook/deliveries\"],\n    redeliverWebhookDelivery: [\"POST /app/hook/deliveries/{delivery_id}/attempts\"],\n    removeRepoFromInstallation: [\"DELETE /user/installations/{installation_id}/repositories/{repository_id}\", {}, {\n      renamed: [\"apps\", \"removeRepoFromInstallationForAuthenticatedUser\"]\n    }],\n    removeRepoFromInstallationForAuthenticatedUser: [\"DELETE /user/installations/{installation_id}/repositories/{repository_id}\"],\n    resetToken: [\"PATCH /applications/{client_id}/token\"],\n    revokeInstallationAccessToken: [\"DELETE /installation/token\"],\n    scopeToken: [\"POST /applications/{client_id}/token/scoped\"],\n    suspendInstallation: [\"PUT /app/installations/{installation_id}/suspended\"],\n    unsuspendInstallation: [\"DELETE /app/installations/{installation_id}/suspended\"],\n    updateWebhookConfigForApp: [\"PATCH /app/hook/config\"]\n  },\n  billing: {\n    getGithubActionsBillingOrg: [\"GET /orgs/{org}/settings/billing/actions\"],\n    getGithubActionsBillingUser: [\"GET /users/{username}/settings/billing/actions\"],\n    getGithubAdvancedSecurityBillingGhe: [\"GET /enterprises/{enterprise}/settings/billing/advanced-security\"],\n    getGithubAdvancedSecurityBillingOrg: [\"GET /orgs/{org}/settings/billing/advanced-security\"],\n    getGithubPackagesBillingOrg: [\"GET /orgs/{org}/settings/billing/packages\"],\n    getGithubPackagesBillingUser: [\"GET /users/{username}/settings/billing/packages\"],\n    getSharedStorageBillingOrg: [\"GET /orgs/{org}/settings/billing/shared-storage\"],\n    getSharedStorageBillingUser: [\"GET /users/{username}/settings/billing/shared-storage\"]\n  },\n  checks: {\n    create: [\"POST /repos/{owner}/{repo}/check-runs\"],\n    createSuite: [\"POST /repos/{owner}/{repo}/check-suites\"],\n    get: [\"GET /repos/{owner}/{repo}/check-runs/{check_run_id}\"],\n    getSuite: [\"GET /repos/{owner}/{repo}/check-suites/{check_suite_id}\"],\n    listAnnotations: [\"GET /repos/{owner}/{repo}/check-runs/{check_run_id}/annotations\"],\n    listForRef: [\"GET /repos/{owner}/{repo}/commits/{ref}/check-runs\"],\n    listForSuite: [\"GET /repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs\"],\n    listSuitesForRef: [\"GET /repos/{owner}/{repo}/commits/{ref}/check-suites\"],\n    rerequestRun: [\"POST /repos/{owner}/{repo}/check-runs/{check_run_id}/rerequest\"],\n    rerequestSuite: [\"POST /repos/{owner}/{repo}/check-suites/{check_suite_id}/rerequest\"],\n    setSuitesPreferences: [\"PATCH /repos/{owner}/{repo}/check-suites/preferences\"],\n    update: [\"PATCH /repos/{owner}/{repo}/check-runs/{check_run_id}\"]\n  },\n  codeScanning: {\n    deleteAnalysis: [\"DELETE /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}{?confirm_delete}\"],\n    getAlert: [\"GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}\", {}, {\n      renamedParameters: {\n        alert_id: \"alert_number\"\n      }\n    }],\n    getAnalysis: [\"GET /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}\"],\n    getSarif: [\"GET /repos/{owner}/{repo}/code-scanning/sarifs/{sarif_id}\"],\n    listAlertInstances: [\"GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances\"],\n    listAlertsForOrg: [\"GET /orgs/{org}/code-scanning/alerts\"],\n    listAlertsForRepo: [\"GET /repos/{owner}/{repo}/code-scanning/alerts\"],\n    listAlertsInstances: [\"GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances\", {}, {\n      renamed: [\"codeScanning\", \"listAlertInstances\"]\n    }],\n    listRecentAnalyses: [\"GET /repos/{owner}/{repo}/code-scanning/analyses\"],\n    updateAlert: [\"PATCH /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}\"],\n    uploadSarif: [\"POST /repos/{owner}/{repo}/code-scanning/sarifs\"]\n  },\n  codesOfConduct: {\n    getAllCodesOfConduct: [\"GET /codes_of_conduct\"],\n    getConductCode: [\"GET /codes_of_conduct/{key}\"]\n  },\n  codespaces: {\n    addRepositoryForSecretForAuthenticatedUser: [\"PUT /user/codespaces/secrets/{secret_name}/repositories/{repository_id}\"],\n    codespaceMachinesForAuthenticatedUser: [\"GET /user/codespaces/{codespace_name}/machines\"],\n    createForAuthenticatedUser: [\"POST /user/codespaces\"],\n    createOrUpdateRepoSecret: [\"PUT /repos/{owner}/{repo}/codespaces/secrets/{secret_name}\"],\n    createOrUpdateSecretForAuthenticatedUser: [\"PUT /user/codespaces/secrets/{secret_name}\"],\n    createWithPrForAuthenticatedUser: [\"POST /repos/{owner}/{repo}/pulls/{pull_number}/codespaces\"],\n    createWithRepoForAuthenticatedUser: [\"POST /repos/{owner}/{repo}/codespaces\"],\n    deleteForAuthenticatedUser: [\"DELETE /user/codespaces/{codespace_name}\"],\n    deleteFromOrganization: [\"DELETE /orgs/{org}/members/{username}/codespaces/{codespace_name}\"],\n    deleteRepoSecret: [\"DELETE /repos/{owner}/{repo}/codespaces/secrets/{secret_name}\"],\n    deleteSecretForAuthenticatedUser: [\"DELETE /user/codespaces/secrets/{secret_name}\"],\n    exportForAuthenticatedUser: [\"POST /user/codespaces/{codespace_name}/exports\"],\n    getExportDetailsForAuthenticatedUser: [\"GET /user/codespaces/{codespace_name}/exports/{export_id}\"],\n    getForAuthenticatedUser: [\"GET /user/codespaces/{codespace_name}\"],\n    getPublicKeyForAuthenticatedUser: [\"GET /user/codespaces/secrets/public-key\"],\n    getRepoPublicKey: [\"GET /repos/{owner}/{repo}/codespaces/secrets/public-key\"],\n    getRepoSecret: [\"GET /repos/{owner}/{repo}/codespaces/secrets/{secret_name}\"],\n    getSecretForAuthenticatedUser: [\"GET /user/codespaces/secrets/{secret_name}\"],\n    listDevcontainersInRepositoryForAuthenticatedUser: [\"GET /repos/{owner}/{repo}/codespaces/devcontainers\"],\n    listForAuthenticatedUser: [\"GET /user/codespaces\"],\n    listInOrganization: [\"GET /orgs/{org}/codespaces\", {}, {\n      renamedParameters: {\n        org_id: \"org\"\n      }\n    }],\n    listInRepositoryForAuthenticatedUser: [\"GET /repos/{owner}/{repo}/codespaces\"],\n    listRepoSecrets: [\"GET /repos/{owner}/{repo}/codespaces/secrets\"],\n    listRepositoriesForSecretForAuthenticatedUser: [\"GET /user/codespaces/secrets/{secret_name}/repositories\"],\n    listSecretsForAuthenticatedUser: [\"GET /user/codespaces/secrets\"],\n    removeRepositoryForSecretForAuthenticatedUser: [\"DELETE /user/codespaces/secrets/{secret_name}/repositories/{repository_id}\"],\n    repoMachinesForAuthenticatedUser: [\"GET /repos/{owner}/{repo}/codespaces/machines\"],\n    setRepositoriesForSecretForAuthenticatedUser: [\"PUT /user/codespaces/secrets/{secret_name}/repositories\"],\n    startForAuthenticatedUser: [\"POST /user/codespaces/{codespace_name}/start\"],\n    stopForAuthenticatedUser: [\"POST /user/codespaces/{codespace_name}/stop\"],\n    stopInOrganization: [\"POST /orgs/{org}/members/{username}/codespaces/{codespace_name}/stop\"],\n    updateForAuthenticatedUser: [\"PATCH /user/codespaces/{codespace_name}\"]\n  },\n  dependabot: {\n    addSelectedRepoToOrgSecret: [\"PUT /orgs/{org}/dependabot/secrets/{secret_name}/repositories/{repository_id}\"],\n    createOrUpdateOrgSecret: [\"PUT /orgs/{org}/dependabot/secrets/{secret_name}\"],\n    createOrUpdateRepoSecret: [\"PUT /repos/{owner}/{repo}/dependabot/secrets/{secret_name}\"],\n    deleteOrgSecret: [\"DELETE /orgs/{org}/dependabot/secrets/{secret_name}\"],\n    deleteRepoSecret: [\"DELETE /repos/{owner}/{repo}/dependabot/secrets/{secret_name}\"],\n    getOrgPublicKey: [\"GET /orgs/{org}/dependabot/secrets/public-key\"],\n    getOrgSecret: [\"GET /orgs/{org}/dependabot/secrets/{secret_name}\"],\n    getRepoPublicKey: [\"GET /repos/{owner}/{repo}/dependabot/secrets/public-key\"],\n    getRepoSecret: [\"GET /repos/{owner}/{repo}/dependabot/secrets/{secret_name}\"],\n    listOrgSecrets: [\"GET /orgs/{org}/dependabot/secrets\"],\n    listRepoSecrets: [\"GET /repos/{owner}/{repo}/dependabot/secrets\"],\n    listSelectedReposForOrgSecret: [\"GET /orgs/{org}/dependabot/secrets/{secret_name}/repositories\"],\n    removeSelectedRepoFromOrgSecret: [\"DELETE /orgs/{org}/dependabot/secrets/{secret_name}/repositories/{repository_id}\"],\n    setSelectedReposForOrgSecret: [\"PUT /orgs/{org}/dependabot/secrets/{secret_name}/repositories\"]\n  },\n  dependencyGraph: {\n    createRepositorySnapshot: [\"POST /repos/{owner}/{repo}/dependency-graph/snapshots\"],\n    diffRange: [\"GET /repos/{owner}/{repo}/dependency-graph/compare/{basehead}\"]\n  },\n  emojis: {\n    get: [\"GET /emojis\"]\n  },\n  enterpriseAdmin: {\n    addCustomLabelsToSelfHostedRunnerForEnterprise: [\"POST /enterprises/{enterprise}/actions/runners/{runner_id}/labels\"],\n    disableSelectedOrganizationGithubActionsEnterprise: [\"DELETE /enterprises/{enterprise}/actions/permissions/organizations/{org_id}\"],\n    enableSelectedOrganizationGithubActionsEnterprise: [\"PUT /enterprises/{enterprise}/actions/permissions/organizations/{org_id}\"],\n    getAllowedActionsEnterprise: [\"GET /enterprises/{enterprise}/actions/permissions/selected-actions\"],\n    getGithubActionsPermissionsEnterprise: [\"GET /enterprises/{enterprise}/actions/permissions\"],\n    getServerStatistics: [\"GET /enterprise-installation/{enterprise_or_org}/server-statistics\"],\n    listLabelsForSelfHostedRunnerForEnterprise: [\"GET /enterprises/{enterprise}/actions/runners/{runner_id}/labels\"],\n    listSelectedOrganizationsEnabledGithubActionsEnterprise: [\"GET /enterprises/{enterprise}/actions/permissions/organizations\"],\n    removeAllCustomLabelsFromSelfHostedRunnerForEnterprise: [\"DELETE /enterprises/{enterprise}/actions/runners/{runner_id}/labels\"],\n    removeCustomLabelFromSelfHostedRunnerForEnterprise: [\"DELETE /enterprises/{enterprise}/actions/runners/{runner_id}/labels/{name}\"],\n    setAllowedActionsEnterprise: [\"PUT /enterprises/{enterprise}/actions/permissions/selected-actions\"],\n    setCustomLabelsForSelfHostedRunnerForEnterprise: [\"PUT /enterprises/{enterprise}/actions/runners/{runner_id}/labels\"],\n    setGithubActionsPermissionsEnterprise: [\"PUT /enterprises/{enterprise}/actions/permissions\"],\n    setSelectedOrganizationsEnabledGithubActionsEnterprise: [\"PUT /enterprises/{enterprise}/actions/permissions/organizations\"]\n  },\n  gists: {\n    checkIsStarred: [\"GET /gists/{gist_id}/star\"],\n    create: [\"POST /gists\"],\n    createComment: [\"POST /gists/{gist_id}/comments\"],\n    delete: [\"DELETE /gists/{gist_id}\"],\n    deleteComment: [\"DELETE /gists/{gist_id}/comments/{comment_id}\"],\n    fork: [\"POST /gists/{gist_id}/forks\"],\n    get: [\"GET /gists/{gist_id}\"],\n    getComment: [\"GET /gists/{gist_id}/comments/{comment_id}\"],\n    getRevision: [\"GET /gists/{gist_id}/{sha}\"],\n    list: [\"GET /gists\"],\n    listComments: [\"GET /gists/{gist_id}/comments\"],\n    listCommits: [\"GET /gists/{gist_id}/commits\"],\n    listForUser: [\"GET /users/{username}/gists\"],\n    listForks: [\"GET /gists/{gist_id}/forks\"],\n    listPublic: [\"GET /gists/public\"],\n    listStarred: [\"GET /gists/starred\"],\n    star: [\"PUT /gists/{gist_id}/star\"],\n    unstar: [\"DELETE /gists/{gist_id}/star\"],\n    update: [\"PATCH /gists/{gist_id}\"],\n    updateComment: [\"PATCH /gists/{gist_id}/comments/{comment_id}\"]\n  },\n  git: {\n    createBlob: [\"POST /repos/{owner}/{repo}/git/blobs\"],\n    createCommit: [\"POST /repos/{owner}/{repo}/git/commits\"],\n    createRef: [\"POST /repos/{owner}/{repo}/git/refs\"],\n    createTag: [\"POST /repos/{owner}/{repo}/git/tags\"],\n    createTree: [\"POST /repos/{owner}/{repo}/git/trees\"],\n    deleteRef: [\"DELETE /repos/{owner}/{repo}/git/refs/{ref}\"],\n    getBlob: [\"GET /repos/{owner}/{repo}/git/blobs/{file_sha}\"],\n    getCommit: [\"GET /repos/{owner}/{repo}/git/commits/{commit_sha}\"],\n    getRef: [\"GET /repos/{owner}/{repo}/git/ref/{ref}\"],\n    getTag: [\"GET /repos/{owner}/{repo}/git/tags/{tag_sha}\"],\n    getTree: [\"GET /repos/{owner}/{repo}/git/trees/{tree_sha}\"],\n    listMatchingRefs: [\"GET /repos/{owner}/{repo}/git/matching-refs/{ref}\"],\n    updateRef: [\"PATCH /repos/{owner}/{repo}/git/refs/{ref}\"]\n  },\n  gitignore: {\n    getAllTemplates: [\"GET /gitignore/templates\"],\n    getTemplate: [\"GET /gitignore/templates/{name}\"]\n  },\n  interactions: {\n    getRestrictionsForAuthenticatedUser: [\"GET /user/interaction-limits\"],\n    getRestrictionsForOrg: [\"GET /orgs/{org}/interaction-limits\"],\n    getRestrictionsForRepo: [\"GET /repos/{owner}/{repo}/interaction-limits\"],\n    getRestrictionsForYourPublicRepos: [\"GET /user/interaction-limits\", {}, {\n      renamed: [\"interactions\", \"getRestrictionsForAuthenticatedUser\"]\n    }],\n    removeRestrictionsForAuthenticatedUser: [\"DELETE /user/interaction-limits\"],\n    removeRestrictionsForOrg: [\"DELETE /orgs/{org}/interaction-limits\"],\n    removeRestrictionsForRepo: [\"DELETE /repos/{owner}/{repo}/interaction-limits\"],\n    removeRestrictionsForYourPublicRepos: [\"DELETE /user/interaction-limits\", {}, {\n      renamed: [\"interactions\", \"removeRestrictionsForAuthenticatedUser\"]\n    }],\n    setRestrictionsForAuthenticatedUser: [\"PUT /user/interaction-limits\"],\n    setRestrictionsForOrg: [\"PUT /orgs/{org}/interaction-limits\"],\n    setRestrictionsForRepo: [\"PUT /repos/{owner}/{repo}/interaction-limits\"],\n    setRestrictionsForYourPublicRepos: [\"PUT /user/interaction-limits\", {}, {\n      renamed: [\"interactions\", \"setRestrictionsForAuthenticatedUser\"]\n    }]\n  },\n  issues: {\n    addAssignees: [\"POST /repos/{owner}/{repo}/issues/{issue_number}/assignees\"],\n    addLabels: [\"POST /repos/{owner}/{repo}/issues/{issue_number}/labels\"],\n    checkUserCanBeAssigned: [\"GET /repos/{owner}/{repo}/assignees/{assignee}\"],\n    create: [\"POST /repos/{owner}/{repo}/issues\"],\n    createComment: [\"POST /repos/{owner}/{repo}/issues/{issue_number}/comments\"],\n    createLabel: [\"POST /repos/{owner}/{repo}/labels\"],\n    createMilestone: [\"POST /repos/{owner}/{repo}/milestones\"],\n    deleteComment: [\"DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}\"],\n    deleteLabel: [\"DELETE /repos/{owner}/{repo}/labels/{name}\"],\n    deleteMilestone: [\"DELETE /repos/{owner}/{repo}/milestones/{milestone_number}\"],\n    get: [\"GET /repos/{owner}/{repo}/issues/{issue_number}\"],\n    getComment: [\"GET /repos/{owner}/{repo}/issues/comments/{comment_id}\"],\n    getEvent: [\"GET /repos/{owner}/{repo}/issues/events/{event_id}\"],\n    getLabel: [\"GET /repos/{owner}/{repo}/labels/{name}\"],\n    getMilestone: [\"GET /repos/{owner}/{repo}/milestones/{milestone_number}\"],\n    list: [\"GET /issues\"],\n    listAssignees: [\"GET /repos/{owner}/{repo}/assignees\"],\n    listComments: [\"GET /repos/{owner}/{repo}/issues/{issue_number}/comments\"],\n    listCommentsForRepo: [\"GET /repos/{owner}/{repo}/issues/comments\"],\n    listEvents: [\"GET /repos/{owner}/{repo}/issues/{issue_number}/events\"],\n    listEventsForRepo: [\"GET /repos/{owner}/{repo}/issues/events\"],\n    listEventsForTimeline: [\"GET /repos/{owner}/{repo}/issues/{issue_number}/timeline\"],\n    listForAuthenticatedUser: [\"GET /user/issues\"],\n    listForOrg: [\"GET /orgs/{org}/issues\"],\n    listForRepo: [\"GET /repos/{owner}/{repo}/issues\"],\n    listLabelsForMilestone: [\"GET /repos/{owner}/{repo}/milestones/{milestone_number}/labels\"],\n    listLabelsForRepo: [\"GET /repos/{owner}/{repo}/labels\"],\n    listLabelsOnIssue: [\"GET /repos/{owner}/{repo}/issues/{issue_number}/labels\"],\n    listMilestones: [\"GET /repos/{owner}/{repo}/milestones\"],\n    lock: [\"PUT /repos/{owner}/{repo}/issues/{issue_number}/lock\"],\n    removeAllLabels: [\"DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels\"],\n    removeAssignees: [\"DELETE /repos/{owner}/{repo}/issues/{issue_number}/assignees\"],\n    removeLabel: [\"DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels/{name}\"],\n    setLabels: [\"PUT /repos/{owner}/{repo}/issues/{issue_number}/labels\"],\n    unlock: [\"DELETE /repos/{owner}/{repo}/issues/{issue_number}/lock\"],\n    update: [\"PATCH /repos/{owner}/{repo}/issues/{issue_number}\"],\n    updateComment: [\"PATCH /repos/{owner}/{repo}/issues/comments/{comment_id}\"],\n    updateLabel: [\"PATCH /repos/{owner}/{repo}/labels/{name}\"],\n    updateMilestone: [\"PATCH /repos/{owner}/{repo}/milestones/{milestone_number}\"]\n  },\n  licenses: {\n    get: [\"GET /licenses/{license}\"],\n    getAllCommonlyUsed: [\"GET /licenses\"],\n    getForRepo: [\"GET /repos/{owner}/{repo}/license\"]\n  },\n  markdown: {\n    render: [\"POST /markdown\"],\n    renderRaw: [\"POST /markdown/raw\", {\n      headers: {\n        \"content-type\": \"text/plain; charset=utf-8\"\n      }\n    }]\n  },\n  meta: {\n    get: [\"GET /meta\"],\n    getOctocat: [\"GET /octocat\"],\n    getZen: [\"GET /zen\"],\n    root: [\"GET /\"]\n  },\n  migrations: {\n    cancelImport: [\"DELETE /repos/{owner}/{repo}/import\"],\n    deleteArchiveForAuthenticatedUser: [\"DELETE /user/migrations/{migration_id}/archive\"],\n    deleteArchiveForOrg: [\"DELETE /orgs/{org}/migrations/{migration_id}/archive\"],\n    downloadArchiveForOrg: [\"GET /orgs/{org}/migrations/{migration_id}/archive\"],\n    getArchiveForAuthenticatedUser: [\"GET /user/migrations/{migration_id}/archive\"],\n    getCommitAuthors: [\"GET /repos/{owner}/{repo}/import/authors\"],\n    getImportStatus: [\"GET /repos/{owner}/{repo}/import\"],\n    getLargeFiles: [\"GET /repos/{owner}/{repo}/import/large_files\"],\n    getStatusForAuthenticatedUser: [\"GET /user/migrations/{migration_id}\"],\n    getStatusForOrg: [\"GET /orgs/{org}/migrations/{migration_id}\"],\n    listForAuthenticatedUser: [\"GET /user/migrations\"],\n    listForOrg: [\"GET /orgs/{org}/migrations\"],\n    listReposForAuthenticatedUser: [\"GET /user/migrations/{migration_id}/repositories\"],\n    listReposForOrg: [\"GET /orgs/{org}/migrations/{migration_id}/repositories\"],\n    listReposForUser: [\"GET /user/migrations/{migration_id}/repositories\", {}, {\n      renamed: [\"migrations\", \"listReposForAuthenticatedUser\"]\n    }],\n    mapCommitAuthor: [\"PATCH /repos/{owner}/{repo}/import/authors/{author_id}\"],\n    setLfsPreference: [\"PATCH /repos/{owner}/{repo}/import/lfs\"],\n    startForAuthenticatedUser: [\"POST /user/migrations\"],\n    startForOrg: [\"POST /orgs/{org}/migrations\"],\n    startImport: [\"PUT /repos/{owner}/{repo}/import\"],\n    unlockRepoForAuthenticatedUser: [\"DELETE /user/migrations/{migration_id}/repos/{repo_name}/lock\"],\n    unlockRepoForOrg: [\"DELETE /orgs/{org}/migrations/{migration_id}/repos/{repo_name}/lock\"],\n    updateImport: [\"PATCH /repos/{owner}/{repo}/import\"]\n  },\n  orgs: {\n    blockUser: [\"PUT /orgs/{org}/blocks/{username}\"],\n    cancelInvitation: [\"DELETE /orgs/{org}/invitations/{invitation_id}\"],\n    checkBlockedUser: [\"GET /orgs/{org}/blocks/{username}\"],\n    checkMembershipForUser: [\"GET /orgs/{org}/members/{username}\"],\n    checkPublicMembershipForUser: [\"GET /orgs/{org}/public_members/{username}\"],\n    convertMemberToOutsideCollaborator: [\"PUT /orgs/{org}/outside_collaborators/{username}\"],\n    createInvitation: [\"POST /orgs/{org}/invitations\"],\n    createWebhook: [\"POST /orgs/{org}/hooks\"],\n    deleteWebhook: [\"DELETE /orgs/{org}/hooks/{hook_id}\"],\n    get: [\"GET /orgs/{org}\"],\n    getMembershipForAuthenticatedUser: [\"GET /user/memberships/orgs/{org}\"],\n    getMembershipForUser: [\"GET /orgs/{org}/memberships/{username}\"],\n    getWebhook: [\"GET /orgs/{org}/hooks/{hook_id}\"],\n    getWebhookConfigForOrg: [\"GET /orgs/{org}/hooks/{hook_id}/config\"],\n    getWebhookDelivery: [\"GET /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}\"],\n    list: [\"GET /organizations\"],\n    listAppInstallations: [\"GET /orgs/{org}/installations\"],\n    listBlockedUsers: [\"GET /orgs/{org}/blocks\"],\n    listCustomRoles: [\"GET /organizations/{organization_id}/custom_roles\"],\n    listFailedInvitations: [\"GET /orgs/{org}/failed_invitations\"],\n    listForAuthenticatedUser: [\"GET /user/orgs\"],\n    listForUser: [\"GET /users/{username}/orgs\"],\n    listInvitationTeams: [\"GET /orgs/{org}/invitations/{invitation_id}/teams\"],\n    listMembers: [\"GET /orgs/{org}/members\"],\n    listMembershipsForAuthenticatedUser: [\"GET /user/memberships/orgs\"],\n    listOutsideCollaborators: [\"GET /orgs/{org}/outside_collaborators\"],\n    listPendingInvitations: [\"GET /orgs/{org}/invitations\"],\n    listPublicMembers: [\"GET /orgs/{org}/public_members\"],\n    listWebhookDeliveries: [\"GET /orgs/{org}/hooks/{hook_id}/deliveries\"],\n    listWebhooks: [\"GET /orgs/{org}/hooks\"],\n    pingWebhook: [\"POST /orgs/{org}/hooks/{hook_id}/pings\"],\n    redeliverWebhookDelivery: [\"POST /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}/attempts\"],\n    removeMember: [\"DELETE /orgs/{org}/members/{username}\"],\n    removeMembershipForUser: [\"DELETE /orgs/{org}/memberships/{username}\"],\n    removeOutsideCollaborator: [\"DELETE /orgs/{org}/outside_collaborators/{username}\"],\n    removePublicMembershipForAuthenticatedUser: [\"DELETE /orgs/{org}/public_members/{username}\"],\n    setMembershipForUser: [\"PUT /orgs/{org}/memberships/{username}\"],\n    setPublicMembershipForAuthenticatedUser: [\"PUT /orgs/{org}/public_members/{username}\"],\n    unblockUser: [\"DELETE /orgs/{org}/blocks/{username}\"],\n    update: [\"PATCH /orgs/{org}\"],\n    updateMembershipForAuthenticatedUser: [\"PATCH /user/memberships/orgs/{org}\"],\n    updateWebhook: [\"PATCH /orgs/{org}/hooks/{hook_id}\"],\n    updateWebhookConfigForOrg: [\"PATCH /orgs/{org}/hooks/{hook_id}/config\"]\n  },\n  packages: {\n    deletePackageForAuthenticatedUser: [\"DELETE /user/packages/{package_type}/{package_name}\"],\n    deletePackageForOrg: [\"DELETE /orgs/{org}/packages/{package_type}/{package_name}\"],\n    deletePackageForUser: [\"DELETE /users/{username}/packages/{package_type}/{package_name}\"],\n    deletePackageVersionForAuthenticatedUser: [\"DELETE /user/packages/{package_type}/{package_name}/versions/{package_version_id}\"],\n    deletePackageVersionForOrg: [\"DELETE /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}\"],\n    deletePackageVersionForUser: [\"DELETE /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}\"],\n    getAllPackageVersionsForAPackageOwnedByAnOrg: [\"GET /orgs/{org}/packages/{package_type}/{package_name}/versions\", {}, {\n      renamed: [\"packages\", \"getAllPackageVersionsForPackageOwnedByOrg\"]\n    }],\n    getAllPackageVersionsForAPackageOwnedByTheAuthenticatedUser: [\"GET /user/packages/{package_type}/{package_name}/versions\", {}, {\n      renamed: [\"packages\", \"getAllPackageVersionsForPackageOwnedByAuthenticatedUser\"]\n    }],\n    getAllPackageVersionsForPackageOwnedByAuthenticatedUser: [\"GET /user/packages/{package_type}/{package_name}/versions\"],\n    getAllPackageVersionsForPackageOwnedByOrg: [\"GET /orgs/{org}/packages/{package_type}/{package_name}/versions\"],\n    getAllPackageVersionsForPackageOwnedByUser: [\"GET /users/{username}/packages/{package_type}/{package_name}/versions\"],\n    getPackageForAuthenticatedUser: [\"GET /user/packages/{package_type}/{package_name}\"],\n    getPackageForOrganization: [\"GET /orgs/{org}/packages/{package_type}/{package_name}\"],\n    getPackageForUser: [\"GET /users/{username}/packages/{package_type}/{package_name}\"],\n    getPackageVersionForAuthenticatedUser: [\"GET /user/packages/{package_type}/{package_name}/versions/{package_version_id}\"],\n    getPackageVersionForOrganization: [\"GET /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}\"],\n    getPackageVersionForUser: [\"GET /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}\"],\n    listPackagesForAuthenticatedUser: [\"GET /user/packages\"],\n    listPackagesForOrganization: [\"GET /orgs/{org}/packages\"],\n    listPackagesForUser: [\"GET /users/{username}/packages\"],\n    restorePackageForAuthenticatedUser: [\"POST /user/packages/{package_type}/{package_name}/restore{?token}\"],\n    restorePackageForOrg: [\"POST /orgs/{org}/packages/{package_type}/{package_name}/restore{?token}\"],\n    restorePackageForUser: [\"POST /users/{username}/packages/{package_type}/{package_name}/restore{?token}\"],\n    restorePackageVersionForAuthenticatedUser: [\"POST /user/packages/{package_type}/{package_name}/versions/{package_version_id}/restore\"],\n    restorePackageVersionForOrg: [\"POST /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore\"],\n    restorePackageVersionForUser: [\"POST /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore\"]\n  },\n  projects: {\n    addCollaborator: [\"PUT /projects/{project_id}/collaborators/{username}\"],\n    createCard: [\"POST /projects/columns/{column_id}/cards\"],\n    createColumn: [\"POST /projects/{project_id}/columns\"],\n    createForAuthenticatedUser: [\"POST /user/projects\"],\n    createForOrg: [\"POST /orgs/{org}/projects\"],\n    createForRepo: [\"POST /repos/{owner}/{repo}/projects\"],\n    delete: [\"DELETE /projects/{project_id}\"],\n    deleteCard: [\"DELETE /projects/columns/cards/{card_id}\"],\n    deleteColumn: [\"DELETE /projects/columns/{column_id}\"],\n    get: [\"GET /projects/{project_id}\"],\n    getCard: [\"GET /projects/columns/cards/{card_id}\"],\n    getColumn: [\"GET /projects/columns/{column_id}\"],\n    getPermissionForUser: [\"GET /projects/{project_id}/collaborators/{username}/permission\"],\n    listCards: [\"GET /projects/columns/{column_id}/cards\"],\n    listCollaborators: [\"GET /projects/{project_id}/collaborators\"],\n    listColumns: [\"GET /projects/{project_id}/columns\"],\n    listForOrg: [\"GET /orgs/{org}/projects\"],\n    listForRepo: [\"GET /repos/{owner}/{repo}/projects\"],\n    listForUser: [\"GET /users/{username}/projects\"],\n    moveCard: [\"POST /projects/columns/cards/{card_id}/moves\"],\n    moveColumn: [\"POST /projects/columns/{column_id}/moves\"],\n    removeCollaborator: [\"DELETE /projects/{project_id}/collaborators/{username}\"],\n    update: [\"PATCH /projects/{project_id}\"],\n    updateCard: [\"PATCH /projects/columns/cards/{card_id}\"],\n    updateColumn: [\"PATCH /projects/columns/{column_id}\"]\n  },\n  pulls: {\n    checkIfMerged: [\"GET /repos/{owner}/{repo}/pulls/{pull_number}/merge\"],\n    create: [\"POST /repos/{owner}/{repo}/pulls\"],\n    createReplyForReviewComment: [\"POST /repos/{owner}/{repo}/pulls/{pull_number}/comments/{comment_id}/replies\"],\n    createReview: [\"POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews\"],\n    createReviewComment: [\"POST /repos/{owner}/{repo}/pulls/{pull_number}/comments\"],\n    deletePendingReview: [\"DELETE /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}\"],\n    deleteReviewComment: [\"DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}\"],\n    dismissReview: [\"PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/dismissals\"],\n    get: [\"GET /repos/{owner}/{repo}/pulls/{pull_number}\"],\n    getReview: [\"GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}\"],\n    getReviewComment: [\"GET /repos/{owner}/{repo}/pulls/comments/{comment_id}\"],\n    list: [\"GET /repos/{owner}/{repo}/pulls\"],\n    listCommentsForReview: [\"GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments\"],\n    listCommits: [\"GET /repos/{owner}/{repo}/pulls/{pull_number}/commits\"],\n    listFiles: [\"GET /repos/{owner}/{repo}/pulls/{pull_number}/files\"],\n    listRequestedReviewers: [\"GET /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers\"],\n    listReviewComments: [\"GET /repos/{owner}/{repo}/pulls/{pull_number}/comments\"],\n    listReviewCommentsForRepo: [\"GET /repos/{owner}/{repo}/pulls/comments\"],\n    listReviews: [\"GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews\"],\n    merge: [\"PUT /repos/{owner}/{repo}/pulls/{pull_number}/merge\"],\n    removeRequestedReviewers: [\"DELETE /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers\"],\n    requestReviewers: [\"POST /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers\"],\n    submitReview: [\"POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/events\"],\n    update: [\"PATCH /repos/{owner}/{repo}/pulls/{pull_number}\"],\n    updateBranch: [\"PUT /repos/{owner}/{repo}/pulls/{pull_number}/update-branch\"],\n    updateReview: [\"PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}\"],\n    updateReviewComment: [\"PATCH /repos/{owner}/{repo}/pulls/comments/{comment_id}\"]\n  },\n  rateLimit: {\n    get: [\"GET /rate_limit\"]\n  },\n  reactions: {\n    createForCommitComment: [\"POST /repos/{owner}/{repo}/comments/{comment_id}/reactions\"],\n    createForIssue: [\"POST /repos/{owner}/{repo}/issues/{issue_number}/reactions\"],\n    createForIssueComment: [\"POST /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions\"],\n    createForPullRequestReviewComment: [\"POST /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions\"],\n    createForRelease: [\"POST /repos/{owner}/{repo}/releases/{release_id}/reactions\"],\n    createForTeamDiscussionCommentInOrg: [\"POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions\"],\n    createForTeamDiscussionInOrg: [\"POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions\"],\n    deleteForCommitComment: [\"DELETE /repos/{owner}/{repo}/comments/{comment_id}/reactions/{reaction_id}\"],\n    deleteForIssue: [\"DELETE /repos/{owner}/{repo}/issues/{issue_number}/reactions/{reaction_id}\"],\n    deleteForIssueComment: [\"DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions/{reaction_id}\"],\n    deleteForPullRequestComment: [\"DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions/{reaction_id}\"],\n    deleteForRelease: [\"DELETE /repos/{owner}/{repo}/releases/{release_id}/reactions/{reaction_id}\"],\n    deleteForTeamDiscussion: [\"DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions/{reaction_id}\"],\n    deleteForTeamDiscussionComment: [\"DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions/{reaction_id}\"],\n    listForCommitComment: [\"GET /repos/{owner}/{repo}/comments/{comment_id}/reactions\"],\n    listForIssue: [\"GET /repos/{owner}/{repo}/issues/{issue_number}/reactions\"],\n    listForIssueComment: [\"GET /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions\"],\n    listForPullRequestReviewComment: [\"GET /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions\"],\n    listForRelease: [\"GET /repos/{owner}/{repo}/releases/{release_id}/reactions\"],\n    listForTeamDiscussionCommentInOrg: [\"GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions\"],\n    listForTeamDiscussionInOrg: [\"GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions\"]\n  },\n  repos: {\n    acceptInvitation: [\"PATCH /user/repository_invitations/{invitation_id}\", {}, {\n      renamed: [\"repos\", \"acceptInvitationForAuthenticatedUser\"]\n    }],\n    acceptInvitationForAuthenticatedUser: [\"PATCH /user/repository_invitations/{invitation_id}\"],\n    addAppAccessRestrictions: [\"POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps\", {}, {\n      mapToData: \"apps\"\n    }],\n    addCollaborator: [\"PUT /repos/{owner}/{repo}/collaborators/{username}\"],\n    addStatusCheckContexts: [\"POST /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts\", {}, {\n      mapToData: \"contexts\"\n    }],\n    addTeamAccessRestrictions: [\"POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams\", {}, {\n      mapToData: \"teams\"\n    }],\n    addUserAccessRestrictions: [\"POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users\", {}, {\n      mapToData: \"users\"\n    }],\n    checkCollaborator: [\"GET /repos/{owner}/{repo}/collaborators/{username}\"],\n    checkVulnerabilityAlerts: [\"GET /repos/{owner}/{repo}/vulnerability-alerts\"],\n    codeownersErrors: [\"GET /repos/{owner}/{repo}/codeowners/errors\"],\n    compareCommits: [\"GET /repos/{owner}/{repo}/compare/{base}...{head}\"],\n    compareCommitsWithBasehead: [\"GET /repos/{owner}/{repo}/compare/{basehead}\"],\n    createAutolink: [\"POST /repos/{owner}/{repo}/autolinks\"],\n    createCommitComment: [\"POST /repos/{owner}/{repo}/commits/{commit_sha}/comments\"],\n    createCommitSignatureProtection: [\"POST /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures\"],\n    createCommitStatus: [\"POST /repos/{owner}/{repo}/statuses/{sha}\"],\n    createDeployKey: [\"POST /repos/{owner}/{repo}/keys\"],\n    createDeployment: [\"POST /repos/{owner}/{repo}/deployments\"],\n    createDeploymentStatus: [\"POST /repos/{owner}/{repo}/deployments/{deployment_id}/statuses\"],\n    createDispatchEvent: [\"POST /repos/{owner}/{repo}/dispatches\"],\n    createForAuthenticatedUser: [\"POST /user/repos\"],\n    createFork: [\"POST /repos/{owner}/{repo}/forks\"],\n    createInOrg: [\"POST /orgs/{org}/repos\"],\n    createOrUpdateEnvironment: [\"PUT /repos/{owner}/{repo}/environments/{environment_name}\"],\n    createOrUpdateFileContents: [\"PUT /repos/{owner}/{repo}/contents/{path}\"],\n    createPagesSite: [\"POST /repos/{owner}/{repo}/pages\"],\n    createRelease: [\"POST /repos/{owner}/{repo}/releases\"],\n    createTagProtection: [\"POST /repos/{owner}/{repo}/tags/protection\"],\n    createUsingTemplate: [\"POST /repos/{template_owner}/{template_repo}/generate\"],\n    createWebhook: [\"POST /repos/{owner}/{repo}/hooks\"],\n    declineInvitation: [\"DELETE /user/repository_invitations/{invitation_id}\", {}, {\n      renamed: [\"repos\", \"declineInvitationForAuthenticatedUser\"]\n    }],\n    declineInvitationForAuthenticatedUser: [\"DELETE /user/repository_invitations/{invitation_id}\"],\n    delete: [\"DELETE /repos/{owner}/{repo}\"],\n    deleteAccessRestrictions: [\"DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions\"],\n    deleteAdminBranchProtection: [\"DELETE /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins\"],\n    deleteAnEnvironment: [\"DELETE /repos/{owner}/{repo}/environments/{environment_name}\"],\n    deleteAutolink: [\"DELETE /repos/{owner}/{repo}/autolinks/{autolink_id}\"],\n    deleteBranchProtection: [\"DELETE /repos/{owner}/{repo}/branches/{branch}/protection\"],\n    deleteCommitComment: [\"DELETE /repos/{owner}/{repo}/comments/{comment_id}\"],\n    deleteCommitSignatureProtection: [\"DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures\"],\n    deleteDeployKey: [\"DELETE /repos/{owner}/{repo}/keys/{key_id}\"],\n    deleteDeployment: [\"DELETE /repos/{owner}/{repo}/deployments/{deployment_id}\"],\n    deleteFile: [\"DELETE /repos/{owner}/{repo}/contents/{path}\"],\n    deleteInvitation: [\"DELETE /repos/{owner}/{repo}/invitations/{invitation_id}\"],\n    deletePagesSite: [\"DELETE /repos/{owner}/{repo}/pages\"],\n    deletePullRequestReviewProtection: [\"DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews\"],\n    deleteRelease: [\"DELETE /repos/{owner}/{repo}/releases/{release_id}\"],\n    deleteReleaseAsset: [\"DELETE /repos/{owner}/{repo}/releases/assets/{asset_id}\"],\n    deleteTagProtection: [\"DELETE /repos/{owner}/{repo}/tags/protection/{tag_protection_id}\"],\n    deleteWebhook: [\"DELETE /repos/{owner}/{repo}/hooks/{hook_id}\"],\n    disableAutomatedSecurityFixes: [\"DELETE /repos/{owner}/{repo}/automated-security-fixes\"],\n    disableLfsForRepo: [\"DELETE /repos/{owner}/{repo}/lfs\"],\n    disableVulnerabilityAlerts: [\"DELETE /repos/{owner}/{repo}/vulnerability-alerts\"],\n    downloadArchive: [\"GET /repos/{owner}/{repo}/zipball/{ref}\", {}, {\n      renamed: [\"repos\", \"downloadZipballArchive\"]\n    }],\n    downloadTarballArchive: [\"GET /repos/{owner}/{repo}/tarball/{ref}\"],\n    downloadZipballArchive: [\"GET /repos/{owner}/{repo}/zipball/{ref}\"],\n    enableAutomatedSecurityFixes: [\"PUT /repos/{owner}/{repo}/automated-security-fixes\"],\n    enableLfsForRepo: [\"PUT /repos/{owner}/{repo}/lfs\"],\n    enableVulnerabilityAlerts: [\"PUT /repos/{owner}/{repo}/vulnerability-alerts\"],\n    generateReleaseNotes: [\"POST /repos/{owner}/{repo}/releases/generate-notes\"],\n    get: [\"GET /repos/{owner}/{repo}\"],\n    getAccessRestrictions: [\"GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions\"],\n    getAdminBranchProtection: [\"GET /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins\"],\n    getAllEnvironments: [\"GET /repos/{owner}/{repo}/environments\"],\n    getAllStatusCheckContexts: [\"GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts\"],\n    getAllTopics: [\"GET /repos/{owner}/{repo}/topics\"],\n    getAppsWithAccessToProtectedBranch: [\"GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps\"],\n    getAutolink: [\"GET /repos/{owner}/{repo}/autolinks/{autolink_id}\"],\n    getBranch: [\"GET /repos/{owner}/{repo}/branches/{branch}\"],\n    getBranchProtection: [\"GET /repos/{owner}/{repo}/branches/{branch}/protection\"],\n    getClones: [\"GET /repos/{owner}/{repo}/traffic/clones\"],\n    getCodeFrequencyStats: [\"GET /repos/{owner}/{repo}/stats/code_frequency\"],\n    getCollaboratorPermissionLevel: [\"GET /repos/{owner}/{repo}/collaborators/{username}/permission\"],\n    getCombinedStatusForRef: [\"GET /repos/{owner}/{repo}/commits/{ref}/status\"],\n    getCommit: [\"GET /repos/{owner}/{repo}/commits/{ref}\"],\n    getCommitActivityStats: [\"GET /repos/{owner}/{repo}/stats/commit_activity\"],\n    getCommitComment: [\"GET /repos/{owner}/{repo}/comments/{comment_id}\"],\n    getCommitSignatureProtection: [\"GET /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures\"],\n    getCommunityProfileMetrics: [\"GET /repos/{owner}/{repo}/community/profile\"],\n    getContent: [\"GET /repos/{owner}/{repo}/contents/{path}\"],\n    getContributorsStats: [\"GET /repos/{owner}/{repo}/stats/contributors\"],\n    getDeployKey: [\"GET /repos/{owner}/{repo}/keys/{key_id}\"],\n    getDeployment: [\"GET /repos/{owner}/{repo}/deployments/{deployment_id}\"],\n    getDeploymentStatus: [\"GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses/{status_id}\"],\n    getEnvironment: [\"GET /repos/{owner}/{repo}/environments/{environment_name}\"],\n    getLatestPagesBuild: [\"GET /repos/{owner}/{repo}/pages/builds/latest\"],\n    getLatestRelease: [\"GET /repos/{owner}/{repo}/releases/latest\"],\n    getPages: [\"GET /repos/{owner}/{repo}/pages\"],\n    getPagesBuild: [\"GET /repos/{owner}/{repo}/pages/builds/{build_id}\"],\n    getPagesHealthCheck: [\"GET /repos/{owner}/{repo}/pages/health\"],\n    getParticipationStats: [\"GET /repos/{owner}/{repo}/stats/participation\"],\n    getPullRequestReviewProtection: [\"GET /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews\"],\n    getPunchCardStats: [\"GET /repos/{owner}/{repo}/stats/punch_card\"],\n    getReadme: [\"GET /repos/{owner}/{repo}/readme\"],\n    getReadmeInDirectory: [\"GET /repos/{owner}/{repo}/readme/{dir}\"],\n    getRelease: [\"GET /repos/{owner}/{repo}/releases/{release_id}\"],\n    getReleaseAsset: [\"GET /repos/{owner}/{repo}/releases/assets/{asset_id}\"],\n    getReleaseByTag: [\"GET /repos/{owner}/{repo}/releases/tags/{tag}\"],\n    getStatusChecksProtection: [\"GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks\"],\n    getTeamsWithAccessToProtectedBranch: [\"GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams\"],\n    getTopPaths: [\"GET /repos/{owner}/{repo}/traffic/popular/paths\"],\n    getTopReferrers: [\"GET /repos/{owner}/{repo}/traffic/popular/referrers\"],\n    getUsersWithAccessToProtectedBranch: [\"GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users\"],\n    getViews: [\"GET /repos/{owner}/{repo}/traffic/views\"],\n    getWebhook: [\"GET /repos/{owner}/{repo}/hooks/{hook_id}\"],\n    getWebhookConfigForRepo: [\"GET /repos/{owner}/{repo}/hooks/{hook_id}/config\"],\n    getWebhookDelivery: [\"GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}\"],\n    listAutolinks: [\"GET /repos/{owner}/{repo}/autolinks\"],\n    listBranches: [\"GET /repos/{owner}/{repo}/branches\"],\n    listBranchesForHeadCommit: [\"GET /repos/{owner}/{repo}/commits/{commit_sha}/branches-where-head\"],\n    listCollaborators: [\"GET /repos/{owner}/{repo}/collaborators\"],\n    listCommentsForCommit: [\"GET /repos/{owner}/{repo}/commits/{commit_sha}/comments\"],\n    listCommitCommentsForRepo: [\"GET /repos/{owner}/{repo}/comments\"],\n    listCommitStatusesForRef: [\"GET /repos/{owner}/{repo}/commits/{ref}/statuses\"],\n    listCommits: [\"GET /repos/{owner}/{repo}/commits\"],\n    listContributors: [\"GET /repos/{owner}/{repo}/contributors\"],\n    listDeployKeys: [\"GET /repos/{owner}/{repo}/keys\"],\n    listDeploymentStatuses: [\"GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses\"],\n    listDeployments: [\"GET /repos/{owner}/{repo}/deployments\"],\n    listForAuthenticatedUser: [\"GET /user/repos\"],\n    listForOrg: [\"GET /orgs/{org}/repos\"],\n    listForUser: [\"GET /users/{username}/repos\"],\n    listForks: [\"GET /repos/{owner}/{repo}/forks\"],\n    listInvitations: [\"GET /repos/{owner}/{repo}/invitations\"],\n    listInvitationsForAuthenticatedUser: [\"GET /user/repository_invitations\"],\n    listLanguages: [\"GET /repos/{owner}/{repo}/languages\"],\n    listPagesBuilds: [\"GET /repos/{owner}/{repo}/pages/builds\"],\n    listPublic: [\"GET /repositories\"],\n    listPullRequestsAssociatedWithCommit: [\"GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls\"],\n    listReleaseAssets: [\"GET /repos/{owner}/{repo}/releases/{release_id}/assets\"],\n    listReleases: [\"GET /repos/{owner}/{repo}/releases\"],\n    listTagProtection: [\"GET /repos/{owner}/{repo}/tags/protection\"],\n    listTags: [\"GET /repos/{owner}/{repo}/tags\"],\n    listTeams: [\"GET /repos/{owner}/{repo}/teams\"],\n    listWebhookDeliveries: [\"GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries\"],\n    listWebhooks: [\"GET /repos/{owner}/{repo}/hooks\"],\n    merge: [\"POST /repos/{owner}/{repo}/merges\"],\n    mergeUpstream: [\"POST /repos/{owner}/{repo}/merge-upstream\"],\n    pingWebhook: [\"POST /repos/{owner}/{repo}/hooks/{hook_id}/pings\"],\n    redeliverWebhookDelivery: [\"POST /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}/attempts\"],\n    removeAppAccessRestrictions: [\"DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps\", {}, {\n      mapToData: \"apps\"\n    }],\n    removeCollaborator: [\"DELETE /repos/{owner}/{repo}/collaborators/{username}\"],\n    removeStatusCheckContexts: [\"DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts\", {}, {\n      mapToData: \"contexts\"\n    }],\n    removeStatusCheckProtection: [\"DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks\"],\n    removeTeamAccessRestrictions: [\"DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams\", {}, {\n      mapToData: \"teams\"\n    }],\n    removeUserAccessRestrictions: [\"DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users\", {}, {\n      mapToData: \"users\"\n    }],\n    renameBranch: [\"POST /repos/{owner}/{repo}/branches/{branch}/rename\"],\n    replaceAllTopics: [\"PUT /repos/{owner}/{repo}/topics\"],\n    requestPagesBuild: [\"POST /repos/{owner}/{repo}/pages/builds\"],\n    setAdminBranchProtection: [\"POST /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins\"],\n    setAppAccessRestrictions: [\"PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps\", {}, {\n      mapToData: \"apps\"\n    }],\n    setStatusCheckContexts: [\"PUT /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts\", {}, {\n      mapToData: \"contexts\"\n    }],\n    setTeamAccessRestrictions: [\"PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams\", {}, {\n      mapToData: \"teams\"\n    }],\n    setUserAccessRestrictions: [\"PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users\", {}, {\n      mapToData: \"users\"\n    }],\n    testPushWebhook: [\"POST /repos/{owner}/{repo}/hooks/{hook_id}/tests\"],\n    transfer: [\"POST /repos/{owner}/{repo}/transfer\"],\n    update: [\"PATCH /repos/{owner}/{repo}\"],\n    updateBranchProtection: [\"PUT /repos/{owner}/{repo}/branches/{branch}/protection\"],\n    updateCommitComment: [\"PATCH /repos/{owner}/{repo}/comments/{comment_id}\"],\n    updateInformationAboutPagesSite: [\"PUT /repos/{owner}/{repo}/pages\"],\n    updateInvitation: [\"PATCH /repos/{owner}/{repo}/invitations/{invitation_id}\"],\n    updatePullRequestReviewProtection: [\"PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews\"],\n    updateRelease: [\"PATCH /repos/{owner}/{repo}/releases/{release_id}\"],\n    updateReleaseAsset: [\"PATCH /repos/{owner}/{repo}/releases/assets/{asset_id}\"],\n    updateStatusCheckPotection: [\"PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks\", {}, {\n      renamed: [\"repos\", \"updateStatusCheckProtection\"]\n    }],\n    updateStatusCheckProtection: [\"PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks\"],\n    updateWebhook: [\"PATCH /repos/{owner}/{repo}/hooks/{hook_id}\"],\n    updateWebhookConfigForRepo: [\"PATCH /repos/{owner}/{repo}/hooks/{hook_id}/config\"],\n    uploadReleaseAsset: [\"POST /repos/{owner}/{repo}/releases/{release_id}/assets{?name,label}\", {\n      baseUrl: \"https://uploads.github.com\"\n    }]\n  },\n  search: {\n    code: [\"GET /search/code\"],\n    commits: [\"GET /search/commits\"],\n    issuesAndPullRequests: [\"GET /search/issues\"],\n    labels: [\"GET /search/labels\"],\n    repos: [\"GET /search/repositories\"],\n    topics: [\"GET /search/topics\"],\n    users: [\"GET /search/users\"]\n  },\n  secretScanning: {\n    getAlert: [\"GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}\"],\n    listAlertsForEnterprise: [\"GET /enterprises/{enterprise}/secret-scanning/alerts\"],\n    listAlertsForOrg: [\"GET /orgs/{org}/secret-scanning/alerts\"],\n    listAlertsForRepo: [\"GET /repos/{owner}/{repo}/secret-scanning/alerts\"],\n    listLocationsForAlert: [\"GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}/locations\"],\n    updateAlert: [\"PATCH /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}\"]\n  },\n  teams: {\n    addOrUpdateMembershipForUserInOrg: [\"PUT /orgs/{org}/teams/{team_slug}/memberships/{username}\"],\n    addOrUpdateProjectPermissionsInOrg: [\"PUT /orgs/{org}/teams/{team_slug}/projects/{project_id}\"],\n    addOrUpdateRepoPermissionsInOrg: [\"PUT /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}\"],\n    checkPermissionsForProjectInOrg: [\"GET /orgs/{org}/teams/{team_slug}/projects/{project_id}\"],\n    checkPermissionsForRepoInOrg: [\"GET /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}\"],\n    create: [\"POST /orgs/{org}/teams\"],\n    createDiscussionCommentInOrg: [\"POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments\"],\n    createDiscussionInOrg: [\"POST /orgs/{org}/teams/{team_slug}/discussions\"],\n    deleteDiscussionCommentInOrg: [\"DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}\"],\n    deleteDiscussionInOrg: [\"DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}\"],\n    deleteInOrg: [\"DELETE /orgs/{org}/teams/{team_slug}\"],\n    getByName: [\"GET /orgs/{org}/teams/{team_slug}\"],\n    getDiscussionCommentInOrg: [\"GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}\"],\n    getDiscussionInOrg: [\"GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}\"],\n    getMembershipForUserInOrg: [\"GET /orgs/{org}/teams/{team_slug}/memberships/{username}\"],\n    list: [\"GET /orgs/{org}/teams\"],\n    listChildInOrg: [\"GET /orgs/{org}/teams/{team_slug}/teams\"],\n    listDiscussionCommentsInOrg: [\"GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments\"],\n    listDiscussionsInOrg: [\"GET /orgs/{org}/teams/{team_slug}/discussions\"],\n    listForAuthenticatedUser: [\"GET /user/teams\"],\n    listMembersInOrg: [\"GET /orgs/{org}/teams/{team_slug}/members\"],\n    listPendingInvitationsInOrg: [\"GET /orgs/{org}/teams/{team_slug}/invitations\"],\n    listProjectsInOrg: [\"GET /orgs/{org}/teams/{team_slug}/projects\"],\n    listReposInOrg: [\"GET /orgs/{org}/teams/{team_slug}/repos\"],\n    removeMembershipForUserInOrg: [\"DELETE /orgs/{org}/teams/{team_slug}/memberships/{username}\"],\n    removeProjectInOrg: [\"DELETE /orgs/{org}/teams/{team_slug}/projects/{project_id}\"],\n    removeRepoInOrg: [\"DELETE /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}\"],\n    updateDiscussionCommentInOrg: [\"PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}\"],\n    updateDiscussionInOrg: [\"PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}\"],\n    updateInOrg: [\"PATCH /orgs/{org}/teams/{team_slug}\"]\n  },\n  users: {\n    addEmailForAuthenticated: [\"POST /user/emails\", {}, {\n      renamed: [\"users\", \"addEmailForAuthenticatedUser\"]\n    }],\n    addEmailForAuthenticatedUser: [\"POST /user/emails\"],\n    block: [\"PUT /user/blocks/{username}\"],\n    checkBlocked: [\"GET /user/blocks/{username}\"],\n    checkFollowingForUser: [\"GET /users/{username}/following/{target_user}\"],\n    checkPersonIsFollowedByAuthenticated: [\"GET /user/following/{username}\"],\n    createGpgKeyForAuthenticated: [\"POST /user/gpg_keys\", {}, {\n      renamed: [\"users\", \"createGpgKeyForAuthenticatedUser\"]\n    }],\n    createGpgKeyForAuthenticatedUser: [\"POST /user/gpg_keys\"],\n    createPublicSshKeyForAuthenticated: [\"POST /user/keys\", {}, {\n      renamed: [\"users\", \"createPublicSshKeyForAuthenticatedUser\"]\n    }],\n    createPublicSshKeyForAuthenticatedUser: [\"POST /user/keys\"],\n    deleteEmailForAuthenticated: [\"DELETE /user/emails\", {}, {\n      renamed: [\"users\", \"deleteEmailForAuthenticatedUser\"]\n    }],\n    deleteEmailForAuthenticatedUser: [\"DELETE /user/emails\"],\n    deleteGpgKeyForAuthenticated: [\"DELETE /user/gpg_keys/{gpg_key_id}\", {}, {\n      renamed: [\"users\", \"deleteGpgKeyForAuthenticatedUser\"]\n    }],\n    deleteGpgKeyForAuthenticatedUser: [\"DELETE /user/gpg_keys/{gpg_key_id}\"],\n    deletePublicSshKeyForAuthenticated: [\"DELETE /user/keys/{key_id}\", {}, {\n      renamed: [\"users\", \"deletePublicSshKeyForAuthenticatedUser\"]\n    }],\n    deletePublicSshKeyForAuthenticatedUser: [\"DELETE /user/keys/{key_id}\"],\n    follow: [\"PUT /user/following/{username}\"],\n    getAuthenticated: [\"GET /user\"],\n    getByUsername: [\"GET /users/{username}\"],\n    getContextForUser: [\"GET /users/{username}/hovercard\"],\n    getGpgKeyForAuthenticated: [\"GET /user/gpg_keys/{gpg_key_id}\", {}, {\n      renamed: [\"users\", \"getGpgKeyForAuthenticatedUser\"]\n    }],\n    getGpgKeyForAuthenticatedUser: [\"GET /user/gpg_keys/{gpg_key_id}\"],\n    getPublicSshKeyForAuthenticated: [\"GET /user/keys/{key_id}\", {}, {\n      renamed: [\"users\", \"getPublicSshKeyForAuthenticatedUser\"]\n    }],\n    getPublicSshKeyForAuthenticatedUser: [\"GET /user/keys/{key_id}\"],\n    list: [\"GET /users\"],\n    listBlockedByAuthenticated: [\"GET /user/blocks\", {}, {\n      renamed: [\"users\", \"listBlockedByAuthenticatedUser\"]\n    }],\n    listBlockedByAuthenticatedUser: [\"GET /user/blocks\"],\n    listEmailsForAuthenticated: [\"GET /user/emails\", {}, {\n      renamed: [\"users\", \"listEmailsForAuthenticatedUser\"]\n    }],\n    listEmailsForAuthenticatedUser: [\"GET /user/emails\"],\n    listFollowedByAuthenticated: [\"GET /user/following\", {}, {\n      renamed: [\"users\", \"listFollowedByAuthenticatedUser\"]\n    }],\n    listFollowedByAuthenticatedUser: [\"GET /user/following\"],\n    listFollowersForAuthenticatedUser: [\"GET /user/followers\"],\n    listFollowersForUser: [\"GET /users/{username}/followers\"],\n    listFollowingForUser: [\"GET /users/{username}/following\"],\n    listGpgKeysForAuthenticated: [\"GET /user/gpg_keys\", {}, {\n      renamed: [\"users\", \"listGpgKeysForAuthenticatedUser\"]\n    }],\n    listGpgKeysForAuthenticatedUser: [\"GET /user/gpg_keys\"],\n    listGpgKeysForUser: [\"GET /users/{username}/gpg_keys\"],\n    listPublicEmailsForAuthenticated: [\"GET /user/public_emails\", {}, {\n      renamed: [\"users\", \"listPublicEmailsForAuthenticatedUser\"]\n    }],\n    listPublicEmailsForAuthenticatedUser: [\"GET /user/public_emails\"],\n    listPublicKeysForUser: [\"GET /users/{username}/keys\"],\n    listPublicSshKeysForAuthenticated: [\"GET /user/keys\", {}, {\n      renamed: [\"users\", \"listPublicSshKeysForAuthenticatedUser\"]\n    }],\n    listPublicSshKeysForAuthenticatedUser: [\"GET /user/keys\"],\n    setPrimaryEmailVisibilityForAuthenticated: [\"PATCH /user/email/visibility\", {}, {\n      renamed: [\"users\", \"setPrimaryEmailVisibilityForAuthenticatedUser\"]\n    }],\n    setPrimaryEmailVisibilityForAuthenticatedUser: [\"PATCH /user/email/visibility\"],\n    unblock: [\"DELETE /user/blocks/{username}\"],\n    unfollow: [\"DELETE /user/following/{username}\"],\n    updateAuthenticated: [\"PATCH /user\"]\n  }\n};\n\nconst VERSION = \"5.16.2\";\n\nfunction endpointsToMethods(octokit, endpointsMap) {\n  const newMethods = {};\n\n  for (const [scope, endpoints] of Object.entries(endpointsMap)) {\n    for (const [methodName, endpoint] of Object.entries(endpoints)) {\n      const [route, defaults, decorations] = endpoint;\n      const [method, url] = route.split(/ /);\n      const endpointDefaults = Object.assign({\n        method,\n        url\n      }, defaults);\n\n      if (!newMethods[scope]) {\n        newMethods[scope] = {};\n      }\n\n      const scopeMethods = newMethods[scope];\n\n      if (decorations) {\n        scopeMethods[methodName] = decorate(octokit, scope, methodName, endpointDefaults, decorations);\n        continue;\n      }\n\n      scopeMethods[methodName] = octokit.request.defaults(endpointDefaults);\n    }\n  }\n\n  return newMethods;\n}\n\nfunction decorate(octokit, scope, methodName, defaults, decorations) {\n  const requestWithDefaults = octokit.request.defaults(defaults);\n  /* istanbul ignore next */\n\n  function withDecorations(...args) {\n    // @ts-ignore https://github.com/microsoft/TypeScript/issues/25488\n    let options = requestWithDefaults.endpoint.merge(...args); // There are currently no other decorations than `.mapToData`\n\n    if (decorations.mapToData) {\n      options = Object.assign({}, options, {\n        data: options[decorations.mapToData],\n        [decorations.mapToData]: undefined\n      });\n      return requestWithDefaults(options);\n    }\n\n    if (decorations.renamed) {\n      const [newScope, newMethodName] = decorations.renamed;\n      octokit.log.warn(`octokit.${scope}.${methodName}() has been renamed to octokit.${newScope}.${newMethodName}()`);\n    }\n\n    if (decorations.deprecated) {\n      octokit.log.warn(decorations.deprecated);\n    }\n\n    if (decorations.renamedParameters) {\n      // @ts-ignore https://github.com/microsoft/TypeScript/issues/25488\n      const options = requestWithDefaults.endpoint.merge(...args);\n\n      for (const [name, alias] of Object.entries(decorations.renamedParameters)) {\n        if (name in options) {\n          octokit.log.warn(`\"${name}\" parameter is deprecated for \"octokit.${scope}.${methodName}()\". Use \"${alias}\" instead`);\n\n          if (!(alias in options)) {\n            options[alias] = options[name];\n          }\n\n          delete options[name];\n        }\n      }\n\n      return requestWithDefaults(options);\n    } // @ts-ignore https://github.com/microsoft/TypeScript/issues/25488\n\n\n    return requestWithDefaults(...args);\n  }\n\n  return Object.assign(withDecorations, requestWithDefaults);\n}\n\nfunction restEndpointMethods(octokit) {\n  const api = endpointsToMethods(octokit, Endpoints);\n  return {\n    rest: api\n  };\n}\nrestEndpointMethods.VERSION = VERSION;\nfunction legacyRestEndpointMethods(octokit) {\n  const api = endpointsToMethods(octokit, Endpoints);\n  return _objectSpread2(_objectSpread2({}, api), {}, {\n    rest: api\n  });\n}\nlegacyRestEndpointMethods.VERSION = VERSION;\n\nexports.legacyRestEndpointMethods = legacyRestEndpointMethods;\nexports.restEndpointMethods = restEndpointMethods;\n//# sourceMappingURL=index.js.map\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar deprecation = require('deprecation');\nvar once = _interopDefault(require('once'));\n\nconst logOnceCode = once(deprecation => console.warn(deprecation));\nconst logOnceHeaders = once(deprecation => console.warn(deprecation));\n/**\n * Error with extra properties to help with debugging\n */\n\nclass RequestError extends Error {\n  constructor(message, statusCode, options) {\n    super(message); // Maintains proper stack trace (only available on V8)\n\n    /* istanbul ignore next */\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor);\n    }\n\n    this.name = \"HttpError\";\n    this.status = statusCode;\n    let headers;\n\n    if (\"headers\" in options && typeof options.headers !== \"undefined\") {\n      headers = options.headers;\n    }\n\n    if (\"response\" in options) {\n      this.response = options.response;\n      headers = options.response.headers;\n    } // redact request credentials without mutating original request options\n\n\n    const requestCopy = Object.assign({}, options.request);\n\n    if (options.request.headers.authorization) {\n      requestCopy.headers = Object.assign({}, options.request.headers, {\n        authorization: options.request.headers.authorization.replace(/ .*$/, \" [REDACTED]\")\n      });\n    }\n\n    requestCopy.url = requestCopy.url // client_id & client_secret can be passed as URL query parameters to increase rate limit\n    // see https://developer.github.com/v3/#increasing-the-unauthenticated-rate-limit-for-oauth-applications\n    .replace(/\\bclient_secret=\\w+/g, \"client_secret=[REDACTED]\") // OAuth tokens can be passed as URL query parameters, although it is not recommended\n    // see https://developer.github.com/v3/#oauth2-token-sent-in-a-header\n    .replace(/\\baccess_token=\\w+/g, \"access_token=[REDACTED]\");\n    this.request = requestCopy; // deprecations\n\n    Object.defineProperty(this, \"code\", {\n      get() {\n        logOnceCode(new deprecation.Deprecation(\"[@octokit/request-error] `error.code` is deprecated, use `error.status`.\"));\n        return statusCode;\n      }\n\n    });\n    Object.defineProperty(this, \"headers\", {\n      get() {\n        logOnceHeaders(new deprecation.Deprecation(\"[@octokit/request-error] `error.headers` is deprecated, use `error.response.headers`.\"));\n        return headers || {};\n      }\n\n    });\n  }\n\n}\n\nexports.RequestError = RequestError;\n//# sourceMappingURL=index.js.map\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar endpoint = require('@octokit/endpoint');\nvar universalUserAgent = require('universal-user-agent');\nvar isPlainObject = require('is-plain-object');\nvar nodeFetch = _interopDefault(require('node-fetch'));\nvar requestError = require('@octokit/request-error');\n\nconst VERSION = \"5.6.3\";\n\nfunction getBufferResponse(response) {\n  return response.arrayBuffer();\n}\n\nfunction fetchWrapper(requestOptions) {\n  const log = requestOptions.request && requestOptions.request.log ? requestOptions.request.log : console;\n\n  if (isPlainObject.isPlainObject(requestOptions.body) || Array.isArray(requestOptions.body)) {\n    requestOptions.body = JSON.stringify(requestOptions.body);\n  }\n\n  let headers = {};\n  let status;\n  let url;\n  const fetch = requestOptions.request && requestOptions.request.fetch || nodeFetch;\n  return fetch(requestOptions.url, Object.assign({\n    method: requestOptions.method,\n    body: requestOptions.body,\n    headers: requestOptions.headers,\n    redirect: requestOptions.redirect\n  }, // `requestOptions.request.agent` type is incompatible\n  // see https://github.com/octokit/types.ts/pull/264\n  requestOptions.request)).then(async response => {\n    url = response.url;\n    status = response.status;\n\n    for (const keyAndValue of response.headers) {\n      headers[keyAndValue[0]] = keyAndValue[1];\n    }\n\n    if (\"deprecation\" in headers) {\n      const matches = headers.link && headers.link.match(/<([^>]+)>; rel=\"deprecation\"/);\n      const deprecationLink = matches && matches.pop();\n      log.warn(`[@octokit/request] \"${requestOptions.method} ${requestOptions.url}\" is deprecated. It is scheduled to be removed on ${headers.sunset}${deprecationLink ? `. See ${deprecationLink}` : \"\"}`);\n    }\n\n    if (status === 204 || status === 205) {\n      return;\n    } // GitHub API returns 200 for HEAD requests\n\n\n    if (requestOptions.method === \"HEAD\") {\n      if (status < 400) {\n        return;\n      }\n\n      throw new requestError.RequestError(response.statusText, status, {\n        response: {\n          url,\n          status,\n          headers,\n          data: undefined\n        },\n        request: requestOptions\n      });\n    }\n\n    if (status === 304) {\n      throw new requestError.RequestError(\"Not modified\", status, {\n        response: {\n          url,\n          status,\n          headers,\n          data: await getResponseData(response)\n        },\n        request: requestOptions\n      });\n    }\n\n    if (status >= 400) {\n      const data = await getResponseData(response);\n      const error = new requestError.RequestError(toErrorMessage(data), status, {\n        response: {\n          url,\n          status,\n          headers,\n          data\n        },\n        request: requestOptions\n      });\n      throw error;\n    }\n\n    return getResponseData(response);\n  }).then(data => {\n    return {\n      status,\n      url,\n      headers,\n      data\n    };\n  }).catch(error => {\n    if (error instanceof requestError.RequestError) throw error;\n    throw new requestError.RequestError(error.message, 500, {\n      request: requestOptions\n    });\n  });\n}\n\nasync function getResponseData(response) {\n  const contentType = response.headers.get(\"content-type\");\n\n  if (/application\\/json/.test(contentType)) {\n    return response.json();\n  }\n\n  if (!contentType || /^text\\/|charset=utf-8$/.test(contentType)) {\n    return response.text();\n  }\n\n  return getBufferResponse(response);\n}\n\nfunction toErrorMessage(data) {\n  if (typeof data === \"string\") return data; // istanbul ignore else - just in case\n\n  if (\"message\" in data) {\n    if (Array.isArray(data.errors)) {\n      return `${data.message}: ${data.errors.map(JSON.stringify).join(\", \")}`;\n    }\n\n    return data.message;\n  } // istanbul ignore next - just in case\n\n\n  return `Unknown error: ${JSON.stringify(data)}`;\n}\n\nfunction withDefaults(oldEndpoint, newDefaults) {\n  const endpoint = oldEndpoint.defaults(newDefaults);\n\n  const newApi = function (route, parameters) {\n    const endpointOptions = endpoint.merge(route, parameters);\n\n    if (!endpointOptions.request || !endpointOptions.request.hook) {\n      return fetchWrapper(endpoint.parse(endpointOptions));\n    }\n\n    const request = (route, parameters) => {\n      return fetchWrapper(endpoint.parse(endpoint.merge(route, parameters)));\n    };\n\n    Object.assign(request, {\n      endpoint,\n      defaults: withDefaults.bind(null, endpoint)\n    });\n    return endpointOptions.request.hook(request, endpointOptions);\n  };\n\n  return Object.assign(newApi, {\n    endpoint,\n    defaults: withDefaults.bind(null, endpoint)\n  });\n}\n\nconst request = withDefaults(endpoint.endpoint, {\n  headers: {\n    \"user-agent\": `octokit-request.js/${VERSION} ${universalUserAgent.getUserAgent()}`\n  }\n});\n\nexports.request = request;\n//# sourceMappingURL=index.js.map\n","var register = require(\"./lib/register\");\nvar addHook = require(\"./lib/add\");\nvar removeHook = require(\"./lib/remove\");\n\n// bind with array of arguments: https://stackoverflow.com/a/21792913\nvar bind = Function.bind;\nvar bindable = bind.bind(bind);\n\nfunction bindApi(hook, state, name) {\n  var removeHookRef = bindable(removeHook, null).apply(\n    null,\n    name ? [state, name] : [state]\n  );\n  hook.api = { remove: removeHookRef };\n  hook.remove = removeHookRef;\n  [\"before\", \"error\", \"after\", \"wrap\"].forEach(function (kind) {\n    var args = name ? [state, kind, name] : [state, kind];\n    hook[kind] = hook.api[kind] = bindable(addHook, null).apply(null, args);\n  });\n}\n\nfunction HookSingular() {\n  var singularHookName = \"h\";\n  var singularHookState = {\n    registry: {},\n  };\n  var singularHook = register.bind(null, singularHookState, singularHookName);\n  bindApi(singularHook, singularHookState, singularHookName);\n  return singularHook;\n}\n\nfunction HookCollection() {\n  var state = {\n    registry: {},\n  };\n\n  var hook = register.bind(null, state);\n  bindApi(hook, state);\n\n  return hook;\n}\n\nvar collectionHookDeprecationMessageDisplayed = false;\nfunction Hook() {\n  if (!collectionHookDeprecationMessageDisplayed) {\n    console.warn(\n      '[before-after-hook]: \"Hook()\" repurposing warning, use \"Hook.Collection()\". Read more: https://git.io/upgrade-before-after-hook-to-1.4'\n    );\n    collectionHookDeprecationMessageDisplayed = true;\n  }\n  return HookCollection();\n}\n\nHook.Singular = HookSingular.bind();\nHook.Collection = HookCollection.bind();\n\nmodule.exports = Hook;\n// expose constructors as a named property for TypeScript\nmodule.exports.Hook = Hook;\nmodule.exports.Singular = Hook.Singular;\nmodule.exports.Collection = Hook.Collection;\n","module.exports = addHook;\n\nfunction addHook(state, kind, name, hook) {\n  var orig = hook;\n  if (!state.registry[name]) {\n    state.registry[name] = [];\n  }\n\n  if (kind === \"before\") {\n    hook = function (method, options) {\n      return Promise.resolve()\n        .then(orig.bind(null, options))\n        .then(method.bind(null, options));\n    };\n  }\n\n  if (kind === \"after\") {\n    hook = function (method, options) {\n      var result;\n      return Promise.resolve()\n        .then(method.bind(null, options))\n        .then(function (result_) {\n          result = result_;\n          return orig(result, options);\n        })\n        .then(function () {\n          return result;\n        });\n    };\n  }\n\n  if (kind === \"error\") {\n    hook = function (method, options) {\n      return Promise.resolve()\n        .then(method.bind(null, options))\n        .catch(function (error) {\n          return orig(error, options);\n        });\n    };\n  }\n\n  state.registry[name].push({\n    hook: hook,\n    orig: orig,\n  });\n}\n","module.exports = register;\n\nfunction register(state, name, method, options) {\n  if (typeof method !== \"function\") {\n    throw new Error(\"method for before hook must be a function\");\n  }\n\n  if (!options) {\n    options = {};\n  }\n\n  if (Array.isArray(name)) {\n    return name.reverse().reduce(function (callback, name) {\n      return register.bind(null, state, name, callback, options);\n    }, method)();\n  }\n\n  return Promise.resolve().then(function () {\n    if (!state.registry[name]) {\n      return method(options);\n    }\n\n    return state.registry[name].reduce(function (method, registered) {\n      return registered.hook.bind(null, method, options);\n    }, method)();\n  });\n}\n","module.exports = removeHook;\n\nfunction removeHook(state, name, method) {\n  if (!state.registry[name]) {\n    return;\n  }\n\n  var index = state.registry[name]\n    .map(function (registered) {\n      return registered.orig;\n    })\n    .indexOf(method);\n\n  if (index === -1) {\n    return;\n  }\n\n  state.registry[name].splice(index, 1);\n}\n","/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\n\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\nexports.destroy = (() => {\n\tlet warned = false;\n\n\treturn () => {\n\t\tif (!warned) {\n\t\t\twarned = true;\n\t\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t\t}\n\t};\n})();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n\t'#0000CC',\n\t'#0000FF',\n\t'#0033CC',\n\t'#0033FF',\n\t'#0066CC',\n\t'#0066FF',\n\t'#0099CC',\n\t'#0099FF',\n\t'#00CC00',\n\t'#00CC33',\n\t'#00CC66',\n\t'#00CC99',\n\t'#00CCCC',\n\t'#00CCFF',\n\t'#3300CC',\n\t'#3300FF',\n\t'#3333CC',\n\t'#3333FF',\n\t'#3366CC',\n\t'#3366FF',\n\t'#3399CC',\n\t'#3399FF',\n\t'#33CC00',\n\t'#33CC33',\n\t'#33CC66',\n\t'#33CC99',\n\t'#33CCCC',\n\t'#33CCFF',\n\t'#6600CC',\n\t'#6600FF',\n\t'#6633CC',\n\t'#6633FF',\n\t'#66CC00',\n\t'#66CC33',\n\t'#9900CC',\n\t'#9900FF',\n\t'#9933CC',\n\t'#9933FF',\n\t'#99CC00',\n\t'#99CC33',\n\t'#CC0000',\n\t'#CC0033',\n\t'#CC0066',\n\t'#CC0099',\n\t'#CC00CC',\n\t'#CC00FF',\n\t'#CC3300',\n\t'#CC3333',\n\t'#CC3366',\n\t'#CC3399',\n\t'#CC33CC',\n\t'#CC33FF',\n\t'#CC6600',\n\t'#CC6633',\n\t'#CC9900',\n\t'#CC9933',\n\t'#CCCC00',\n\t'#CCCC33',\n\t'#FF0000',\n\t'#FF0033',\n\t'#FF0066',\n\t'#FF0099',\n\t'#FF00CC',\n\t'#FF00FF',\n\t'#FF3300',\n\t'#FF3333',\n\t'#FF3366',\n\t'#FF3399',\n\t'#FF33CC',\n\t'#FF33FF',\n\t'#FF6600',\n\t'#FF6633',\n\t'#FF9900',\n\t'#FF9933',\n\t'#FFCC00',\n\t'#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\n// eslint-disable-next-line complexity\nfunction useColors() {\n\t// NB: In an Electron preload script, document will be defined but not fully\n\t// initialized. Since we know we're in Chrome, we'll just detect this case\n\t// explicitly\n\tif (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n\t\treturn true;\n\t}\n\n\t// Internet Explorer and Edge do not support colors.\n\tif (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n\t\treturn false;\n\t}\n\n\t// Is webkit? http://stackoverflow.com/a/16459606/376773\n\t// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\treturn (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n\t\t// Is firebug? http://stackoverflow.com/a/398120/376773\n\t\t(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n\t\t// Is firefox >= v31?\n\t\t// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n\t\t// Double check webkit in userAgent just in case we are in a worker\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\targs[0] = (this.useColors ? '%c' : '') +\n\t\tthis.namespace +\n\t\t(this.useColors ? ' %c' : ' ') +\n\t\targs[0] +\n\t\t(this.useColors ? '%c ' : ' ') +\n\t\t'+' + module.exports.humanize(this.diff);\n\n\tif (!this.useColors) {\n\t\treturn;\n\t}\n\n\tconst c = 'color: ' + this.color;\n\targs.splice(1, 0, c, 'color: inherit');\n\n\t// The final \"%c\" is somewhat tricky, because there could be other\n\t// arguments passed either before or after the %c, so we need to\n\t// figure out the correct index to insert the CSS into\n\tlet index = 0;\n\tlet lastC = 0;\n\targs[0].replace(/%[a-zA-Z%]/g, match => {\n\t\tif (match === '%%') {\n\t\t\treturn;\n\t\t}\n\t\tindex++;\n\t\tif (match === '%c') {\n\t\t\t// We only are interested in the *last* %c\n\t\t\t// (the user may have provided their own)\n\t\t\tlastC = index;\n\t\t}\n\t});\n\n\targs.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.debug()` when available.\n * No-op when `console.debug` is not a \"function\".\n * If `console.debug` is not available, falls back\n * to `console.log`.\n *\n * @api public\n */\nexports.log = console.debug || console.log || (() => {});\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\ttry {\n\t\tif (namespaces) {\n\t\t\texports.storage.setItem('debug', namespaces);\n\t\t} else {\n\t\t\texports.storage.removeItem('debug');\n\t\t}\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\nfunction load() {\n\tlet r;\n\ttry {\n\t\tr = exports.storage.getItem('debug');\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n\n\t// If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\tif (!r && typeof process !== 'undefined' && 'env' in process) {\n\t\tr = process.env.DEBUG;\n\t}\n\n\treturn r;\n}\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n\ttry {\n\t\t// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n\t\t// The Browser also has localStorage in the global context.\n\t\treturn localStorage;\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\nmodule.exports = require('./common')(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nformatters.j = function (v) {\n\ttry {\n\t\treturn JSON.stringify(v);\n\t} catch (error) {\n\t\treturn '[UnexpectedJSONParseError]: ' + error.message;\n\t}\n};\n","\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\n\nfunction setup(env) {\n\tcreateDebug.debug = createDebug;\n\tcreateDebug.default = createDebug;\n\tcreateDebug.coerce = coerce;\n\tcreateDebug.disable = disable;\n\tcreateDebug.enable = enable;\n\tcreateDebug.enabled = enabled;\n\tcreateDebug.humanize = require('ms');\n\tcreateDebug.destroy = destroy;\n\n\tObject.keys(env).forEach(key => {\n\t\tcreateDebug[key] = env[key];\n\t});\n\n\t/**\n\t* The currently active debug mode names, and names to skip.\n\t*/\n\n\tcreateDebug.names = [];\n\tcreateDebug.skips = [];\n\n\t/**\n\t* Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t*\n\t* Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n\t*/\n\tcreateDebug.formatters = {};\n\n\t/**\n\t* Selects a color for a debug namespace\n\t* @param {String} namespace The namespace string for the debug instance to be colored\n\t* @return {Number|String} An ANSI color code for the given namespace\n\t* @api private\n\t*/\n\tfunction selectColor(namespace) {\n\t\tlet hash = 0;\n\n\t\tfor (let i = 0; i < namespace.length; i++) {\n\t\t\thash = ((hash << 5) - hash) + namespace.charCodeAt(i);\n\t\t\thash |= 0; // Convert to 32bit integer\n\t\t}\n\n\t\treturn createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n\t}\n\tcreateDebug.selectColor = selectColor;\n\n\t/**\n\t* Create a debugger with the given `namespace`.\n\t*\n\t* @param {String} namespace\n\t* @return {Function}\n\t* @api public\n\t*/\n\tfunction createDebug(namespace) {\n\t\tlet prevTime;\n\t\tlet enableOverride = null;\n\t\tlet namespacesCache;\n\t\tlet enabledCache;\n\n\t\tfunction debug(...args) {\n\t\t\t// Disabled?\n\t\t\tif (!debug.enabled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst self = debug;\n\n\t\t\t// Set `diff` timestamp\n\t\t\tconst curr = Number(new Date());\n\t\t\tconst ms = curr - (prevTime || curr);\n\t\t\tself.diff = ms;\n\t\t\tself.prev = prevTime;\n\t\t\tself.curr = curr;\n\t\t\tprevTime = curr;\n\n\t\t\targs[0] = createDebug.coerce(args[0]);\n\n\t\t\tif (typeof args[0] !== 'string') {\n\t\t\t\t// Anything else let's inspect with %O\n\t\t\t\targs.unshift('%O');\n\t\t\t}\n\n\t\t\t// Apply any `formatters` transformations\n\t\t\tlet index = 0;\n\t\t\targs[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {\n\t\t\t\t// If we encounter an escaped % then don't increase the array index\n\t\t\t\tif (match === '%%') {\n\t\t\t\t\treturn '%';\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t\tconst formatter = createDebug.formatters[format];\n\t\t\t\tif (typeof formatter === 'function') {\n\t\t\t\t\tconst val = args[index];\n\t\t\t\t\tmatch = formatter.call(self, val);\n\n\t\t\t\t\t// Now we need to remove `args[index]` since it's inlined in the `format`\n\t\t\t\t\targs.splice(index, 1);\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\t\t\t\treturn match;\n\t\t\t});\n\n\t\t\t// Apply env-specific formatting (colors, etc.)\n\t\t\tcreateDebug.formatArgs.call(self, args);\n\n\t\t\tconst logFn = self.log || createDebug.log;\n\t\t\tlogFn.apply(self, args);\n\t\t}\n\n\t\tdebug.namespace = namespace;\n\t\tdebug.useColors = createDebug.useColors();\n\t\tdebug.color = createDebug.selectColor(namespace);\n\t\tdebug.extend = extend;\n\t\tdebug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.\n\n\t\tObject.defineProperty(debug, 'enabled', {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: false,\n\t\t\tget: () => {\n\t\t\t\tif (enableOverride !== null) {\n\t\t\t\t\treturn enableOverride;\n\t\t\t\t}\n\t\t\t\tif (namespacesCache !== createDebug.namespaces) {\n\t\t\t\t\tnamespacesCache = createDebug.namespaces;\n\t\t\t\t\tenabledCache = createDebug.enabled(namespace);\n\t\t\t\t}\n\n\t\t\t\treturn enabledCache;\n\t\t\t},\n\t\t\tset: v => {\n\t\t\t\tenableOverride = v;\n\t\t\t}\n\t\t});\n\n\t\t// Env-specific initialization logic for debug instances\n\t\tif (typeof createDebug.init === 'function') {\n\t\t\tcreateDebug.init(debug);\n\t\t}\n\n\t\treturn debug;\n\t}\n\n\tfunction extend(namespace, delimiter) {\n\t\tconst newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n\t\tnewDebug.log = this.log;\n\t\treturn newDebug;\n\t}\n\n\t/**\n\t* Enables a debug mode by namespaces. This can include modes\n\t* separated by a colon and wildcards.\n\t*\n\t* @param {String} namespaces\n\t* @api public\n\t*/\n\tfunction enable(namespaces) {\n\t\tcreateDebug.save(namespaces);\n\t\tcreateDebug.namespaces = namespaces;\n\n\t\tcreateDebug.names = [];\n\t\tcreateDebug.skips = [];\n\n\t\tlet i;\n\t\tconst split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n\t\tconst len = split.length;\n\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (!split[i]) {\n\t\t\t\t// ignore empty strings\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnamespaces = split[i].replace(/\\*/g, '.*?');\n\n\t\t\tif (namespaces[0] === '-') {\n\t\t\t\tcreateDebug.skips.push(new RegExp('^' + namespaces.slice(1) + '$'));\n\t\t\t} else {\n\t\t\t\tcreateDebug.names.push(new RegExp('^' + namespaces + '$'));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t* Disable debug output.\n\t*\n\t* @return {String} namespaces\n\t* @api public\n\t*/\n\tfunction disable() {\n\t\tconst namespaces = [\n\t\t\t...createDebug.names.map(toNamespace),\n\t\t\t...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)\n\t\t].join(',');\n\t\tcreateDebug.enable('');\n\t\treturn namespaces;\n\t}\n\n\t/**\n\t* Returns true if the given mode name is enabled, false otherwise.\n\t*\n\t* @param {String} name\n\t* @return {Boolean}\n\t* @api public\n\t*/\n\tfunction enabled(name) {\n\t\tif (name[name.length - 1] === '*') {\n\t\t\treturn true;\n\t\t}\n\n\t\tlet i;\n\t\tlet len;\n\n\t\tfor (i = 0, len = createDebug.skips.length; i < len; i++) {\n\t\t\tif (createDebug.skips[i].test(name)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0, len = createDebug.names.length; i < len; i++) {\n\t\t\tif (createDebug.names[i].test(name)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t* Convert regexp to namespace\n\t*\n\t* @param {RegExp} regxep\n\t* @return {String} namespace\n\t* @api private\n\t*/\n\tfunction toNamespace(regexp) {\n\t\treturn regexp.toString()\n\t\t\t.substring(2, regexp.toString().length - 2)\n\t\t\t.replace(/\\.\\*\\?$/, '*');\n\t}\n\n\t/**\n\t* Coerce `val`.\n\t*\n\t* @param {Mixed} val\n\t* @return {Mixed}\n\t* @api private\n\t*/\n\tfunction coerce(val) {\n\t\tif (val instanceof Error) {\n\t\t\treturn val.stack || val.message;\n\t\t}\n\t\treturn val;\n\t}\n\n\t/**\n\t* XXX DO NOT USE. This is a temporary stub function.\n\t* XXX It WILL be removed in the next major release.\n\t*/\n\tfunction destroy() {\n\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t}\n\n\tcreateDebug.enable(createDebug.load());\n\n\treturn createDebug;\n}\n\nmodule.exports = setup;\n","/**\n * Detect Electron renderer / nwjs process, which is node, but we should\n * treat as a browser.\n */\n\nif (typeof process === 'undefined' || process.type === 'renderer' || process.browser === true || process.__nwjs) {\n\tmodule.exports = require('./browser.js');\n} else {\n\tmodule.exports = require('./node.js');\n}\n","/**\n * Module dependencies.\n */\n\nconst tty = require('tty');\nconst util = require('util');\n\n/**\n * This is the Node.js implementation of `debug()`.\n */\n\nexports.init = init;\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.destroy = util.deprecate(\n\t() => {},\n\t'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.'\n);\n\n/**\n * Colors.\n */\n\nexports.colors = [6, 2, 3, 4, 5, 1];\n\ntry {\n\t// Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)\n\t// eslint-disable-next-line import/no-extraneous-dependencies\n\tconst supportsColor = require('supports-color');\n\n\tif (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {\n\t\texports.colors = [\n\t\t\t20,\n\t\t\t21,\n\t\t\t26,\n\t\t\t27,\n\t\t\t32,\n\t\t\t33,\n\t\t\t38,\n\t\t\t39,\n\t\t\t40,\n\t\t\t41,\n\t\t\t42,\n\t\t\t43,\n\t\t\t44,\n\t\t\t45,\n\t\t\t56,\n\t\t\t57,\n\t\t\t62,\n\t\t\t63,\n\t\t\t68,\n\t\t\t69,\n\t\t\t74,\n\t\t\t75,\n\t\t\t76,\n\t\t\t77,\n\t\t\t78,\n\t\t\t79,\n\t\t\t80,\n\t\t\t81,\n\t\t\t92,\n\t\t\t93,\n\t\t\t98,\n\t\t\t99,\n\t\t\t112,\n\t\t\t113,\n\t\t\t128,\n\t\t\t129,\n\t\t\t134,\n\t\t\t135,\n\t\t\t148,\n\t\t\t149,\n\t\t\t160,\n\t\t\t161,\n\t\t\t162,\n\t\t\t163,\n\t\t\t164,\n\t\t\t165,\n\t\t\t166,\n\t\t\t167,\n\t\t\t168,\n\t\t\t169,\n\t\t\t170,\n\t\t\t171,\n\t\t\t172,\n\t\t\t173,\n\t\t\t178,\n\t\t\t179,\n\t\t\t184,\n\t\t\t185,\n\t\t\t196,\n\t\t\t197,\n\t\t\t198,\n\t\t\t199,\n\t\t\t200,\n\t\t\t201,\n\t\t\t202,\n\t\t\t203,\n\t\t\t204,\n\t\t\t205,\n\t\t\t206,\n\t\t\t207,\n\t\t\t208,\n\t\t\t209,\n\t\t\t214,\n\t\t\t215,\n\t\t\t220,\n\t\t\t221\n\t\t];\n\t}\n} catch (error) {\n\t// Swallow - we only care if `supports-color` is available; it doesn't have to be.\n}\n\n/**\n * Build up the default `inspectOpts` object from the environment variables.\n *\n *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js\n */\n\nexports.inspectOpts = Object.keys(process.env).filter(key => {\n\treturn /^debug_/i.test(key);\n}).reduce((obj, key) => {\n\t// Camel-case\n\tconst prop = key\n\t\t.substring(6)\n\t\t.toLowerCase()\n\t\t.replace(/_([a-z])/g, (_, k) => {\n\t\t\treturn k.toUpperCase();\n\t\t});\n\n\t// Coerce string value into JS value\n\tlet val = process.env[key];\n\tif (/^(yes|on|true|enabled)$/i.test(val)) {\n\t\tval = true;\n\t} else if (/^(no|off|false|disabled)$/i.test(val)) {\n\t\tval = false;\n\t} else if (val === 'null') {\n\t\tval = null;\n\t} else {\n\t\tval = Number(val);\n\t}\n\n\tobj[prop] = val;\n\treturn obj;\n}, {});\n\n/**\n * Is stdout a TTY? Colored output is enabled when `true`.\n */\n\nfunction useColors() {\n\treturn 'colors' in exports.inspectOpts ?\n\t\tBoolean(exports.inspectOpts.colors) :\n\t\ttty.isatty(process.stderr.fd);\n}\n\n/**\n * Adds ANSI color escape codes if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\tconst {namespace: name, useColors} = this;\n\n\tif (useColors) {\n\t\tconst c = this.color;\n\t\tconst colorCode = '\\u001B[3' + (c < 8 ? c : '8;5;' + c);\n\t\tconst prefix = `  ${colorCode};1m${name} \\u001B[0m`;\n\n\t\targs[0] = prefix + args[0].split('\\n').join('\\n' + prefix);\n\t\targs.push(colorCode + 'm+' + module.exports.humanize(this.diff) + '\\u001B[0m');\n\t} else {\n\t\targs[0] = getDate() + name + ' ' + args[0];\n\t}\n}\n\nfunction getDate() {\n\tif (exports.inspectOpts.hideDate) {\n\t\treturn '';\n\t}\n\treturn new Date().toISOString() + ' ';\n}\n\n/**\n * Invokes `util.format()` with the specified arguments and writes to stderr.\n */\n\nfunction log(...args) {\n\treturn process.stderr.write(util.format(...args) + '\\n');\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\tif (namespaces) {\n\t\tprocess.env.DEBUG = namespaces;\n\t} else {\n\t\t// If you set a process.env field to null or undefined, it gets cast to the\n\t\t// string 'null' or 'undefined'. Just delete instead.\n\t\tdelete process.env.DEBUG;\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n\treturn process.env.DEBUG;\n}\n\n/**\n * Init logic for `debug` instances.\n *\n * Create a new `inspectOpts` object in case `useColors` is set\n * differently for a particular `debug` instance.\n */\n\nfunction init(debug) {\n\tdebug.inspectOpts = {};\n\n\tconst keys = Object.keys(exports.inspectOpts);\n\tfor (let i = 0; i < keys.length; i++) {\n\t\tdebug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];\n\t}\n}\n\nmodule.exports = require('./common')(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %o to `util.inspect()`, all on a single line.\n */\n\nformatters.o = function (v) {\n\tthis.inspectOpts.colors = this.useColors;\n\treturn util.inspect(v, this.inspectOpts)\n\t\t.split('\\n')\n\t\t.map(str => str.trim())\n\t\t.join(' ');\n};\n\n/**\n * Map %O to `util.inspect()`, allowing multiple lines if needed.\n */\n\nformatters.O = function (v) {\n\tthis.inspectOpts.colors = this.useColors;\n\treturn util.inspect(v, this.inspectOpts);\n};\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nclass Deprecation extends Error {\n  constructor(message) {\n    super(message); // Maintains proper stack trace (only available on V8)\n\n    /* istanbul ignore next */\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor);\n    }\n\n    this.name = 'Deprecation';\n  }\n\n}\n\nexports.Deprecation = Deprecation;\n","const fs = require('fs')\nconst path = require('path')\nconst os = require('os')\nconst packageJson = require('../package.json')\n\nconst version = packageJson.version\n\nconst LINE = /(?:^|^)\\s*(?:export\\s+)?([\\w.-]+)(?:\\s*=\\s*?|:\\s+?)(\\s*'(?:\\\\'|[^'])*'|\\s*\"(?:\\\\\"|[^\"])*\"|\\s*`(?:\\\\`|[^`])*`|[^#\\r\\n]+)?\\s*(?:#.*)?(?:$|$)/mg\n\n// Parser src into an Object\nfunction parse (src) {\n  const obj = {}\n\n  // Convert buffer to string\n  let lines = src.toString()\n\n  // Convert line breaks to same format\n  lines = lines.replace(/\\r\\n?/mg, '\\n')\n\n  let match\n  while ((match = LINE.exec(lines)) != null) {\n    const key = match[1]\n\n    // Default undefined or null to empty string\n    let value = (match[2] || '')\n\n    // Remove whitespace\n    value = value.trim()\n\n    // Check if double quoted\n    const maybeQuote = value[0]\n\n    // Remove surrounding quotes\n    value = value.replace(/^(['\"`])([\\s\\S]*)\\1$/mg, '$2')\n\n    // Expand newlines if double quoted\n    if (maybeQuote === '\"') {\n      value = value.replace(/\\\\n/g, '\\n')\n      value = value.replace(/\\\\r/g, '\\r')\n    }\n\n    // Add to object\n    obj[key] = value\n  }\n\n  return obj\n}\n\nfunction _log (message) {\n  console.log(`[dotenv@${version}][DEBUG] ${message}`)\n}\n\nfunction _resolveHome (envPath) {\n  return envPath[0] === '~' ? path.join(os.homedir(), envPath.slice(1)) : envPath\n}\n\n// Populates process.env from .env file\nfunction config (options) {\n  let dotenvPath = path.resolve(process.cwd(), '.env')\n  let encoding = 'utf8'\n  const debug = Boolean(options && options.debug)\n  const override = Boolean(options && options.override)\n\n  if (options) {\n    if (options.path != null) {\n      dotenvPath = _resolveHome(options.path)\n    }\n    if (options.encoding != null) {\n      encoding = options.encoding\n    }\n  }\n\n  try {\n    // Specifying an encoding returns a string instead of a buffer\n    const parsed = DotenvModule.parse(fs.readFileSync(dotenvPath, { encoding }))\n\n    Object.keys(parsed).forEach(function (key) {\n      if (!Object.prototype.hasOwnProperty.call(process.env, key)) {\n        process.env[key] = parsed[key]\n      } else {\n        if (override === true) {\n          process.env[key] = parsed[key]\n        }\n\n        if (debug) {\n          if (override === true) {\n            _log(`\"${key}\" is already defined in \\`process.env\\` and WAS overwritten`)\n          } else {\n            _log(`\"${key}\" is already defined in \\`process.env\\` and was NOT overwritten`)\n          }\n        }\n      }\n    })\n\n    return { parsed }\n  } catch (e) {\n    if (debug) {\n      _log(`Failed to load ${dotenvPath} ${e.message}`)\n    }\n\n    return { error: e }\n  }\n}\n\nconst DotenvModule = {\n  config,\n  parse\n}\n\nmodule.exports.config = DotenvModule.config\nmodule.exports.parse = DotenvModule.parse\nmodule.exports = DotenvModule\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n/*!\n * is-plain-object <https://github.com/jonschlinkert/is-plain-object>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nfunction isObject(o) {\n  return Object.prototype.toString.call(o) === '[object Object]';\n}\n\nfunction isPlainObject(o) {\n  var ctor,prot;\n\n  if (isObject(o) === false) return false;\n\n  // If has modified constructor\n  ctor = o.constructor;\n  if (ctor === undefined) return true;\n\n  // If has modified prototype\n  prot = ctor.prototype;\n  if (isObject(prot) === false) return false;\n\n  // If constructor does not have an Object-specific method\n  if (prot.hasOwnProperty('isPrototypeOf') === false) {\n    return false;\n  }\n\n  // Most likely a plain Object\n  return true;\n}\n\nexports.isPlainObject = isPlainObject;\n","/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isFinite(val)) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n  return ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar Stream = _interopDefault(require('stream'));\nvar http = _interopDefault(require('http'));\nvar Url = _interopDefault(require('url'));\nvar whatwgUrl = _interopDefault(require('whatwg-url'));\nvar https = _interopDefault(require('https'));\nvar zlib = _interopDefault(require('zlib'));\n\n// Based on https://github.com/tmpvar/jsdom/blob/aa85b2abf07766ff7bf5c1f6daafb3726f2f2db5/lib/jsdom/living/blob.js\n\n// fix for \"Readable\" isn't a named export issue\nconst Readable = Stream.Readable;\n\nconst BUFFER = Symbol('buffer');\nconst TYPE = Symbol('type');\n\nclass Blob {\n\tconstructor() {\n\t\tthis[TYPE] = '';\n\n\t\tconst blobParts = arguments[0];\n\t\tconst options = arguments[1];\n\n\t\tconst buffers = [];\n\t\tlet size = 0;\n\n\t\tif (blobParts) {\n\t\t\tconst a = blobParts;\n\t\t\tconst length = Number(a.length);\n\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\tconst element = a[i];\n\t\t\t\tlet buffer;\n\t\t\t\tif (element instanceof Buffer) {\n\t\t\t\t\tbuffer = element;\n\t\t\t\t} else if (ArrayBuffer.isView(element)) {\n\t\t\t\t\tbuffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);\n\t\t\t\t} else if (element instanceof ArrayBuffer) {\n\t\t\t\t\tbuffer = Buffer.from(element);\n\t\t\t\t} else if (element instanceof Blob) {\n\t\t\t\t\tbuffer = element[BUFFER];\n\t\t\t\t} else {\n\t\t\t\t\tbuffer = Buffer.from(typeof element === 'string' ? element : String(element));\n\t\t\t\t}\n\t\t\t\tsize += buffer.length;\n\t\t\t\tbuffers.push(buffer);\n\t\t\t}\n\t\t}\n\n\t\tthis[BUFFER] = Buffer.concat(buffers);\n\n\t\tlet type = options && options.type !== undefined && String(options.type).toLowerCase();\n\t\tif (type && !/[^\\u0020-\\u007E]/.test(type)) {\n\t\t\tthis[TYPE] = type;\n\t\t}\n\t}\n\tget size() {\n\t\treturn this[BUFFER].length;\n\t}\n\tget type() {\n\t\treturn this[TYPE];\n\t}\n\ttext() {\n\t\treturn Promise.resolve(this[BUFFER].toString());\n\t}\n\tarrayBuffer() {\n\t\tconst buf = this[BUFFER];\n\t\tconst ab = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);\n\t\treturn Promise.resolve(ab);\n\t}\n\tstream() {\n\t\tconst readable = new Readable();\n\t\treadable._read = function () {};\n\t\treadable.push(this[BUFFER]);\n\t\treadable.push(null);\n\t\treturn readable;\n\t}\n\ttoString() {\n\t\treturn '[object Blob]';\n\t}\n\tslice() {\n\t\tconst size = this.size;\n\n\t\tconst start = arguments[0];\n\t\tconst end = arguments[1];\n\t\tlet relativeStart, relativeEnd;\n\t\tif (start === undefined) {\n\t\t\trelativeStart = 0;\n\t\t} else if (start < 0) {\n\t\t\trelativeStart = Math.max(size + start, 0);\n\t\t} else {\n\t\t\trelativeStart = Math.min(start, size);\n\t\t}\n\t\tif (end === undefined) {\n\t\t\trelativeEnd = size;\n\t\t} else if (end < 0) {\n\t\t\trelativeEnd = Math.max(size + end, 0);\n\t\t} else {\n\t\t\trelativeEnd = Math.min(end, size);\n\t\t}\n\t\tconst span = Math.max(relativeEnd - relativeStart, 0);\n\n\t\tconst buffer = this[BUFFER];\n\t\tconst slicedBuffer = buffer.slice(relativeStart, relativeStart + span);\n\t\tconst blob = new Blob([], { type: arguments[2] });\n\t\tblob[BUFFER] = slicedBuffer;\n\t\treturn blob;\n\t}\n}\n\nObject.defineProperties(Blob.prototype, {\n\tsize: { enumerable: true },\n\ttype: { enumerable: true },\n\tslice: { enumerable: true }\n});\n\nObject.defineProperty(Blob.prototype, Symbol.toStringTag, {\n\tvalue: 'Blob',\n\twritable: false,\n\tenumerable: false,\n\tconfigurable: true\n});\n\n/**\n * fetch-error.js\n *\n * FetchError interface for operational errors\n */\n\n/**\n * Create FetchError instance\n *\n * @param   String      message      Error message for human\n * @param   String      type         Error type for machine\n * @param   String      systemError  For Node.js system error\n * @return  FetchError\n */\nfunction FetchError(message, type, systemError) {\n  Error.call(this, message);\n\n  this.message = message;\n  this.type = type;\n\n  // when err.type is `system`, err.code contains system error code\n  if (systemError) {\n    this.code = this.errno = systemError.code;\n  }\n\n  // hide custom error implementation details from end-users\n  Error.captureStackTrace(this, this.constructor);\n}\n\nFetchError.prototype = Object.create(Error.prototype);\nFetchError.prototype.constructor = FetchError;\nFetchError.prototype.name = 'FetchError';\n\nlet convert;\ntry {\n\tconvert = require('encoding').convert;\n} catch (e) {}\n\nconst INTERNALS = Symbol('Body internals');\n\n// fix an issue where \"PassThrough\" isn't a named export for node <10\nconst PassThrough = Stream.PassThrough;\n\n/**\n * Body mixin\n *\n * Ref: https://fetch.spec.whatwg.org/#body\n *\n * @param   Stream  body  Readable stream\n * @param   Object  opts  Response options\n * @return  Void\n */\nfunction Body(body) {\n\tvar _this = this;\n\n\tvar _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n\t    _ref$size = _ref.size;\n\n\tlet size = _ref$size === undefined ? 0 : _ref$size;\n\tvar _ref$timeout = _ref.timeout;\n\tlet timeout = _ref$timeout === undefined ? 0 : _ref$timeout;\n\n\tif (body == null) {\n\t\t// body is undefined or null\n\t\tbody = null;\n\t} else if (isURLSearchParams(body)) {\n\t\t// body is a URLSearchParams\n\t\tbody = Buffer.from(body.toString());\n\t} else if (isBlob(body)) ; else if (Buffer.isBuffer(body)) ; else if (Object.prototype.toString.call(body) === '[object ArrayBuffer]') {\n\t\t// body is ArrayBuffer\n\t\tbody = Buffer.from(body);\n\t} else if (ArrayBuffer.isView(body)) {\n\t\t// body is ArrayBufferView\n\t\tbody = Buffer.from(body.buffer, body.byteOffset, body.byteLength);\n\t} else if (body instanceof Stream) ; else {\n\t\t// none of the above\n\t\t// coerce to string then buffer\n\t\tbody = Buffer.from(String(body));\n\t}\n\tthis[INTERNALS] = {\n\t\tbody,\n\t\tdisturbed: false,\n\t\terror: null\n\t};\n\tthis.size = size;\n\tthis.timeout = timeout;\n\n\tif (body instanceof Stream) {\n\t\tbody.on('error', function (err) {\n\t\t\tconst error = err.name === 'AbortError' ? err : new FetchError(`Invalid response body while trying to fetch ${_this.url}: ${err.message}`, 'system', err);\n\t\t\t_this[INTERNALS].error = error;\n\t\t});\n\t}\n}\n\nBody.prototype = {\n\tget body() {\n\t\treturn this[INTERNALS].body;\n\t},\n\n\tget bodyUsed() {\n\t\treturn this[INTERNALS].disturbed;\n\t},\n\n\t/**\n  * Decode response as ArrayBuffer\n  *\n  * @return  Promise\n  */\n\tarrayBuffer() {\n\t\treturn consumeBody.call(this).then(function (buf) {\n\t\t\treturn buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);\n\t\t});\n\t},\n\n\t/**\n  * Return raw response as Blob\n  *\n  * @return Promise\n  */\n\tblob() {\n\t\tlet ct = this.headers && this.headers.get('content-type') || '';\n\t\treturn consumeBody.call(this).then(function (buf) {\n\t\t\treturn Object.assign(\n\t\t\t// Prevent copying\n\t\t\tnew Blob([], {\n\t\t\t\ttype: ct.toLowerCase()\n\t\t\t}), {\n\t\t\t\t[BUFFER]: buf\n\t\t\t});\n\t\t});\n\t},\n\n\t/**\n  * Decode response as json\n  *\n  * @return  Promise\n  */\n\tjson() {\n\t\tvar _this2 = this;\n\n\t\treturn consumeBody.call(this).then(function (buffer) {\n\t\t\ttry {\n\t\t\t\treturn JSON.parse(buffer.toString());\n\t\t\t} catch (err) {\n\t\t\t\treturn Body.Promise.reject(new FetchError(`invalid json response body at ${_this2.url} reason: ${err.message}`, 'invalid-json'));\n\t\t\t}\n\t\t});\n\t},\n\n\t/**\n  * Decode response as text\n  *\n  * @return  Promise\n  */\n\ttext() {\n\t\treturn consumeBody.call(this).then(function (buffer) {\n\t\t\treturn buffer.toString();\n\t\t});\n\t},\n\n\t/**\n  * Decode response as buffer (non-spec api)\n  *\n  * @return  Promise\n  */\n\tbuffer() {\n\t\treturn consumeBody.call(this);\n\t},\n\n\t/**\n  * Decode response as text, while automatically detecting the encoding and\n  * trying to decode to UTF-8 (non-spec api)\n  *\n  * @return  Promise\n  */\n\ttextConverted() {\n\t\tvar _this3 = this;\n\n\t\treturn consumeBody.call(this).then(function (buffer) {\n\t\t\treturn convertBody(buffer, _this3.headers);\n\t\t});\n\t}\n};\n\n// In browsers, all properties are enumerable.\nObject.defineProperties(Body.prototype, {\n\tbody: { enumerable: true },\n\tbodyUsed: { enumerable: true },\n\tarrayBuffer: { enumerable: true },\n\tblob: { enumerable: true },\n\tjson: { enumerable: true },\n\ttext: { enumerable: true }\n});\n\nBody.mixIn = function (proto) {\n\tfor (const name of Object.getOwnPropertyNames(Body.prototype)) {\n\t\t// istanbul ignore else: future proof\n\t\tif (!(name in proto)) {\n\t\t\tconst desc = Object.getOwnPropertyDescriptor(Body.prototype, name);\n\t\t\tObject.defineProperty(proto, name, desc);\n\t\t}\n\t}\n};\n\n/**\n * Consume and convert an entire Body to a Buffer.\n *\n * Ref: https://fetch.spec.whatwg.org/#concept-body-consume-body\n *\n * @return  Promise\n */\nfunction consumeBody() {\n\tvar _this4 = this;\n\n\tif (this[INTERNALS].disturbed) {\n\t\treturn Body.Promise.reject(new TypeError(`body used already for: ${this.url}`));\n\t}\n\n\tthis[INTERNALS].disturbed = true;\n\n\tif (this[INTERNALS].error) {\n\t\treturn Body.Promise.reject(this[INTERNALS].error);\n\t}\n\n\tlet body = this.body;\n\n\t// body is null\n\tif (body === null) {\n\t\treturn Body.Promise.resolve(Buffer.alloc(0));\n\t}\n\n\t// body is blob\n\tif (isBlob(body)) {\n\t\tbody = body.stream();\n\t}\n\n\t// body is buffer\n\tif (Buffer.isBuffer(body)) {\n\t\treturn Body.Promise.resolve(body);\n\t}\n\n\t// istanbul ignore if: should never happen\n\tif (!(body instanceof Stream)) {\n\t\treturn Body.Promise.resolve(Buffer.alloc(0));\n\t}\n\n\t// body is stream\n\t// get ready to actually consume the body\n\tlet accum = [];\n\tlet accumBytes = 0;\n\tlet abort = false;\n\n\treturn new Body.Promise(function (resolve, reject) {\n\t\tlet resTimeout;\n\n\t\t// allow timeout on slow response body\n\t\tif (_this4.timeout) {\n\t\t\tresTimeout = setTimeout(function () {\n\t\t\t\tabort = true;\n\t\t\t\treject(new FetchError(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, 'body-timeout'));\n\t\t\t}, _this4.timeout);\n\t\t}\n\n\t\t// handle stream errors\n\t\tbody.on('error', function (err) {\n\t\t\tif (err.name === 'AbortError') {\n\t\t\t\t// if the request was aborted, reject with this Error\n\t\t\t\tabort = true;\n\t\t\t\treject(err);\n\t\t\t} else {\n\t\t\t\t// other errors, such as incorrect content-encoding\n\t\t\t\treject(new FetchError(`Invalid response body while trying to fetch ${_this4.url}: ${err.message}`, 'system', err));\n\t\t\t}\n\t\t});\n\n\t\tbody.on('data', function (chunk) {\n\t\t\tif (abort || chunk === null) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (_this4.size && accumBytes + chunk.length > _this4.size) {\n\t\t\t\tabort = true;\n\t\t\t\treject(new FetchError(`content size at ${_this4.url} over limit: ${_this4.size}`, 'max-size'));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\taccumBytes += chunk.length;\n\t\t\taccum.push(chunk);\n\t\t});\n\n\t\tbody.on('end', function () {\n\t\t\tif (abort) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tclearTimeout(resTimeout);\n\n\t\t\ttry {\n\t\t\t\tresolve(Buffer.concat(accum, accumBytes));\n\t\t\t} catch (err) {\n\t\t\t\t// handle streams that have accumulated too much data (issue #414)\n\t\t\t\treject(new FetchError(`Could not create Buffer from response body for ${_this4.url}: ${err.message}`, 'system', err));\n\t\t\t}\n\t\t});\n\t});\n}\n\n/**\n * Detect buffer encoding and convert to target encoding\n * ref: http://www.w3.org/TR/2011/WD-html5-20110113/parsing.html#determining-the-character-encoding\n *\n * @param   Buffer  buffer    Incoming buffer\n * @param   String  encoding  Target encoding\n * @return  String\n */\nfunction convertBody(buffer, headers) {\n\tif (typeof convert !== 'function') {\n\t\tthrow new Error('The package `encoding` must be installed to use the textConverted() function');\n\t}\n\n\tconst ct = headers.get('content-type');\n\tlet charset = 'utf-8';\n\tlet res, str;\n\n\t// header\n\tif (ct) {\n\t\tres = /charset=([^;]*)/i.exec(ct);\n\t}\n\n\t// no charset in content type, peek at response body for at most 1024 bytes\n\tstr = buffer.slice(0, 1024).toString();\n\n\t// html5\n\tif (!res && str) {\n\t\tres = /<meta.+?charset=(['\"])(.+?)\\1/i.exec(str);\n\t}\n\n\t// html4\n\tif (!res && str) {\n\t\tres = /<meta[\\s]+?http-equiv=(['\"])content-type\\1[\\s]+?content=(['\"])(.+?)\\2/i.exec(str);\n\t\tif (!res) {\n\t\t\tres = /<meta[\\s]+?content=(['\"])(.+?)\\1[\\s]+?http-equiv=(['\"])content-type\\3/i.exec(str);\n\t\t\tif (res) {\n\t\t\t\tres.pop(); // drop last quote\n\t\t\t}\n\t\t}\n\n\t\tif (res) {\n\t\t\tres = /charset=(.*)/i.exec(res.pop());\n\t\t}\n\t}\n\n\t// xml\n\tif (!res && str) {\n\t\tres = /<\\?xml.+?encoding=(['\"])(.+?)\\1/i.exec(str);\n\t}\n\n\t// found charset\n\tif (res) {\n\t\tcharset = res.pop();\n\n\t\t// prevent decode issues when sites use incorrect encoding\n\t\t// ref: https://hsivonen.fi/encoding-menu/\n\t\tif (charset === 'gb2312' || charset === 'gbk') {\n\t\t\tcharset = 'gb18030';\n\t\t}\n\t}\n\n\t// turn raw buffers into a single utf-8 buffer\n\treturn convert(buffer, 'UTF-8', charset).toString();\n}\n\n/**\n * Detect a URLSearchParams object\n * ref: https://github.com/bitinn/node-fetch/issues/296#issuecomment-307598143\n *\n * @param   Object  obj     Object to detect by type or brand\n * @return  String\n */\nfunction isURLSearchParams(obj) {\n\t// Duck-typing as a necessary condition.\n\tif (typeof obj !== 'object' || typeof obj.append !== 'function' || typeof obj.delete !== 'function' || typeof obj.get !== 'function' || typeof obj.getAll !== 'function' || typeof obj.has !== 'function' || typeof obj.set !== 'function') {\n\t\treturn false;\n\t}\n\n\t// Brand-checking and more duck-typing as optional condition.\n\treturn obj.constructor.name === 'URLSearchParams' || Object.prototype.toString.call(obj) === '[object URLSearchParams]' || typeof obj.sort === 'function';\n}\n\n/**\n * Check if `obj` is a W3C `Blob` object (which `File` inherits from)\n * @param  {*} obj\n * @return {boolean}\n */\nfunction isBlob(obj) {\n\treturn typeof obj === 'object' && typeof obj.arrayBuffer === 'function' && typeof obj.type === 'string' && typeof obj.stream === 'function' && typeof obj.constructor === 'function' && typeof obj.constructor.name === 'string' && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag]);\n}\n\n/**\n * Clone body given Res/Req instance\n *\n * @param   Mixed  instance  Response or Request instance\n * @return  Mixed\n */\nfunction clone(instance) {\n\tlet p1, p2;\n\tlet body = instance.body;\n\n\t// don't allow cloning a used body\n\tif (instance.bodyUsed) {\n\t\tthrow new Error('cannot clone body after it is used');\n\t}\n\n\t// check that body is a stream and not form-data object\n\t// note: we can't clone the form-data object without having it as a dependency\n\tif (body instanceof Stream && typeof body.getBoundary !== 'function') {\n\t\t// tee instance body\n\t\tp1 = new PassThrough();\n\t\tp2 = new PassThrough();\n\t\tbody.pipe(p1);\n\t\tbody.pipe(p2);\n\t\t// set instance body to teed body and return the other teed body\n\t\tinstance[INTERNALS].body = p1;\n\t\tbody = p2;\n\t}\n\n\treturn body;\n}\n\n/**\n * Performs the operation \"extract a `Content-Type` value from |object|\" as\n * specified in the specification:\n * https://fetch.spec.whatwg.org/#concept-bodyinit-extract\n *\n * This function assumes that instance.body is present.\n *\n * @param   Mixed  instance  Any options.body input\n */\nfunction extractContentType(body) {\n\tif (body === null) {\n\t\t// body is null\n\t\treturn null;\n\t} else if (typeof body === 'string') {\n\t\t// body is string\n\t\treturn 'text/plain;charset=UTF-8';\n\t} else if (isURLSearchParams(body)) {\n\t\t// body is a URLSearchParams\n\t\treturn 'application/x-www-form-urlencoded;charset=UTF-8';\n\t} else if (isBlob(body)) {\n\t\t// body is blob\n\t\treturn body.type || null;\n\t} else if (Buffer.isBuffer(body)) {\n\t\t// body is buffer\n\t\treturn null;\n\t} else if (Object.prototype.toString.call(body) === '[object ArrayBuffer]') {\n\t\t// body is ArrayBuffer\n\t\treturn null;\n\t} else if (ArrayBuffer.isView(body)) {\n\t\t// body is ArrayBufferView\n\t\treturn null;\n\t} else if (typeof body.getBoundary === 'function') {\n\t\t// detect form data input from form-data module\n\t\treturn `multipart/form-data;boundary=${body.getBoundary()}`;\n\t} else if (body instanceof Stream) {\n\t\t// body is stream\n\t\t// can't really do much about this\n\t\treturn null;\n\t} else {\n\t\t// Body constructor defaults other things to string\n\t\treturn 'text/plain;charset=UTF-8';\n\t}\n}\n\n/**\n * The Fetch Standard treats this as if \"total bytes\" is a property on the body.\n * For us, we have to explicitly get it with a function.\n *\n * ref: https://fetch.spec.whatwg.org/#concept-body-total-bytes\n *\n * @param   Body    instance   Instance of Body\n * @return  Number?            Number of bytes, or null if not possible\n */\nfunction getTotalBytes(instance) {\n\tconst body = instance.body;\n\n\n\tif (body === null) {\n\t\t// body is null\n\t\treturn 0;\n\t} else if (isBlob(body)) {\n\t\treturn body.size;\n\t} else if (Buffer.isBuffer(body)) {\n\t\t// body is buffer\n\t\treturn body.length;\n\t} else if (body && typeof body.getLengthSync === 'function') {\n\t\t// detect form data input from form-data module\n\t\tif (body._lengthRetrievers && body._lengthRetrievers.length == 0 || // 1.x\n\t\tbody.hasKnownLength && body.hasKnownLength()) {\n\t\t\t// 2.x\n\t\t\treturn body.getLengthSync();\n\t\t}\n\t\treturn null;\n\t} else {\n\t\t// body is stream\n\t\treturn null;\n\t}\n}\n\n/**\n * Write a Body to a Node.js WritableStream (e.g. http.Request) object.\n *\n * @param   Body    instance   Instance of Body\n * @return  Void\n */\nfunction writeToStream(dest, instance) {\n\tconst body = instance.body;\n\n\n\tif (body === null) {\n\t\t// body is null\n\t\tdest.end();\n\t} else if (isBlob(body)) {\n\t\tbody.stream().pipe(dest);\n\t} else if (Buffer.isBuffer(body)) {\n\t\t// body is buffer\n\t\tdest.write(body);\n\t\tdest.end();\n\t} else {\n\t\t// body is stream\n\t\tbody.pipe(dest);\n\t}\n}\n\n// expose Promise\nBody.Promise = global.Promise;\n\n/**\n * headers.js\n *\n * Headers class offers convenient helpers\n */\n\nconst invalidTokenRegex = /[^\\^_`a-zA-Z\\-0-9!#$%&'*+.|~]/;\nconst invalidHeaderCharRegex = /[^\\t\\x20-\\x7e\\x80-\\xff]/;\n\nfunction validateName(name) {\n\tname = `${name}`;\n\tif (invalidTokenRegex.test(name) || name === '') {\n\t\tthrow new TypeError(`${name} is not a legal HTTP header name`);\n\t}\n}\n\nfunction validateValue(value) {\n\tvalue = `${value}`;\n\tif (invalidHeaderCharRegex.test(value)) {\n\t\tthrow new TypeError(`${value} is not a legal HTTP header value`);\n\t}\n}\n\n/**\n * Find the key in the map object given a header name.\n *\n * Returns undefined if not found.\n *\n * @param   String  name  Header name\n * @return  String|Undefined\n */\nfunction find(map, name) {\n\tname = name.toLowerCase();\n\tfor (const key in map) {\n\t\tif (key.toLowerCase() === name) {\n\t\t\treturn key;\n\t\t}\n\t}\n\treturn undefined;\n}\n\nconst MAP = Symbol('map');\nclass Headers {\n\t/**\n  * Headers class\n  *\n  * @param   Object  headers  Response headers\n  * @return  Void\n  */\n\tconstructor() {\n\t\tlet init = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n\n\t\tthis[MAP] = Object.create(null);\n\n\t\tif (init instanceof Headers) {\n\t\t\tconst rawHeaders = init.raw();\n\t\t\tconst headerNames = Object.keys(rawHeaders);\n\n\t\t\tfor (const headerName of headerNames) {\n\t\t\t\tfor (const value of rawHeaders[headerName]) {\n\t\t\t\t\tthis.append(headerName, value);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\t// We don't worry about converting prop to ByteString here as append()\n\t\t// will handle it.\n\t\tif (init == null) ; else if (typeof init === 'object') {\n\t\t\tconst method = init[Symbol.iterator];\n\t\t\tif (method != null) {\n\t\t\t\tif (typeof method !== 'function') {\n\t\t\t\t\tthrow new TypeError('Header pairs must be iterable');\n\t\t\t\t}\n\n\t\t\t\t// sequence<sequence<ByteString>>\n\t\t\t\t// Note: per spec we have to first exhaust the lists then process them\n\t\t\t\tconst pairs = [];\n\t\t\t\tfor (const pair of init) {\n\t\t\t\t\tif (typeof pair !== 'object' || typeof pair[Symbol.iterator] !== 'function') {\n\t\t\t\t\t\tthrow new TypeError('Each header pair must be iterable');\n\t\t\t\t\t}\n\t\t\t\t\tpairs.push(Array.from(pair));\n\t\t\t\t}\n\n\t\t\t\tfor (const pair of pairs) {\n\t\t\t\t\tif (pair.length !== 2) {\n\t\t\t\t\t\tthrow new TypeError('Each header pair must be a name/value tuple');\n\t\t\t\t\t}\n\t\t\t\t\tthis.append(pair[0], pair[1]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// record<ByteString, ByteString>\n\t\t\t\tfor (const key of Object.keys(init)) {\n\t\t\t\t\tconst value = init[key];\n\t\t\t\t\tthis.append(key, value);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new TypeError('Provided initializer must be an object');\n\t\t}\n\t}\n\n\t/**\n  * Return combined header value given name\n  *\n  * @param   String  name  Header name\n  * @return  Mixed\n  */\n\tget(name) {\n\t\tname = `${name}`;\n\t\tvalidateName(name);\n\t\tconst key = find(this[MAP], name);\n\t\tif (key === undefined) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn this[MAP][key].join(', ');\n\t}\n\n\t/**\n  * Iterate over all headers\n  *\n  * @param   Function  callback  Executed for each item with parameters (value, name, thisArg)\n  * @param   Boolean   thisArg   `this` context for callback function\n  * @return  Void\n  */\n\tforEach(callback) {\n\t\tlet thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n\n\t\tlet pairs = getHeaders(this);\n\t\tlet i = 0;\n\t\twhile (i < pairs.length) {\n\t\t\tvar _pairs$i = pairs[i];\n\t\t\tconst name = _pairs$i[0],\n\t\t\t      value = _pairs$i[1];\n\n\t\t\tcallback.call(thisArg, value, name, this);\n\t\t\tpairs = getHeaders(this);\n\t\t\ti++;\n\t\t}\n\t}\n\n\t/**\n  * Overwrite header values given name\n  *\n  * @param   String  name   Header name\n  * @param   String  value  Header value\n  * @return  Void\n  */\n\tset(name, value) {\n\t\tname = `${name}`;\n\t\tvalue = `${value}`;\n\t\tvalidateName(name);\n\t\tvalidateValue(value);\n\t\tconst key = find(this[MAP], name);\n\t\tthis[MAP][key !== undefined ? key : name] = [value];\n\t}\n\n\t/**\n  * Append a value onto existing header\n  *\n  * @param   String  name   Header name\n  * @param   String  value  Header value\n  * @return  Void\n  */\n\tappend(name, value) {\n\t\tname = `${name}`;\n\t\tvalue = `${value}`;\n\t\tvalidateName(name);\n\t\tvalidateValue(value);\n\t\tconst key = find(this[MAP], name);\n\t\tif (key !== undefined) {\n\t\t\tthis[MAP][key].push(value);\n\t\t} else {\n\t\t\tthis[MAP][name] = [value];\n\t\t}\n\t}\n\n\t/**\n  * Check for header name existence\n  *\n  * @param   String   name  Header name\n  * @return  Boolean\n  */\n\thas(name) {\n\t\tname = `${name}`;\n\t\tvalidateName(name);\n\t\treturn find(this[MAP], name) !== undefined;\n\t}\n\n\t/**\n  * Delete all header values given name\n  *\n  * @param   String  name  Header name\n  * @return  Void\n  */\n\tdelete(name) {\n\t\tname = `${name}`;\n\t\tvalidateName(name);\n\t\tconst key = find(this[MAP], name);\n\t\tif (key !== undefined) {\n\t\t\tdelete this[MAP][key];\n\t\t}\n\t}\n\n\t/**\n  * Return raw headers (non-spec api)\n  *\n  * @return  Object\n  */\n\traw() {\n\t\treturn this[MAP];\n\t}\n\n\t/**\n  * Get an iterator on keys.\n  *\n  * @return  Iterator\n  */\n\tkeys() {\n\t\treturn createHeadersIterator(this, 'key');\n\t}\n\n\t/**\n  * Get an iterator on values.\n  *\n  * @return  Iterator\n  */\n\tvalues() {\n\t\treturn createHeadersIterator(this, 'value');\n\t}\n\n\t/**\n  * Get an iterator on entries.\n  *\n  * This is the default iterator of the Headers object.\n  *\n  * @return  Iterator\n  */\n\t[Symbol.iterator]() {\n\t\treturn createHeadersIterator(this, 'key+value');\n\t}\n}\nHeaders.prototype.entries = Headers.prototype[Symbol.iterator];\n\nObject.defineProperty(Headers.prototype, Symbol.toStringTag, {\n\tvalue: 'Headers',\n\twritable: false,\n\tenumerable: false,\n\tconfigurable: true\n});\n\nObject.defineProperties(Headers.prototype, {\n\tget: { enumerable: true },\n\tforEach: { enumerable: true },\n\tset: { enumerable: true },\n\tappend: { enumerable: true },\n\thas: { enumerable: true },\n\tdelete: { enumerable: true },\n\tkeys: { enumerable: true },\n\tvalues: { enumerable: true },\n\tentries: { enumerable: true }\n});\n\nfunction getHeaders(headers) {\n\tlet kind = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'key+value';\n\n\tconst keys = Object.keys(headers[MAP]).sort();\n\treturn keys.map(kind === 'key' ? function (k) {\n\t\treturn k.toLowerCase();\n\t} : kind === 'value' ? function (k) {\n\t\treturn headers[MAP][k].join(', ');\n\t} : function (k) {\n\t\treturn [k.toLowerCase(), headers[MAP][k].join(', ')];\n\t});\n}\n\nconst INTERNAL = Symbol('internal');\n\nfunction createHeadersIterator(target, kind) {\n\tconst iterator = Object.create(HeadersIteratorPrototype);\n\titerator[INTERNAL] = {\n\t\ttarget,\n\t\tkind,\n\t\tindex: 0\n\t};\n\treturn iterator;\n}\n\nconst HeadersIteratorPrototype = Object.setPrototypeOf({\n\tnext() {\n\t\t// istanbul ignore if\n\t\tif (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {\n\t\t\tthrow new TypeError('Value of `this` is not a HeadersIterator');\n\t\t}\n\n\t\tvar _INTERNAL = this[INTERNAL];\n\t\tconst target = _INTERNAL.target,\n\t\t      kind = _INTERNAL.kind,\n\t\t      index = _INTERNAL.index;\n\n\t\tconst values = getHeaders(target, kind);\n\t\tconst len = values.length;\n\t\tif (index >= len) {\n\t\t\treturn {\n\t\t\t\tvalue: undefined,\n\t\t\t\tdone: true\n\t\t\t};\n\t\t}\n\n\t\tthis[INTERNAL].index = index + 1;\n\n\t\treturn {\n\t\t\tvalue: values[index],\n\t\t\tdone: false\n\t\t};\n\t}\n}, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));\n\nObject.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {\n\tvalue: 'HeadersIterator',\n\twritable: false,\n\tenumerable: false,\n\tconfigurable: true\n});\n\n/**\n * Export the Headers object in a form that Node.js can consume.\n *\n * @param   Headers  headers\n * @return  Object\n */\nfunction exportNodeCompatibleHeaders(headers) {\n\tconst obj = Object.assign({ __proto__: null }, headers[MAP]);\n\n\t// http.request() only supports string as Host header. This hack makes\n\t// specifying custom Host header possible.\n\tconst hostHeaderKey = find(headers[MAP], 'Host');\n\tif (hostHeaderKey !== undefined) {\n\t\tobj[hostHeaderKey] = obj[hostHeaderKey][0];\n\t}\n\n\treturn obj;\n}\n\n/**\n * Create a Headers object from an object of headers, ignoring those that do\n * not conform to HTTP grammar productions.\n *\n * @param   Object  obj  Object of headers\n * @return  Headers\n */\nfunction createHeadersLenient(obj) {\n\tconst headers = new Headers();\n\tfor (const name of Object.keys(obj)) {\n\t\tif (invalidTokenRegex.test(name)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (Array.isArray(obj[name])) {\n\t\t\tfor (const val of obj[name]) {\n\t\t\t\tif (invalidHeaderCharRegex.test(val)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (headers[MAP][name] === undefined) {\n\t\t\t\t\theaders[MAP][name] = [val];\n\t\t\t\t} else {\n\t\t\t\t\theaders[MAP][name].push(val);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (!invalidHeaderCharRegex.test(obj[name])) {\n\t\t\theaders[MAP][name] = [obj[name]];\n\t\t}\n\t}\n\treturn headers;\n}\n\nconst INTERNALS$1 = Symbol('Response internals');\n\n// fix an issue where \"STATUS_CODES\" aren't a named export for node <10\nconst STATUS_CODES = http.STATUS_CODES;\n\n/**\n * Response class\n *\n * @param   Stream  body  Readable stream\n * @param   Object  opts  Response options\n * @return  Void\n */\nclass Response {\n\tconstructor() {\n\t\tlet body = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\t\tlet opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n\t\tBody.call(this, body, opts);\n\n\t\tconst status = opts.status || 200;\n\t\tconst headers = new Headers(opts.headers);\n\n\t\tif (body != null && !headers.has('Content-Type')) {\n\t\t\tconst contentType = extractContentType(body);\n\t\t\tif (contentType) {\n\t\t\t\theaders.append('Content-Type', contentType);\n\t\t\t}\n\t\t}\n\n\t\tthis[INTERNALS$1] = {\n\t\t\turl: opts.url,\n\t\t\tstatus,\n\t\t\tstatusText: opts.statusText || STATUS_CODES[status],\n\t\t\theaders,\n\t\t\tcounter: opts.counter\n\t\t};\n\t}\n\n\tget url() {\n\t\treturn this[INTERNALS$1].url || '';\n\t}\n\n\tget status() {\n\t\treturn this[INTERNALS$1].status;\n\t}\n\n\t/**\n  * Convenience property representing if the request ended normally\n  */\n\tget ok() {\n\t\treturn this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;\n\t}\n\n\tget redirected() {\n\t\treturn this[INTERNALS$1].counter > 0;\n\t}\n\n\tget statusText() {\n\t\treturn this[INTERNALS$1].statusText;\n\t}\n\n\tget headers() {\n\t\treturn this[INTERNALS$1].headers;\n\t}\n\n\t/**\n  * Clone this response\n  *\n  * @return  Response\n  */\n\tclone() {\n\t\treturn new Response(clone(this), {\n\t\t\turl: this.url,\n\t\t\tstatus: this.status,\n\t\t\tstatusText: this.statusText,\n\t\t\theaders: this.headers,\n\t\t\tok: this.ok,\n\t\t\tredirected: this.redirected\n\t\t});\n\t}\n}\n\nBody.mixIn(Response.prototype);\n\nObject.defineProperties(Response.prototype, {\n\turl: { enumerable: true },\n\tstatus: { enumerable: true },\n\tok: { enumerable: true },\n\tredirected: { enumerable: true },\n\tstatusText: { enumerable: true },\n\theaders: { enumerable: true },\n\tclone: { enumerable: true }\n});\n\nObject.defineProperty(Response.prototype, Symbol.toStringTag, {\n\tvalue: 'Response',\n\twritable: false,\n\tenumerable: false,\n\tconfigurable: true\n});\n\nconst INTERNALS$2 = Symbol('Request internals');\nconst URL = Url.URL || whatwgUrl.URL;\n\n// fix an issue where \"format\", \"parse\" aren't a named export for node <10\nconst parse_url = Url.parse;\nconst format_url = Url.format;\n\n/**\n * Wrapper around `new URL` to handle arbitrary URLs\n *\n * @param  {string} urlStr\n * @return {void}\n */\nfunction parseURL(urlStr) {\n\t/*\n \tCheck whether the URL is absolute or not\n \t\tScheme: https://tools.ietf.org/html/rfc3986#section-3.1\n \tAbsolute URL: https://tools.ietf.org/html/rfc3986#section-4.3\n */\n\tif (/^[a-zA-Z][a-zA-Z\\d+\\-.]*:/.exec(urlStr)) {\n\t\turlStr = new URL(urlStr).toString();\n\t}\n\n\t// Fallback to old implementation for arbitrary URLs\n\treturn parse_url(urlStr);\n}\n\nconst streamDestructionSupported = 'destroy' in Stream.Readable.prototype;\n\n/**\n * Check if a value is an instance of Request.\n *\n * @param   Mixed   input\n * @return  Boolean\n */\nfunction isRequest(input) {\n\treturn typeof input === 'object' && typeof input[INTERNALS$2] === 'object';\n}\n\nfunction isAbortSignal(signal) {\n\tconst proto = signal && typeof signal === 'object' && Object.getPrototypeOf(signal);\n\treturn !!(proto && proto.constructor.name === 'AbortSignal');\n}\n\n/**\n * Request class\n *\n * @param   Mixed   input  Url or Request instance\n * @param   Object  init   Custom options\n * @return  Void\n */\nclass Request {\n\tconstructor(input) {\n\t\tlet init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n\t\tlet parsedURL;\n\n\t\t// normalize input\n\t\tif (!isRequest(input)) {\n\t\t\tif (input && input.href) {\n\t\t\t\t// in order to support Node.js' Url objects; though WHATWG's URL objects\n\t\t\t\t// will fall into this branch also (since their `toString()` will return\n\t\t\t\t// `href` property anyway)\n\t\t\t\tparsedURL = parseURL(input.href);\n\t\t\t} else {\n\t\t\t\t// coerce input to a string before attempting to parse\n\t\t\t\tparsedURL = parseURL(`${input}`);\n\t\t\t}\n\t\t\tinput = {};\n\t\t} else {\n\t\t\tparsedURL = parseURL(input.url);\n\t\t}\n\n\t\tlet method = init.method || input.method || 'GET';\n\t\tmethod = method.toUpperCase();\n\n\t\tif ((init.body != null || isRequest(input) && input.body !== null) && (method === 'GET' || method === 'HEAD')) {\n\t\t\tthrow new TypeError('Request with GET/HEAD method cannot have body');\n\t\t}\n\n\t\tlet inputBody = init.body != null ? init.body : isRequest(input) && input.body !== null ? clone(input) : null;\n\n\t\tBody.call(this, inputBody, {\n\t\t\ttimeout: init.timeout || input.timeout || 0,\n\t\t\tsize: init.size || input.size || 0\n\t\t});\n\n\t\tconst headers = new Headers(init.headers || input.headers || {});\n\n\t\tif (inputBody != null && !headers.has('Content-Type')) {\n\t\t\tconst contentType = extractContentType(inputBody);\n\t\t\tif (contentType) {\n\t\t\t\theaders.append('Content-Type', contentType);\n\t\t\t}\n\t\t}\n\n\t\tlet signal = isRequest(input) ? input.signal : null;\n\t\tif ('signal' in init) signal = init.signal;\n\n\t\tif (signal != null && !isAbortSignal(signal)) {\n\t\t\tthrow new TypeError('Expected signal to be an instanceof AbortSignal');\n\t\t}\n\n\t\tthis[INTERNALS$2] = {\n\t\t\tmethod,\n\t\t\tredirect: init.redirect || input.redirect || 'follow',\n\t\t\theaders,\n\t\t\tparsedURL,\n\t\t\tsignal\n\t\t};\n\n\t\t// node-fetch-only options\n\t\tthis.follow = init.follow !== undefined ? init.follow : input.follow !== undefined ? input.follow : 20;\n\t\tthis.compress = init.compress !== undefined ? init.compress : input.compress !== undefined ? input.compress : true;\n\t\tthis.counter = init.counter || input.counter || 0;\n\t\tthis.agent = init.agent || input.agent;\n\t}\n\n\tget method() {\n\t\treturn this[INTERNALS$2].method;\n\t}\n\n\tget url() {\n\t\treturn format_url(this[INTERNALS$2].parsedURL);\n\t}\n\n\tget headers() {\n\t\treturn this[INTERNALS$2].headers;\n\t}\n\n\tget redirect() {\n\t\treturn this[INTERNALS$2].redirect;\n\t}\n\n\tget signal() {\n\t\treturn this[INTERNALS$2].signal;\n\t}\n\n\t/**\n  * Clone this request\n  *\n  * @return  Request\n  */\n\tclone() {\n\t\treturn new Request(this);\n\t}\n}\n\nBody.mixIn(Request.prototype);\n\nObject.defineProperty(Request.prototype, Symbol.toStringTag, {\n\tvalue: 'Request',\n\twritable: false,\n\tenumerable: false,\n\tconfigurable: true\n});\n\nObject.defineProperties(Request.prototype, {\n\tmethod: { enumerable: true },\n\turl: { enumerable: true },\n\theaders: { enumerable: true },\n\tredirect: { enumerable: true },\n\tclone: { enumerable: true },\n\tsignal: { enumerable: true }\n});\n\n/**\n * Convert a Request to Node.js http request options.\n *\n * @param   Request  A Request instance\n * @return  Object   The options object to be passed to http.request\n */\nfunction getNodeRequestOptions(request) {\n\tconst parsedURL = request[INTERNALS$2].parsedURL;\n\tconst headers = new Headers(request[INTERNALS$2].headers);\n\n\t// fetch step 1.3\n\tif (!headers.has('Accept')) {\n\t\theaders.set('Accept', '*/*');\n\t}\n\n\t// Basic fetch\n\tif (!parsedURL.protocol || !parsedURL.hostname) {\n\t\tthrow new TypeError('Only absolute URLs are supported');\n\t}\n\n\tif (!/^https?:$/.test(parsedURL.protocol)) {\n\t\tthrow new TypeError('Only HTTP(S) protocols are supported');\n\t}\n\n\tif (request.signal && request.body instanceof Stream.Readable && !streamDestructionSupported) {\n\t\tthrow new Error('Cancellation of streamed requests with AbortSignal is not supported in node < 8');\n\t}\n\n\t// HTTP-network-or-cache fetch steps 2.4-2.7\n\tlet contentLengthValue = null;\n\tif (request.body == null && /^(POST|PUT)$/i.test(request.method)) {\n\t\tcontentLengthValue = '0';\n\t}\n\tif (request.body != null) {\n\t\tconst totalBytes = getTotalBytes(request);\n\t\tif (typeof totalBytes === 'number') {\n\t\t\tcontentLengthValue = String(totalBytes);\n\t\t}\n\t}\n\tif (contentLengthValue) {\n\t\theaders.set('Content-Length', contentLengthValue);\n\t}\n\n\t// HTTP-network-or-cache fetch step 2.11\n\tif (!headers.has('User-Agent')) {\n\t\theaders.set('User-Agent', 'node-fetch/1.0 (+https://github.com/bitinn/node-fetch)');\n\t}\n\n\t// HTTP-network-or-cache fetch step 2.15\n\tif (request.compress && !headers.has('Accept-Encoding')) {\n\t\theaders.set('Accept-Encoding', 'gzip,deflate');\n\t}\n\n\tlet agent = request.agent;\n\tif (typeof agent === 'function') {\n\t\tagent = agent(parsedURL);\n\t}\n\n\tif (!headers.has('Connection') && !agent) {\n\t\theaders.set('Connection', 'close');\n\t}\n\n\t// HTTP-network fetch step 4.2\n\t// chunked encoding is handled by Node.js\n\n\treturn Object.assign({}, parsedURL, {\n\t\tmethod: request.method,\n\t\theaders: exportNodeCompatibleHeaders(headers),\n\t\tagent\n\t});\n}\n\n/**\n * abort-error.js\n *\n * AbortError interface for cancelled requests\n */\n\n/**\n * Create AbortError instance\n *\n * @param   String      message      Error message for human\n * @return  AbortError\n */\nfunction AbortError(message) {\n  Error.call(this, message);\n\n  this.type = 'aborted';\n  this.message = message;\n\n  // hide custom error implementation details from end-users\n  Error.captureStackTrace(this, this.constructor);\n}\n\nAbortError.prototype = Object.create(Error.prototype);\nAbortError.prototype.constructor = AbortError;\nAbortError.prototype.name = 'AbortError';\n\nconst URL$1 = Url.URL || whatwgUrl.URL;\n\n// fix an issue where \"PassThrough\", \"resolve\" aren't a named export for node <10\nconst PassThrough$1 = Stream.PassThrough;\n\nconst isDomainOrSubdomain = function isDomainOrSubdomain(destination, original) {\n\tconst orig = new URL$1(original).hostname;\n\tconst dest = new URL$1(destination).hostname;\n\n\treturn orig === dest || orig[orig.length - dest.length - 1] === '.' && orig.endsWith(dest);\n};\n\n/**\n * isSameProtocol reports whether the two provided URLs use the same protocol.\n *\n * Both domains must already be in canonical form.\n * @param {string|URL} original\n * @param {string|URL} destination\n */\nconst isSameProtocol = function isSameProtocol(destination, original) {\n\tconst orig = new URL$1(original).protocol;\n\tconst dest = new URL$1(destination).protocol;\n\n\treturn orig === dest;\n};\n\n/**\n * Fetch function\n *\n * @param   Mixed    url   Absolute url or Request instance\n * @param   Object   opts  Fetch options\n * @return  Promise\n */\nfunction fetch(url, opts) {\n\n\t// allow custom promise\n\tif (!fetch.Promise) {\n\t\tthrow new Error('native promise missing, set fetch.Promise to your favorite alternative');\n\t}\n\n\tBody.Promise = fetch.Promise;\n\n\t// wrap http.request into fetch\n\treturn new fetch.Promise(function (resolve, reject) {\n\t\t// build request object\n\t\tconst request = new Request(url, opts);\n\t\tconst options = getNodeRequestOptions(request);\n\n\t\tconst send = (options.protocol === 'https:' ? https : http).request;\n\t\tconst signal = request.signal;\n\n\t\tlet response = null;\n\n\t\tconst abort = function abort() {\n\t\t\tlet error = new AbortError('The user aborted a request.');\n\t\t\treject(error);\n\t\t\tif (request.body && request.body instanceof Stream.Readable) {\n\t\t\t\tdestroyStream(request.body, error);\n\t\t\t}\n\t\t\tif (!response || !response.body) return;\n\t\t\tresponse.body.emit('error', error);\n\t\t};\n\n\t\tif (signal && signal.aborted) {\n\t\t\tabort();\n\t\t\treturn;\n\t\t}\n\n\t\tconst abortAndFinalize = function abortAndFinalize() {\n\t\t\tabort();\n\t\t\tfinalize();\n\t\t};\n\n\t\t// send request\n\t\tconst req = send(options);\n\t\tlet reqTimeout;\n\n\t\tif (signal) {\n\t\t\tsignal.addEventListener('abort', abortAndFinalize);\n\t\t}\n\n\t\tfunction finalize() {\n\t\t\treq.abort();\n\t\t\tif (signal) signal.removeEventListener('abort', abortAndFinalize);\n\t\t\tclearTimeout(reqTimeout);\n\t\t}\n\n\t\tif (request.timeout) {\n\t\t\treq.once('socket', function (socket) {\n\t\t\t\treqTimeout = setTimeout(function () {\n\t\t\t\t\treject(new FetchError(`network timeout at: ${request.url}`, 'request-timeout'));\n\t\t\t\t\tfinalize();\n\t\t\t\t}, request.timeout);\n\t\t\t});\n\t\t}\n\n\t\treq.on('error', function (err) {\n\t\t\treject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, 'system', err));\n\n\t\t\tif (response && response.body) {\n\t\t\t\tdestroyStream(response.body, err);\n\t\t\t}\n\n\t\t\tfinalize();\n\t\t});\n\n\t\tfixResponseChunkedTransferBadEnding(req, function (err) {\n\t\t\tif (signal && signal.aborted) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (response && response.body) {\n\t\t\t\tdestroyStream(response.body, err);\n\t\t\t}\n\t\t});\n\n\t\t/* c8 ignore next 18 */\n\t\tif (parseInt(process.version.substring(1)) < 14) {\n\t\t\t// Before Node.js 14, pipeline() does not fully support async iterators and does not always\n\t\t\t// properly handle when the socket close/end events are out of order.\n\t\t\treq.on('socket', function (s) {\n\t\t\t\ts.addListener('close', function (hadError) {\n\t\t\t\t\t// if a data listener is still present we didn't end cleanly\n\t\t\t\t\tconst hasDataListener = s.listenerCount('data') > 0;\n\n\t\t\t\t\t// if end happened before close but the socket didn't emit an error, do it now\n\t\t\t\t\tif (response && hasDataListener && !hadError && !(signal && signal.aborted)) {\n\t\t\t\t\t\tconst err = new Error('Premature close');\n\t\t\t\t\t\terr.code = 'ERR_STREAM_PREMATURE_CLOSE';\n\t\t\t\t\t\tresponse.body.emit('error', err);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\n\t\treq.on('response', function (res) {\n\t\t\tclearTimeout(reqTimeout);\n\n\t\t\tconst headers = createHeadersLenient(res.headers);\n\n\t\t\t// HTTP fetch step 5\n\t\t\tif (fetch.isRedirect(res.statusCode)) {\n\t\t\t\t// HTTP fetch step 5.2\n\t\t\t\tconst location = headers.get('Location');\n\n\t\t\t\t// HTTP fetch step 5.3\n\t\t\t\tlet locationURL = null;\n\t\t\t\ttry {\n\t\t\t\t\tlocationURL = location === null ? null : new URL$1(location, request.url).toString();\n\t\t\t\t} catch (err) {\n\t\t\t\t\t// error here can only be invalid URL in Location: header\n\t\t\t\t\t// do not throw when options.redirect == manual\n\t\t\t\t\t// let the user extract the errorneous redirect URL\n\t\t\t\t\tif (request.redirect !== 'manual') {\n\t\t\t\t\t\treject(new FetchError(`uri requested responds with an invalid redirect URL: ${location}`, 'invalid-redirect'));\n\t\t\t\t\t\tfinalize();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// HTTP fetch step 5.5\n\t\t\t\tswitch (request.redirect) {\n\t\t\t\t\tcase 'error':\n\t\t\t\t\t\treject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, 'no-redirect'));\n\t\t\t\t\t\tfinalize();\n\t\t\t\t\t\treturn;\n\t\t\t\t\tcase 'manual':\n\t\t\t\t\t\t// node-fetch-specific step: make manual redirect a bit easier to use by setting the Location header value to the resolved URL.\n\t\t\t\t\t\tif (locationURL !== null) {\n\t\t\t\t\t\t\t// handle corrupted header\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\theaders.set('Location', locationURL);\n\t\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\t\t// istanbul ignore next: nodejs server prevent invalid response headers, we can't test this through normal request\n\t\t\t\t\t\t\t\treject(err);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'follow':\n\t\t\t\t\t\t// HTTP-redirect fetch step 2\n\t\t\t\t\t\tif (locationURL === null) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 5\n\t\t\t\t\t\tif (request.counter >= request.follow) {\n\t\t\t\t\t\t\treject(new FetchError(`maximum redirect reached at: ${request.url}`, 'max-redirect'));\n\t\t\t\t\t\t\tfinalize();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 6 (counter increment)\n\t\t\t\t\t\t// Create a new Request object.\n\t\t\t\t\t\tconst requestOpts = {\n\t\t\t\t\t\t\theaders: new Headers(request.headers),\n\t\t\t\t\t\t\tfollow: request.follow,\n\t\t\t\t\t\t\tcounter: request.counter + 1,\n\t\t\t\t\t\t\tagent: request.agent,\n\t\t\t\t\t\t\tcompress: request.compress,\n\t\t\t\t\t\t\tmethod: request.method,\n\t\t\t\t\t\t\tbody: request.body,\n\t\t\t\t\t\t\tsignal: request.signal,\n\t\t\t\t\t\t\ttimeout: request.timeout,\n\t\t\t\t\t\t\tsize: request.size\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tif (!isDomainOrSubdomain(request.url, locationURL) || !isSameProtocol(request.url, locationURL)) {\n\t\t\t\t\t\t\tfor (const name of ['authorization', 'www-authenticate', 'cookie', 'cookie2']) {\n\t\t\t\t\t\t\t\trequestOpts.headers.delete(name);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 9\n\t\t\t\t\t\tif (res.statusCode !== 303 && request.body && getTotalBytes(request) === null) {\n\t\t\t\t\t\t\treject(new FetchError('Cannot follow redirect with body being a readable stream', 'unsupported-redirect'));\n\t\t\t\t\t\t\tfinalize();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 11\n\t\t\t\t\t\tif (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === 'POST') {\n\t\t\t\t\t\t\trequestOpts.method = 'GET';\n\t\t\t\t\t\t\trequestOpts.body = undefined;\n\t\t\t\t\t\t\trequestOpts.headers.delete('content-length');\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 15\n\t\t\t\t\t\tresolve(fetch(new Request(locationURL, requestOpts)));\n\t\t\t\t\t\tfinalize();\n\t\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// prepare response\n\t\t\tres.once('end', function () {\n\t\t\t\tif (signal) signal.removeEventListener('abort', abortAndFinalize);\n\t\t\t});\n\t\t\tlet body = res.pipe(new PassThrough$1());\n\n\t\t\tconst response_options = {\n\t\t\t\turl: request.url,\n\t\t\t\tstatus: res.statusCode,\n\t\t\t\tstatusText: res.statusMessage,\n\t\t\t\theaders: headers,\n\t\t\t\tsize: request.size,\n\t\t\t\ttimeout: request.timeout,\n\t\t\t\tcounter: request.counter\n\t\t\t};\n\n\t\t\t// HTTP-network fetch step 12.1.1.3\n\t\t\tconst codings = headers.get('Content-Encoding');\n\n\t\t\t// HTTP-network fetch step 12.1.1.4: handle content codings\n\n\t\t\t// in following scenarios we ignore compression support\n\t\t\t// 1. compression support is disabled\n\t\t\t// 2. HEAD request\n\t\t\t// 3. no Content-Encoding header\n\t\t\t// 4. no content response (204)\n\t\t\t// 5. content not modified response (304)\n\t\t\tif (!request.compress || request.method === 'HEAD' || codings === null || res.statusCode === 204 || res.statusCode === 304) {\n\t\t\t\tresponse = new Response(body, response_options);\n\t\t\t\tresolve(response);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// For Node v6+\n\t\t\t// Be less strict when decoding compressed responses, since sometimes\n\t\t\t// servers send slightly invalid responses that are still accepted\n\t\t\t// by common browsers.\n\t\t\t// Always using Z_SYNC_FLUSH is what cURL does.\n\t\t\tconst zlibOptions = {\n\t\t\t\tflush: zlib.Z_SYNC_FLUSH,\n\t\t\t\tfinishFlush: zlib.Z_SYNC_FLUSH\n\t\t\t};\n\n\t\t\t// for gzip\n\t\t\tif (codings == 'gzip' || codings == 'x-gzip') {\n\t\t\t\tbody = body.pipe(zlib.createGunzip(zlibOptions));\n\t\t\t\tresponse = new Response(body, response_options);\n\t\t\t\tresolve(response);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// for deflate\n\t\t\tif (codings == 'deflate' || codings == 'x-deflate') {\n\t\t\t\t// handle the infamous raw deflate response from old servers\n\t\t\t\t// a hack for old IIS and Apache servers\n\t\t\t\tconst raw = res.pipe(new PassThrough$1());\n\t\t\t\traw.once('data', function (chunk) {\n\t\t\t\t\t// see http://stackoverflow.com/questions/37519828\n\t\t\t\t\tif ((chunk[0] & 0x0F) === 0x08) {\n\t\t\t\t\t\tbody = body.pipe(zlib.createInflate());\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbody = body.pipe(zlib.createInflateRaw());\n\t\t\t\t\t}\n\t\t\t\t\tresponse = new Response(body, response_options);\n\t\t\t\t\tresolve(response);\n\t\t\t\t});\n\t\t\t\traw.on('end', function () {\n\t\t\t\t\t// some old IIS servers return zero-length OK deflate responses, so 'data' is never emitted.\n\t\t\t\t\tif (!response) {\n\t\t\t\t\t\tresponse = new Response(body, response_options);\n\t\t\t\t\t\tresolve(response);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// for br\n\t\t\tif (codings == 'br' && typeof zlib.createBrotliDecompress === 'function') {\n\t\t\t\tbody = body.pipe(zlib.createBrotliDecompress());\n\t\t\t\tresponse = new Response(body, response_options);\n\t\t\t\tresolve(response);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// otherwise, use response as-is\n\t\t\tresponse = new Response(body, response_options);\n\t\t\tresolve(response);\n\t\t});\n\n\t\twriteToStream(req, request);\n\t});\n}\nfunction fixResponseChunkedTransferBadEnding(request, errorCallback) {\n\tlet socket;\n\n\trequest.on('socket', function (s) {\n\t\tsocket = s;\n\t});\n\n\trequest.on('response', function (response) {\n\t\tconst headers = response.headers;\n\n\t\tif (headers['transfer-encoding'] === 'chunked' && !headers['content-length']) {\n\t\t\tresponse.once('close', function (hadError) {\n\t\t\t\t// if a data listener is still present we didn't end cleanly\n\t\t\t\tconst hasDataListener = socket.listenerCount('data') > 0;\n\n\t\t\t\tif (hasDataListener && !hadError) {\n\t\t\t\t\tconst err = new Error('Premature close');\n\t\t\t\t\terr.code = 'ERR_STREAM_PREMATURE_CLOSE';\n\t\t\t\t\terrorCallback(err);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t});\n}\n\nfunction destroyStream(stream, err) {\n\tif (stream.destroy) {\n\t\tstream.destroy(err);\n\t} else {\n\t\t// node < 8\n\t\tstream.emit('error', err);\n\t\tstream.end();\n\t}\n}\n\n/**\n * Redirect code matching\n *\n * @param   Number   code  Status code\n * @return  Boolean\n */\nfetch.isRedirect = function (code) {\n\treturn code === 301 || code === 302 || code === 303 || code === 307 || code === 308;\n};\n\n// expose Promise\nfetch.Promise = global.Promise;\n\nmodule.exports = exports = fetch;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = exports;\nexports.Headers = Headers;\nexports.Request = Request;\nexports.Response = Response;\nexports.FetchError = FetchError;\n","var wrappy = require('wrappy')\nmodule.exports = wrappy(once)\nmodule.exports.strict = wrappy(onceStrict)\n\nonce.proto = once(function () {\n  Object.defineProperty(Function.prototype, 'once', {\n    value: function () {\n      return once(this)\n    },\n    configurable: true\n  })\n\n  Object.defineProperty(Function.prototype, 'onceStrict', {\n    value: function () {\n      return onceStrict(this)\n    },\n    configurable: true\n  })\n})\n\nfunction once (fn) {\n  var f = function () {\n    if (f.called) return f.value\n    f.called = true\n    return f.value = fn.apply(this, arguments)\n  }\n  f.called = false\n  return f\n}\n\nfunction onceStrict (fn) {\n  var f = function () {\n    if (f.called)\n      throw new Error(f.onceError)\n    f.called = true\n    return f.value = fn.apply(this, arguments)\n  }\n  var name = fn.name || 'Function wrapped with `once`'\n  f.onceError = name + \" shouldn't be called more than once\"\n  f.called = false\n  return f\n}\n","var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __esm = (fn, res) => function __init() {\n  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;\n};\nvar __commonJS = (cb, mod) => function __require() {\n  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n};\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __reExport = (target, module2, copyDefault, desc) => {\n  if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n    for (let key of __getOwnPropNames(module2))\n      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== \"default\"))\n        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });\n  }\n  return target;\n};\nvar __toESM = (module2, isNodeMode) => {\n  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, \"default\", !isNodeMode && module2 && module2.__esModule ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);\n};\nvar __toCommonJS = /* @__PURE__ */ ((cache) => {\n  return (module2, temp) => {\n    return cache && cache.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache && cache.set(module2, temp), temp);\n  };\n})(typeof WeakMap !== \"undefined\" ? /* @__PURE__ */ new WeakMap() : 0);\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = (value) => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = (value) => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\n\n// src/lib/errors/git-error.ts\nvar GitError;\nvar init_git_error = __esm({\n  \"src/lib/errors/git-error.ts\"() {\n    GitError = class extends Error {\n      constructor(task, message) {\n        super(message);\n        this.task = task;\n        Object.setPrototypeOf(this, new.target.prototype);\n      }\n    };\n  }\n});\n\n// src/lib/errors/git-response-error.ts\nvar GitResponseError;\nvar init_git_response_error = __esm({\n  \"src/lib/errors/git-response-error.ts\"() {\n    init_git_error();\n    GitResponseError = class extends GitError {\n      constructor(git, message) {\n        super(void 0, message || String(git));\n        this.git = git;\n      }\n    };\n  }\n});\n\n// src/lib/errors/git-construct-error.ts\nvar GitConstructError;\nvar init_git_construct_error = __esm({\n  \"src/lib/errors/git-construct-error.ts\"() {\n    init_git_error();\n    GitConstructError = class extends GitError {\n      constructor(config, message) {\n        super(void 0, message);\n        this.config = config;\n      }\n    };\n  }\n});\n\n// src/lib/errors/git-plugin-error.ts\nvar GitPluginError;\nvar init_git_plugin_error = __esm({\n  \"src/lib/errors/git-plugin-error.ts\"() {\n    init_git_error();\n    GitPluginError = class extends GitError {\n      constructor(task, plugin, message) {\n        super(task, message);\n        this.task = task;\n        this.plugin = plugin;\n        Object.setPrototypeOf(this, new.target.prototype);\n      }\n    };\n  }\n});\n\n// src/lib/errors/task-configuration-error.ts\nvar TaskConfigurationError;\nvar init_task_configuration_error = __esm({\n  \"src/lib/errors/task-configuration-error.ts\"() {\n    init_git_error();\n    TaskConfigurationError = class extends GitError {\n      constructor(message) {\n        super(void 0, message);\n      }\n    };\n  }\n});\n\n// src/lib/utils/util.ts\nfunction asFunction(source) {\n  return typeof source === \"function\" ? source : NOOP;\n}\nfunction isUserFunction(source) {\n  return typeof source === \"function\" && source !== NOOP;\n}\nfunction splitOn(input, char) {\n  const index = input.indexOf(char);\n  if (index <= 0) {\n    return [input, \"\"];\n  }\n  return [input.substr(0, index), input.substr(index + 1)];\n}\nfunction first(input, offset = 0) {\n  return isArrayLike(input) && input.length > offset ? input[offset] : void 0;\n}\nfunction last(input, offset = 0) {\n  if (isArrayLike(input) && input.length > offset) {\n    return input[input.length - 1 - offset];\n  }\n}\nfunction isArrayLike(input) {\n  return !!(input && typeof input.length === \"number\");\n}\nfunction toLinesWithContent(input = \"\", trimmed2 = true, separator = \"\\n\") {\n  return input.split(separator).reduce((output, line) => {\n    const lineContent = trimmed2 ? line.trim() : line;\n    if (lineContent) {\n      output.push(lineContent);\n    }\n    return output;\n  }, []);\n}\nfunction forEachLineWithContent(input, callback) {\n  return toLinesWithContent(input, true).map((line) => callback(line));\n}\nfunction folderExists(path) {\n  return (0, import_file_exists.exists)(path, import_file_exists.FOLDER);\n}\nfunction append(target, item) {\n  if (Array.isArray(target)) {\n    if (!target.includes(item)) {\n      target.push(item);\n    }\n  } else {\n    target.add(item);\n  }\n  return item;\n}\nfunction including(target, item) {\n  if (Array.isArray(target) && !target.includes(item)) {\n    target.push(item);\n  }\n  return target;\n}\nfunction remove(target, item) {\n  if (Array.isArray(target)) {\n    const index = target.indexOf(item);\n    if (index >= 0) {\n      target.splice(index, 1);\n    }\n  } else {\n    target.delete(item);\n  }\n  return item;\n}\nfunction asArray(source) {\n  return Array.isArray(source) ? source : [source];\n}\nfunction asStringArray(source) {\n  return asArray(source).map(String);\n}\nfunction asNumber(source, onNaN = 0) {\n  if (source == null) {\n    return onNaN;\n  }\n  const num = parseInt(source, 10);\n  return isNaN(num) ? onNaN : num;\n}\nfunction prefixedArray(input, prefix) {\n  const output = [];\n  for (let i = 0, max = input.length; i < max; i++) {\n    output.push(prefix, input[i]);\n  }\n  return output;\n}\nfunction bufferToString(input) {\n  return (Array.isArray(input) ? Buffer.concat(input) : input).toString(\"utf-8\");\n}\nfunction pick(source, properties) {\n  return Object.assign({}, ...properties.map((property) => property in source ? { [property]: source[property] } : {}));\n}\nfunction delay(duration = 0) {\n  return new Promise((done) => setTimeout(done, duration));\n}\nvar import_file_exists, NULL, NOOP, objectToString;\nvar init_util = __esm({\n  \"src/lib/utils/util.ts\"() {\n    import_file_exists = require(\"@kwsites/file-exists\");\n    NULL = \"\\0\";\n    NOOP = () => {\n    };\n    objectToString = Object.prototype.toString.call.bind(Object.prototype.toString);\n  }\n});\n\n// src/lib/utils/argument-filters.ts\nfunction filterType(input, filter, def) {\n  if (filter(input)) {\n    return input;\n  }\n  return arguments.length > 2 ? def : void 0;\n}\nfunction filterPrimitives(input, omit) {\n  return /number|string|boolean/.test(typeof input) && (!omit || !omit.includes(typeof input));\n}\nfunction filterPlainObject(input) {\n  return !!input && objectToString(input) === \"[object Object]\";\n}\nfunction filterFunction(input) {\n  return typeof input === \"function\";\n}\nvar filterArray, filterString, filterStringArray, filterStringOrStringArray, filterHasLength;\nvar init_argument_filters = __esm({\n  \"src/lib/utils/argument-filters.ts\"() {\n    init_util();\n    filterArray = (input) => {\n      return Array.isArray(input);\n    };\n    filterString = (input) => {\n      return typeof input === \"string\";\n    };\n    filterStringArray = (input) => {\n      return Array.isArray(input) && input.every(filterString);\n    };\n    filterStringOrStringArray = (input) => {\n      return filterString(input) || Array.isArray(input) && input.every(filterString);\n    };\n    filterHasLength = (input) => {\n      if (input == null || \"number|boolean|function\".includes(typeof input)) {\n        return false;\n      }\n      return Array.isArray(input) || typeof input === \"string\" || typeof input.length === \"number\";\n    };\n  }\n});\n\n// src/lib/utils/exit-codes.ts\nvar ExitCodes;\nvar init_exit_codes = __esm({\n  \"src/lib/utils/exit-codes.ts\"() {\n    ExitCodes = /* @__PURE__ */ ((ExitCodes2) => {\n      ExitCodes2[ExitCodes2[\"SUCCESS\"] = 0] = \"SUCCESS\";\n      ExitCodes2[ExitCodes2[\"ERROR\"] = 1] = \"ERROR\";\n      ExitCodes2[ExitCodes2[\"NOT_FOUND\"] = -2] = \"NOT_FOUND\";\n      ExitCodes2[ExitCodes2[\"UNCLEAN\"] = 128] = \"UNCLEAN\";\n      return ExitCodes2;\n    })(ExitCodes || {});\n  }\n});\n\n// src/lib/utils/git-output-streams.ts\nvar GitOutputStreams;\nvar init_git_output_streams = __esm({\n  \"src/lib/utils/git-output-streams.ts\"() {\n    GitOutputStreams = class {\n      constructor(stdOut, stdErr) {\n        this.stdOut = stdOut;\n        this.stdErr = stdErr;\n      }\n      asStrings() {\n        return new GitOutputStreams(this.stdOut.toString(\"utf8\"), this.stdErr.toString(\"utf8\"));\n      }\n    };\n  }\n});\n\n// src/lib/utils/line-parser.ts\nvar LineParser, RemoteLineParser;\nvar init_line_parser = __esm({\n  \"src/lib/utils/line-parser.ts\"() {\n    LineParser = class {\n      constructor(regExp, useMatches) {\n        this.matches = [];\n        this.parse = (line, target) => {\n          this.resetMatches();\n          if (!this._regExp.every((reg, index) => this.addMatch(reg, index, line(index)))) {\n            return false;\n          }\n          return this.useMatches(target, this.prepareMatches()) !== false;\n        };\n        this._regExp = Array.isArray(regExp) ? regExp : [regExp];\n        if (useMatches) {\n          this.useMatches = useMatches;\n        }\n      }\n      useMatches(target, match) {\n        throw new Error(`LineParser:useMatches not implemented`);\n      }\n      resetMatches() {\n        this.matches.length = 0;\n      }\n      prepareMatches() {\n        return this.matches;\n      }\n      addMatch(reg, index, line) {\n        const matched = line && reg.exec(line);\n        if (matched) {\n          this.pushMatch(index, matched);\n        }\n        return !!matched;\n      }\n      pushMatch(_index, matched) {\n        this.matches.push(...matched.slice(1));\n      }\n    };\n    RemoteLineParser = class extends LineParser {\n      addMatch(reg, index, line) {\n        return /^remote:\\s/.test(String(line)) && super.addMatch(reg, index, line);\n      }\n      pushMatch(index, matched) {\n        if (index > 0 || matched.length > 1) {\n          super.pushMatch(index, matched);\n        }\n      }\n    };\n  }\n});\n\n// src/lib/utils/simple-git-options.ts\nfunction createInstanceConfig(...options) {\n  const baseDir = process.cwd();\n  const config = Object.assign(__spreadValues({ baseDir }, defaultOptions), ...options.filter((o) => typeof o === \"object\" && o));\n  config.baseDir = config.baseDir || baseDir;\n  config.trimmed = config.trimmed === true;\n  return config;\n}\nvar defaultOptions;\nvar init_simple_git_options = __esm({\n  \"src/lib/utils/simple-git-options.ts\"() {\n    defaultOptions = {\n      binary: \"git\",\n      maxConcurrentProcesses: 5,\n      config: [],\n      trimmed: false\n    };\n  }\n});\n\n// src/lib/utils/task-options.ts\nfunction appendTaskOptions(options, commands = []) {\n  if (!filterPlainObject(options)) {\n    return commands;\n  }\n  return Object.keys(options).reduce((commands2, key) => {\n    const value = options[key];\n    if (filterPrimitives(value, [\"boolean\"])) {\n      commands2.push(key + \"=\" + value);\n    } else {\n      commands2.push(key);\n    }\n    return commands2;\n  }, commands);\n}\nfunction getTrailingOptions(args, initialPrimitive = 0, objectOnly = false) {\n  const command = [];\n  for (let i = 0, max = initialPrimitive < 0 ? args.length : initialPrimitive; i < max; i++) {\n    if (\"string|number\".includes(typeof args[i])) {\n      command.push(String(args[i]));\n    }\n  }\n  appendTaskOptions(trailingOptionsArgument(args), command);\n  if (!objectOnly) {\n    command.push(...trailingArrayArgument(args));\n  }\n  return command;\n}\nfunction trailingArrayArgument(args) {\n  const hasTrailingCallback = typeof last(args) === \"function\";\n  return filterType(last(args, hasTrailingCallback ? 1 : 0), filterArray, []);\n}\nfunction trailingOptionsArgument(args) {\n  const hasTrailingCallback = filterFunction(last(args));\n  return filterType(last(args, hasTrailingCallback ? 1 : 0), filterPlainObject);\n}\nfunction trailingFunctionArgument(args, includeNoop = true) {\n  const callback = asFunction(last(args));\n  return includeNoop || isUserFunction(callback) ? callback : void 0;\n}\nvar init_task_options = __esm({\n  \"src/lib/utils/task-options.ts\"() {\n    init_argument_filters();\n    init_util();\n  }\n});\n\n// src/lib/utils/task-parser.ts\nfunction callTaskParser(parser3, streams) {\n  return parser3(streams.stdOut, streams.stdErr);\n}\nfunction parseStringResponse(result, parsers12, texts, trim = true) {\n  asArray(texts).forEach((text) => {\n    for (let lines = toLinesWithContent(text, trim), i = 0, max = lines.length; i < max; i++) {\n      const line = (offset = 0) => {\n        if (i + offset >= max) {\n          return;\n        }\n        return lines[i + offset];\n      };\n      parsers12.some(({ parse }) => parse(line, result));\n    }\n  });\n  return result;\n}\nvar init_task_parser = __esm({\n  \"src/lib/utils/task-parser.ts\"() {\n    init_util();\n  }\n});\n\n// src/lib/utils/index.ts\nvar utils_exports = {};\n__export(utils_exports, {\n  ExitCodes: () => ExitCodes,\n  GitOutputStreams: () => GitOutputStreams,\n  LineParser: () => LineParser,\n  NOOP: () => NOOP,\n  NULL: () => NULL,\n  RemoteLineParser: () => RemoteLineParser,\n  append: () => append,\n  appendTaskOptions: () => appendTaskOptions,\n  asArray: () => asArray,\n  asFunction: () => asFunction,\n  asNumber: () => asNumber,\n  asStringArray: () => asStringArray,\n  bufferToString: () => bufferToString,\n  callTaskParser: () => callTaskParser,\n  createInstanceConfig: () => createInstanceConfig,\n  delay: () => delay,\n  filterArray: () => filterArray,\n  filterFunction: () => filterFunction,\n  filterHasLength: () => filterHasLength,\n  filterPlainObject: () => filterPlainObject,\n  filterPrimitives: () => filterPrimitives,\n  filterString: () => filterString,\n  filterStringArray: () => filterStringArray,\n  filterStringOrStringArray: () => filterStringOrStringArray,\n  filterType: () => filterType,\n  first: () => first,\n  folderExists: () => folderExists,\n  forEachLineWithContent: () => forEachLineWithContent,\n  getTrailingOptions: () => getTrailingOptions,\n  including: () => including,\n  isUserFunction: () => isUserFunction,\n  last: () => last,\n  objectToString: () => objectToString,\n  parseStringResponse: () => parseStringResponse,\n  pick: () => pick,\n  prefixedArray: () => prefixedArray,\n  remove: () => remove,\n  splitOn: () => splitOn,\n  toLinesWithContent: () => toLinesWithContent,\n  trailingFunctionArgument: () => trailingFunctionArgument,\n  trailingOptionsArgument: () => trailingOptionsArgument\n});\nvar init_utils = __esm({\n  \"src/lib/utils/index.ts\"() {\n    init_argument_filters();\n    init_exit_codes();\n    init_git_output_streams();\n    init_line_parser();\n    init_simple_git_options();\n    init_task_options();\n    init_task_parser();\n    init_util();\n  }\n});\n\n// src/lib/tasks/check-is-repo.ts\nvar check_is_repo_exports = {};\n__export(check_is_repo_exports, {\n  CheckRepoActions: () => CheckRepoActions,\n  checkIsBareRepoTask: () => checkIsBareRepoTask,\n  checkIsRepoRootTask: () => checkIsRepoRootTask,\n  checkIsRepoTask: () => checkIsRepoTask\n});\nfunction checkIsRepoTask(action) {\n  switch (action) {\n    case \"bare\" /* BARE */:\n      return checkIsBareRepoTask();\n    case \"root\" /* IS_REPO_ROOT */:\n      return checkIsRepoRootTask();\n  }\n  const commands = [\"rev-parse\", \"--is-inside-work-tree\"];\n  return {\n    commands,\n    format: \"utf-8\",\n    onError,\n    parser\n  };\n}\nfunction checkIsRepoRootTask() {\n  const commands = [\"rev-parse\", \"--git-dir\"];\n  return {\n    commands,\n    format: \"utf-8\",\n    onError,\n    parser(path) {\n      return /^\\.(git)?$/.test(path.trim());\n    }\n  };\n}\nfunction checkIsBareRepoTask() {\n  const commands = [\"rev-parse\", \"--is-bare-repository\"];\n  return {\n    commands,\n    format: \"utf-8\",\n    onError,\n    parser\n  };\n}\nfunction isNotRepoMessage(error) {\n  return /(Not a git repository|Kein Git-Repository)/i.test(String(error));\n}\nvar CheckRepoActions, onError, parser;\nvar init_check_is_repo = __esm({\n  \"src/lib/tasks/check-is-repo.ts\"() {\n    init_utils();\n    CheckRepoActions = /* @__PURE__ */ ((CheckRepoActions2) => {\n      CheckRepoActions2[\"BARE\"] = \"bare\";\n      CheckRepoActions2[\"IN_TREE\"] = \"tree\";\n      CheckRepoActions2[\"IS_REPO_ROOT\"] = \"root\";\n      return CheckRepoActions2;\n    })(CheckRepoActions || {});\n    onError = ({ exitCode }, error, done, fail) => {\n      if (exitCode === 128 /* UNCLEAN */ && isNotRepoMessage(error)) {\n        return done(Buffer.from(\"false\"));\n      }\n      fail(error);\n    };\n    parser = (text) => {\n      return text.trim() === \"true\";\n    };\n  }\n});\n\n// src/lib/responses/CleanSummary.ts\nfunction cleanSummaryParser(dryRun, text) {\n  const summary = new CleanResponse(dryRun);\n  const regexp = dryRun ? dryRunRemovalRegexp : removalRegexp;\n  toLinesWithContent(text).forEach((line) => {\n    const removed = line.replace(regexp, \"\");\n    summary.paths.push(removed);\n    (isFolderRegexp.test(removed) ? summary.folders : summary.files).push(removed);\n  });\n  return summary;\n}\nvar CleanResponse, removalRegexp, dryRunRemovalRegexp, isFolderRegexp;\nvar init_CleanSummary = __esm({\n  \"src/lib/responses/CleanSummary.ts\"() {\n    init_utils();\n    CleanResponse = class {\n      constructor(dryRun) {\n        this.dryRun = dryRun;\n        this.paths = [];\n        this.files = [];\n        this.folders = [];\n      }\n    };\n    removalRegexp = /^[a-z]+\\s*/i;\n    dryRunRemovalRegexp = /^[a-z]+\\s+[a-z]+\\s*/i;\n    isFolderRegexp = /\\/$/;\n  }\n});\n\n// src/lib/tasks/task.ts\nvar task_exports = {};\n__export(task_exports, {\n  EMPTY_COMMANDS: () => EMPTY_COMMANDS,\n  adhocExecTask: () => adhocExecTask,\n  configurationErrorTask: () => configurationErrorTask,\n  isBufferTask: () => isBufferTask,\n  isEmptyTask: () => isEmptyTask,\n  straightThroughBufferTask: () => straightThroughBufferTask,\n  straightThroughStringTask: () => straightThroughStringTask\n});\nfunction adhocExecTask(parser3) {\n  return {\n    commands: EMPTY_COMMANDS,\n    format: \"empty\",\n    parser: parser3\n  };\n}\nfunction configurationErrorTask(error) {\n  return {\n    commands: EMPTY_COMMANDS,\n    format: \"empty\",\n    parser() {\n      throw typeof error === \"string\" ? new TaskConfigurationError(error) : error;\n    }\n  };\n}\nfunction straightThroughStringTask(commands, trimmed2 = false) {\n  return {\n    commands,\n    format: \"utf-8\",\n    parser(text) {\n      return trimmed2 ? String(text).trim() : text;\n    }\n  };\n}\nfunction straightThroughBufferTask(commands) {\n  return {\n    commands,\n    format: \"buffer\",\n    parser(buffer) {\n      return buffer;\n    }\n  };\n}\nfunction isBufferTask(task) {\n  return task.format === \"buffer\";\n}\nfunction isEmptyTask(task) {\n  return task.format === \"empty\" || !task.commands.length;\n}\nvar EMPTY_COMMANDS;\nvar init_task = __esm({\n  \"src/lib/tasks/task.ts\"() {\n    init_task_configuration_error();\n    EMPTY_COMMANDS = [];\n  }\n});\n\n// src/lib/tasks/clean.ts\nvar clean_exports = {};\n__export(clean_exports, {\n  CONFIG_ERROR_INTERACTIVE_MODE: () => CONFIG_ERROR_INTERACTIVE_MODE,\n  CONFIG_ERROR_MODE_REQUIRED: () => CONFIG_ERROR_MODE_REQUIRED,\n  CONFIG_ERROR_UNKNOWN_OPTION: () => CONFIG_ERROR_UNKNOWN_OPTION,\n  CleanOptions: () => CleanOptions,\n  cleanTask: () => cleanTask,\n  cleanWithOptionsTask: () => cleanWithOptionsTask,\n  isCleanOptionsArray: () => isCleanOptionsArray\n});\nfunction cleanWithOptionsTask(mode, customArgs) {\n  const { cleanMode, options, valid } = getCleanOptions(mode);\n  if (!cleanMode) {\n    return configurationErrorTask(CONFIG_ERROR_MODE_REQUIRED);\n  }\n  if (!valid.options) {\n    return configurationErrorTask(CONFIG_ERROR_UNKNOWN_OPTION + JSON.stringify(mode));\n  }\n  options.push(...customArgs);\n  if (options.some(isInteractiveMode)) {\n    return configurationErrorTask(CONFIG_ERROR_INTERACTIVE_MODE);\n  }\n  return cleanTask(cleanMode, options);\n}\nfunction cleanTask(mode, customArgs) {\n  const commands = [\"clean\", `-${mode}`, ...customArgs];\n  return {\n    commands,\n    format: \"utf-8\",\n    parser(text) {\n      return cleanSummaryParser(mode === \"n\" /* DRY_RUN */, text);\n    }\n  };\n}\nfunction isCleanOptionsArray(input) {\n  return Array.isArray(input) && input.every((test) => CleanOptionValues.has(test));\n}\nfunction getCleanOptions(input) {\n  let cleanMode;\n  let options = [];\n  let valid = { cleanMode: false, options: true };\n  input.replace(/[^a-z]i/g, \"\").split(\"\").forEach((char) => {\n    if (isCleanMode(char)) {\n      cleanMode = char;\n      valid.cleanMode = true;\n    } else {\n      valid.options = valid.options && isKnownOption(options[options.length] = `-${char}`);\n    }\n  });\n  return {\n    cleanMode,\n    options,\n    valid\n  };\n}\nfunction isCleanMode(cleanMode) {\n  return cleanMode === \"f\" /* FORCE */ || cleanMode === \"n\" /* DRY_RUN */;\n}\nfunction isKnownOption(option) {\n  return /^-[a-z]$/i.test(option) && CleanOptionValues.has(option.charAt(1));\n}\nfunction isInteractiveMode(option) {\n  if (/^-[^\\-]/.test(option)) {\n    return option.indexOf(\"i\") > 0;\n  }\n  return option === \"--interactive\";\n}\nvar CONFIG_ERROR_INTERACTIVE_MODE, CONFIG_ERROR_MODE_REQUIRED, CONFIG_ERROR_UNKNOWN_OPTION, CleanOptions, CleanOptionValues;\nvar init_clean = __esm({\n  \"src/lib/tasks/clean.ts\"() {\n    init_CleanSummary();\n    init_utils();\n    init_task();\n    CONFIG_ERROR_INTERACTIVE_MODE = \"Git clean interactive mode is not supported\";\n    CONFIG_ERROR_MODE_REQUIRED = 'Git clean mode parameter (\"n\" or \"f\") is required';\n    CONFIG_ERROR_UNKNOWN_OPTION = \"Git clean unknown option found in: \";\n    CleanOptions = /* @__PURE__ */ ((CleanOptions2) => {\n      CleanOptions2[\"DRY_RUN\"] = \"n\";\n      CleanOptions2[\"FORCE\"] = \"f\";\n      CleanOptions2[\"IGNORED_INCLUDED\"] = \"x\";\n      CleanOptions2[\"IGNORED_ONLY\"] = \"X\";\n      CleanOptions2[\"EXCLUDING\"] = \"e\";\n      CleanOptions2[\"QUIET\"] = \"q\";\n      CleanOptions2[\"RECURSIVE\"] = \"d\";\n      return CleanOptions2;\n    })(CleanOptions || {});\n    CleanOptionValues = /* @__PURE__ */ new Set([\n      \"i\",\n      ...asStringArray(Object.values(CleanOptions))\n    ]);\n  }\n});\n\n// src/lib/responses/ConfigList.ts\nfunction configListParser(text) {\n  const config = new ConfigList();\n  for (const item of configParser(text)) {\n    config.addValue(item.file, String(item.key), item.value);\n  }\n  return config;\n}\nfunction configGetParser(text, key) {\n  let value = null;\n  const values = [];\n  const scopes = /* @__PURE__ */ new Map();\n  for (const item of configParser(text, key)) {\n    if (item.key !== key) {\n      continue;\n    }\n    values.push(value = item.value);\n    if (!scopes.has(item.file)) {\n      scopes.set(item.file, []);\n    }\n    scopes.get(item.file).push(value);\n  }\n  return {\n    key,\n    paths: Array.from(scopes.keys()),\n    scopes,\n    value,\n    values\n  };\n}\nfunction configFilePath(filePath) {\n  return filePath.replace(/^(file):/, \"\");\n}\nfunction* configParser(text, requestedKey = null) {\n  const lines = text.split(\"\\0\");\n  for (let i = 0, max = lines.length - 1; i < max; ) {\n    const file = configFilePath(lines[i++]);\n    let value = lines[i++];\n    let key = requestedKey;\n    if (value.includes(\"\\n\")) {\n      const line = splitOn(value, \"\\n\");\n      key = line[0];\n      value = line[1];\n    }\n    yield { file, key, value };\n  }\n}\nvar ConfigList;\nvar init_ConfigList = __esm({\n  \"src/lib/responses/ConfigList.ts\"() {\n    init_utils();\n    ConfigList = class {\n      constructor() {\n        this.files = [];\n        this.values = /* @__PURE__ */ Object.create(null);\n      }\n      get all() {\n        if (!this._all) {\n          this._all = this.files.reduce((all, file) => {\n            return Object.assign(all, this.values[file]);\n          }, {});\n        }\n        return this._all;\n      }\n      addFile(file) {\n        if (!(file in this.values)) {\n          const latest = last(this.files);\n          this.values[file] = latest ? Object.create(this.values[latest]) : {};\n          this.files.push(file);\n        }\n        return this.values[file];\n      }\n      addValue(file, key, value) {\n        const values = this.addFile(file);\n        if (!values.hasOwnProperty(key)) {\n          values[key] = value;\n        } else if (Array.isArray(values[key])) {\n          values[key].push(value);\n        } else {\n          values[key] = [values[key], value];\n        }\n        this._all = void 0;\n      }\n    };\n  }\n});\n\n// src/lib/tasks/config.ts\nfunction asConfigScope(scope, fallback) {\n  if (typeof scope === \"string\" && GitConfigScope.hasOwnProperty(scope)) {\n    return scope;\n  }\n  return fallback;\n}\nfunction addConfigTask(key, value, append2, scope) {\n  const commands = [\"config\", `--${scope}`];\n  if (append2) {\n    commands.push(\"--add\");\n  }\n  commands.push(key, value);\n  return {\n    commands,\n    format: \"utf-8\",\n    parser(text) {\n      return text;\n    }\n  };\n}\nfunction getConfigTask(key, scope) {\n  const commands = [\"config\", \"--null\", \"--show-origin\", \"--get-all\", key];\n  if (scope) {\n    commands.splice(1, 0, `--${scope}`);\n  }\n  return {\n    commands,\n    format: \"utf-8\",\n    parser(text) {\n      return configGetParser(text, key);\n    }\n  };\n}\nfunction listConfigTask(scope) {\n  const commands = [\"config\", \"--list\", \"--show-origin\", \"--null\"];\n  if (scope) {\n    commands.push(`--${scope}`);\n  }\n  return {\n    commands,\n    format: \"utf-8\",\n    parser(text) {\n      return configListParser(text);\n    }\n  };\n}\nfunction config_default() {\n  return {\n    addConfig(key, value, ...rest) {\n      return this._runTask(addConfigTask(key, value, rest[0] === true, asConfigScope(rest[1], \"local\" /* local */)), trailingFunctionArgument(arguments));\n    },\n    getConfig(key, scope) {\n      return this._runTask(getConfigTask(key, asConfigScope(scope, void 0)), trailingFunctionArgument(arguments));\n    },\n    listConfig(...rest) {\n      return this._runTask(listConfigTask(asConfigScope(rest[0], void 0)), trailingFunctionArgument(arguments));\n    }\n  };\n}\nvar GitConfigScope;\nvar init_config = __esm({\n  \"src/lib/tasks/config.ts\"() {\n    init_ConfigList();\n    init_utils();\n    GitConfigScope = /* @__PURE__ */ ((GitConfigScope2) => {\n      GitConfigScope2[\"system\"] = \"system\";\n      GitConfigScope2[\"global\"] = \"global\";\n      GitConfigScope2[\"local\"] = \"local\";\n      GitConfigScope2[\"worktree\"] = \"worktree\";\n      return GitConfigScope2;\n    })(GitConfigScope || {});\n  }\n});\n\n// src/lib/tasks/grep.ts\nfunction grepQueryBuilder(...params) {\n  return new GrepQuery().param(...params);\n}\nfunction parseGrep(grep) {\n  const paths = /* @__PURE__ */ new Set();\n  const results = {};\n  forEachLineWithContent(grep, (input) => {\n    const [path, line, preview] = input.split(NULL);\n    paths.add(path);\n    (results[path] = results[path] || []).push({\n      line: asNumber(line),\n      path,\n      preview\n    });\n  });\n  return {\n    paths,\n    results\n  };\n}\nfunction grep_default() {\n  return {\n    grep(searchTerm) {\n      const then = trailingFunctionArgument(arguments);\n      const options = getTrailingOptions(arguments);\n      for (const option of disallowedOptions) {\n        if (options.includes(option)) {\n          return this._runTask(configurationErrorTask(`git.grep: use of \"${option}\" is not supported.`), then);\n        }\n      }\n      if (typeof searchTerm === \"string\") {\n        searchTerm = grepQueryBuilder().param(searchTerm);\n      }\n      const commands = [\"grep\", \"--null\", \"-n\", \"--full-name\", ...options, ...searchTerm];\n      return this._runTask({\n        commands,\n        format: \"utf-8\",\n        parser(stdOut) {\n          return parseGrep(stdOut);\n        }\n      }, then);\n    }\n  };\n}\nvar disallowedOptions, Query, _a, GrepQuery;\nvar init_grep = __esm({\n  \"src/lib/tasks/grep.ts\"() {\n    init_utils();\n    init_task();\n    disallowedOptions = [\"-h\"];\n    Query = Symbol(\"grepQuery\");\n    GrepQuery = class {\n      constructor() {\n        this[_a] = [];\n      }\n      *[(_a = Query, Symbol.iterator)]() {\n        for (const query of this[Query]) {\n          yield query;\n        }\n      }\n      and(...and) {\n        and.length && this[Query].push(\"--and\", \"(\", ...prefixedArray(and, \"-e\"), \")\");\n        return this;\n      }\n      param(...param) {\n        this[Query].push(...prefixedArray(param, \"-e\"));\n        return this;\n      }\n    };\n  }\n});\n\n// src/lib/tasks/reset.ts\nvar reset_exports = {};\n__export(reset_exports, {\n  ResetMode: () => ResetMode,\n  getResetMode: () => getResetMode,\n  resetTask: () => resetTask\n});\nfunction resetTask(mode, customArgs) {\n  const commands = [\"reset\"];\n  if (isValidResetMode(mode)) {\n    commands.push(`--${mode}`);\n  }\n  commands.push(...customArgs);\n  return straightThroughStringTask(commands);\n}\nfunction getResetMode(mode) {\n  if (isValidResetMode(mode)) {\n    return mode;\n  }\n  switch (typeof mode) {\n    case \"string\":\n    case \"undefined\":\n      return \"soft\" /* SOFT */;\n  }\n  return;\n}\nfunction isValidResetMode(mode) {\n  return ResetModes.includes(mode);\n}\nvar ResetMode, ResetModes;\nvar init_reset = __esm({\n  \"src/lib/tasks/reset.ts\"() {\n    init_task();\n    ResetMode = /* @__PURE__ */ ((ResetMode2) => {\n      ResetMode2[\"MIXED\"] = \"mixed\";\n      ResetMode2[\"SOFT\"] = \"soft\";\n      ResetMode2[\"HARD\"] = \"hard\";\n      ResetMode2[\"MERGE\"] = \"merge\";\n      ResetMode2[\"KEEP\"] = \"keep\";\n      return ResetMode2;\n    })(ResetMode || {});\n    ResetModes = Array.from(Object.values(ResetMode));\n  }\n});\n\n// src/lib/api.ts\nvar api_exports = {};\n__export(api_exports, {\n  CheckRepoActions: () => CheckRepoActions,\n  CleanOptions: () => CleanOptions,\n  GitConfigScope: () => GitConfigScope,\n  GitConstructError: () => GitConstructError,\n  GitError: () => GitError,\n  GitPluginError: () => GitPluginError,\n  GitResponseError: () => GitResponseError,\n  ResetMode: () => ResetMode,\n  TaskConfigurationError: () => TaskConfigurationError,\n  grepQueryBuilder: () => grepQueryBuilder\n});\nvar init_api = __esm({\n  \"src/lib/api.ts\"() {\n    init_git_construct_error();\n    init_git_error();\n    init_git_plugin_error();\n    init_git_response_error();\n    init_task_configuration_error();\n    init_check_is_repo();\n    init_clean();\n    init_config();\n    init_grep();\n    init_reset();\n  }\n});\n\n// src/lib/plugins/abort-plugin.ts\nfunction abortPlugin(signal) {\n  if (!signal) {\n    return;\n  }\n  const onSpawnAfter = {\n    type: \"spawn.after\",\n    action(_data, context) {\n      function kill() {\n        context.kill(new GitPluginError(void 0, \"abort\", \"Abort signal received\"));\n      }\n      signal.addEventListener(\"abort\", kill);\n      context.spawned.on(\"close\", () => signal.removeEventListener(\"abort\", kill));\n    }\n  };\n  const onSpawnBefore = {\n    type: \"spawn.before\",\n    action(_data, context) {\n      if (signal.aborted) {\n        context.kill(new GitPluginError(void 0, \"abort\", \"Abort already signaled\"));\n      }\n    }\n  };\n  return [onSpawnBefore, onSpawnAfter];\n}\nvar init_abort_plugin = __esm({\n  \"src/lib/plugins/abort-plugin.ts\"() {\n    init_git_plugin_error();\n  }\n});\n\n// src/lib/plugins/block-unsafe-operations-plugin.ts\nfunction isConfigSwitch(arg) {\n  return typeof arg === \"string\" && arg.trim().toLowerCase() === \"-c\";\n}\nfunction preventProtocolOverride(arg, next) {\n  if (!isConfigSwitch(arg)) {\n    return;\n  }\n  if (!/^\\s*protocol(.[a-z]+)?.allow/.test(next)) {\n    return;\n  }\n  throw new GitPluginError(void 0, \"unsafe\", \"Configuring protocol.allow is not permitted without enabling allowUnsafeExtProtocol\");\n}\nfunction preventUploadPack(arg, method) {\n  if (/^\\s*--(upload|receive)-pack/.test(arg)) {\n    throw new GitPluginError(void 0, \"unsafe\", `Use of --upload-pack or --receive-pack is not permitted without enabling allowUnsafePack`);\n  }\n  if (method === \"clone\" && /^\\s*-u\\b/.test(arg)) {\n    throw new GitPluginError(void 0, \"unsafe\", `Use of clone with option -u is not permitted without enabling allowUnsafePack`);\n  }\n  if (method === \"push\" && /^\\s*--exec\\b/.test(arg)) {\n    throw new GitPluginError(void 0, \"unsafe\", `Use of push with option --exec is not permitted without enabling allowUnsafePack`);\n  }\n}\nfunction blockUnsafeOperationsPlugin({\n  allowUnsafeProtocolOverride = false,\n  allowUnsafePack = false\n} = {}) {\n  return {\n    type: \"spawn.args\",\n    action(args, context) {\n      args.forEach((current, index) => {\n        const next = index < args.length ? args[index + 1] : \"\";\n        allowUnsafeProtocolOverride || preventProtocolOverride(current, next);\n        allowUnsafePack || preventUploadPack(current, context.method);\n      });\n      return args;\n    }\n  };\n}\nvar init_block_unsafe_operations_plugin = __esm({\n  \"src/lib/plugins/block-unsafe-operations-plugin.ts\"() {\n    init_git_plugin_error();\n  }\n});\n\n// src/lib/plugins/command-config-prefixing-plugin.ts\nfunction commandConfigPrefixingPlugin(configuration) {\n  const prefix = prefixedArray(configuration, \"-c\");\n  return {\n    type: \"spawn.args\",\n    action(data) {\n      return [...prefix, ...data];\n    }\n  };\n}\nvar init_command_config_prefixing_plugin = __esm({\n  \"src/lib/plugins/command-config-prefixing-plugin.ts\"() {\n    init_utils();\n  }\n});\n\n// src/lib/plugins/completion-detection.plugin.ts\nfunction completionDetectionPlugin({\n  onClose = true,\n  onExit = 50\n} = {}) {\n  function createEvents() {\n    let exitCode = -1;\n    const events = {\n      close: (0, import_promise_deferred.deferred)(),\n      closeTimeout: (0, import_promise_deferred.deferred)(),\n      exit: (0, import_promise_deferred.deferred)(),\n      exitTimeout: (0, import_promise_deferred.deferred)()\n    };\n    const result = Promise.race([\n      onClose === false ? never : events.closeTimeout.promise,\n      onExit === false ? never : events.exitTimeout.promise\n    ]);\n    configureTimeout(onClose, events.close, events.closeTimeout);\n    configureTimeout(onExit, events.exit, events.exitTimeout);\n    return {\n      close(code) {\n        exitCode = code;\n        events.close.done();\n      },\n      exit(code) {\n        exitCode = code;\n        events.exit.done();\n      },\n      get exitCode() {\n        return exitCode;\n      },\n      result\n    };\n  }\n  function configureTimeout(flag, event, timeout) {\n    if (flag === false) {\n      return;\n    }\n    (flag === true ? event.promise : event.promise.then(() => delay(flag))).then(timeout.done);\n  }\n  return {\n    type: \"spawn.after\",\n    action(_0, _1) {\n      return __async(this, arguments, function* (_data, { spawned, close }) {\n        var _a2, _b;\n        const events = createEvents();\n        let deferClose = true;\n        let quickClose = () => void (deferClose = false);\n        (_a2 = spawned.stdout) == null ? void 0 : _a2.on(\"data\", quickClose);\n        (_b = spawned.stderr) == null ? void 0 : _b.on(\"data\", quickClose);\n        spawned.on(\"error\", quickClose);\n        spawned.on(\"close\", (code) => events.close(code));\n        spawned.on(\"exit\", (code) => events.exit(code));\n        try {\n          yield events.result;\n          if (deferClose) {\n            yield delay(50);\n          }\n          close(events.exitCode);\n        } catch (err) {\n          close(events.exitCode, err);\n        }\n      });\n    }\n  };\n}\nvar import_promise_deferred, never;\nvar init_completion_detection_plugin = __esm({\n  \"src/lib/plugins/completion-detection.plugin.ts\"() {\n    import_promise_deferred = require(\"@kwsites/promise-deferred\");\n    init_utils();\n    never = (0, import_promise_deferred.deferred)().promise;\n  }\n});\n\n// src/lib/plugins/error-detection.plugin.ts\nfunction isTaskError(result) {\n  return !!(result.exitCode && result.stdErr.length);\n}\nfunction getErrorMessage(result) {\n  return Buffer.concat([...result.stdOut, ...result.stdErr]);\n}\nfunction errorDetectionHandler(overwrite = false, isError = isTaskError, errorMessage = getErrorMessage) {\n  return (error, result) => {\n    if (!overwrite && error || !isError(result)) {\n      return error;\n    }\n    return errorMessage(result);\n  };\n}\nfunction errorDetectionPlugin(config) {\n  return {\n    type: \"task.error\",\n    action(data, context) {\n      const error = config(data.error, {\n        stdErr: context.stdErr,\n        stdOut: context.stdOut,\n        exitCode: context.exitCode\n      });\n      if (Buffer.isBuffer(error)) {\n        return { error: new GitError(void 0, error.toString(\"utf-8\")) };\n      }\n      return {\n        error\n      };\n    }\n  };\n}\nvar init_error_detection_plugin = __esm({\n  \"src/lib/plugins/error-detection.plugin.ts\"() {\n    init_git_error();\n  }\n});\n\n// src/lib/plugins/plugin-store.ts\nvar PluginStore;\nvar init_plugin_store = __esm({\n  \"src/lib/plugins/plugin-store.ts\"() {\n    init_utils();\n    PluginStore = class {\n      constructor() {\n        this.plugins = /* @__PURE__ */ new Set();\n      }\n      add(plugin) {\n        const plugins = [];\n        asArray(plugin).forEach((plugin2) => plugin2 && this.plugins.add(append(plugins, plugin2)));\n        return () => {\n          plugins.forEach((plugin2) => this.plugins.delete(plugin2));\n        };\n      }\n      exec(type, data, context) {\n        let output = data;\n        const contextual = Object.freeze(Object.create(context));\n        for (const plugin of this.plugins) {\n          if (plugin.type === type) {\n            output = plugin.action(output, contextual);\n          }\n        }\n        return output;\n      }\n    };\n  }\n});\n\n// src/lib/plugins/progress-monitor-plugin.ts\nfunction progressMonitorPlugin(progress) {\n  const progressCommand = \"--progress\";\n  const progressMethods = [\"checkout\", \"clone\", \"fetch\", \"pull\", \"push\"];\n  const onProgress = {\n    type: \"spawn.after\",\n    action(_data, context) {\n      var _a2;\n      if (!context.commands.includes(progressCommand)) {\n        return;\n      }\n      (_a2 = context.spawned.stderr) == null ? void 0 : _a2.on(\"data\", (chunk) => {\n        const message = /^([\\s\\S]+?):\\s*(\\d+)% \\((\\d+)\\/(\\d+)\\)/.exec(chunk.toString(\"utf8\"));\n        if (!message) {\n          return;\n        }\n        progress({\n          method: context.method,\n          stage: progressEventStage(message[1]),\n          progress: asNumber(message[2]),\n          processed: asNumber(message[3]),\n          total: asNumber(message[4])\n        });\n      });\n    }\n  };\n  const onArgs = {\n    type: \"spawn.args\",\n    action(args, context) {\n      if (!progressMethods.includes(context.method)) {\n        return args;\n      }\n      return including(args, progressCommand);\n    }\n  };\n  return [onArgs, onProgress];\n}\nfunction progressEventStage(input) {\n  return String(input.toLowerCase().split(\" \", 1)) || \"unknown\";\n}\nvar init_progress_monitor_plugin = __esm({\n  \"src/lib/plugins/progress-monitor-plugin.ts\"() {\n    init_utils();\n  }\n});\n\n// src/lib/plugins/simple-git-plugin.ts\nvar init_simple_git_plugin = __esm({\n  \"src/lib/plugins/simple-git-plugin.ts\"() {\n  }\n});\n\n// src/lib/plugins/spawn-options-plugin.ts\nfunction spawnOptionsPlugin(spawnOptions) {\n  const options = pick(spawnOptions, [\"uid\", \"gid\"]);\n  return {\n    type: \"spawn.options\",\n    action(data) {\n      return __spreadValues(__spreadValues({}, options), data);\n    }\n  };\n}\nvar init_spawn_options_plugin = __esm({\n  \"src/lib/plugins/spawn-options-plugin.ts\"() {\n    init_utils();\n  }\n});\n\n// src/lib/plugins/timout-plugin.ts\nfunction timeoutPlugin({\n  block,\n  stdErr = true,\n  stdOut = true\n}) {\n  if (block > 0) {\n    return {\n      type: \"spawn.after\",\n      action(_data, context) {\n        var _a2, _b;\n        let timeout;\n        function wait() {\n          timeout && clearTimeout(timeout);\n          timeout = setTimeout(kill, block);\n        }\n        function stop() {\n          var _a3, _b2;\n          (_a3 = context.spawned.stdout) == null ? void 0 : _a3.off(\"data\", wait);\n          (_b2 = context.spawned.stderr) == null ? void 0 : _b2.off(\"data\", wait);\n          context.spawned.off(\"exit\", stop);\n          context.spawned.off(\"close\", stop);\n          timeout && clearTimeout(timeout);\n        }\n        function kill() {\n          stop();\n          context.kill(new GitPluginError(void 0, \"timeout\", `block timeout reached`));\n        }\n        stdOut && ((_a2 = context.spawned.stdout) == null ? void 0 : _a2.on(\"data\", wait));\n        stdErr && ((_b = context.spawned.stderr) == null ? void 0 : _b.on(\"data\", wait));\n        context.spawned.on(\"exit\", stop);\n        context.spawned.on(\"close\", stop);\n        wait();\n      }\n    };\n  }\n}\nvar init_timout_plugin = __esm({\n  \"src/lib/plugins/timout-plugin.ts\"() {\n    init_git_plugin_error();\n  }\n});\n\n// src/lib/plugins/index.ts\nvar init_plugins = __esm({\n  \"src/lib/plugins/index.ts\"() {\n    init_abort_plugin();\n    init_block_unsafe_operations_plugin();\n    init_command_config_prefixing_plugin();\n    init_completion_detection_plugin();\n    init_error_detection_plugin();\n    init_plugin_store();\n    init_progress_monitor_plugin();\n    init_simple_git_plugin();\n    init_spawn_options_plugin();\n    init_timout_plugin();\n  }\n});\n\n// src/lib/git-logger.ts\nfunction createLog() {\n  return (0, import_debug.default)(\"simple-git\");\n}\nfunction prefixedLogger(to, prefix, forward) {\n  if (!prefix || !String(prefix).replace(/\\s*/, \"\")) {\n    return !forward ? to : (message, ...args) => {\n      to(message, ...args);\n      forward(message, ...args);\n    };\n  }\n  return (message, ...args) => {\n    to(`%s ${message}`, prefix, ...args);\n    if (forward) {\n      forward(message, ...args);\n    }\n  };\n}\nfunction childLoggerName(name, childDebugger, { namespace: parentNamespace }) {\n  if (typeof name === \"string\") {\n    return name;\n  }\n  const childNamespace = childDebugger && childDebugger.namespace || \"\";\n  if (childNamespace.startsWith(parentNamespace)) {\n    return childNamespace.substr(parentNamespace.length + 1);\n  }\n  return childNamespace || parentNamespace;\n}\nfunction createLogger(label, verbose, initialStep, infoDebugger = createLog()) {\n  const labelPrefix = label && `[${label}]` || \"\";\n  const spawned = [];\n  const debugDebugger = typeof verbose === \"string\" ? infoDebugger.extend(verbose) : verbose;\n  const key = childLoggerName(filterType(verbose, filterString), debugDebugger, infoDebugger);\n  return step(initialStep);\n  function sibling(name, initial) {\n    return append(spawned, createLogger(label, key.replace(/^[^:]+/, name), initial, infoDebugger));\n  }\n  function step(phase) {\n    const stepPrefix = phase && `[${phase}]` || \"\";\n    const debug2 = debugDebugger && prefixedLogger(debugDebugger, stepPrefix) || NOOP;\n    const info = prefixedLogger(infoDebugger, `${labelPrefix} ${stepPrefix}`, debug2);\n    return Object.assign(debugDebugger ? debug2 : info, {\n      label,\n      sibling,\n      info,\n      step\n    });\n  }\n}\nvar import_debug;\nvar init_git_logger = __esm({\n  \"src/lib/git-logger.ts\"() {\n    import_debug = __toESM(require(\"debug\"));\n    init_utils();\n    import_debug.default.formatters.L = (value) => String(filterHasLength(value) ? value.length : \"-\");\n    import_debug.default.formatters.B = (value) => {\n      if (Buffer.isBuffer(value)) {\n        return value.toString(\"utf8\");\n      }\n      return objectToString(value);\n    };\n  }\n});\n\n// src/lib/runners/tasks-pending-queue.ts\nvar _TasksPendingQueue, TasksPendingQueue;\nvar init_tasks_pending_queue = __esm({\n  \"src/lib/runners/tasks-pending-queue.ts\"() {\n    init_git_error();\n    init_git_logger();\n    _TasksPendingQueue = class {\n      constructor(logLabel = \"GitExecutor\") {\n        this.logLabel = logLabel;\n        this._queue = /* @__PURE__ */ new Map();\n      }\n      withProgress(task) {\n        return this._queue.get(task);\n      }\n      createProgress(task) {\n        const name = _TasksPendingQueue.getName(task.commands[0]);\n        const logger = createLogger(this.logLabel, name);\n        return {\n          task,\n          logger,\n          name\n        };\n      }\n      push(task) {\n        const progress = this.createProgress(task);\n        progress.logger(\"Adding task to the queue, commands = %o\", task.commands);\n        this._queue.set(task, progress);\n        return progress;\n      }\n      fatal(err) {\n        for (const [task, { logger }] of Array.from(this._queue.entries())) {\n          if (task === err.task) {\n            logger.info(`Failed %o`, err);\n            logger(`Fatal exception, any as-yet un-started tasks run through this executor will not be attempted`);\n          } else {\n            logger.info(`A fatal exception occurred in a previous task, the queue has been purged: %o`, err.message);\n          }\n          this.complete(task);\n        }\n        if (this._queue.size !== 0) {\n          throw new Error(`Queue size should be zero after fatal: ${this._queue.size}`);\n        }\n      }\n      complete(task) {\n        const progress = this.withProgress(task);\n        if (progress) {\n          this._queue.delete(task);\n        }\n      }\n      attempt(task) {\n        const progress = this.withProgress(task);\n        if (!progress) {\n          throw new GitError(void 0, \"TasksPendingQueue: attempt called for an unknown task\");\n        }\n        progress.logger(\"Starting task\");\n        return progress;\n      }\n      static getName(name = \"empty\") {\n        return `task:${name}:${++_TasksPendingQueue.counter}`;\n      }\n    };\n    TasksPendingQueue = _TasksPendingQueue;\n    TasksPendingQueue.counter = 0;\n  }\n});\n\n// src/lib/runners/git-executor-chain.ts\nfunction pluginContext(task, commands) {\n  return {\n    method: first(task.commands) || \"\",\n    commands\n  };\n}\nfunction onErrorReceived(target, logger) {\n  return (err) => {\n    logger(`[ERROR] child process exception %o`, err);\n    target.push(Buffer.from(String(err.stack), \"ascii\"));\n  };\n}\nfunction onDataReceived(target, name, logger, output) {\n  return (buffer) => {\n    logger(`%s received %L bytes`, name, buffer);\n    output(`%B`, buffer);\n    target.push(buffer);\n  };\n}\nvar import_child_process, GitExecutorChain;\nvar init_git_executor_chain = __esm({\n  \"src/lib/runners/git-executor-chain.ts\"() {\n    import_child_process = require(\"child_process\");\n    init_git_error();\n    init_task();\n    init_utils();\n    init_tasks_pending_queue();\n    GitExecutorChain = class {\n      constructor(_executor, _scheduler, _plugins) {\n        this._executor = _executor;\n        this._scheduler = _scheduler;\n        this._plugins = _plugins;\n        this._chain = Promise.resolve();\n        this._queue = new TasksPendingQueue();\n      }\n      get binary() {\n        return this._executor.binary;\n      }\n      get cwd() {\n        return this._cwd || this._executor.cwd;\n      }\n      set cwd(cwd) {\n        this._cwd = cwd;\n      }\n      get env() {\n        return this._executor.env;\n      }\n      get outputHandler() {\n        return this._executor.outputHandler;\n      }\n      chain() {\n        return this;\n      }\n      push(task) {\n        this._queue.push(task);\n        return this._chain = this._chain.then(() => this.attemptTask(task));\n      }\n      attemptTask(task) {\n        return __async(this, null, function* () {\n          const onScheduleComplete = yield this._scheduler.next();\n          const onQueueComplete = () => this._queue.complete(task);\n          try {\n            const { logger } = this._queue.attempt(task);\n            return yield isEmptyTask(task) ? this.attemptEmptyTask(task, logger) : this.attemptRemoteTask(task, logger);\n          } catch (e) {\n            throw this.onFatalException(task, e);\n          } finally {\n            onQueueComplete();\n            onScheduleComplete();\n          }\n        });\n      }\n      onFatalException(task, e) {\n        const gitError = e instanceof GitError ? Object.assign(e, { task }) : new GitError(task, e && String(e));\n        this._chain = Promise.resolve();\n        this._queue.fatal(gitError);\n        return gitError;\n      }\n      attemptRemoteTask(task, logger) {\n        return __async(this, null, function* () {\n          const args = this._plugins.exec(\"spawn.args\", [...task.commands], pluginContext(task, task.commands));\n          const raw = yield this.gitResponse(task, this.binary, args, this.outputHandler, logger.step(\"SPAWN\"));\n          const outputStreams = yield this.handleTaskData(task, args, raw, logger.step(\"HANDLE\"));\n          logger(`passing response to task's parser as a %s`, task.format);\n          if (isBufferTask(task)) {\n            return callTaskParser(task.parser, outputStreams);\n          }\n          return callTaskParser(task.parser, outputStreams.asStrings());\n        });\n      }\n      attemptEmptyTask(task, logger) {\n        return __async(this, null, function* () {\n          logger(`empty task bypassing child process to call to task's parser`);\n          return task.parser(this);\n        });\n      }\n      handleTaskData(task, args, result, logger) {\n        const { exitCode, rejection, stdOut, stdErr } = result;\n        return new Promise((done, fail) => {\n          logger(`Preparing to handle process response exitCode=%d stdOut=`, exitCode);\n          const { error } = this._plugins.exec(\"task.error\", { error: rejection }, __spreadValues(__spreadValues({}, pluginContext(task, args)), result));\n          if (error && task.onError) {\n            logger.info(`exitCode=%s handling with custom error handler`);\n            return task.onError(result, error, (newStdOut) => {\n              logger.info(`custom error handler treated as success`);\n              logger(`custom error returned a %s`, objectToString(newStdOut));\n              done(new GitOutputStreams(Array.isArray(newStdOut) ? Buffer.concat(newStdOut) : newStdOut, Buffer.concat(stdErr)));\n            }, fail);\n          }\n          if (error) {\n            logger.info(`handling as error: exitCode=%s stdErr=%s rejection=%o`, exitCode, stdErr.length, rejection);\n            return fail(error);\n          }\n          logger.info(`retrieving task output complete`);\n          done(new GitOutputStreams(Buffer.concat(stdOut), Buffer.concat(stdErr)));\n        });\n      }\n      gitResponse(task, command, args, outputHandler, logger) {\n        return __async(this, null, function* () {\n          const outputLogger = logger.sibling(\"output\");\n          const spawnOptions = this._plugins.exec(\"spawn.options\", {\n            cwd: this.cwd,\n            env: this.env,\n            windowsHide: true\n          }, pluginContext(task, task.commands));\n          return new Promise((done) => {\n            const stdOut = [];\n            const stdErr = [];\n            logger.info(`%s %o`, command, args);\n            logger(\"%O\", spawnOptions);\n            let rejection = this._beforeSpawn(task, args);\n            if (rejection) {\n              return done({\n                stdOut,\n                stdErr,\n                exitCode: 9901,\n                rejection\n              });\n            }\n            this._plugins.exec(\"spawn.before\", void 0, __spreadProps(__spreadValues({}, pluginContext(task, args)), {\n              kill(reason) {\n                rejection = reason || rejection;\n              }\n            }));\n            const spawned = (0, import_child_process.spawn)(command, args, spawnOptions);\n            spawned.stdout.on(\"data\", onDataReceived(stdOut, \"stdOut\", logger, outputLogger.step(\"stdOut\")));\n            spawned.stderr.on(\"data\", onDataReceived(stdErr, \"stdErr\", logger, outputLogger.step(\"stdErr\")));\n            spawned.on(\"error\", onErrorReceived(stdErr, logger));\n            if (outputHandler) {\n              logger(`Passing child process stdOut/stdErr to custom outputHandler`);\n              outputHandler(command, spawned.stdout, spawned.stderr, [...args]);\n            }\n            this._plugins.exec(\"spawn.after\", void 0, __spreadProps(__spreadValues({}, pluginContext(task, args)), {\n              spawned,\n              close(exitCode, reason) {\n                done({\n                  stdOut,\n                  stdErr,\n                  exitCode,\n                  rejection: rejection || reason\n                });\n              },\n              kill(reason) {\n                if (spawned.killed) {\n                  return;\n                }\n                rejection = reason;\n                spawned.kill(\"SIGINT\");\n              }\n            }));\n          });\n        });\n      }\n      _beforeSpawn(task, args) {\n        let rejection;\n        this._plugins.exec(\"spawn.before\", void 0, __spreadProps(__spreadValues({}, pluginContext(task, args)), {\n          kill(reason) {\n            rejection = reason || rejection;\n          }\n        }));\n        return rejection;\n      }\n    };\n  }\n});\n\n// src/lib/runners/git-executor.ts\nvar git_executor_exports = {};\n__export(git_executor_exports, {\n  GitExecutor: () => GitExecutor\n});\nvar GitExecutor;\nvar init_git_executor = __esm({\n  \"src/lib/runners/git-executor.ts\"() {\n    init_git_executor_chain();\n    GitExecutor = class {\n      constructor(binary = \"git\", cwd, _scheduler, _plugins) {\n        this.binary = binary;\n        this.cwd = cwd;\n        this._scheduler = _scheduler;\n        this._plugins = _plugins;\n        this._chain = new GitExecutorChain(this, this._scheduler, this._plugins);\n      }\n      chain() {\n        return new GitExecutorChain(this, this._scheduler, this._plugins);\n      }\n      push(task) {\n        return this._chain.push(task);\n      }\n    };\n  }\n});\n\n// src/lib/task-callback.ts\nfunction taskCallback(task, response, callback = NOOP) {\n  const onSuccess = (data) => {\n    callback(null, data);\n  };\n  const onError2 = (err) => {\n    if ((err == null ? void 0 : err.task) === task) {\n      callback(err instanceof GitResponseError ? addDeprecationNoticeToError(err) : err, void 0);\n    }\n  };\n  response.then(onSuccess, onError2);\n}\nfunction addDeprecationNoticeToError(err) {\n  let log = (name) => {\n    console.warn(`simple-git deprecation notice: accessing GitResponseError.${name} should be GitResponseError.git.${name}, this will no longer be available in version 3`);\n    log = NOOP;\n  };\n  return Object.create(err, Object.getOwnPropertyNames(err.git).reduce(descriptorReducer, {}));\n  function descriptorReducer(all, name) {\n    if (name in err) {\n      return all;\n    }\n    all[name] = {\n      enumerable: false,\n      configurable: false,\n      get() {\n        log(name);\n        return err.git[name];\n      }\n    };\n    return all;\n  }\n}\nvar init_task_callback = __esm({\n  \"src/lib/task-callback.ts\"() {\n    init_git_response_error();\n    init_utils();\n  }\n});\n\n// src/lib/tasks/change-working-directory.ts\nfunction changeWorkingDirectoryTask(directory, root) {\n  return adhocExecTask((instance) => {\n    if (!folderExists(directory)) {\n      throw new Error(`Git.cwd: cannot change to non-directory \"${directory}\"`);\n    }\n    return (root || instance).cwd = directory;\n  });\n}\nvar init_change_working_directory = __esm({\n  \"src/lib/tasks/change-working-directory.ts\"() {\n    init_utils();\n    init_task();\n  }\n});\n\n// src/lib/tasks/checkout.ts\nfunction checkoutTask(args) {\n  const commands = [\"checkout\", ...args];\n  if (commands[1] === \"-b\" && commands.includes(\"-B\")) {\n    commands[1] = remove(commands, \"-B\");\n  }\n  return straightThroughStringTask(commands);\n}\nfunction checkout_default() {\n  return {\n    checkout() {\n      return this._runTask(checkoutTask(getTrailingOptions(arguments, 1)), trailingFunctionArgument(arguments));\n    },\n    checkoutBranch(branchName, startPoint) {\n      return this._runTask(checkoutTask([\"-b\", branchName, startPoint, ...getTrailingOptions(arguments)]), trailingFunctionArgument(arguments));\n    },\n    checkoutLocalBranch(branchName) {\n      return this._runTask(checkoutTask([\"-b\", branchName, ...getTrailingOptions(arguments)]), trailingFunctionArgument(arguments));\n    }\n  };\n}\nvar init_checkout = __esm({\n  \"src/lib/tasks/checkout.ts\"() {\n    init_utils();\n    init_task();\n  }\n});\n\n// src/lib/parsers/parse-commit.ts\nfunction parseCommitResult(stdOut) {\n  const result = {\n    author: null,\n    branch: \"\",\n    commit: \"\",\n    root: false,\n    summary: {\n      changes: 0,\n      insertions: 0,\n      deletions: 0\n    }\n  };\n  return parseStringResponse(result, parsers, stdOut);\n}\nvar parsers;\nvar init_parse_commit = __esm({\n  \"src/lib/parsers/parse-commit.ts\"() {\n    init_utils();\n    parsers = [\n      new LineParser(/^\\[([^\\s]+)( \\([^)]+\\))? ([^\\]]+)/, (result, [branch, root, commit]) => {\n        result.branch = branch;\n        result.commit = commit;\n        result.root = !!root;\n      }),\n      new LineParser(/\\s*Author:\\s(.+)/i, (result, [author]) => {\n        const parts = author.split(\"<\");\n        const email = parts.pop();\n        if (!email || !email.includes(\"@\")) {\n          return;\n        }\n        result.author = {\n          email: email.substr(0, email.length - 1),\n          name: parts.join(\"<\").trim()\n        };\n      }),\n      new LineParser(/(\\d+)[^,]*(?:,\\s*(\\d+)[^,]*)(?:,\\s*(\\d+))/g, (result, [changes, insertions, deletions]) => {\n        result.summary.changes = parseInt(changes, 10) || 0;\n        result.summary.insertions = parseInt(insertions, 10) || 0;\n        result.summary.deletions = parseInt(deletions, 10) || 0;\n      }),\n      new LineParser(/^(\\d+)[^,]*(?:,\\s*(\\d+)[^(]+\\(([+-]))?/, (result, [changes, lines, direction]) => {\n        result.summary.changes = parseInt(changes, 10) || 0;\n        const count = parseInt(lines, 10) || 0;\n        if (direction === \"-\") {\n          result.summary.deletions = count;\n        } else if (direction === \"+\") {\n          result.summary.insertions = count;\n        }\n      })\n    ];\n  }\n});\n\n// src/lib/tasks/commit.ts\nfunction commitTask(message, files, customArgs) {\n  const commands = [\n    \"-c\",\n    \"core.abbrev=40\",\n    \"commit\",\n    ...prefixedArray(message, \"-m\"),\n    ...files,\n    ...customArgs\n  ];\n  return {\n    commands,\n    format: \"utf-8\",\n    parser: parseCommitResult\n  };\n}\nfunction commit_default() {\n  return {\n    commit(message, ...rest) {\n      const next = trailingFunctionArgument(arguments);\n      const task = rejectDeprecatedSignatures(message) || commitTask(asArray(message), asArray(filterType(rest[0], filterStringOrStringArray, [])), [...filterType(rest[1], filterArray, []), ...getTrailingOptions(arguments, 0, true)]);\n      return this._runTask(task, next);\n    }\n  };\n  function rejectDeprecatedSignatures(message) {\n    return !filterStringOrStringArray(message) && configurationErrorTask(`git.commit: requires the commit message to be supplied as a string/string[]`);\n  }\n}\nvar init_commit = __esm({\n  \"src/lib/tasks/commit.ts\"() {\n    init_parse_commit();\n    init_utils();\n    init_task();\n  }\n});\n\n// src/lib/tasks/hash-object.ts\nfunction hashObjectTask(filePath, write) {\n  const commands = [\"hash-object\", filePath];\n  if (write) {\n    commands.push(\"-w\");\n  }\n  return straightThroughStringTask(commands, true);\n}\nvar init_hash_object = __esm({\n  \"src/lib/tasks/hash-object.ts\"() {\n    init_task();\n  }\n});\n\n// src/lib/responses/InitSummary.ts\nfunction parseInit(bare, path, text) {\n  const response = String(text).trim();\n  let result;\n  if (result = initResponseRegex.exec(response)) {\n    return new InitSummary(bare, path, false, result[1]);\n  }\n  if (result = reInitResponseRegex.exec(response)) {\n    return new InitSummary(bare, path, true, result[1]);\n  }\n  let gitDir = \"\";\n  const tokens = response.split(\" \");\n  while (tokens.length) {\n    const token = tokens.shift();\n    if (token === \"in\") {\n      gitDir = tokens.join(\" \");\n      break;\n    }\n  }\n  return new InitSummary(bare, path, /^re/i.test(response), gitDir);\n}\nvar InitSummary, initResponseRegex, reInitResponseRegex;\nvar init_InitSummary = __esm({\n  \"src/lib/responses/InitSummary.ts\"() {\n    InitSummary = class {\n      constructor(bare, path, existing, gitDir) {\n        this.bare = bare;\n        this.path = path;\n        this.existing = existing;\n        this.gitDir = gitDir;\n      }\n    };\n    initResponseRegex = /^Init.+ repository in (.+)$/;\n    reInitResponseRegex = /^Rein.+ in (.+)$/;\n  }\n});\n\n// src/lib/tasks/init.ts\nfunction hasBareCommand(command) {\n  return command.includes(bareCommand);\n}\nfunction initTask(bare = false, path, customArgs) {\n  const commands = [\"init\", ...customArgs];\n  if (bare && !hasBareCommand(commands)) {\n    commands.splice(1, 0, bareCommand);\n  }\n  return {\n    commands,\n    format: \"utf-8\",\n    parser(text) {\n      return parseInit(commands.includes(\"--bare\"), path, text);\n    }\n  };\n}\nvar bareCommand;\nvar init_init = __esm({\n  \"src/lib/tasks/init.ts\"() {\n    init_InitSummary();\n    bareCommand = \"--bare\";\n  }\n});\n\n// src/lib/args/log-format.ts\nfunction logFormatFromCommand(customArgs) {\n  for (let i = 0; i < customArgs.length; i++) {\n    const format = logFormatRegex.exec(customArgs[i]);\n    if (format) {\n      return `--${format[1]}`;\n    }\n  }\n  return \"\" /* NONE */;\n}\nfunction isLogFormat(customArg) {\n  return logFormatRegex.test(customArg);\n}\nvar logFormatRegex;\nvar init_log_format = __esm({\n  \"src/lib/args/log-format.ts\"() {\n    logFormatRegex = /^--(stat|numstat|name-only|name-status)(=|$)/;\n  }\n});\n\n// src/lib/responses/DiffSummary.ts\nvar DiffSummary;\nvar init_DiffSummary = __esm({\n  \"src/lib/responses/DiffSummary.ts\"() {\n    DiffSummary = class {\n      constructor() {\n        this.changed = 0;\n        this.deletions = 0;\n        this.insertions = 0;\n        this.files = [];\n      }\n    };\n  }\n});\n\n// src/lib/parsers/parse-diff-summary.ts\nfunction getDiffParser(format = \"\" /* NONE */) {\n  const parser3 = diffSummaryParsers[format];\n  return (stdOut) => parseStringResponse(new DiffSummary(), parser3, stdOut, false);\n}\nvar statParser, numStatParser, nameOnlyParser, nameStatusParser, diffSummaryParsers;\nvar init_parse_diff_summary = __esm({\n  \"src/lib/parsers/parse-diff-summary.ts\"() {\n    init_log_format();\n    init_DiffSummary();\n    init_utils();\n    statParser = [\n      new LineParser(/(.+)\\s+\\|\\s+(\\d+)(\\s+[+\\-]+)?$/, (result, [file, changes, alterations = \"\"]) => {\n        result.files.push({\n          file: file.trim(),\n          changes: asNumber(changes),\n          insertions: alterations.replace(/[^+]/g, \"\").length,\n          deletions: alterations.replace(/[^-]/g, \"\").length,\n          binary: false\n        });\n      }),\n      new LineParser(/(.+) \\|\\s+Bin ([0-9.]+) -> ([0-9.]+) ([a-z]+)/, (result, [file, before, after]) => {\n        result.files.push({\n          file: file.trim(),\n          before: asNumber(before),\n          after: asNumber(after),\n          binary: true\n        });\n      }),\n      new LineParser(/(\\d+) files? changed\\s*((?:, \\d+ [^,]+){0,2})/, (result, [changed, summary]) => {\n        const inserted = /(\\d+) i/.exec(summary);\n        const deleted = /(\\d+) d/.exec(summary);\n        result.changed = asNumber(changed);\n        result.insertions = asNumber(inserted == null ? void 0 : inserted[1]);\n        result.deletions = asNumber(deleted == null ? void 0 : deleted[1]);\n      })\n    ];\n    numStatParser = [\n      new LineParser(/(\\d+)\\t(\\d+)\\t(.+)$/, (result, [changesInsert, changesDelete, file]) => {\n        const insertions = asNumber(changesInsert);\n        const deletions = asNumber(changesDelete);\n        result.changed++;\n        result.insertions += insertions;\n        result.deletions += deletions;\n        result.files.push({\n          file,\n          changes: insertions + deletions,\n          insertions,\n          deletions,\n          binary: false\n        });\n      }),\n      new LineParser(/-\\t-\\t(.+)$/, (result, [file]) => {\n        result.changed++;\n        result.files.push({\n          file,\n          after: 0,\n          before: 0,\n          binary: true\n        });\n      })\n    ];\n    nameOnlyParser = [\n      new LineParser(/(.+)$/, (result, [file]) => {\n        result.changed++;\n        result.files.push({\n          file,\n          changes: 0,\n          insertions: 0,\n          deletions: 0,\n          binary: false\n        });\n      })\n    ];\n    nameStatusParser = [\n      new LineParser(/([ACDMRTUXB])\\s*(.+)$/, (result, [_status, file]) => {\n        result.changed++;\n        result.files.push({\n          file,\n          changes: 0,\n          insertions: 0,\n          deletions: 0,\n          binary: false\n        });\n      })\n    ];\n    diffSummaryParsers = {\n      [\"\" /* NONE */]: statParser,\n      [\"--stat\" /* STAT */]: statParser,\n      [\"--numstat\" /* NUM_STAT */]: numStatParser,\n      [\"--name-status\" /* NAME_STATUS */]: nameStatusParser,\n      [\"--name-only\" /* NAME_ONLY */]: nameOnlyParser\n    };\n  }\n});\n\n// src/lib/parsers/parse-list-log-summary.ts\nfunction lineBuilder(tokens, fields) {\n  return fields.reduce((line, field, index) => {\n    line[field] = tokens[index] || \"\";\n    return line;\n  }, /* @__PURE__ */ Object.create({ diff: null }));\n}\nfunction createListLogSummaryParser(splitter = SPLITTER, fields = defaultFieldNames, logFormat = \"\" /* NONE */) {\n  const parseDiffResult = getDiffParser(logFormat);\n  return function(stdOut) {\n    const all = toLinesWithContent(stdOut, true, START_BOUNDARY).map(function(item) {\n      const lineDetail = item.trim().split(COMMIT_BOUNDARY);\n      const listLogLine = lineBuilder(lineDetail[0].trim().split(splitter), fields);\n      if (lineDetail.length > 1 && !!lineDetail[1].trim()) {\n        listLogLine.diff = parseDiffResult(lineDetail[1]);\n      }\n      return listLogLine;\n    });\n    return {\n      all,\n      latest: all.length && all[0] || null,\n      total: all.length\n    };\n  };\n}\nvar START_BOUNDARY, COMMIT_BOUNDARY, SPLITTER, defaultFieldNames;\nvar init_parse_list_log_summary = __esm({\n  \"src/lib/parsers/parse-list-log-summary.ts\"() {\n    init_utils();\n    init_parse_diff_summary();\n    init_log_format();\n    START_BOUNDARY = \"\\xF2\\xF2\\xF2\\xF2\\xF2\\xF2 \";\n    COMMIT_BOUNDARY = \" \\xF2\\xF2\";\n    SPLITTER = \" \\xF2 \";\n    defaultFieldNames = [\"hash\", \"date\", \"message\", \"refs\", \"author_name\", \"author_email\"];\n  }\n});\n\n// src/lib/tasks/diff.ts\nvar diff_exports = {};\n__export(diff_exports, {\n  diffSummaryTask: () => diffSummaryTask,\n  validateLogFormatConfig: () => validateLogFormatConfig\n});\nfunction diffSummaryTask(customArgs) {\n  let logFormat = logFormatFromCommand(customArgs);\n  const commands = [\"diff\"];\n  if (logFormat === \"\" /* NONE */) {\n    logFormat = \"--stat\" /* STAT */;\n    commands.push(\"--stat=4096\");\n  }\n  commands.push(...customArgs);\n  return validateLogFormatConfig(commands) || {\n    commands,\n    format: \"utf-8\",\n    parser: getDiffParser(logFormat)\n  };\n}\nfunction validateLogFormatConfig(customArgs) {\n  const flags = customArgs.filter(isLogFormat);\n  if (flags.length > 1) {\n    return configurationErrorTask(`Summary flags are mutually exclusive - pick one of ${flags.join(\",\")}`);\n  }\n  if (flags.length && customArgs.includes(\"-z\")) {\n    return configurationErrorTask(`Summary flag ${flags} parsing is not compatible with null termination option '-z'`);\n  }\n}\nvar init_diff = __esm({\n  \"src/lib/tasks/diff.ts\"() {\n    init_log_format();\n    init_parse_diff_summary();\n    init_task();\n  }\n});\n\n// src/lib/tasks/log.ts\nfunction prettyFormat(format, splitter) {\n  const fields = [];\n  const formatStr = [];\n  Object.keys(format).forEach((field) => {\n    fields.push(field);\n    formatStr.push(String(format[field]));\n  });\n  return [fields, formatStr.join(splitter)];\n}\nfunction userOptions(input) {\n  return Object.keys(input).reduce((out, key) => {\n    if (!(key in excludeOptions)) {\n      out[key] = input[key];\n    }\n    return out;\n  }, {});\n}\nfunction parseLogOptions(opt = {}, customArgs = []) {\n  const splitter = filterType(opt.splitter, filterString, SPLITTER);\n  const format = !filterPrimitives(opt.format) && opt.format ? opt.format : {\n    hash: \"%H\",\n    date: opt.strictDate === false ? \"%ai\" : \"%aI\",\n    message: \"%s\",\n    refs: \"%D\",\n    body: opt.multiLine ? \"%B\" : \"%b\",\n    author_name: opt.mailMap !== false ? \"%aN\" : \"%an\",\n    author_email: opt.mailMap !== false ? \"%aE\" : \"%ae\"\n  };\n  const [fields, formatStr] = prettyFormat(format, splitter);\n  const suffix = [];\n  const command = [\n    `--pretty=format:${START_BOUNDARY}${formatStr}${COMMIT_BOUNDARY}`,\n    ...customArgs\n  ];\n  const maxCount = opt.n || opt[\"max-count\"] || opt.maxCount;\n  if (maxCount) {\n    command.push(`--max-count=${maxCount}`);\n  }\n  if (opt.from || opt.to) {\n    const rangeOperator = opt.symmetric !== false ? \"...\" : \"..\";\n    suffix.push(`${opt.from || \"\"}${rangeOperator}${opt.to || \"\"}`);\n  }\n  if (filterString(opt.file)) {\n    suffix.push(\"--follow\", opt.file);\n  }\n  appendTaskOptions(userOptions(opt), command);\n  return {\n    fields,\n    splitter,\n    commands: [...command, ...suffix]\n  };\n}\nfunction logTask(splitter, fields, customArgs) {\n  const parser3 = createListLogSummaryParser(splitter, fields, logFormatFromCommand(customArgs));\n  return {\n    commands: [\"log\", ...customArgs],\n    format: \"utf-8\",\n    parser: parser3\n  };\n}\nfunction log_default() {\n  return {\n    log(...rest) {\n      const next = trailingFunctionArgument(arguments);\n      const options = parseLogOptions(trailingOptionsArgument(arguments), filterType(arguments[0], filterArray));\n      const task = rejectDeprecatedSignatures(...rest) || validateLogFormatConfig(options.commands) || createLogTask(options);\n      return this._runTask(task, next);\n    }\n  };\n  function createLogTask(options) {\n    return logTask(options.splitter, options.fields, options.commands);\n  }\n  function rejectDeprecatedSignatures(from, to) {\n    return filterString(from) && filterString(to) && configurationErrorTask(`git.log(string, string) should be replaced with git.log({ from: string, to: string })`);\n  }\n}\nvar excludeOptions;\nvar init_log = __esm({\n  \"src/lib/tasks/log.ts\"() {\n    init_log_format();\n    init_parse_list_log_summary();\n    init_utils();\n    init_task();\n    init_diff();\n    excludeOptions = /* @__PURE__ */ ((excludeOptions2) => {\n      excludeOptions2[excludeOptions2[\"--pretty\"] = 0] = \"--pretty\";\n      excludeOptions2[excludeOptions2[\"max-count\"] = 1] = \"max-count\";\n      excludeOptions2[excludeOptions2[\"maxCount\"] = 2] = \"maxCount\";\n      excludeOptions2[excludeOptions2[\"n\"] = 3] = \"n\";\n      excludeOptions2[excludeOptions2[\"file\"] = 4] = \"file\";\n      excludeOptions2[excludeOptions2[\"format\"] = 5] = \"format\";\n      excludeOptions2[excludeOptions2[\"from\"] = 6] = \"from\";\n      excludeOptions2[excludeOptions2[\"to\"] = 7] = \"to\";\n      excludeOptions2[excludeOptions2[\"splitter\"] = 8] = \"splitter\";\n      excludeOptions2[excludeOptions2[\"symmetric\"] = 9] = \"symmetric\";\n      excludeOptions2[excludeOptions2[\"mailMap\"] = 10] = \"mailMap\";\n      excludeOptions2[excludeOptions2[\"multiLine\"] = 11] = \"multiLine\";\n      excludeOptions2[excludeOptions2[\"strictDate\"] = 12] = \"strictDate\";\n      return excludeOptions2;\n    })(excludeOptions || {});\n  }\n});\n\n// src/lib/responses/MergeSummary.ts\nvar MergeSummaryConflict, MergeSummaryDetail;\nvar init_MergeSummary = __esm({\n  \"src/lib/responses/MergeSummary.ts\"() {\n    MergeSummaryConflict = class {\n      constructor(reason, file = null, meta) {\n        this.reason = reason;\n        this.file = file;\n        this.meta = meta;\n      }\n      toString() {\n        return `${this.file}:${this.reason}`;\n      }\n    };\n    MergeSummaryDetail = class {\n      constructor() {\n        this.conflicts = [];\n        this.merges = [];\n        this.result = \"success\";\n      }\n      get failed() {\n        return this.conflicts.length > 0;\n      }\n      get reason() {\n        return this.result;\n      }\n      toString() {\n        if (this.conflicts.length) {\n          return `CONFLICTS: ${this.conflicts.join(\", \")}`;\n        }\n        return \"OK\";\n      }\n    };\n  }\n});\n\n// src/lib/responses/PullSummary.ts\nvar PullSummary, PullFailedSummary;\nvar init_PullSummary = __esm({\n  \"src/lib/responses/PullSummary.ts\"() {\n    PullSummary = class {\n      constructor() {\n        this.remoteMessages = {\n          all: []\n        };\n        this.created = [];\n        this.deleted = [];\n        this.files = [];\n        this.deletions = {};\n        this.insertions = {};\n        this.summary = {\n          changes: 0,\n          deletions: 0,\n          insertions: 0\n        };\n      }\n    };\n    PullFailedSummary = class {\n      constructor() {\n        this.remote = \"\";\n        this.hash = {\n          local: \"\",\n          remote: \"\"\n        };\n        this.branch = {\n          local: \"\",\n          remote: \"\"\n        };\n        this.message = \"\";\n      }\n      toString() {\n        return this.message;\n      }\n    };\n  }\n});\n\n// src/lib/parsers/parse-remote-objects.ts\nfunction objectEnumerationResult(remoteMessages) {\n  return remoteMessages.objects = remoteMessages.objects || {\n    compressing: 0,\n    counting: 0,\n    enumerating: 0,\n    packReused: 0,\n    reused: { count: 0, delta: 0 },\n    total: { count: 0, delta: 0 }\n  };\n}\nfunction asObjectCount(source) {\n  const count = /^\\s*(\\d+)/.exec(source);\n  const delta = /delta (\\d+)/i.exec(source);\n  return {\n    count: asNumber(count && count[1] || \"0\"),\n    delta: asNumber(delta && delta[1] || \"0\")\n  };\n}\nvar remoteMessagesObjectParsers;\nvar init_parse_remote_objects = __esm({\n  \"src/lib/parsers/parse-remote-objects.ts\"() {\n    init_utils();\n    remoteMessagesObjectParsers = [\n      new RemoteLineParser(/^remote:\\s*(enumerating|counting|compressing) objects: (\\d+),/i, (result, [action, count]) => {\n        const key = action.toLowerCase();\n        const enumeration = objectEnumerationResult(result.remoteMessages);\n        Object.assign(enumeration, { [key]: asNumber(count) });\n      }),\n      new RemoteLineParser(/^remote:\\s*(enumerating|counting|compressing) objects: \\d+% \\(\\d+\\/(\\d+)\\),/i, (result, [action, count]) => {\n        const key = action.toLowerCase();\n        const enumeration = objectEnumerationResult(result.remoteMessages);\n        Object.assign(enumeration, { [key]: asNumber(count) });\n      }),\n      new RemoteLineParser(/total ([^,]+), reused ([^,]+), pack-reused (\\d+)/i, (result, [total, reused, packReused]) => {\n        const objects = objectEnumerationResult(result.remoteMessages);\n        objects.total = asObjectCount(total);\n        objects.reused = asObjectCount(reused);\n        objects.packReused = asNumber(packReused);\n      })\n    ];\n  }\n});\n\n// src/lib/parsers/parse-remote-messages.ts\nfunction parseRemoteMessages(_stdOut, stdErr) {\n  return parseStringResponse({ remoteMessages: new RemoteMessageSummary() }, parsers2, stdErr);\n}\nvar parsers2, RemoteMessageSummary;\nvar init_parse_remote_messages = __esm({\n  \"src/lib/parsers/parse-remote-messages.ts\"() {\n    init_utils();\n    init_parse_remote_objects();\n    parsers2 = [\n      new RemoteLineParser(/^remote:\\s*(.+)$/, (result, [text]) => {\n        result.remoteMessages.all.push(text.trim());\n        return false;\n      }),\n      ...remoteMessagesObjectParsers,\n      new RemoteLineParser([/create a (?:pull|merge) request/i, /\\s(https?:\\/\\/\\S+)$/], (result, [pullRequestUrl]) => {\n        result.remoteMessages.pullRequestUrl = pullRequestUrl;\n      }),\n      new RemoteLineParser([/found (\\d+) vulnerabilities.+\\(([^)]+)\\)/i, /\\s(https?:\\/\\/\\S+)$/], (result, [count, summary, url]) => {\n        result.remoteMessages.vulnerabilities = {\n          count: asNumber(count),\n          summary,\n          url\n        };\n      })\n    ];\n    RemoteMessageSummary = class {\n      constructor() {\n        this.all = [];\n      }\n    };\n  }\n});\n\n// src/lib/parsers/parse-pull.ts\nfunction parsePullErrorResult(stdOut, stdErr) {\n  const pullError = parseStringResponse(new PullFailedSummary(), errorParsers, [stdOut, stdErr]);\n  return pullError.message && pullError;\n}\nvar FILE_UPDATE_REGEX, SUMMARY_REGEX, ACTION_REGEX, parsers3, errorParsers, parsePullDetail, parsePullResult;\nvar init_parse_pull = __esm({\n  \"src/lib/parsers/parse-pull.ts\"() {\n    init_PullSummary();\n    init_utils();\n    init_parse_remote_messages();\n    FILE_UPDATE_REGEX = /^\\s*(.+?)\\s+\\|\\s+\\d+\\s*(\\+*)(-*)/;\n    SUMMARY_REGEX = /(\\d+)\\D+((\\d+)\\D+\\(\\+\\))?(\\D+(\\d+)\\D+\\(-\\))?/;\n    ACTION_REGEX = /^(create|delete) mode \\d+ (.+)/;\n    parsers3 = [\n      new LineParser(FILE_UPDATE_REGEX, (result, [file, insertions, deletions]) => {\n        result.files.push(file);\n        if (insertions) {\n          result.insertions[file] = insertions.length;\n        }\n        if (deletions) {\n          result.deletions[file] = deletions.length;\n        }\n      }),\n      new LineParser(SUMMARY_REGEX, (result, [changes, , insertions, , deletions]) => {\n        if (insertions !== void 0 || deletions !== void 0) {\n          result.summary.changes = +changes || 0;\n          result.summary.insertions = +insertions || 0;\n          result.summary.deletions = +deletions || 0;\n          return true;\n        }\n        return false;\n      }),\n      new LineParser(ACTION_REGEX, (result, [action, file]) => {\n        append(result.files, file);\n        append(action === \"create\" ? result.created : result.deleted, file);\n      })\n    ];\n    errorParsers = [\n      new LineParser(/^from\\s(.+)$/i, (result, [remote]) => void (result.remote = remote)),\n      new LineParser(/^fatal:\\s(.+)$/, (result, [message]) => void (result.message = message)),\n      new LineParser(/([a-z0-9]+)\\.\\.([a-z0-9]+)\\s+(\\S+)\\s+->\\s+(\\S+)$/, (result, [hashLocal, hashRemote, branchLocal, branchRemote]) => {\n        result.branch.local = branchLocal;\n        result.hash.local = hashLocal;\n        result.branch.remote = branchRemote;\n        result.hash.remote = hashRemote;\n      })\n    ];\n    parsePullDetail = (stdOut, stdErr) => {\n      return parseStringResponse(new PullSummary(), parsers3, [stdOut, stdErr]);\n    };\n    parsePullResult = (stdOut, stdErr) => {\n      return Object.assign(new PullSummary(), parsePullDetail(stdOut, stdErr), parseRemoteMessages(stdOut, stdErr));\n    };\n  }\n});\n\n// src/lib/parsers/parse-merge.ts\nvar parsers4, parseMergeResult, parseMergeDetail;\nvar init_parse_merge = __esm({\n  \"src/lib/parsers/parse-merge.ts\"() {\n    init_MergeSummary();\n    init_utils();\n    init_parse_pull();\n    parsers4 = [\n      new LineParser(/^Auto-merging\\s+(.+)$/, (summary, [autoMerge]) => {\n        summary.merges.push(autoMerge);\n      }),\n      new LineParser(/^CONFLICT\\s+\\((.+)\\): Merge conflict in (.+)$/, (summary, [reason, file]) => {\n        summary.conflicts.push(new MergeSummaryConflict(reason, file));\n      }),\n      new LineParser(/^CONFLICT\\s+\\((.+\\/delete)\\): (.+) deleted in (.+) and/, (summary, [reason, file, deleteRef]) => {\n        summary.conflicts.push(new MergeSummaryConflict(reason, file, { deleteRef }));\n      }),\n      new LineParser(/^CONFLICT\\s+\\((.+)\\):/, (summary, [reason]) => {\n        summary.conflicts.push(new MergeSummaryConflict(reason, null));\n      }),\n      new LineParser(/^Automatic merge failed;\\s+(.+)$/, (summary, [result]) => {\n        summary.result = result;\n      })\n    ];\n    parseMergeResult = (stdOut, stdErr) => {\n      return Object.assign(parseMergeDetail(stdOut, stdErr), parsePullResult(stdOut, stdErr));\n    };\n    parseMergeDetail = (stdOut) => {\n      return parseStringResponse(new MergeSummaryDetail(), parsers4, stdOut);\n    };\n  }\n});\n\n// src/lib/tasks/merge.ts\nfunction mergeTask(customArgs) {\n  if (!customArgs.length) {\n    return configurationErrorTask(\"Git.merge requires at least one option\");\n  }\n  return {\n    commands: [\"merge\", ...customArgs],\n    format: \"utf-8\",\n    parser(stdOut, stdErr) {\n      const merge = parseMergeResult(stdOut, stdErr);\n      if (merge.failed) {\n        throw new GitResponseError(merge);\n      }\n      return merge;\n    }\n  };\n}\nvar init_merge = __esm({\n  \"src/lib/tasks/merge.ts\"() {\n    init_git_response_error();\n    init_parse_merge();\n    init_task();\n  }\n});\n\n// src/lib/parsers/parse-push.ts\nfunction pushResultPushedItem(local, remote, status) {\n  const deleted = status.includes(\"deleted\");\n  const tag = status.includes(\"tag\") || /^refs\\/tags/.test(local);\n  const alreadyUpdated = !status.includes(\"new\");\n  return {\n    deleted,\n    tag,\n    branch: !tag,\n    new: !alreadyUpdated,\n    alreadyUpdated,\n    local,\n    remote\n  };\n}\nvar parsers5, parsePushResult, parsePushDetail;\nvar init_parse_push = __esm({\n  \"src/lib/parsers/parse-push.ts\"() {\n    init_utils();\n    init_parse_remote_messages();\n    parsers5 = [\n      new LineParser(/^Pushing to (.+)$/, (result, [repo]) => {\n        result.repo = repo;\n      }),\n      new LineParser(/^updating local tracking ref '(.+)'/, (result, [local]) => {\n        result.ref = __spreadProps(__spreadValues({}, result.ref || {}), {\n          local\n        });\n      }),\n      new LineParser(/^[=*-]\\s+([^:]+):(\\S+)\\s+\\[(.+)]$/, (result, [local, remote, type]) => {\n        result.pushed.push(pushResultPushedItem(local, remote, type));\n      }),\n      new LineParser(/^Branch '([^']+)' set up to track remote branch '([^']+)' from '([^']+)'/, (result, [local, remote, remoteName]) => {\n        result.branch = __spreadProps(__spreadValues({}, result.branch || {}), {\n          local,\n          remote,\n          remoteName\n        });\n      }),\n      new LineParser(/^([^:]+):(\\S+)\\s+([a-z0-9]+)\\.\\.([a-z0-9]+)$/, (result, [local, remote, from, to]) => {\n        result.update = {\n          head: {\n            local,\n            remote\n          },\n          hash: {\n            from,\n            to\n          }\n        };\n      })\n    ];\n    parsePushResult = (stdOut, stdErr) => {\n      const pushDetail = parsePushDetail(stdOut, stdErr);\n      const responseDetail = parseRemoteMessages(stdOut, stdErr);\n      return __spreadValues(__spreadValues({}, pushDetail), responseDetail);\n    };\n    parsePushDetail = (stdOut, stdErr) => {\n      return parseStringResponse({ pushed: [] }, parsers5, [stdOut, stdErr]);\n    };\n  }\n});\n\n// src/lib/tasks/push.ts\nvar push_exports = {};\n__export(push_exports, {\n  pushTagsTask: () => pushTagsTask,\n  pushTask: () => pushTask\n});\nfunction pushTagsTask(ref = {}, customArgs) {\n  append(customArgs, \"--tags\");\n  return pushTask(ref, customArgs);\n}\nfunction pushTask(ref = {}, customArgs) {\n  const commands = [\"push\", ...customArgs];\n  if (ref.branch) {\n    commands.splice(1, 0, ref.branch);\n  }\n  if (ref.remote) {\n    commands.splice(1, 0, ref.remote);\n  }\n  remove(commands, \"-v\");\n  append(commands, \"--verbose\");\n  append(commands, \"--porcelain\");\n  return {\n    commands,\n    format: \"utf-8\",\n    parser: parsePushResult\n  };\n}\nvar init_push = __esm({\n  \"src/lib/tasks/push.ts\"() {\n    init_parse_push();\n    init_utils();\n  }\n});\n\n// src/lib/responses/FileStatusSummary.ts\nvar fromPathRegex, FileStatusSummary;\nvar init_FileStatusSummary = __esm({\n  \"src/lib/responses/FileStatusSummary.ts\"() {\n    fromPathRegex = /^(.+) -> (.+)$/;\n    FileStatusSummary = class {\n      constructor(path, index, working_dir) {\n        this.path = path;\n        this.index = index;\n        this.working_dir = working_dir;\n        if (index + working_dir === \"R\") {\n          const detail = fromPathRegex.exec(path) || [null, path, path];\n          this.from = detail[1] || \"\";\n          this.path = detail[2] || \"\";\n        }\n      }\n    };\n  }\n});\n\n// src/lib/responses/StatusSummary.ts\nfunction renamedFile(line) {\n  const [to, from] = line.split(NULL);\n  return {\n    from: from || to,\n    to\n  };\n}\nfunction parser2(indexX, indexY, handler) {\n  return [`${indexX}${indexY}`, handler];\n}\nfunction conflicts(indexX, ...indexY) {\n  return indexY.map((y) => parser2(indexX, y, (result, file) => append(result.conflicted, file)));\n}\nfunction splitLine(result, lineStr) {\n  const trimmed2 = lineStr.trim();\n  switch (\" \") {\n    case trimmed2.charAt(2):\n      return data(trimmed2.charAt(0), trimmed2.charAt(1), trimmed2.substr(3));\n    case trimmed2.charAt(1):\n      return data(\" \" /* NONE */, trimmed2.charAt(0), trimmed2.substr(2));\n    default:\n      return;\n  }\n  function data(index, workingDir, path) {\n    const raw = `${index}${workingDir}`;\n    const handler = parsers6.get(raw);\n    if (handler) {\n      handler(result, path);\n    }\n    if (raw !== \"##\" && raw !== \"!!\") {\n      result.files.push(new FileStatusSummary(path.replace(/\\0.+$/, \"\"), index, workingDir));\n    }\n  }\n}\nvar StatusSummary, parsers6, parseStatusSummary;\nvar init_StatusSummary = __esm({\n  \"src/lib/responses/StatusSummary.ts\"() {\n    init_utils();\n    init_FileStatusSummary();\n    StatusSummary = class {\n      constructor() {\n        this.not_added = [];\n        this.conflicted = [];\n        this.created = [];\n        this.deleted = [];\n        this.ignored = void 0;\n        this.modified = [];\n        this.renamed = [];\n        this.files = [];\n        this.staged = [];\n        this.ahead = 0;\n        this.behind = 0;\n        this.current = null;\n        this.tracking = null;\n        this.detached = false;\n        this.isClean = () => {\n          return !this.files.length;\n        };\n      }\n    };\n    parsers6 = new Map([\n      parser2(\" \" /* NONE */, \"A\" /* ADDED */, (result, file) => append(result.created, file)),\n      parser2(\" \" /* NONE */, \"D\" /* DELETED */, (result, file) => append(result.deleted, file)),\n      parser2(\" \" /* NONE */, \"M\" /* MODIFIED */, (result, file) => append(result.modified, file)),\n      parser2(\"A\" /* ADDED */, \" \" /* NONE */, (result, file) => append(result.created, file) && append(result.staged, file)),\n      parser2(\"A\" /* ADDED */, \"M\" /* MODIFIED */, (result, file) => append(result.created, file) && append(result.staged, file) && append(result.modified, file)),\n      parser2(\"D\" /* DELETED */, \" \" /* NONE */, (result, file) => append(result.deleted, file) && append(result.staged, file)),\n      parser2(\"M\" /* MODIFIED */, \" \" /* NONE */, (result, file) => append(result.modified, file) && append(result.staged, file)),\n      parser2(\"M\" /* MODIFIED */, \"M\" /* MODIFIED */, (result, file) => append(result.modified, file) && append(result.staged, file)),\n      parser2(\"R\" /* RENAMED */, \" \" /* NONE */, (result, file) => {\n        append(result.renamed, renamedFile(file));\n      }),\n      parser2(\"R\" /* RENAMED */, \"M\" /* MODIFIED */, (result, file) => {\n        const renamed = renamedFile(file);\n        append(result.renamed, renamed);\n        append(result.modified, renamed.to);\n      }),\n      parser2(\"!\" /* IGNORED */, \"!\" /* IGNORED */, (_result, _file) => {\n        append(_result.ignored = _result.ignored || [], _file);\n      }),\n      parser2(\"?\" /* UNTRACKED */, \"?\" /* UNTRACKED */, (result, file) => append(result.not_added, file)),\n      ...conflicts(\"A\" /* ADDED */, \"A\" /* ADDED */, \"U\" /* UNMERGED */),\n      ...conflicts(\"D\" /* DELETED */, \"D\" /* DELETED */, \"U\" /* UNMERGED */),\n      ...conflicts(\"U\" /* UNMERGED */, \"A\" /* ADDED */, \"D\" /* DELETED */, \"U\" /* UNMERGED */),\n      [\n        \"##\",\n        (result, line) => {\n          const aheadReg = /ahead (\\d+)/;\n          const behindReg = /behind (\\d+)/;\n          const currentReg = /^(.+?(?=(?:\\.{3}|\\s|$)))/;\n          const trackingReg = /\\.{3}(\\S*)/;\n          const onEmptyBranchReg = /\\son\\s([\\S]+)$/;\n          let regexResult;\n          regexResult = aheadReg.exec(line);\n          result.ahead = regexResult && +regexResult[1] || 0;\n          regexResult = behindReg.exec(line);\n          result.behind = regexResult && +regexResult[1] || 0;\n          regexResult = currentReg.exec(line);\n          result.current = regexResult && regexResult[1];\n          regexResult = trackingReg.exec(line);\n          result.tracking = regexResult && regexResult[1];\n          regexResult = onEmptyBranchReg.exec(line);\n          result.current = regexResult && regexResult[1] || result.current;\n          result.detached = /\\(no branch\\)/.test(line);\n        }\n      ]\n    ]);\n    parseStatusSummary = function(text) {\n      const lines = text.split(NULL);\n      const status = new StatusSummary();\n      for (let i = 0, l = lines.length; i < l; ) {\n        let line = lines[i++].trim();\n        if (!line) {\n          continue;\n        }\n        if (line.charAt(0) === \"R\" /* RENAMED */) {\n          line += NULL + (lines[i++] || \"\");\n        }\n        splitLine(status, line);\n      }\n      return status;\n    };\n  }\n});\n\n// src/lib/tasks/status.ts\nfunction statusTask(customArgs) {\n  const commands = [\n    \"status\",\n    \"--porcelain\",\n    \"-b\",\n    \"-u\",\n    \"--null\",\n    ...customArgs.filter((arg) => !ignoredOptions.includes(arg))\n  ];\n  return {\n    format: \"utf-8\",\n    commands,\n    parser(text) {\n      return parseStatusSummary(text);\n    }\n  };\n}\nvar ignoredOptions;\nvar init_status = __esm({\n  \"src/lib/tasks/status.ts\"() {\n    init_StatusSummary();\n    ignoredOptions = [\"--null\", \"-z\"];\n  }\n});\n\n// src/lib/tasks/version.ts\nfunction versionResponse(major = 0, minor = 0, patch = 0, agent = \"\", installed = true) {\n  return Object.defineProperty({\n    major,\n    minor,\n    patch,\n    agent,\n    installed\n  }, \"toString\", {\n    value() {\n      return `${this.major}.${this.minor}.${this.patch}`;\n    },\n    configurable: false,\n    enumerable: false\n  });\n}\nfunction notInstalledResponse() {\n  return versionResponse(0, 0, 0, \"\", false);\n}\nfunction version_default() {\n  return {\n    version() {\n      return this._runTask({\n        commands: [\"--version\"],\n        format: \"utf-8\",\n        parser: versionParser,\n        onError(result, error, done, fail) {\n          if (result.exitCode === -2 /* NOT_FOUND */) {\n            return done(Buffer.from(NOT_INSTALLED));\n          }\n          fail(error);\n        }\n      });\n    }\n  };\n}\nfunction versionParser(stdOut) {\n  if (stdOut === NOT_INSTALLED) {\n    return notInstalledResponse();\n  }\n  return parseStringResponse(versionResponse(0, 0, 0, stdOut), parsers7, stdOut);\n}\nvar NOT_INSTALLED, parsers7;\nvar init_version = __esm({\n  \"src/lib/tasks/version.ts\"() {\n    init_utils();\n    NOT_INSTALLED = \"installed=false\";\n    parsers7 = [\n      new LineParser(/version (\\d+)\\.(\\d+)\\.(\\d+)(?:\\s*\\((.+)\\))?/, (result, [major, minor, patch, agent = \"\"]) => {\n        Object.assign(result, versionResponse(asNumber(major), asNumber(minor), asNumber(patch), agent));\n      }),\n      new LineParser(/version (\\d+)\\.(\\d+)\\.(\\D+)(.+)?$/, (result, [major, minor, patch, agent = \"\"]) => {\n        Object.assign(result, versionResponse(asNumber(major), asNumber(minor), patch, agent));\n      })\n    ];\n  }\n});\n\n// src/lib/simple-git-api.ts\nvar simple_git_api_exports = {};\n__export(simple_git_api_exports, {\n  SimpleGitApi: () => SimpleGitApi\n});\nvar SimpleGitApi;\nvar init_simple_git_api = __esm({\n  \"src/lib/simple-git-api.ts\"() {\n    init_task_callback();\n    init_change_working_directory();\n    init_checkout();\n    init_commit();\n    init_config();\n    init_grep();\n    init_hash_object();\n    init_init();\n    init_log();\n    init_merge();\n    init_push();\n    init_status();\n    init_task();\n    init_version();\n    init_utils();\n    SimpleGitApi = class {\n      constructor(_executor) {\n        this._executor = _executor;\n      }\n      _runTask(task, then) {\n        const chain = this._executor.chain();\n        const promise = chain.push(task);\n        if (then) {\n          taskCallback(task, promise, then);\n        }\n        return Object.create(this, {\n          then: { value: promise.then.bind(promise) },\n          catch: { value: promise.catch.bind(promise) },\n          _executor: { value: chain }\n        });\n      }\n      add(files) {\n        return this._runTask(straightThroughStringTask([\"add\", ...asArray(files)]), trailingFunctionArgument(arguments));\n      }\n      cwd(directory) {\n        const next = trailingFunctionArgument(arguments);\n        if (typeof directory === \"string\") {\n          return this._runTask(changeWorkingDirectoryTask(directory, this._executor), next);\n        }\n        if (typeof (directory == null ? void 0 : directory.path) === \"string\") {\n          return this._runTask(changeWorkingDirectoryTask(directory.path, directory.root && this._executor || void 0), next);\n        }\n        return this._runTask(configurationErrorTask(\"Git.cwd: workingDirectory must be supplied as a string\"), next);\n      }\n      hashObject(path, write) {\n        return this._runTask(hashObjectTask(path, write === true), trailingFunctionArgument(arguments));\n      }\n      init(bare) {\n        return this._runTask(initTask(bare === true, this._executor.cwd, getTrailingOptions(arguments)), trailingFunctionArgument(arguments));\n      }\n      merge() {\n        return this._runTask(mergeTask(getTrailingOptions(arguments)), trailingFunctionArgument(arguments));\n      }\n      mergeFromTo(remote, branch) {\n        if (!(filterString(remote) && filterString(branch))) {\n          return this._runTask(configurationErrorTask(`Git.mergeFromTo requires that the 'remote' and 'branch' arguments are supplied as strings`));\n        }\n        return this._runTask(mergeTask([remote, branch, ...getTrailingOptions(arguments)]), trailingFunctionArgument(arguments, false));\n      }\n      outputHandler(handler) {\n        this._executor.outputHandler = handler;\n        return this;\n      }\n      push() {\n        const task = pushTask({\n          remote: filterType(arguments[0], filterString),\n          branch: filterType(arguments[1], filterString)\n        }, getTrailingOptions(arguments));\n        return this._runTask(task, trailingFunctionArgument(arguments));\n      }\n      stash() {\n        return this._runTask(straightThroughStringTask([\"stash\", ...getTrailingOptions(arguments)]), trailingFunctionArgument(arguments));\n      }\n      status() {\n        return this._runTask(statusTask(getTrailingOptions(arguments)), trailingFunctionArgument(arguments));\n      }\n    };\n    Object.assign(SimpleGitApi.prototype, checkout_default(), commit_default(), config_default(), grep_default(), log_default(), version_default());\n  }\n});\n\n// src/lib/runners/scheduler.ts\nvar scheduler_exports = {};\n__export(scheduler_exports, {\n  Scheduler: () => Scheduler\n});\nvar import_promise_deferred2, createScheduledTask, Scheduler;\nvar init_scheduler = __esm({\n  \"src/lib/runners/scheduler.ts\"() {\n    init_utils();\n    import_promise_deferred2 = require(\"@kwsites/promise-deferred\");\n    init_git_logger();\n    createScheduledTask = (() => {\n      let id = 0;\n      return () => {\n        id++;\n        const { promise, done } = (0, import_promise_deferred2.createDeferred)();\n        return {\n          promise,\n          done,\n          id\n        };\n      };\n    })();\n    Scheduler = class {\n      constructor(concurrency = 2) {\n        this.concurrency = concurrency;\n        this.logger = createLogger(\"\", \"scheduler\");\n        this.pending = [];\n        this.running = [];\n        this.logger(`Constructed, concurrency=%s`, concurrency);\n      }\n      schedule() {\n        if (!this.pending.length || this.running.length >= this.concurrency) {\n          this.logger(`Schedule attempt ignored, pending=%s running=%s concurrency=%s`, this.pending.length, this.running.length, this.concurrency);\n          return;\n        }\n        const task = append(this.running, this.pending.shift());\n        this.logger(`Attempting id=%s`, task.id);\n        task.done(() => {\n          this.logger(`Completing id=`, task.id);\n          remove(this.running, task);\n          this.schedule();\n        });\n      }\n      next() {\n        const { promise, id } = append(this.pending, createScheduledTask());\n        this.logger(`Scheduling id=%s`, id);\n        this.schedule();\n        return promise;\n      }\n    };\n  }\n});\n\n// src/lib/tasks/apply-patch.ts\nvar apply_patch_exports = {};\n__export(apply_patch_exports, {\n  applyPatchTask: () => applyPatchTask\n});\nfunction applyPatchTask(patches, customArgs) {\n  return straightThroughStringTask([\"apply\", ...customArgs, ...patches]);\n}\nvar init_apply_patch = __esm({\n  \"src/lib/tasks/apply-patch.ts\"() {\n    init_task();\n  }\n});\n\n// src/lib/responses/BranchDeleteSummary.ts\nfunction branchDeletionSuccess(branch, hash) {\n  return {\n    branch,\n    hash,\n    success: true\n  };\n}\nfunction branchDeletionFailure(branch) {\n  return {\n    branch,\n    hash: null,\n    success: false\n  };\n}\nvar BranchDeletionBatch;\nvar init_BranchDeleteSummary = __esm({\n  \"src/lib/responses/BranchDeleteSummary.ts\"() {\n    BranchDeletionBatch = class {\n      constructor() {\n        this.all = [];\n        this.branches = {};\n        this.errors = [];\n      }\n      get success() {\n        return !this.errors.length;\n      }\n    };\n  }\n});\n\n// src/lib/parsers/parse-branch-delete.ts\nfunction hasBranchDeletionError(data, processExitCode) {\n  return processExitCode === 1 /* ERROR */ && deleteErrorRegex.test(data);\n}\nvar deleteSuccessRegex, deleteErrorRegex, parsers8, parseBranchDeletions;\nvar init_parse_branch_delete = __esm({\n  \"src/lib/parsers/parse-branch-delete.ts\"() {\n    init_BranchDeleteSummary();\n    init_utils();\n    deleteSuccessRegex = /(\\S+)\\s+\\(\\S+\\s([^)]+)\\)/;\n    deleteErrorRegex = /^error[^']+'([^']+)'/m;\n    parsers8 = [\n      new LineParser(deleteSuccessRegex, (result, [branch, hash]) => {\n        const deletion = branchDeletionSuccess(branch, hash);\n        result.all.push(deletion);\n        result.branches[branch] = deletion;\n      }),\n      new LineParser(deleteErrorRegex, (result, [branch]) => {\n        const deletion = branchDeletionFailure(branch);\n        result.errors.push(deletion);\n        result.all.push(deletion);\n        result.branches[branch] = deletion;\n      })\n    ];\n    parseBranchDeletions = (stdOut, stdErr) => {\n      return parseStringResponse(new BranchDeletionBatch(), parsers8, [stdOut, stdErr]);\n    };\n  }\n});\n\n// src/lib/responses/BranchSummary.ts\nvar BranchSummaryResult;\nvar init_BranchSummary = __esm({\n  \"src/lib/responses/BranchSummary.ts\"() {\n    BranchSummaryResult = class {\n      constructor() {\n        this.all = [];\n        this.branches = {};\n        this.current = \"\";\n        this.detached = false;\n      }\n      push(status, detached, name, commit, label) {\n        if (status === \"*\" /* CURRENT */) {\n          this.detached = detached;\n          this.current = name;\n        }\n        this.all.push(name);\n        this.branches[name] = {\n          current: status === \"*\" /* CURRENT */,\n          linkedWorkTree: status === \"+\" /* LINKED */,\n          name,\n          commit,\n          label\n        };\n      }\n    };\n  }\n});\n\n// src/lib/parsers/parse-branch.ts\nfunction branchStatus(input) {\n  return input ? input.charAt(0) : \"\";\n}\nfunction parseBranchSummary(stdOut) {\n  return parseStringResponse(new BranchSummaryResult(), parsers9, stdOut);\n}\nvar parsers9;\nvar init_parse_branch = __esm({\n  \"src/lib/parsers/parse-branch.ts\"() {\n    init_BranchSummary();\n    init_utils();\n    parsers9 = [\n      new LineParser(/^([*+]\\s)?\\((?:HEAD )?detached (?:from|at) (\\S+)\\)\\s+([a-z0-9]+)\\s(.*)$/, (result, [current, name, commit, label]) => {\n        result.push(branchStatus(current), true, name, commit, label);\n      }),\n      new LineParser(/^([*+]\\s)?(\\S+)\\s+([a-z0-9]+)\\s?(.*)$/s, (result, [current, name, commit, label]) => {\n        result.push(branchStatus(current), false, name, commit, label);\n      })\n    ];\n  }\n});\n\n// src/lib/tasks/branch.ts\nvar branch_exports = {};\n__export(branch_exports, {\n  branchLocalTask: () => branchLocalTask,\n  branchTask: () => branchTask,\n  containsDeleteBranchCommand: () => containsDeleteBranchCommand,\n  deleteBranchTask: () => deleteBranchTask,\n  deleteBranchesTask: () => deleteBranchesTask\n});\nfunction containsDeleteBranchCommand(commands) {\n  const deleteCommands = [\"-d\", \"-D\", \"--delete\"];\n  return commands.some((command) => deleteCommands.includes(command));\n}\nfunction branchTask(customArgs) {\n  const isDelete = containsDeleteBranchCommand(customArgs);\n  const commands = [\"branch\", ...customArgs];\n  if (commands.length === 1) {\n    commands.push(\"-a\");\n  }\n  if (!commands.includes(\"-v\")) {\n    commands.splice(1, 0, \"-v\");\n  }\n  return {\n    format: \"utf-8\",\n    commands,\n    parser(stdOut, stdErr) {\n      if (isDelete) {\n        return parseBranchDeletions(stdOut, stdErr).all[0];\n      }\n      return parseBranchSummary(stdOut);\n    }\n  };\n}\nfunction branchLocalTask() {\n  const parser3 = parseBranchSummary;\n  return {\n    format: \"utf-8\",\n    commands: [\"branch\", \"-v\"],\n    parser: parser3\n  };\n}\nfunction deleteBranchesTask(branches, forceDelete = false) {\n  return {\n    format: \"utf-8\",\n    commands: [\"branch\", \"-v\", forceDelete ? \"-D\" : \"-d\", ...branches],\n    parser(stdOut, stdErr) {\n      return parseBranchDeletions(stdOut, stdErr);\n    },\n    onError({ exitCode, stdOut }, error, done, fail) {\n      if (!hasBranchDeletionError(String(error), exitCode)) {\n        return fail(error);\n      }\n      done(stdOut);\n    }\n  };\n}\nfunction deleteBranchTask(branch, forceDelete = false) {\n  const task = {\n    format: \"utf-8\",\n    commands: [\"branch\", \"-v\", forceDelete ? \"-D\" : \"-d\", branch],\n    parser(stdOut, stdErr) {\n      return parseBranchDeletions(stdOut, stdErr).branches[branch];\n    },\n    onError({ exitCode, stdErr, stdOut }, error, _, fail) {\n      if (!hasBranchDeletionError(String(error), exitCode)) {\n        return fail(error);\n      }\n      throw new GitResponseError(task.parser(bufferToString(stdOut), bufferToString(stdErr)), String(error));\n    }\n  };\n  return task;\n}\nvar init_branch = __esm({\n  \"src/lib/tasks/branch.ts\"() {\n    init_git_response_error();\n    init_parse_branch_delete();\n    init_parse_branch();\n    init_utils();\n  }\n});\n\n// src/lib/responses/CheckIgnore.ts\nvar parseCheckIgnore;\nvar init_CheckIgnore = __esm({\n  \"src/lib/responses/CheckIgnore.ts\"() {\n    parseCheckIgnore = (text) => {\n      return text.split(/\\n/g).map((line) => line.trim()).filter((file) => !!file);\n    };\n  }\n});\n\n// src/lib/tasks/check-ignore.ts\nvar check_ignore_exports = {};\n__export(check_ignore_exports, {\n  checkIgnoreTask: () => checkIgnoreTask\n});\nfunction checkIgnoreTask(paths) {\n  return {\n    commands: [\"check-ignore\", ...paths],\n    format: \"utf-8\",\n    parser: parseCheckIgnore\n  };\n}\nvar init_check_ignore = __esm({\n  \"src/lib/tasks/check-ignore.ts\"() {\n    init_CheckIgnore();\n  }\n});\n\n// src/lib/tasks/clone.ts\nvar clone_exports = {};\n__export(clone_exports, {\n  cloneMirrorTask: () => cloneMirrorTask,\n  cloneTask: () => cloneTask\n});\nfunction disallowedCommand(command) {\n  return /^--upload-pack(=|$)/.test(command);\n}\nfunction cloneTask(repo, directory, customArgs) {\n  const commands = [\"clone\", ...customArgs];\n  filterString(repo) && commands.push(repo);\n  filterString(directory) && commands.push(directory);\n  const banned = commands.find(disallowedCommand);\n  if (banned) {\n    return configurationErrorTask(`git.fetch: potential exploit argument blocked.`);\n  }\n  return straightThroughStringTask(commands);\n}\nfunction cloneMirrorTask(repo, directory, customArgs) {\n  append(customArgs, \"--mirror\");\n  return cloneTask(repo, directory, customArgs);\n}\nvar init_clone = __esm({\n  \"src/lib/tasks/clone.ts\"() {\n    init_task();\n    init_utils();\n  }\n});\n\n// src/lib/parsers/parse-fetch.ts\nfunction parseFetchResult(stdOut, stdErr) {\n  const result = {\n    raw: stdOut,\n    remote: null,\n    branches: [],\n    tags: [],\n    updated: [],\n    deleted: []\n  };\n  return parseStringResponse(result, parsers10, [stdOut, stdErr]);\n}\nvar parsers10;\nvar init_parse_fetch = __esm({\n  \"src/lib/parsers/parse-fetch.ts\"() {\n    init_utils();\n    parsers10 = [\n      new LineParser(/From (.+)$/, (result, [remote]) => {\n        result.remote = remote;\n      }),\n      new LineParser(/\\* \\[new branch]\\s+(\\S+)\\s*-> (.+)$/, (result, [name, tracking]) => {\n        result.branches.push({\n          name,\n          tracking\n        });\n      }),\n      new LineParser(/\\* \\[new tag]\\s+(\\S+)\\s*-> (.+)$/, (result, [name, tracking]) => {\n        result.tags.push({\n          name,\n          tracking\n        });\n      }),\n      new LineParser(/- \\[deleted]\\s+\\S+\\s*-> (.+)$/, (result, [tracking]) => {\n        result.deleted.push({\n          tracking\n        });\n      }),\n      new LineParser(/\\s*([^.]+)\\.\\.(\\S+)\\s+(\\S+)\\s*-> (.+)$/, (result, [from, to, name, tracking]) => {\n        result.updated.push({\n          name,\n          tracking,\n          to,\n          from\n        });\n      })\n    ];\n  }\n});\n\n// src/lib/tasks/fetch.ts\nvar fetch_exports = {};\n__export(fetch_exports, {\n  fetchTask: () => fetchTask\n});\nfunction disallowedCommand2(command) {\n  return /^--upload-pack(=|$)/.test(command);\n}\nfunction fetchTask(remote, branch, customArgs) {\n  const commands = [\"fetch\", ...customArgs];\n  if (remote && branch) {\n    commands.push(remote, branch);\n  }\n  const banned = commands.find(disallowedCommand2);\n  if (banned) {\n    return configurationErrorTask(`git.fetch: potential exploit argument blocked.`);\n  }\n  return {\n    commands,\n    format: \"utf-8\",\n    parser: parseFetchResult\n  };\n}\nvar init_fetch = __esm({\n  \"src/lib/tasks/fetch.ts\"() {\n    init_parse_fetch();\n    init_task();\n  }\n});\n\n// src/lib/parsers/parse-move.ts\nfunction parseMoveResult(stdOut) {\n  return parseStringResponse({ moves: [] }, parsers11, stdOut);\n}\nvar parsers11;\nvar init_parse_move = __esm({\n  \"src/lib/parsers/parse-move.ts\"() {\n    init_utils();\n    parsers11 = [\n      new LineParser(/^Renaming (.+) to (.+)$/, (result, [from, to]) => {\n        result.moves.push({ from, to });\n      })\n    ];\n  }\n});\n\n// src/lib/tasks/move.ts\nvar move_exports = {};\n__export(move_exports, {\n  moveTask: () => moveTask\n});\nfunction moveTask(from, to) {\n  return {\n    commands: [\"mv\", \"-v\", ...asArray(from), to],\n    format: \"utf-8\",\n    parser: parseMoveResult\n  };\n}\nvar init_move = __esm({\n  \"src/lib/tasks/move.ts\"() {\n    init_parse_move();\n    init_utils();\n  }\n});\n\n// src/lib/tasks/pull.ts\nvar pull_exports = {};\n__export(pull_exports, {\n  pullTask: () => pullTask\n});\nfunction pullTask(remote, branch, customArgs) {\n  const commands = [\"pull\", ...customArgs];\n  if (remote && branch) {\n    commands.splice(1, 0, remote, branch);\n  }\n  return {\n    commands,\n    format: \"utf-8\",\n    parser(stdOut, stdErr) {\n      return parsePullResult(stdOut, stdErr);\n    },\n    onError(result, _error, _done, fail) {\n      const pullError = parsePullErrorResult(bufferToString(result.stdOut), bufferToString(result.stdErr));\n      if (pullError) {\n        return fail(new GitResponseError(pullError));\n      }\n      fail(_error);\n    }\n  };\n}\nvar init_pull = __esm({\n  \"src/lib/tasks/pull.ts\"() {\n    init_git_response_error();\n    init_parse_pull();\n    init_utils();\n  }\n});\n\n// src/lib/responses/GetRemoteSummary.ts\nfunction parseGetRemotes(text) {\n  const remotes = {};\n  forEach(text, ([name]) => remotes[name] = { name });\n  return Object.values(remotes);\n}\nfunction parseGetRemotesVerbose(text) {\n  const remotes = {};\n  forEach(text, ([name, url, purpose]) => {\n    if (!remotes.hasOwnProperty(name)) {\n      remotes[name] = {\n        name,\n        refs: { fetch: \"\", push: \"\" }\n      };\n    }\n    if (purpose && url) {\n      remotes[name].refs[purpose.replace(/[^a-z]/g, \"\")] = url;\n    }\n  });\n  return Object.values(remotes);\n}\nfunction forEach(text, handler) {\n  forEachLineWithContent(text, (line) => handler(line.split(/\\s+/)));\n}\nvar init_GetRemoteSummary = __esm({\n  \"src/lib/responses/GetRemoteSummary.ts\"() {\n    init_utils();\n  }\n});\n\n// src/lib/tasks/remote.ts\nvar remote_exports = {};\n__export(remote_exports, {\n  addRemoteTask: () => addRemoteTask,\n  getRemotesTask: () => getRemotesTask,\n  listRemotesTask: () => listRemotesTask,\n  remoteTask: () => remoteTask,\n  removeRemoteTask: () => removeRemoteTask\n});\nfunction addRemoteTask(remoteName, remoteRepo, customArgs = []) {\n  return straightThroughStringTask([\"remote\", \"add\", ...customArgs, remoteName, remoteRepo]);\n}\nfunction getRemotesTask(verbose) {\n  const commands = [\"remote\"];\n  if (verbose) {\n    commands.push(\"-v\");\n  }\n  return {\n    commands,\n    format: \"utf-8\",\n    parser: verbose ? parseGetRemotesVerbose : parseGetRemotes\n  };\n}\nfunction listRemotesTask(customArgs = []) {\n  const commands = [...customArgs];\n  if (commands[0] !== \"ls-remote\") {\n    commands.unshift(\"ls-remote\");\n  }\n  return straightThroughStringTask(commands);\n}\nfunction remoteTask(customArgs = []) {\n  const commands = [...customArgs];\n  if (commands[0] !== \"remote\") {\n    commands.unshift(\"remote\");\n  }\n  return straightThroughStringTask(commands);\n}\nfunction removeRemoteTask(remoteName) {\n  return straightThroughStringTask([\"remote\", \"remove\", remoteName]);\n}\nvar init_remote = __esm({\n  \"src/lib/tasks/remote.ts\"() {\n    init_GetRemoteSummary();\n    init_task();\n  }\n});\n\n// src/lib/tasks/stash-list.ts\nvar stash_list_exports = {};\n__export(stash_list_exports, {\n  stashListTask: () => stashListTask\n});\nfunction stashListTask(opt = {}, customArgs) {\n  const options = parseLogOptions(opt);\n  const commands = [\"stash\", \"list\", ...options.commands, ...customArgs];\n  const parser3 = createListLogSummaryParser(options.splitter, options.fields, logFormatFromCommand(commands));\n  return validateLogFormatConfig(commands) || {\n    commands,\n    format: \"utf-8\",\n    parser: parser3\n  };\n}\nvar init_stash_list = __esm({\n  \"src/lib/tasks/stash-list.ts\"() {\n    init_log_format();\n    init_parse_list_log_summary();\n    init_diff();\n    init_log();\n  }\n});\n\n// src/lib/tasks/sub-module.ts\nvar sub_module_exports = {};\n__export(sub_module_exports, {\n  addSubModuleTask: () => addSubModuleTask,\n  initSubModuleTask: () => initSubModuleTask,\n  subModuleTask: () => subModuleTask,\n  updateSubModuleTask: () => updateSubModuleTask\n});\nfunction addSubModuleTask(repo, path) {\n  return subModuleTask([\"add\", repo, path]);\n}\nfunction initSubModuleTask(customArgs) {\n  return subModuleTask([\"init\", ...customArgs]);\n}\nfunction subModuleTask(customArgs) {\n  const commands = [...customArgs];\n  if (commands[0] !== \"submodule\") {\n    commands.unshift(\"submodule\");\n  }\n  return straightThroughStringTask(commands);\n}\nfunction updateSubModuleTask(customArgs) {\n  return subModuleTask([\"update\", ...customArgs]);\n}\nvar init_sub_module = __esm({\n  \"src/lib/tasks/sub-module.ts\"() {\n    init_task();\n  }\n});\n\n// src/lib/responses/TagList.ts\nfunction singleSorted(a, b) {\n  const aIsNum = isNaN(a);\n  const bIsNum = isNaN(b);\n  if (aIsNum !== bIsNum) {\n    return aIsNum ? 1 : -1;\n  }\n  return aIsNum ? sorted(a, b) : 0;\n}\nfunction sorted(a, b) {\n  return a === b ? 0 : a > b ? 1 : -1;\n}\nfunction trimmed(input) {\n  return input.trim();\n}\nfunction toNumber(input) {\n  if (typeof input === \"string\") {\n    return parseInt(input.replace(/^\\D+/g, \"\"), 10) || 0;\n  }\n  return 0;\n}\nvar TagList, parseTagList;\nvar init_TagList = __esm({\n  \"src/lib/responses/TagList.ts\"() {\n    TagList = class {\n      constructor(all, latest) {\n        this.all = all;\n        this.latest = latest;\n      }\n    };\n    parseTagList = function(data, customSort = false) {\n      const tags = data.split(\"\\n\").map(trimmed).filter(Boolean);\n      if (!customSort) {\n        tags.sort(function(tagA, tagB) {\n          const partsA = tagA.split(\".\");\n          const partsB = tagB.split(\".\");\n          if (partsA.length === 1 || partsB.length === 1) {\n            return singleSorted(toNumber(partsA[0]), toNumber(partsB[0]));\n          }\n          for (let i = 0, l = Math.max(partsA.length, partsB.length); i < l; i++) {\n            const diff = sorted(toNumber(partsA[i]), toNumber(partsB[i]));\n            if (diff) {\n              return diff;\n            }\n          }\n          return 0;\n        });\n      }\n      const latest = customSort ? tags[0] : [...tags].reverse().find((tag) => tag.indexOf(\".\") >= 0);\n      return new TagList(tags, latest);\n    };\n  }\n});\n\n// src/lib/tasks/tag.ts\nvar tag_exports = {};\n__export(tag_exports, {\n  addAnnotatedTagTask: () => addAnnotatedTagTask,\n  addTagTask: () => addTagTask,\n  tagListTask: () => tagListTask\n});\nfunction tagListTask(customArgs = []) {\n  const hasCustomSort = customArgs.some((option) => /^--sort=/.test(option));\n  return {\n    format: \"utf-8\",\n    commands: [\"tag\", \"-l\", ...customArgs],\n    parser(text) {\n      return parseTagList(text, hasCustomSort);\n    }\n  };\n}\nfunction addTagTask(name) {\n  return {\n    format: \"utf-8\",\n    commands: [\"tag\", name],\n    parser() {\n      return { name };\n    }\n  };\n}\nfunction addAnnotatedTagTask(name, tagMessage) {\n  return {\n    format: \"utf-8\",\n    commands: [\"tag\", \"-a\", \"-m\", tagMessage, name],\n    parser() {\n      return { name };\n    }\n  };\n}\nvar init_tag = __esm({\n  \"src/lib/tasks/tag.ts\"() {\n    init_TagList();\n  }\n});\n\n// src/git.js\nvar require_git = __commonJS({\n  \"src/git.js\"(exports2, module2) {\n    var { GitExecutor: GitExecutor2 } = (init_git_executor(), __toCommonJS(git_executor_exports));\n    var { SimpleGitApi: SimpleGitApi2 } = (init_simple_git_api(), __toCommonJS(simple_git_api_exports));\n    var { Scheduler: Scheduler2 } = (init_scheduler(), __toCommonJS(scheduler_exports));\n    var { configurationErrorTask: configurationErrorTask2 } = (init_task(), __toCommonJS(task_exports));\n    var {\n      asArray: asArray2,\n      filterArray: filterArray2,\n      filterPrimitives: filterPrimitives2,\n      filterString: filterString2,\n      filterStringOrStringArray: filterStringOrStringArray2,\n      filterType: filterType2,\n      getTrailingOptions: getTrailingOptions2,\n      trailingFunctionArgument: trailingFunctionArgument2,\n      trailingOptionsArgument: trailingOptionsArgument2\n    } = (init_utils(), __toCommonJS(utils_exports));\n    var { applyPatchTask: applyPatchTask2 } = (init_apply_patch(), __toCommonJS(apply_patch_exports));\n    var {\n      branchTask: branchTask2,\n      branchLocalTask: branchLocalTask2,\n      deleteBranchesTask: deleteBranchesTask2,\n      deleteBranchTask: deleteBranchTask2\n    } = (init_branch(), __toCommonJS(branch_exports));\n    var { checkIgnoreTask: checkIgnoreTask2 } = (init_check_ignore(), __toCommonJS(check_ignore_exports));\n    var { checkIsRepoTask: checkIsRepoTask2 } = (init_check_is_repo(), __toCommonJS(check_is_repo_exports));\n    var { cloneTask: cloneTask2, cloneMirrorTask: cloneMirrorTask2 } = (init_clone(), __toCommonJS(clone_exports));\n    var { cleanWithOptionsTask: cleanWithOptionsTask2, isCleanOptionsArray: isCleanOptionsArray2 } = (init_clean(), __toCommonJS(clean_exports));\n    var { diffSummaryTask: diffSummaryTask2 } = (init_diff(), __toCommonJS(diff_exports));\n    var { fetchTask: fetchTask2 } = (init_fetch(), __toCommonJS(fetch_exports));\n    var { moveTask: moveTask2 } = (init_move(), __toCommonJS(move_exports));\n    var { pullTask: pullTask2 } = (init_pull(), __toCommonJS(pull_exports));\n    var { pushTagsTask: pushTagsTask2 } = (init_push(), __toCommonJS(push_exports));\n    var {\n      addRemoteTask: addRemoteTask2,\n      getRemotesTask: getRemotesTask2,\n      listRemotesTask: listRemotesTask2,\n      remoteTask: remoteTask2,\n      removeRemoteTask: removeRemoteTask2\n    } = (init_remote(), __toCommonJS(remote_exports));\n    var { getResetMode: getResetMode2, resetTask: resetTask2 } = (init_reset(), __toCommonJS(reset_exports));\n    var { stashListTask: stashListTask2 } = (init_stash_list(), __toCommonJS(stash_list_exports));\n    var {\n      addSubModuleTask: addSubModuleTask2,\n      initSubModuleTask: initSubModuleTask2,\n      subModuleTask: subModuleTask2,\n      updateSubModuleTask: updateSubModuleTask2\n    } = (init_sub_module(), __toCommonJS(sub_module_exports));\n    var { addAnnotatedTagTask: addAnnotatedTagTask2, addTagTask: addTagTask2, tagListTask: tagListTask2 } = (init_tag(), __toCommonJS(tag_exports));\n    var { straightThroughBufferTask: straightThroughBufferTask2, straightThroughStringTask: straightThroughStringTask2 } = (init_task(), __toCommonJS(task_exports));\n    function Git2(options, plugins) {\n      this._executor = new GitExecutor2(options.binary, options.baseDir, new Scheduler2(options.maxConcurrentProcesses), plugins);\n      this._trimmed = options.trimmed;\n    }\n    (Git2.prototype = Object.create(SimpleGitApi2.prototype)).constructor = Git2;\n    Git2.prototype.customBinary = function(command) {\n      this._executor.binary = command;\n      return this;\n    };\n    Git2.prototype.env = function(name, value) {\n      if (arguments.length === 1 && typeof name === \"object\") {\n        this._executor.env = name;\n      } else {\n        (this._executor.env = this._executor.env || {})[name] = value;\n      }\n      return this;\n    };\n    Git2.prototype.stashList = function(options) {\n      return this._runTask(stashListTask2(trailingOptionsArgument2(arguments) || {}, filterArray2(options) && options || []), trailingFunctionArgument2(arguments));\n    };\n    function createCloneTask(api, task, repoPath, localPath) {\n      if (typeof repoPath !== \"string\") {\n        return configurationErrorTask2(`git.${api}() requires a string 'repoPath'`);\n      }\n      return task(repoPath, filterType2(localPath, filterString2), getTrailingOptions2(arguments));\n    }\n    Git2.prototype.clone = function() {\n      return this._runTask(createCloneTask(\"clone\", cloneTask2, ...arguments), trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.mirror = function() {\n      return this._runTask(createCloneTask(\"mirror\", cloneMirrorTask2, ...arguments), trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.mv = function(from, to) {\n      return this._runTask(moveTask2(from, to), trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.checkoutLatestTag = function(then) {\n      var git = this;\n      return this.pull(function() {\n        git.tags(function(err, tags) {\n          git.checkout(tags.latest, then);\n        });\n      });\n    };\n    Git2.prototype.pull = function(remote, branch, options, then) {\n      return this._runTask(pullTask2(filterType2(remote, filterString2), filterType2(branch, filterString2), getTrailingOptions2(arguments)), trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.fetch = function(remote, branch) {\n      return this._runTask(fetchTask2(filterType2(remote, filterString2), filterType2(branch, filterString2), getTrailingOptions2(arguments)), trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.silent = function(silence) {\n      console.warn(\"simple-git deprecation notice: git.silent: logging should be configured using the `debug` library / `DEBUG` environment variable, this will be an error in version 3\");\n      return this;\n    };\n    Git2.prototype.tags = function(options, then) {\n      return this._runTask(tagListTask2(getTrailingOptions2(arguments)), trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.rebase = function() {\n      return this._runTask(straightThroughStringTask2([\"rebase\", ...getTrailingOptions2(arguments)]), trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.reset = function(mode) {\n      return this._runTask(resetTask2(getResetMode2(mode), getTrailingOptions2(arguments)), trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.revert = function(commit) {\n      const next = trailingFunctionArgument2(arguments);\n      if (typeof commit !== \"string\") {\n        return this._runTask(configurationErrorTask2(\"Commit must be a string\"), next);\n      }\n      return this._runTask(straightThroughStringTask2([\"revert\", ...getTrailingOptions2(arguments, 0, true), commit]), next);\n    };\n    Git2.prototype.addTag = function(name) {\n      const task = typeof name === \"string\" ? addTagTask2(name) : configurationErrorTask2(\"Git.addTag requires a tag name\");\n      return this._runTask(task, trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.addAnnotatedTag = function(tagName, tagMessage) {\n      return this._runTask(addAnnotatedTagTask2(tagName, tagMessage), trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.deleteLocalBranch = function(branchName, forceDelete, then) {\n      return this._runTask(deleteBranchTask2(branchName, typeof forceDelete === \"boolean\" ? forceDelete : false), trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.deleteLocalBranches = function(branchNames, forceDelete, then) {\n      return this._runTask(deleteBranchesTask2(branchNames, typeof forceDelete === \"boolean\" ? forceDelete : false), trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.branch = function(options, then) {\n      return this._runTask(branchTask2(getTrailingOptions2(arguments)), trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.branchLocal = function(then) {\n      return this._runTask(branchLocalTask2(), trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.raw = function(commands) {\n      const createRestCommands = !Array.isArray(commands);\n      const command = [].slice.call(createRestCommands ? arguments : commands, 0);\n      for (let i = 0; i < command.length && createRestCommands; i++) {\n        if (!filterPrimitives2(command[i])) {\n          command.splice(i, command.length - i);\n          break;\n        }\n      }\n      command.push(...getTrailingOptions2(arguments, 0, true));\n      var next = trailingFunctionArgument2(arguments);\n      if (!command.length) {\n        return this._runTask(configurationErrorTask2(\"Raw: must supply one or more command to execute\"), next);\n      }\n      return this._runTask(straightThroughStringTask2(command, this._trimmed), next);\n    };\n    Git2.prototype.submoduleAdd = function(repo, path, then) {\n      return this._runTask(addSubModuleTask2(repo, path), trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.submoduleUpdate = function(args, then) {\n      return this._runTask(updateSubModuleTask2(getTrailingOptions2(arguments, true)), trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.submoduleInit = function(args, then) {\n      return this._runTask(initSubModuleTask2(getTrailingOptions2(arguments, true)), trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.subModule = function(options, then) {\n      return this._runTask(subModuleTask2(getTrailingOptions2(arguments)), trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.listRemote = function() {\n      return this._runTask(listRemotesTask2(getTrailingOptions2(arguments)), trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.addRemote = function(remoteName, remoteRepo, then) {\n      return this._runTask(addRemoteTask2(remoteName, remoteRepo, getTrailingOptions2(arguments)), trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.removeRemote = function(remoteName, then) {\n      return this._runTask(removeRemoteTask2(remoteName), trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.getRemotes = function(verbose, then) {\n      return this._runTask(getRemotesTask2(verbose === true), trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.remote = function(options, then) {\n      return this._runTask(remoteTask2(getTrailingOptions2(arguments)), trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.tag = function(options, then) {\n      const command = getTrailingOptions2(arguments);\n      if (command[0] !== \"tag\") {\n        command.unshift(\"tag\");\n      }\n      return this._runTask(straightThroughStringTask2(command), trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.updateServerInfo = function(then) {\n      return this._runTask(straightThroughStringTask2([\"update-server-info\"]), trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.pushTags = function(remote, then) {\n      const task = pushTagsTask2({ remote: filterType2(remote, filterString2) }, getTrailingOptions2(arguments));\n      return this._runTask(task, trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.rm = function(files) {\n      return this._runTask(straightThroughStringTask2([\"rm\", \"-f\", ...asArray2(files)]), trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.rmKeepLocal = function(files) {\n      return this._runTask(straightThroughStringTask2([\"rm\", \"--cached\", ...asArray2(files)]), trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.catFile = function(options, then) {\n      return this._catFile(\"utf-8\", arguments);\n    };\n    Git2.prototype.binaryCatFile = function() {\n      return this._catFile(\"buffer\", arguments);\n    };\n    Git2.prototype._catFile = function(format, args) {\n      var handler = trailingFunctionArgument2(args);\n      var command = [\"cat-file\"];\n      var options = args[0];\n      if (typeof options === \"string\") {\n        return this._runTask(configurationErrorTask2(\"Git.catFile: options must be supplied as an array of strings\"), handler);\n      }\n      if (Array.isArray(options)) {\n        command.push.apply(command, options);\n      }\n      const task = format === \"buffer\" ? straightThroughBufferTask2(command) : straightThroughStringTask2(command);\n      return this._runTask(task, handler);\n    };\n    Git2.prototype.diff = function(options, then) {\n      const task = filterString2(options) ? configurationErrorTask2(\"git.diff: supplying options as a single string is no longer supported, switch to an array of strings\") : straightThroughStringTask2([\"diff\", ...getTrailingOptions2(arguments)]);\n      return this._runTask(task, trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.diffSummary = function() {\n      return this._runTask(diffSummaryTask2(getTrailingOptions2(arguments, 1)), trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.applyPatch = function(patches) {\n      const task = !filterStringOrStringArray2(patches) ? configurationErrorTask2(`git.applyPatch requires one or more string patches as the first argument`) : applyPatchTask2(asArray2(patches), getTrailingOptions2([].slice.call(arguments, 1)));\n      return this._runTask(task, trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.revparse = function() {\n      const commands = [\"rev-parse\", ...getTrailingOptions2(arguments, true)];\n      return this._runTask(straightThroughStringTask2(commands, true), trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.show = function(options, then) {\n      return this._runTask(straightThroughStringTask2([\"show\", ...getTrailingOptions2(arguments, 1)]), trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.clean = function(mode, options, then) {\n      const usingCleanOptionsArray = isCleanOptionsArray2(mode);\n      const cleanMode = usingCleanOptionsArray && mode.join(\"\") || filterType2(mode, filterString2) || \"\";\n      const customArgs = getTrailingOptions2([].slice.call(arguments, usingCleanOptionsArray ? 1 : 0));\n      return this._runTask(cleanWithOptionsTask2(cleanMode, customArgs), trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.exec = function(then) {\n      const task = {\n        commands: [],\n        format: \"utf-8\",\n        parser() {\n          if (typeof then === \"function\") {\n            then();\n          }\n        }\n      };\n      return this._runTask(task);\n    };\n    Git2.prototype.clearQueue = function() {\n      return this;\n    };\n    Git2.prototype.checkIgnore = function(pathnames, then) {\n      return this._runTask(checkIgnoreTask2(asArray2(filterType2(pathnames, filterStringOrStringArray2, []))), trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.checkIsRepo = function(checkType, then) {\n      return this._runTask(checkIsRepoTask2(filterType2(checkType, filterString2)), trailingFunctionArgument2(arguments));\n    };\n    module2.exports = Git2;\n  }\n});\n\n// src/lib/git-factory.ts\nvar git_factory_exports = {};\n__export(git_factory_exports, {\n  esModuleFactory: () => esModuleFactory,\n  gitExportFactory: () => gitExportFactory,\n  gitInstanceFactory: () => gitInstanceFactory\n});\nfunction esModuleFactory(defaultExport) {\n  return Object.defineProperties(defaultExport, {\n    __esModule: { value: true },\n    default: { value: defaultExport }\n  });\n}\nfunction gitExportFactory(factory) {\n  return Object.assign(factory.bind(null), api_exports);\n}\nfunction gitInstanceFactory(baseDir, options) {\n  const plugins = new PluginStore();\n  const config = createInstanceConfig(baseDir && (typeof baseDir === \"string\" ? { baseDir } : baseDir) || {}, options);\n  if (!folderExists(config.baseDir)) {\n    throw new GitConstructError(config, `Cannot use simple-git on a directory that does not exist`);\n  }\n  if (Array.isArray(config.config)) {\n    plugins.add(commandConfigPrefixingPlugin(config.config));\n  }\n  plugins.add(blockUnsafeOperationsPlugin(config.unsafe));\n  plugins.add(completionDetectionPlugin(config.completion));\n  config.abort && plugins.add(abortPlugin(config.abort));\n  config.progress && plugins.add(progressMonitorPlugin(config.progress));\n  config.timeout && plugins.add(timeoutPlugin(config.timeout));\n  config.spawnOptions && plugins.add(spawnOptionsPlugin(config.spawnOptions));\n  plugins.add(errorDetectionPlugin(errorDetectionHandler(true)));\n  config.errors && plugins.add(errorDetectionPlugin(config.errors));\n  return new Git(config, plugins);\n}\nvar Git;\nvar init_git_factory = __esm({\n  \"src/lib/git-factory.ts\"() {\n    init_api();\n    init_plugins();\n    init_utils();\n    Git = require_git();\n  }\n});\n\n// src/lib/runners/promise-wrapped.ts\nvar promise_wrapped_exports = {};\n__export(promise_wrapped_exports, {\n  gitP: () => gitP\n});\nfunction gitP(...args) {\n  let git;\n  let chain = Promise.resolve();\n  try {\n    git = gitInstanceFactory(...args);\n  } catch (e) {\n    chain = Promise.reject(e);\n  }\n  function builderReturn() {\n    return promiseApi;\n  }\n  function chainReturn() {\n    return chain;\n  }\n  const promiseApi = [...functionNamesBuilderApi, ...functionNamesPromiseApi].reduce((api, name) => {\n    const isAsync = functionNamesPromiseApi.includes(name);\n    const valid = isAsync ? asyncWrapper(name, git) : syncWrapper(name, git, api);\n    const alternative = isAsync ? chainReturn : builderReturn;\n    Object.defineProperty(api, name, {\n      enumerable: false,\n      configurable: false,\n      value: git ? valid : alternative\n    });\n    return api;\n  }, {});\n  return promiseApi;\n  function asyncWrapper(fn, git2) {\n    return function(...args2) {\n      if (typeof args2[args2.length] === \"function\") {\n        throw new TypeError(\"Promise interface requires that handlers are not supplied inline, trailing function not allowed in call to \" + fn);\n      }\n      return chain.then(function() {\n        return new Promise(function(resolve, reject) {\n          const callback = (err, result) => {\n            if (err) {\n              return reject(toError(err));\n            }\n            resolve(result);\n          };\n          args2.push(callback);\n          git2[fn].apply(git2, args2);\n        });\n      });\n    };\n  }\n  function syncWrapper(fn, git2, api) {\n    return (...args2) => {\n      git2[fn](...args2);\n      return api;\n    };\n  }\n}\nfunction toError(error) {\n  if (error instanceof Error) {\n    return error;\n  }\n  if (typeof error === \"string\") {\n    return new Error(error);\n  }\n  return new GitResponseError(error);\n}\nvar functionNamesBuilderApi, functionNamesPromiseApi;\nvar init_promise_wrapped = __esm({\n  \"src/lib/runners/promise-wrapped.ts\"() {\n    init_git_response_error();\n    init_git_factory();\n    functionNamesBuilderApi = [\"customBinary\", \"env\", \"outputHandler\", \"silent\"];\n    functionNamesPromiseApi = [\n      \"add\",\n      \"addAnnotatedTag\",\n      \"addConfig\",\n      \"addRemote\",\n      \"addTag\",\n      \"applyPatch\",\n      \"binaryCatFile\",\n      \"branch\",\n      \"branchLocal\",\n      \"catFile\",\n      \"checkIgnore\",\n      \"checkIsRepo\",\n      \"checkout\",\n      \"checkoutBranch\",\n      \"checkoutLatestTag\",\n      \"checkoutLocalBranch\",\n      \"clean\",\n      \"clone\",\n      \"commit\",\n      \"cwd\",\n      \"deleteLocalBranch\",\n      \"deleteLocalBranches\",\n      \"diff\",\n      \"diffSummary\",\n      \"exec\",\n      \"fetch\",\n      \"getRemotes\",\n      \"init\",\n      \"listConfig\",\n      \"listRemote\",\n      \"log\",\n      \"merge\",\n      \"mergeFromTo\",\n      \"mirror\",\n      \"mv\",\n      \"pull\",\n      \"push\",\n      \"pushTags\",\n      \"raw\",\n      \"rebase\",\n      \"remote\",\n      \"removeRemote\",\n      \"reset\",\n      \"revert\",\n      \"revparse\",\n      \"rm\",\n      \"rmKeepLocal\",\n      \"show\",\n      \"stash\",\n      \"stashList\",\n      \"status\",\n      \"subModule\",\n      \"submoduleAdd\",\n      \"submoduleInit\",\n      \"submoduleUpdate\",\n      \"tag\",\n      \"tags\",\n      \"updateServerInfo\"\n    ];\n  }\n});\n\n// src/index.js\nvar { gitP: gitP2 } = (init_promise_wrapped(), __toCommonJS(promise_wrapped_exports));\nvar { esModuleFactory: esModuleFactory2, gitInstanceFactory: gitInstanceFactory2, gitExportFactory: gitExportFactory2 } = (init_git_factory(), __toCommonJS(git_factory_exports));\nvar simpleGit = esModuleFactory2(gitExportFactory2(gitInstanceFactory2));\nmodule.exports = Object.assign(simpleGit, { gitP: gitP2, simpleGit });\n//# sourceMappingURL=index.js.map\n","\"use strict\";\n\nvar punycode = require(\"punycode\");\nvar mappingTable = require(\"./lib/mappingTable.json\");\n\nvar PROCESSING_OPTIONS = {\n  TRANSITIONAL: 0,\n  NONTRANSITIONAL: 1\n};\n\nfunction normalize(str) { // fix bug in v8\n  return str.split('\\u0000').map(function (s) { return s.normalize('NFC'); }).join('\\u0000');\n}\n\nfunction findStatus(val) {\n  var start = 0;\n  var end = mappingTable.length - 1;\n\n  while (start <= end) {\n    var mid = Math.floor((start + end) / 2);\n\n    var target = mappingTable[mid];\n    if (target[0][0] <= val && target[0][1] >= val) {\n      return target;\n    } else if (target[0][0] > val) {\n      end = mid - 1;\n    } else {\n      start = mid + 1;\n    }\n  }\n\n  return null;\n}\n\nvar regexAstralSymbols = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g;\n\nfunction countSymbols(string) {\n  return string\n    // replace every surrogate pair with a BMP symbol\n    .replace(regexAstralSymbols, '_')\n    // then get the length\n    .length;\n}\n\nfunction mapChars(domain_name, useSTD3, processing_option) {\n  var hasError = false;\n  var processed = \"\";\n\n  var len = countSymbols(domain_name);\n  for (var i = 0; i < len; ++i) {\n    var codePoint = domain_name.codePointAt(i);\n    var status = findStatus(codePoint);\n\n    switch (status[1]) {\n      case \"disallowed\":\n        hasError = true;\n        processed += String.fromCodePoint(codePoint);\n        break;\n      case \"ignored\":\n        break;\n      case \"mapped\":\n        processed += String.fromCodePoint.apply(String, status[2]);\n        break;\n      case \"deviation\":\n        if (processing_option === PROCESSING_OPTIONS.TRANSITIONAL) {\n          processed += String.fromCodePoint.apply(String, status[2]);\n        } else {\n          processed += String.fromCodePoint(codePoint);\n        }\n        break;\n      case \"valid\":\n        processed += String.fromCodePoint(codePoint);\n        break;\n      case \"disallowed_STD3_mapped\":\n        if (useSTD3) {\n          hasError = true;\n          processed += String.fromCodePoint(codePoint);\n        } else {\n          processed += String.fromCodePoint.apply(String, status[2]);\n        }\n        break;\n      case \"disallowed_STD3_valid\":\n        if (useSTD3) {\n          hasError = true;\n        }\n\n        processed += String.fromCodePoint(codePoint);\n        break;\n    }\n  }\n\n  return {\n    string: processed,\n    error: hasError\n  };\n}\n\nvar combiningMarksRegex = /[\\u0300-\\u036F\\u0483-\\u0489\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u065F\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u0711\\u0730-\\u074A\\u07A6-\\u07B0\\u07EB-\\u07F3\\u0816-\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0859-\\u085B\\u08E4-\\u0903\\u093A-\\u093C\\u093E-\\u094F\\u0951-\\u0957\\u0962\\u0963\\u0981-\\u0983\\u09BC\\u09BE-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CD\\u09D7\\u09E2\\u09E3\\u0A01-\\u0A03\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A70\\u0A71\\u0A75\\u0A81-\\u0A83\\u0ABC\\u0ABE-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AE2\\u0AE3\\u0B01-\\u0B03\\u0B3C\\u0B3E-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B62\\u0B63\\u0B82\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD7\\u0C00-\\u0C03\\u0C3E-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C62\\u0C63\\u0C81-\\u0C83\\u0CBC\\u0CBE-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CE2\\u0CE3\\u0D01-\\u0D03\\u0D3E-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4D\\u0D57\\u0D62\\u0D63\\u0D82\\u0D83\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DF2\\u0DF3\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0EB1\\u0EB4-\\u0EB9\\u0EBB\\u0EBC\\u0EC8-\\u0ECD\\u0F18\\u0F19\\u0F35\\u0F37\\u0F39\\u0F3E\\u0F3F\\u0F71-\\u0F84\\u0F86\\u0F87\\u0F8D-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u102B-\\u103E\\u1056-\\u1059\\u105E-\\u1060\\u1062-\\u1064\\u1067-\\u106D\\u1071-\\u1074\\u1082-\\u108D\\u108F\\u109A-\\u109D\\u135D-\\u135F\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17B4-\\u17D3\\u17DD\\u180B-\\u180D\\u18A9\\u1920-\\u192B\\u1930-\\u193B\\u19B0-\\u19C0\\u19C8\\u19C9\\u1A17-\\u1A1B\\u1A55-\\u1A5E\\u1A60-\\u1A7C\\u1A7F\\u1AB0-\\u1ABE\\u1B00-\\u1B04\\u1B34-\\u1B44\\u1B6B-\\u1B73\\u1B80-\\u1B82\\u1BA1-\\u1BAD\\u1BE6-\\u1BF3\\u1C24-\\u1C37\\u1CD0-\\u1CD2\\u1CD4-\\u1CE8\\u1CED\\u1CF2-\\u1CF4\\u1CF8\\u1CF9\\u1DC0-\\u1DF5\\u1DFC-\\u1DFF\\u20D0-\\u20F0\\u2CEF-\\u2CF1\\u2D7F\\u2DE0-\\u2DFF\\u302A-\\u302F\\u3099\\u309A\\uA66F-\\uA672\\uA674-\\uA67D\\uA69F\\uA6F0\\uA6F1\\uA802\\uA806\\uA80B\\uA823-\\uA827\\uA880\\uA881\\uA8B4-\\uA8C4\\uA8E0-\\uA8F1\\uA926-\\uA92D\\uA947-\\uA953\\uA980-\\uA983\\uA9B3-\\uA9C0\\uA9E5\\uAA29-\\uAA36\\uAA43\\uAA4C\\uAA4D\\uAA7B-\\uAA7D\\uAAB0\\uAAB2-\\uAAB4\\uAAB7\\uAAB8\\uAABE\\uAABF\\uAAC1\\uAAEB-\\uAAEF\\uAAF5\\uAAF6\\uABE3-\\uABEA\\uABEC\\uABED\\uFB1E\\uFE00-\\uFE0F\\uFE20-\\uFE2D]|\\uD800[\\uDDFD\\uDEE0\\uDF76-\\uDF7A]|\\uD802[\\uDE01-\\uDE03\\uDE05\\uDE06\\uDE0C-\\uDE0F\\uDE38-\\uDE3A\\uDE3F\\uDEE5\\uDEE6]|\\uD804[\\uDC00-\\uDC02\\uDC38-\\uDC46\\uDC7F-\\uDC82\\uDCB0-\\uDCBA\\uDD00-\\uDD02\\uDD27-\\uDD34\\uDD73\\uDD80-\\uDD82\\uDDB3-\\uDDC0\\uDE2C-\\uDE37\\uDEDF-\\uDEEA\\uDF01-\\uDF03\\uDF3C\\uDF3E-\\uDF44\\uDF47\\uDF48\\uDF4B-\\uDF4D\\uDF57\\uDF62\\uDF63\\uDF66-\\uDF6C\\uDF70-\\uDF74]|\\uD805[\\uDCB0-\\uDCC3\\uDDAF-\\uDDB5\\uDDB8-\\uDDC0\\uDE30-\\uDE40\\uDEAB-\\uDEB7]|\\uD81A[\\uDEF0-\\uDEF4\\uDF30-\\uDF36]|\\uD81B[\\uDF51-\\uDF7E\\uDF8F-\\uDF92]|\\uD82F[\\uDC9D\\uDC9E]|\\uD834[\\uDD65-\\uDD69\\uDD6D-\\uDD72\\uDD7B-\\uDD82\\uDD85-\\uDD8B\\uDDAA-\\uDDAD\\uDE42-\\uDE44]|\\uD83A[\\uDCD0-\\uDCD6]|\\uDB40[\\uDD00-\\uDDEF]/;\n\nfunction validateLabel(label, processing_option) {\n  if (label.substr(0, 4) === \"xn--\") {\n    label = punycode.toUnicode(label);\n    processing_option = PROCESSING_OPTIONS.NONTRANSITIONAL;\n  }\n\n  var error = false;\n\n  if (normalize(label) !== label ||\n      (label[3] === \"-\" && label[4] === \"-\") ||\n      label[0] === \"-\" || label[label.length - 1] === \"-\" ||\n      label.indexOf(\".\") !== -1 ||\n      label.search(combiningMarksRegex) === 0) {\n    error = true;\n  }\n\n  var len = countSymbols(label);\n  for (var i = 0; i < len; ++i) {\n    var status = findStatus(label.codePointAt(i));\n    if ((processing === PROCESSING_OPTIONS.TRANSITIONAL && status[1] !== \"valid\") ||\n        (processing === PROCESSING_OPTIONS.NONTRANSITIONAL &&\n         status[1] !== \"valid\" && status[1] !== \"deviation\")) {\n      error = true;\n      break;\n    }\n  }\n\n  return {\n    label: label,\n    error: error\n  };\n}\n\nfunction processing(domain_name, useSTD3, processing_option) {\n  var result = mapChars(domain_name, useSTD3, processing_option);\n  result.string = normalize(result.string);\n\n  var labels = result.string.split(\".\");\n  for (var i = 0; i < labels.length; ++i) {\n    try {\n      var validation = validateLabel(labels[i]);\n      labels[i] = validation.label;\n      result.error = result.error || validation.error;\n    } catch(e) {\n      result.error = true;\n    }\n  }\n\n  return {\n    string: labels.join(\".\"),\n    error: result.error\n  };\n}\n\nmodule.exports.toASCII = function(domain_name, useSTD3, processing_option, verifyDnsLength) {\n  var result = processing(domain_name, useSTD3, processing_option);\n  var labels = result.string.split(\".\");\n  labels = labels.map(function(l) {\n    try {\n      return punycode.toASCII(l);\n    } catch(e) {\n      result.error = true;\n      return l;\n    }\n  });\n\n  if (verifyDnsLength) {\n    var total = labels.slice(0, labels.length - 1).join(\".\").length;\n    if (total.length > 253 || total.length === 0) {\n      result.error = true;\n    }\n\n    for (var i=0; i < labels.length; ++i) {\n      if (labels.length > 63 || labels.length === 0) {\n        result.error = true;\n        break;\n      }\n    }\n  }\n\n  if (result.error) return null;\n  return labels.join(\".\");\n};\n\nmodule.exports.toUnicode = function(domain_name, useSTD3) {\n  var result = processing(domain_name, useSTD3, PROCESSING_OPTIONS.NONTRANSITIONAL);\n\n  return {\n    domain: result.string,\n    error: result.error\n  };\n};\n\nmodule.exports.PROCESSING_OPTIONS = PROCESSING_OPTIONS;\n","module.exports = require('./lib/tunnel');\n","'use strict';\n\nvar net = require('net');\nvar tls = require('tls');\nvar http = require('http');\nvar https = require('https');\nvar events = require('events');\nvar assert = require('assert');\nvar util = require('util');\n\n\nexports.httpOverHttp = httpOverHttp;\nexports.httpsOverHttp = httpsOverHttp;\nexports.httpOverHttps = httpOverHttps;\nexports.httpsOverHttps = httpsOverHttps;\n\n\nfunction httpOverHttp(options) {\n  var agent = new TunnelingAgent(options);\n  agent.request = http.request;\n  return agent;\n}\n\nfunction httpsOverHttp(options) {\n  var agent = new TunnelingAgent(options);\n  agent.request = http.request;\n  agent.createSocket = createSecureSocket;\n  agent.defaultPort = 443;\n  return agent;\n}\n\nfunction httpOverHttps(options) {\n  var agent = new TunnelingAgent(options);\n  agent.request = https.request;\n  return agent;\n}\n\nfunction httpsOverHttps(options) {\n  var agent = new TunnelingAgent(options);\n  agent.request = https.request;\n  agent.createSocket = createSecureSocket;\n  agent.defaultPort = 443;\n  return agent;\n}\n\n\nfunction TunnelingAgent(options) {\n  var self = this;\n  self.options = options || {};\n  self.proxyOptions = self.options.proxy || {};\n  self.maxSockets = self.options.maxSockets || http.Agent.defaultMaxSockets;\n  self.requests = [];\n  self.sockets = [];\n\n  self.on('free', function onFree(socket, host, port, localAddress) {\n    var options = toOptions(host, port, localAddress);\n    for (var i = 0, len = self.requests.length; i < len; ++i) {\n      var pending = self.requests[i];\n      if (pending.host === options.host && pending.port === options.port) {\n        // Detect the request to connect same origin server,\n        // reuse the connection.\n        self.requests.splice(i, 1);\n        pending.request.onSocket(socket);\n        return;\n      }\n    }\n    socket.destroy();\n    self.removeSocket(socket);\n  });\n}\nutil.inherits(TunnelingAgent, events.EventEmitter);\n\nTunnelingAgent.prototype.addRequest = function addRequest(req, host, port, localAddress) {\n  var self = this;\n  var options = mergeOptions({request: req}, self.options, toOptions(host, port, localAddress));\n\n  if (self.sockets.length >= this.maxSockets) {\n    // We are over limit so we'll add it to the queue.\n    self.requests.push(options);\n    return;\n  }\n\n  // If we are under maxSockets create a new one.\n  self.createSocket(options, function(socket) {\n    socket.on('free', onFree);\n    socket.on('close', onCloseOrRemove);\n    socket.on('agentRemove', onCloseOrRemove);\n    req.onSocket(socket);\n\n    function onFree() {\n      self.emit('free', socket, options);\n    }\n\n    function onCloseOrRemove(err) {\n      self.removeSocket(socket);\n      socket.removeListener('free', onFree);\n      socket.removeListener('close', onCloseOrRemove);\n      socket.removeListener('agentRemove', onCloseOrRemove);\n    }\n  });\n};\n\nTunnelingAgent.prototype.createSocket = function createSocket(options, cb) {\n  var self = this;\n  var placeholder = {};\n  self.sockets.push(placeholder);\n\n  var connectOptions = mergeOptions({}, self.proxyOptions, {\n    method: 'CONNECT',\n    path: options.host + ':' + options.port,\n    agent: false,\n    headers: {\n      host: options.host + ':' + options.port\n    }\n  });\n  if (options.localAddress) {\n    connectOptions.localAddress = options.localAddress;\n  }\n  if (connectOptions.proxyAuth) {\n    connectOptions.headers = connectOptions.headers || {};\n    connectOptions.headers['Proxy-Authorization'] = 'Basic ' +\n        new Buffer(connectOptions.proxyAuth).toString('base64');\n  }\n\n  debug('making CONNECT request');\n  var connectReq = self.request(connectOptions);\n  connectReq.useChunkedEncodingByDefault = false; // for v0.6\n  connectReq.once('response', onResponse); // for v0.6\n  connectReq.once('upgrade', onUpgrade);   // for v0.6\n  connectReq.once('connect', onConnect);   // for v0.7 or later\n  connectReq.once('error', onError);\n  connectReq.end();\n\n  function onResponse(res) {\n    // Very hacky. This is necessary to avoid http-parser leaks.\n    res.upgrade = true;\n  }\n\n  function onUpgrade(res, socket, head) {\n    // Hacky.\n    process.nextTick(function() {\n      onConnect(res, socket, head);\n    });\n  }\n\n  function onConnect(res, socket, head) {\n    connectReq.removeAllListeners();\n    socket.removeAllListeners();\n\n    if (res.statusCode !== 200) {\n      debug('tunneling socket could not be established, statusCode=%d',\n        res.statusCode);\n      socket.destroy();\n      var error = new Error('tunneling socket could not be established, ' +\n        'statusCode=' + res.statusCode);\n      error.code = 'ECONNRESET';\n      options.request.emit('error', error);\n      self.removeSocket(placeholder);\n      return;\n    }\n    if (head.length > 0) {\n      debug('got illegal response body from proxy');\n      socket.destroy();\n      var error = new Error('got illegal response body from proxy');\n      error.code = 'ECONNRESET';\n      options.request.emit('error', error);\n      self.removeSocket(placeholder);\n      return;\n    }\n    debug('tunneling connection has established');\n    self.sockets[self.sockets.indexOf(placeholder)] = socket;\n    return cb(socket);\n  }\n\n  function onError(cause) {\n    connectReq.removeAllListeners();\n\n    debug('tunneling socket could not be established, cause=%s\\n',\n          cause.message, cause.stack);\n    var error = new Error('tunneling socket could not be established, ' +\n                          'cause=' + cause.message);\n    error.code = 'ECONNRESET';\n    options.request.emit('error', error);\n    self.removeSocket(placeholder);\n  }\n};\n\nTunnelingAgent.prototype.removeSocket = function removeSocket(socket) {\n  var pos = this.sockets.indexOf(socket)\n  if (pos === -1) {\n    return;\n  }\n  this.sockets.splice(pos, 1);\n\n  var pending = this.requests.shift();\n  if (pending) {\n    // If we have pending requests and a socket gets closed a new one\n    // needs to be created to take over in the pool for the one that closed.\n    this.createSocket(pending, function(socket) {\n      pending.request.onSocket(socket);\n    });\n  }\n};\n\nfunction createSecureSocket(options, cb) {\n  var self = this;\n  TunnelingAgent.prototype.createSocket.call(self, options, function(socket) {\n    var hostHeader = options.request.getHeader('host');\n    var tlsOptions = mergeOptions({}, self.options, {\n      socket: socket,\n      servername: hostHeader ? hostHeader.replace(/:.*$/, '') : options.host\n    });\n\n    // 0 is dummy port for v0.6\n    var secureSocket = tls.connect(0, tlsOptions);\n    self.sockets[self.sockets.indexOf(socket)] = secureSocket;\n    cb(secureSocket);\n  });\n}\n\n\nfunction toOptions(host, port, localAddress) {\n  if (typeof host === 'string') { // since v0.10\n    return {\n      host: host,\n      port: port,\n      localAddress: localAddress\n    };\n  }\n  return host; // for v0.11 or later\n}\n\nfunction mergeOptions(target) {\n  for (var i = 1, len = arguments.length; i < len; ++i) {\n    var overrides = arguments[i];\n    if (typeof overrides === 'object') {\n      var keys = Object.keys(overrides);\n      for (var j = 0, keyLen = keys.length; j < keyLen; ++j) {\n        var k = keys[j];\n        if (overrides[k] !== undefined) {\n          target[k] = overrides[k];\n        }\n      }\n    }\n  }\n  return target;\n}\n\n\nvar debug;\nif (process.env.NODE_DEBUG && /\\btunnel\\b/.test(process.env.NODE_DEBUG)) {\n  debug = function() {\n    var args = Array.prototype.slice.call(arguments);\n    if (typeof args[0] === 'string') {\n      args[0] = 'TUNNEL: ' + args[0];\n    } else {\n      args.unshift('TUNNEL:');\n    }\n    console.error.apply(console, args);\n  }\n} else {\n  debug = function() {};\n}\nexports.debug = debug; // for test\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nfunction getUserAgent() {\n  if (typeof navigator === \"object\" && \"userAgent\" in navigator) {\n    return navigator.userAgent;\n  }\n\n  if (typeof process === \"object\" && \"version\" in process) {\n    return `Node.js/${process.version.substr(1)} (${process.platform}; ${process.arch})`;\n  }\n\n  return \"<environment undetectable>\";\n}\n\nexports.getUserAgent = getUserAgent;\n//# sourceMappingURL=index.js.map\n","\"use strict\";\n\nvar conversions = {};\nmodule.exports = conversions;\n\nfunction sign(x) {\n    return x < 0 ? -1 : 1;\n}\n\nfunction evenRound(x) {\n    // Round x to the nearest integer, choosing the even integer if it lies halfway between two.\n    if ((x % 1) === 0.5 && (x & 1) === 0) { // [even number].5; round down (i.e. floor)\n        return Math.floor(x);\n    } else {\n        return Math.round(x);\n    }\n}\n\nfunction createNumberConversion(bitLength, typeOpts) {\n    if (!typeOpts.unsigned) {\n        --bitLength;\n    }\n    const lowerBound = typeOpts.unsigned ? 0 : -Math.pow(2, bitLength);\n    const upperBound = Math.pow(2, bitLength) - 1;\n\n    const moduloVal = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength) : Math.pow(2, bitLength);\n    const moduloBound = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength - 1) : Math.pow(2, bitLength - 1);\n\n    return function(V, opts) {\n        if (!opts) opts = {};\n\n        let x = +V;\n\n        if (opts.enforceRange) {\n            if (!Number.isFinite(x)) {\n                throw new TypeError(\"Argument is not a finite number\");\n            }\n\n            x = sign(x) * Math.floor(Math.abs(x));\n            if (x < lowerBound || x > upperBound) {\n                throw new TypeError(\"Argument is not in byte range\");\n            }\n\n            return x;\n        }\n\n        if (!isNaN(x) && opts.clamp) {\n            x = evenRound(x);\n\n            if (x < lowerBound) x = lowerBound;\n            if (x > upperBound) x = upperBound;\n            return x;\n        }\n\n        if (!Number.isFinite(x) || x === 0) {\n            return 0;\n        }\n\n        x = sign(x) * Math.floor(Math.abs(x));\n        x = x % moduloVal;\n\n        if (!typeOpts.unsigned && x >= moduloBound) {\n            return x - moduloVal;\n        } else if (typeOpts.unsigned) {\n            if (x < 0) {\n              x += moduloVal;\n            } else if (x === -0) { // don't return negative zero\n              return 0;\n            }\n        }\n\n        return x;\n    }\n}\n\nconversions[\"void\"] = function () {\n    return undefined;\n};\n\nconversions[\"boolean\"] = function (val) {\n    return !!val;\n};\n\nconversions[\"byte\"] = createNumberConversion(8, { unsigned: false });\nconversions[\"octet\"] = createNumberConversion(8, { unsigned: true });\n\nconversions[\"short\"] = createNumberConversion(16, { unsigned: false });\nconversions[\"unsigned short\"] = createNumberConversion(16, { unsigned: true });\n\nconversions[\"long\"] = createNumberConversion(32, { unsigned: false });\nconversions[\"unsigned long\"] = createNumberConversion(32, { unsigned: true });\n\nconversions[\"long long\"] = createNumberConversion(32, { unsigned: false, moduloBitLength: 64 });\nconversions[\"unsigned long long\"] = createNumberConversion(32, { unsigned: true, moduloBitLength: 64 });\n\nconversions[\"double\"] = function (V) {\n    const x = +V;\n\n    if (!Number.isFinite(x)) {\n        throw new TypeError(\"Argument is not a finite floating-point value\");\n    }\n\n    return x;\n};\n\nconversions[\"unrestricted double\"] = function (V) {\n    const x = +V;\n\n    if (isNaN(x)) {\n        throw new TypeError(\"Argument is NaN\");\n    }\n\n    return x;\n};\n\n// not quite valid, but good enough for JS\nconversions[\"float\"] = conversions[\"double\"];\nconversions[\"unrestricted float\"] = conversions[\"unrestricted double\"];\n\nconversions[\"DOMString\"] = function (V, opts) {\n    if (!opts) opts = {};\n\n    if (opts.treatNullAsEmptyString && V === null) {\n        return \"\";\n    }\n\n    return String(V);\n};\n\nconversions[\"ByteString\"] = function (V, opts) {\n    const x = String(V);\n    let c = undefined;\n    for (let i = 0; (c = x.codePointAt(i)) !== undefined; ++i) {\n        if (c > 255) {\n            throw new TypeError(\"Argument is not a valid bytestring\");\n        }\n    }\n\n    return x;\n};\n\nconversions[\"USVString\"] = function (V) {\n    const S = String(V);\n    const n = S.length;\n    const U = [];\n    for (let i = 0; i < n; ++i) {\n        const c = S.charCodeAt(i);\n        if (c < 0xD800 || c > 0xDFFF) {\n            U.push(String.fromCodePoint(c));\n        } else if (0xDC00 <= c && c <= 0xDFFF) {\n            U.push(String.fromCodePoint(0xFFFD));\n        } else {\n            if (i === n - 1) {\n                U.push(String.fromCodePoint(0xFFFD));\n            } else {\n                const d = S.charCodeAt(i + 1);\n                if (0xDC00 <= d && d <= 0xDFFF) {\n                    const a = c & 0x3FF;\n                    const b = d & 0x3FF;\n                    U.push(String.fromCodePoint((2 << 15) + (2 << 9) * a + b));\n                    ++i;\n                } else {\n                    U.push(String.fromCodePoint(0xFFFD));\n                }\n            }\n        }\n    }\n\n    return U.join('');\n};\n\nconversions[\"Date\"] = function (V, opts) {\n    if (!(V instanceof Date)) {\n        throw new TypeError(\"Argument is not a Date object\");\n    }\n    if (isNaN(V)) {\n        return undefined;\n    }\n\n    return V;\n};\n\nconversions[\"RegExp\"] = function (V, opts) {\n    if (!(V instanceof RegExp)) {\n        V = new RegExp(V);\n    }\n\n    return V;\n};\n","\"use strict\";\nconst usm = require(\"./url-state-machine\");\n\nexports.implementation = class URLImpl {\n  constructor(constructorArgs) {\n    const url = constructorArgs[0];\n    const base = constructorArgs[1];\n\n    let parsedBase = null;\n    if (base !== undefined) {\n      parsedBase = usm.basicURLParse(base);\n      if (parsedBase === \"failure\") {\n        throw new TypeError(\"Invalid base URL\");\n      }\n    }\n\n    const parsedURL = usm.basicURLParse(url, { baseURL: parsedBase });\n    if (parsedURL === \"failure\") {\n      throw new TypeError(\"Invalid URL\");\n    }\n\n    this._url = parsedURL;\n\n    // TODO: query stuff\n  }\n\n  get href() {\n    return usm.serializeURL(this._url);\n  }\n\n  set href(v) {\n    const parsedURL = usm.basicURLParse(v);\n    if (parsedURL === \"failure\") {\n      throw new TypeError(\"Invalid URL\");\n    }\n\n    this._url = parsedURL;\n  }\n\n  get origin() {\n    return usm.serializeURLOrigin(this._url);\n  }\n\n  get protocol() {\n    return this._url.scheme + \":\";\n  }\n\n  set protocol(v) {\n    usm.basicURLParse(v + \":\", { url: this._url, stateOverride: \"scheme start\" });\n  }\n\n  get username() {\n    return this._url.username;\n  }\n\n  set username(v) {\n    if (usm.cannotHaveAUsernamePasswordPort(this._url)) {\n      return;\n    }\n\n    usm.setTheUsername(this._url, v);\n  }\n\n  get password() {\n    return this._url.password;\n  }\n\n  set password(v) {\n    if (usm.cannotHaveAUsernamePasswordPort(this._url)) {\n      return;\n    }\n\n    usm.setThePassword(this._url, v);\n  }\n\n  get host() {\n    const url = this._url;\n\n    if (url.host === null) {\n      return \"\";\n    }\n\n    if (url.port === null) {\n      return usm.serializeHost(url.host);\n    }\n\n    return usm.serializeHost(url.host) + \":\" + usm.serializeInteger(url.port);\n  }\n\n  set host(v) {\n    if (this._url.cannotBeABaseURL) {\n      return;\n    }\n\n    usm.basicURLParse(v, { url: this._url, stateOverride: \"host\" });\n  }\n\n  get hostname() {\n    if (this._url.host === null) {\n      return \"\";\n    }\n\n    return usm.serializeHost(this._url.host);\n  }\n\n  set hostname(v) {\n    if (this._url.cannotBeABaseURL) {\n      return;\n    }\n\n    usm.basicURLParse(v, { url: this._url, stateOverride: \"hostname\" });\n  }\n\n  get port() {\n    if (this._url.port === null) {\n      return \"\";\n    }\n\n    return usm.serializeInteger(this._url.port);\n  }\n\n  set port(v) {\n    if (usm.cannotHaveAUsernamePasswordPort(this._url)) {\n      return;\n    }\n\n    if (v === \"\") {\n      this._url.port = null;\n    } else {\n      usm.basicURLParse(v, { url: this._url, stateOverride: \"port\" });\n    }\n  }\n\n  get pathname() {\n    if (this._url.cannotBeABaseURL) {\n      return this._url.path[0];\n    }\n\n    if (this._url.path.length === 0) {\n      return \"\";\n    }\n\n    return \"/\" + this._url.path.join(\"/\");\n  }\n\n  set pathname(v) {\n    if (this._url.cannotBeABaseURL) {\n      return;\n    }\n\n    this._url.path = [];\n    usm.basicURLParse(v, { url: this._url, stateOverride: \"path start\" });\n  }\n\n  get search() {\n    if (this._url.query === null || this._url.query === \"\") {\n      return \"\";\n    }\n\n    return \"?\" + this._url.query;\n  }\n\n  set search(v) {\n    // TODO: query stuff\n\n    const url = this._url;\n\n    if (v === \"\") {\n      url.query = null;\n      return;\n    }\n\n    const input = v[0] === \"?\" ? v.substring(1) : v;\n    url.query = \"\";\n    usm.basicURLParse(input, { url, stateOverride: \"query\" });\n  }\n\n  get hash() {\n    if (this._url.fragment === null || this._url.fragment === \"\") {\n      return \"\";\n    }\n\n    return \"#\" + this._url.fragment;\n  }\n\n  set hash(v) {\n    if (v === \"\") {\n      this._url.fragment = null;\n      return;\n    }\n\n    const input = v[0] === \"#\" ? v.substring(1) : v;\n    this._url.fragment = \"\";\n    usm.basicURLParse(input, { url: this._url, stateOverride: \"fragment\" });\n  }\n\n  toJSON() {\n    return this.href;\n  }\n};\n","\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst Impl = require(\".//URL-impl.js\");\n\nconst impl = utils.implSymbol;\n\nfunction URL(url) {\n  if (!this || this[impl] || !(this instanceof URL)) {\n    throw new TypeError(\"Failed to construct 'URL': Please use the 'new' operator, this DOM object constructor cannot be called as a function.\");\n  }\n  if (arguments.length < 1) {\n    throw new TypeError(\"Failed to construct 'URL': 1 argument required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 2; ++i) {\n    args[i] = arguments[i];\n  }\n  args[0] = conversions[\"USVString\"](args[0]);\n  if (args[1] !== undefined) {\n  args[1] = conversions[\"USVString\"](args[1]);\n  }\n\n  module.exports.setup(this, args);\n}\n\nURL.prototype.toJSON = function toJSON() {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 0; ++i) {\n    args[i] = arguments[i];\n  }\n  return this[impl].toJSON.apply(this[impl], args);\n};\nObject.defineProperty(URL.prototype, \"href\", {\n  get() {\n    return this[impl].href;\n  },\n  set(V) {\n    V = conversions[\"USVString\"](V);\n    this[impl].href = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nURL.prototype.toString = function () {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  return this.href;\n};\n\nObject.defineProperty(URL.prototype, \"origin\", {\n  get() {\n    return this[impl].origin;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(URL.prototype, \"protocol\", {\n  get() {\n    return this[impl].protocol;\n  },\n  set(V) {\n    V = conversions[\"USVString\"](V);\n    this[impl].protocol = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(URL.prototype, \"username\", {\n  get() {\n    return this[impl].username;\n  },\n  set(V) {\n    V = conversions[\"USVString\"](V);\n    this[impl].username = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(URL.prototype, \"password\", {\n  get() {\n    return this[impl].password;\n  },\n  set(V) {\n    V = conversions[\"USVString\"](V);\n    this[impl].password = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(URL.prototype, \"host\", {\n  get() {\n    return this[impl].host;\n  },\n  set(V) {\n    V = conversions[\"USVString\"](V);\n    this[impl].host = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(URL.prototype, \"hostname\", {\n  get() {\n    return this[impl].hostname;\n  },\n  set(V) {\n    V = conversions[\"USVString\"](V);\n    this[impl].hostname = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(URL.prototype, \"port\", {\n  get() {\n    return this[impl].port;\n  },\n  set(V) {\n    V = conversions[\"USVString\"](V);\n    this[impl].port = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(URL.prototype, \"pathname\", {\n  get() {\n    return this[impl].pathname;\n  },\n  set(V) {\n    V = conversions[\"USVString\"](V);\n    this[impl].pathname = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(URL.prototype, \"search\", {\n  get() {\n    return this[impl].search;\n  },\n  set(V) {\n    V = conversions[\"USVString\"](V);\n    this[impl].search = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(URL.prototype, \"hash\", {\n  get() {\n    return this[impl].hash;\n  },\n  set(V) {\n    V = conversions[\"USVString\"](V);\n    this[impl].hash = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nmodule.exports = {\n  is(obj) {\n    return !!obj && obj[impl] instanceof Impl.implementation;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(URL.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: URL,\n  expose: {\n    Window: { URL: URL },\n    Worker: { URL: URL }\n  }\n};\n\n","\"use strict\";\n\nexports.URL = require(\"./URL\").interface;\nexports.serializeURL = require(\"./url-state-machine\").serializeURL;\nexports.serializeURLOrigin = require(\"./url-state-machine\").serializeURLOrigin;\nexports.basicURLParse = require(\"./url-state-machine\").basicURLParse;\nexports.setTheUsername = require(\"./url-state-machine\").setTheUsername;\nexports.setThePassword = require(\"./url-state-machine\").setThePassword;\nexports.serializeHost = require(\"./url-state-machine\").serializeHost;\nexports.serializeInteger = require(\"./url-state-machine\").serializeInteger;\nexports.parseURL = require(\"./url-state-machine\").parseURL;\n","\"use strict\";\r\nconst punycode = require(\"punycode\");\r\nconst tr46 = require(\"tr46\");\r\n\r\nconst specialSchemes = {\r\n  ftp: 21,\r\n  file: null,\r\n  gopher: 70,\r\n  http: 80,\r\n  https: 443,\r\n  ws: 80,\r\n  wss: 443\r\n};\r\n\r\nconst failure = Symbol(\"failure\");\r\n\r\nfunction countSymbols(str) {\r\n  return punycode.ucs2.decode(str).length;\r\n}\r\n\r\nfunction at(input, idx) {\r\n  const c = input[idx];\r\n  return isNaN(c) ? undefined : String.fromCodePoint(c);\r\n}\r\n\r\nfunction isASCIIDigit(c) {\r\n  return c >= 0x30 && c <= 0x39;\r\n}\r\n\r\nfunction isASCIIAlpha(c) {\r\n  return (c >= 0x41 && c <= 0x5A) || (c >= 0x61 && c <= 0x7A);\r\n}\r\n\r\nfunction isASCIIAlphanumeric(c) {\r\n  return isASCIIAlpha(c) || isASCIIDigit(c);\r\n}\r\n\r\nfunction isASCIIHex(c) {\r\n  return isASCIIDigit(c) || (c >= 0x41 && c <= 0x46) || (c >= 0x61 && c <= 0x66);\r\n}\r\n\r\nfunction isSingleDot(buffer) {\r\n  return buffer === \".\" || buffer.toLowerCase() === \"%2e\";\r\n}\r\n\r\nfunction isDoubleDot(buffer) {\r\n  buffer = buffer.toLowerCase();\r\n  return buffer === \"..\" || buffer === \"%2e.\" || buffer === \".%2e\" || buffer === \"%2e%2e\";\r\n}\r\n\r\nfunction isWindowsDriveLetterCodePoints(cp1, cp2) {\r\n  return isASCIIAlpha(cp1) && (cp2 === 58 || cp2 === 124);\r\n}\r\n\r\nfunction isWindowsDriveLetterString(string) {\r\n  return string.length === 2 && isASCIIAlpha(string.codePointAt(0)) && (string[1] === \":\" || string[1] === \"|\");\r\n}\r\n\r\nfunction isNormalizedWindowsDriveLetterString(string) {\r\n  return string.length === 2 && isASCIIAlpha(string.codePointAt(0)) && string[1] === \":\";\r\n}\r\n\r\nfunction containsForbiddenHostCodePoint(string) {\r\n  return string.search(/\\u0000|\\u0009|\\u000A|\\u000D|\\u0020|#|%|\\/|:|\\?|@|\\[|\\\\|\\]/) !== -1;\r\n}\r\n\r\nfunction containsForbiddenHostCodePointExcludingPercent(string) {\r\n  return string.search(/\\u0000|\\u0009|\\u000A|\\u000D|\\u0020|#|\\/|:|\\?|@|\\[|\\\\|\\]/) !== -1;\r\n}\r\n\r\nfunction isSpecialScheme(scheme) {\r\n  return specialSchemes[scheme] !== undefined;\r\n}\r\n\r\nfunction isSpecial(url) {\r\n  return isSpecialScheme(url.scheme);\r\n}\r\n\r\nfunction defaultPort(scheme) {\r\n  return specialSchemes[scheme];\r\n}\r\n\r\nfunction percentEncode(c) {\r\n  let hex = c.toString(16).toUpperCase();\r\n  if (hex.length === 1) {\r\n    hex = \"0\" + hex;\r\n  }\r\n\r\n  return \"%\" + hex;\r\n}\r\n\r\nfunction utf8PercentEncode(c) {\r\n  const buf = new Buffer(c);\r\n\r\n  let str = \"\";\r\n\r\n  for (let i = 0; i < buf.length; ++i) {\r\n    str += percentEncode(buf[i]);\r\n  }\r\n\r\n  return str;\r\n}\r\n\r\nfunction utf8PercentDecode(str) {\r\n  const input = new Buffer(str);\r\n  const output = [];\r\n  for (let i = 0; i < input.length; ++i) {\r\n    if (input[i] !== 37) {\r\n      output.push(input[i]);\r\n    } else if (input[i] === 37 && isASCIIHex(input[i + 1]) && isASCIIHex(input[i + 2])) {\r\n      output.push(parseInt(input.slice(i + 1, i + 3).toString(), 16));\r\n      i += 2;\r\n    } else {\r\n      output.push(input[i]);\r\n    }\r\n  }\r\n  return new Buffer(output).toString();\r\n}\r\n\r\nfunction isC0ControlPercentEncode(c) {\r\n  return c <= 0x1F || c > 0x7E;\r\n}\r\n\r\nconst extraPathPercentEncodeSet = new Set([32, 34, 35, 60, 62, 63, 96, 123, 125]);\r\nfunction isPathPercentEncode(c) {\r\n  return isC0ControlPercentEncode(c) || extraPathPercentEncodeSet.has(c);\r\n}\r\n\r\nconst extraUserinfoPercentEncodeSet =\r\n  new Set([47, 58, 59, 61, 64, 91, 92, 93, 94, 124]);\r\nfunction isUserinfoPercentEncode(c) {\r\n  return isPathPercentEncode(c) || extraUserinfoPercentEncodeSet.has(c);\r\n}\r\n\r\nfunction percentEncodeChar(c, encodeSetPredicate) {\r\n  const cStr = String.fromCodePoint(c);\r\n\r\n  if (encodeSetPredicate(c)) {\r\n    return utf8PercentEncode(cStr);\r\n  }\r\n\r\n  return cStr;\r\n}\r\n\r\nfunction parseIPv4Number(input) {\r\n  let R = 10;\r\n\r\n  if (input.length >= 2 && input.charAt(0) === \"0\" && input.charAt(1).toLowerCase() === \"x\") {\r\n    input = input.substring(2);\r\n    R = 16;\r\n  } else if (input.length >= 2 && input.charAt(0) === \"0\") {\r\n    input = input.substring(1);\r\n    R = 8;\r\n  }\r\n\r\n  if (input === \"\") {\r\n    return 0;\r\n  }\r\n\r\n  const regex = R === 10 ? /[^0-9]/ : (R === 16 ? /[^0-9A-Fa-f]/ : /[^0-7]/);\r\n  if (regex.test(input)) {\r\n    return failure;\r\n  }\r\n\r\n  return parseInt(input, R);\r\n}\r\n\r\nfunction parseIPv4(input) {\r\n  const parts = input.split(\".\");\r\n  if (parts[parts.length - 1] === \"\") {\r\n    if (parts.length > 1) {\r\n      parts.pop();\r\n    }\r\n  }\r\n\r\n  if (parts.length > 4) {\r\n    return input;\r\n  }\r\n\r\n  const numbers = [];\r\n  for (const part of parts) {\r\n    if (part === \"\") {\r\n      return input;\r\n    }\r\n    const n = parseIPv4Number(part);\r\n    if (n === failure) {\r\n      return input;\r\n    }\r\n\r\n    numbers.push(n);\r\n  }\r\n\r\n  for (let i = 0; i < numbers.length - 1; ++i) {\r\n    if (numbers[i] > 255) {\r\n      return failure;\r\n    }\r\n  }\r\n  if (numbers[numbers.length - 1] >= Math.pow(256, 5 - numbers.length)) {\r\n    return failure;\r\n  }\r\n\r\n  let ipv4 = numbers.pop();\r\n  let counter = 0;\r\n\r\n  for (const n of numbers) {\r\n    ipv4 += n * Math.pow(256, 3 - counter);\r\n    ++counter;\r\n  }\r\n\r\n  return ipv4;\r\n}\r\n\r\nfunction serializeIPv4(address) {\r\n  let output = \"\";\r\n  let n = address;\r\n\r\n  for (let i = 1; i <= 4; ++i) {\r\n    output = String(n % 256) + output;\r\n    if (i !== 4) {\r\n      output = \".\" + output;\r\n    }\r\n    n = Math.floor(n / 256);\r\n  }\r\n\r\n  return output;\r\n}\r\n\r\nfunction parseIPv6(input) {\r\n  const address = [0, 0, 0, 0, 0, 0, 0, 0];\r\n  let pieceIndex = 0;\r\n  let compress = null;\r\n  let pointer = 0;\r\n\r\n  input = punycode.ucs2.decode(input);\r\n\r\n  if (input[pointer] === 58) {\r\n    if (input[pointer + 1] !== 58) {\r\n      return failure;\r\n    }\r\n\r\n    pointer += 2;\r\n    ++pieceIndex;\r\n    compress = pieceIndex;\r\n  }\r\n\r\n  while (pointer < input.length) {\r\n    if (pieceIndex === 8) {\r\n      return failure;\r\n    }\r\n\r\n    if (input[pointer] === 58) {\r\n      if (compress !== null) {\r\n        return failure;\r\n      }\r\n      ++pointer;\r\n      ++pieceIndex;\r\n      compress = pieceIndex;\r\n      continue;\r\n    }\r\n\r\n    let value = 0;\r\n    let length = 0;\r\n\r\n    while (length < 4 && isASCIIHex(input[pointer])) {\r\n      value = value * 0x10 + parseInt(at(input, pointer), 16);\r\n      ++pointer;\r\n      ++length;\r\n    }\r\n\r\n    if (input[pointer] === 46) {\r\n      if (length === 0) {\r\n        return failure;\r\n      }\r\n\r\n      pointer -= length;\r\n\r\n      if (pieceIndex > 6) {\r\n        return failure;\r\n      }\r\n\r\n      let numbersSeen = 0;\r\n\r\n      while (input[pointer] !== undefined) {\r\n        let ipv4Piece = null;\r\n\r\n        if (numbersSeen > 0) {\r\n          if (input[pointer] === 46 && numbersSeen < 4) {\r\n            ++pointer;\r\n          } else {\r\n            return failure;\r\n          }\r\n        }\r\n\r\n        if (!isASCIIDigit(input[pointer])) {\r\n          return failure;\r\n        }\r\n\r\n        while (isASCIIDigit(input[pointer])) {\r\n          const number = parseInt(at(input, pointer));\r\n          if (ipv4Piece === null) {\r\n            ipv4Piece = number;\r\n          } else if (ipv4Piece === 0) {\r\n            return failure;\r\n          } else {\r\n            ipv4Piece = ipv4Piece * 10 + number;\r\n          }\r\n          if (ipv4Piece > 255) {\r\n            return failure;\r\n          }\r\n          ++pointer;\r\n        }\r\n\r\n        address[pieceIndex] = address[pieceIndex] * 0x100 + ipv4Piece;\r\n\r\n        ++numbersSeen;\r\n\r\n        if (numbersSeen === 2 || numbersSeen === 4) {\r\n          ++pieceIndex;\r\n        }\r\n      }\r\n\r\n      if (numbersSeen !== 4) {\r\n        return failure;\r\n      }\r\n\r\n      break;\r\n    } else if (input[pointer] === 58) {\r\n      ++pointer;\r\n      if (input[pointer] === undefined) {\r\n        return failure;\r\n      }\r\n    } else if (input[pointer] !== undefined) {\r\n      return failure;\r\n    }\r\n\r\n    address[pieceIndex] = value;\r\n    ++pieceIndex;\r\n  }\r\n\r\n  if (compress !== null) {\r\n    let swaps = pieceIndex - compress;\r\n    pieceIndex = 7;\r\n    while (pieceIndex !== 0 && swaps > 0) {\r\n      const temp = address[compress + swaps - 1];\r\n      address[compress + swaps - 1] = address[pieceIndex];\r\n      address[pieceIndex] = temp;\r\n      --pieceIndex;\r\n      --swaps;\r\n    }\r\n  } else if (compress === null && pieceIndex !== 8) {\r\n    return failure;\r\n  }\r\n\r\n  return address;\r\n}\r\n\r\nfunction serializeIPv6(address) {\r\n  let output = \"\";\r\n  const seqResult = findLongestZeroSequence(address);\r\n  const compress = seqResult.idx;\r\n  let ignore0 = false;\r\n\r\n  for (let pieceIndex = 0; pieceIndex <= 7; ++pieceIndex) {\r\n    if (ignore0 && address[pieceIndex] === 0) {\r\n      continue;\r\n    } else if (ignore0) {\r\n      ignore0 = false;\r\n    }\r\n\r\n    if (compress === pieceIndex) {\r\n      const separator = pieceIndex === 0 ? \"::\" : \":\";\r\n      output += separator;\r\n      ignore0 = true;\r\n      continue;\r\n    }\r\n\r\n    output += address[pieceIndex].toString(16);\r\n\r\n    if (pieceIndex !== 7) {\r\n      output += \":\";\r\n    }\r\n  }\r\n\r\n  return output;\r\n}\r\n\r\nfunction parseHost(input, isSpecialArg) {\r\n  if (input[0] === \"[\") {\r\n    if (input[input.length - 1] !== \"]\") {\r\n      return failure;\r\n    }\r\n\r\n    return parseIPv6(input.substring(1, input.length - 1));\r\n  }\r\n\r\n  if (!isSpecialArg) {\r\n    return parseOpaqueHost(input);\r\n  }\r\n\r\n  const domain = utf8PercentDecode(input);\r\n  const asciiDomain = tr46.toASCII(domain, false, tr46.PROCESSING_OPTIONS.NONTRANSITIONAL, false);\r\n  if (asciiDomain === null) {\r\n    return failure;\r\n  }\r\n\r\n  if (containsForbiddenHostCodePoint(asciiDomain)) {\r\n    return failure;\r\n  }\r\n\r\n  const ipv4Host = parseIPv4(asciiDomain);\r\n  if (typeof ipv4Host === \"number\" || ipv4Host === failure) {\r\n    return ipv4Host;\r\n  }\r\n\r\n  return asciiDomain;\r\n}\r\n\r\nfunction parseOpaqueHost(input) {\r\n  if (containsForbiddenHostCodePointExcludingPercent(input)) {\r\n    return failure;\r\n  }\r\n\r\n  let output = \"\";\r\n  const decoded = punycode.ucs2.decode(input);\r\n  for (let i = 0; i < decoded.length; ++i) {\r\n    output += percentEncodeChar(decoded[i], isC0ControlPercentEncode);\r\n  }\r\n  return output;\r\n}\r\n\r\nfunction findLongestZeroSequence(arr) {\r\n  let maxIdx = null;\r\n  let maxLen = 1; // only find elements > 1\r\n  let currStart = null;\r\n  let currLen = 0;\r\n\r\n  for (let i = 0; i < arr.length; ++i) {\r\n    if (arr[i] !== 0) {\r\n      if (currLen > maxLen) {\r\n        maxIdx = currStart;\r\n        maxLen = currLen;\r\n      }\r\n\r\n      currStart = null;\r\n      currLen = 0;\r\n    } else {\r\n      if (currStart === null) {\r\n        currStart = i;\r\n      }\r\n      ++currLen;\r\n    }\r\n  }\r\n\r\n  // if trailing zeros\r\n  if (currLen > maxLen) {\r\n    maxIdx = currStart;\r\n    maxLen = currLen;\r\n  }\r\n\r\n  return {\r\n    idx: maxIdx,\r\n    len: maxLen\r\n  };\r\n}\r\n\r\nfunction serializeHost(host) {\r\n  if (typeof host === \"number\") {\r\n    return serializeIPv4(host);\r\n  }\r\n\r\n  // IPv6 serializer\r\n  if (host instanceof Array) {\r\n    return \"[\" + serializeIPv6(host) + \"]\";\r\n  }\r\n\r\n  return host;\r\n}\r\n\r\nfunction trimControlChars(url) {\r\n  return url.replace(/^[\\u0000-\\u001F\\u0020]+|[\\u0000-\\u001F\\u0020]+$/g, \"\");\r\n}\r\n\r\nfunction trimTabAndNewline(url) {\r\n  return url.replace(/\\u0009|\\u000A|\\u000D/g, \"\");\r\n}\r\n\r\nfunction shortenPath(url) {\r\n  const path = url.path;\r\n  if (path.length === 0) {\r\n    return;\r\n  }\r\n  if (url.scheme === \"file\" && path.length === 1 && isNormalizedWindowsDriveLetter(path[0])) {\r\n    return;\r\n  }\r\n\r\n  path.pop();\r\n}\r\n\r\nfunction includesCredentials(url) {\r\n  return url.username !== \"\" || url.password !== \"\";\r\n}\r\n\r\nfunction cannotHaveAUsernamePasswordPort(url) {\r\n  return url.host === null || url.host === \"\" || url.cannotBeABaseURL || url.scheme === \"file\";\r\n}\r\n\r\nfunction isNormalizedWindowsDriveLetter(string) {\r\n  return /^[A-Za-z]:$/.test(string);\r\n}\r\n\r\nfunction URLStateMachine(input, base, encodingOverride, url, stateOverride) {\r\n  this.pointer = 0;\r\n  this.input = input;\r\n  this.base = base || null;\r\n  this.encodingOverride = encodingOverride || \"utf-8\";\r\n  this.stateOverride = stateOverride;\r\n  this.url = url;\r\n  this.failure = false;\r\n  this.parseError = false;\r\n\r\n  if (!this.url) {\r\n    this.url = {\r\n      scheme: \"\",\r\n      username: \"\",\r\n      password: \"\",\r\n      host: null,\r\n      port: null,\r\n      path: [],\r\n      query: null,\r\n      fragment: null,\r\n\r\n      cannotBeABaseURL: false\r\n    };\r\n\r\n    const res = trimControlChars(this.input);\r\n    if (res !== this.input) {\r\n      this.parseError = true;\r\n    }\r\n    this.input = res;\r\n  }\r\n\r\n  const res = trimTabAndNewline(this.input);\r\n  if (res !== this.input) {\r\n    this.parseError = true;\r\n  }\r\n  this.input = res;\r\n\r\n  this.state = stateOverride || \"scheme start\";\r\n\r\n  this.buffer = \"\";\r\n  this.atFlag = false;\r\n  this.arrFlag = false;\r\n  this.passwordTokenSeenFlag = false;\r\n\r\n  this.input = punycode.ucs2.decode(this.input);\r\n\r\n  for (; this.pointer <= this.input.length; ++this.pointer) {\r\n    const c = this.input[this.pointer];\r\n    const cStr = isNaN(c) ? undefined : String.fromCodePoint(c);\r\n\r\n    // exec state machine\r\n    const ret = this[\"parse \" + this.state](c, cStr);\r\n    if (!ret) {\r\n      break; // terminate algorithm\r\n    } else if (ret === failure) {\r\n      this.failure = true;\r\n      break;\r\n    }\r\n  }\r\n}\r\n\r\nURLStateMachine.prototype[\"parse scheme start\"] = function parseSchemeStart(c, cStr) {\r\n  if (isASCIIAlpha(c)) {\r\n    this.buffer += cStr.toLowerCase();\r\n    this.state = \"scheme\";\r\n  } else if (!this.stateOverride) {\r\n    this.state = \"no scheme\";\r\n    --this.pointer;\r\n  } else {\r\n    this.parseError = true;\r\n    return failure;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse scheme\"] = function parseScheme(c, cStr) {\r\n  if (isASCIIAlphanumeric(c) || c === 43 || c === 45 || c === 46) {\r\n    this.buffer += cStr.toLowerCase();\r\n  } else if (c === 58) {\r\n    if (this.stateOverride) {\r\n      if (isSpecial(this.url) && !isSpecialScheme(this.buffer)) {\r\n        return false;\r\n      }\r\n\r\n      if (!isSpecial(this.url) && isSpecialScheme(this.buffer)) {\r\n        return false;\r\n      }\r\n\r\n      if ((includesCredentials(this.url) || this.url.port !== null) && this.buffer === \"file\") {\r\n        return false;\r\n      }\r\n\r\n      if (this.url.scheme === \"file\" && (this.url.host === \"\" || this.url.host === null)) {\r\n        return false;\r\n      }\r\n    }\r\n    this.url.scheme = this.buffer;\r\n    this.buffer = \"\";\r\n    if (this.stateOverride) {\r\n      return false;\r\n    }\r\n    if (this.url.scheme === \"file\") {\r\n      if (this.input[this.pointer + 1] !== 47 || this.input[this.pointer + 2] !== 47) {\r\n        this.parseError = true;\r\n      }\r\n      this.state = \"file\";\r\n    } else if (isSpecial(this.url) && this.base !== null && this.base.scheme === this.url.scheme) {\r\n      this.state = \"special relative or authority\";\r\n    } else if (isSpecial(this.url)) {\r\n      this.state = \"special authority slashes\";\r\n    } else if (this.input[this.pointer + 1] === 47) {\r\n      this.state = \"path or authority\";\r\n      ++this.pointer;\r\n    } else {\r\n      this.url.cannotBeABaseURL = true;\r\n      this.url.path.push(\"\");\r\n      this.state = \"cannot-be-a-base-URL path\";\r\n    }\r\n  } else if (!this.stateOverride) {\r\n    this.buffer = \"\";\r\n    this.state = \"no scheme\";\r\n    this.pointer = -1;\r\n  } else {\r\n    this.parseError = true;\r\n    return failure;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse no scheme\"] = function parseNoScheme(c) {\r\n  if (this.base === null || (this.base.cannotBeABaseURL && c !== 35)) {\r\n    return failure;\r\n  } else if (this.base.cannotBeABaseURL && c === 35) {\r\n    this.url.scheme = this.base.scheme;\r\n    this.url.path = this.base.path.slice();\r\n    this.url.query = this.base.query;\r\n    this.url.fragment = \"\";\r\n    this.url.cannotBeABaseURL = true;\r\n    this.state = \"fragment\";\r\n  } else if (this.base.scheme === \"file\") {\r\n    this.state = \"file\";\r\n    --this.pointer;\r\n  } else {\r\n    this.state = \"relative\";\r\n    --this.pointer;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse special relative or authority\"] = function parseSpecialRelativeOrAuthority(c) {\r\n  if (c === 47 && this.input[this.pointer + 1] === 47) {\r\n    this.state = \"special authority ignore slashes\";\r\n    ++this.pointer;\r\n  } else {\r\n    this.parseError = true;\r\n    this.state = \"relative\";\r\n    --this.pointer;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse path or authority\"] = function parsePathOrAuthority(c) {\r\n  if (c === 47) {\r\n    this.state = \"authority\";\r\n  } else {\r\n    this.state = \"path\";\r\n    --this.pointer;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse relative\"] = function parseRelative(c) {\r\n  this.url.scheme = this.base.scheme;\r\n  if (isNaN(c)) {\r\n    this.url.username = this.base.username;\r\n    this.url.password = this.base.password;\r\n    this.url.host = this.base.host;\r\n    this.url.port = this.base.port;\r\n    this.url.path = this.base.path.slice();\r\n    this.url.query = this.base.query;\r\n  } else if (c === 47) {\r\n    this.state = \"relative slash\";\r\n  } else if (c === 63) {\r\n    this.url.username = this.base.username;\r\n    this.url.password = this.base.password;\r\n    this.url.host = this.base.host;\r\n    this.url.port = this.base.port;\r\n    this.url.path = this.base.path.slice();\r\n    this.url.query = \"\";\r\n    this.state = \"query\";\r\n  } else if (c === 35) {\r\n    this.url.username = this.base.username;\r\n    this.url.password = this.base.password;\r\n    this.url.host = this.base.host;\r\n    this.url.port = this.base.port;\r\n    this.url.path = this.base.path.slice();\r\n    this.url.query = this.base.query;\r\n    this.url.fragment = \"\";\r\n    this.state = \"fragment\";\r\n  } else if (isSpecial(this.url) && c === 92) {\r\n    this.parseError = true;\r\n    this.state = \"relative slash\";\r\n  } else {\r\n    this.url.username = this.base.username;\r\n    this.url.password = this.base.password;\r\n    this.url.host = this.base.host;\r\n    this.url.port = this.base.port;\r\n    this.url.path = this.base.path.slice(0, this.base.path.length - 1);\r\n\r\n    this.state = \"path\";\r\n    --this.pointer;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse relative slash\"] = function parseRelativeSlash(c) {\r\n  if (isSpecial(this.url) && (c === 47 || c === 92)) {\r\n    if (c === 92) {\r\n      this.parseError = true;\r\n    }\r\n    this.state = \"special authority ignore slashes\";\r\n  } else if (c === 47) {\r\n    this.state = \"authority\";\r\n  } else {\r\n    this.url.username = this.base.username;\r\n    this.url.password = this.base.password;\r\n    this.url.host = this.base.host;\r\n    this.url.port = this.base.port;\r\n    this.state = \"path\";\r\n    --this.pointer;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse special authority slashes\"] = function parseSpecialAuthoritySlashes(c) {\r\n  if (c === 47 && this.input[this.pointer + 1] === 47) {\r\n    this.state = \"special authority ignore slashes\";\r\n    ++this.pointer;\r\n  } else {\r\n    this.parseError = true;\r\n    this.state = \"special authority ignore slashes\";\r\n    --this.pointer;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse special authority ignore slashes\"] = function parseSpecialAuthorityIgnoreSlashes(c) {\r\n  if (c !== 47 && c !== 92) {\r\n    this.state = \"authority\";\r\n    --this.pointer;\r\n  } else {\r\n    this.parseError = true;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse authority\"] = function parseAuthority(c, cStr) {\r\n  if (c === 64) {\r\n    this.parseError = true;\r\n    if (this.atFlag) {\r\n      this.buffer = \"%40\" + this.buffer;\r\n    }\r\n    this.atFlag = true;\r\n\r\n    // careful, this is based on buffer and has its own pointer (this.pointer != pointer) and inner chars\r\n    const len = countSymbols(this.buffer);\r\n    for (let pointer = 0; pointer < len; ++pointer) {\r\n      const codePoint = this.buffer.codePointAt(pointer);\r\n\r\n      if (codePoint === 58 && !this.passwordTokenSeenFlag) {\r\n        this.passwordTokenSeenFlag = true;\r\n        continue;\r\n      }\r\n      const encodedCodePoints = percentEncodeChar(codePoint, isUserinfoPercentEncode);\r\n      if (this.passwordTokenSeenFlag) {\r\n        this.url.password += encodedCodePoints;\r\n      } else {\r\n        this.url.username += encodedCodePoints;\r\n      }\r\n    }\r\n    this.buffer = \"\";\r\n  } else if (isNaN(c) || c === 47 || c === 63 || c === 35 ||\r\n             (isSpecial(this.url) && c === 92)) {\r\n    if (this.atFlag && this.buffer === \"\") {\r\n      this.parseError = true;\r\n      return failure;\r\n    }\r\n    this.pointer -= countSymbols(this.buffer) + 1;\r\n    this.buffer = \"\";\r\n    this.state = \"host\";\r\n  } else {\r\n    this.buffer += cStr;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse hostname\"] =\r\nURLStateMachine.prototype[\"parse host\"] = function parseHostName(c, cStr) {\r\n  if (this.stateOverride && this.url.scheme === \"file\") {\r\n    --this.pointer;\r\n    this.state = \"file host\";\r\n  } else if (c === 58 && !this.arrFlag) {\r\n    if (this.buffer === \"\") {\r\n      this.parseError = true;\r\n      return failure;\r\n    }\r\n\r\n    const host = parseHost(this.buffer, isSpecial(this.url));\r\n    if (host === failure) {\r\n      return failure;\r\n    }\r\n\r\n    this.url.host = host;\r\n    this.buffer = \"\";\r\n    this.state = \"port\";\r\n    if (this.stateOverride === \"hostname\") {\r\n      return false;\r\n    }\r\n  } else if (isNaN(c) || c === 47 || c === 63 || c === 35 ||\r\n             (isSpecial(this.url) && c === 92)) {\r\n    --this.pointer;\r\n    if (isSpecial(this.url) && this.buffer === \"\") {\r\n      this.parseError = true;\r\n      return failure;\r\n    } else if (this.stateOverride && this.buffer === \"\" &&\r\n               (includesCredentials(this.url) || this.url.port !== null)) {\r\n      this.parseError = true;\r\n      return false;\r\n    }\r\n\r\n    const host = parseHost(this.buffer, isSpecial(this.url));\r\n    if (host === failure) {\r\n      return failure;\r\n    }\r\n\r\n    this.url.host = host;\r\n    this.buffer = \"\";\r\n    this.state = \"path start\";\r\n    if (this.stateOverride) {\r\n      return false;\r\n    }\r\n  } else {\r\n    if (c === 91) {\r\n      this.arrFlag = true;\r\n    } else if (c === 93) {\r\n      this.arrFlag = false;\r\n    }\r\n    this.buffer += cStr;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse port\"] = function parsePort(c, cStr) {\r\n  if (isASCIIDigit(c)) {\r\n    this.buffer += cStr;\r\n  } else if (isNaN(c) || c === 47 || c === 63 || c === 35 ||\r\n             (isSpecial(this.url) && c === 92) ||\r\n             this.stateOverride) {\r\n    if (this.buffer !== \"\") {\r\n      const port = parseInt(this.buffer);\r\n      if (port > Math.pow(2, 16) - 1) {\r\n        this.parseError = true;\r\n        return failure;\r\n      }\r\n      this.url.port = port === defaultPort(this.url.scheme) ? null : port;\r\n      this.buffer = \"\";\r\n    }\r\n    if (this.stateOverride) {\r\n      return false;\r\n    }\r\n    this.state = \"path start\";\r\n    --this.pointer;\r\n  } else {\r\n    this.parseError = true;\r\n    return failure;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nconst fileOtherwiseCodePoints = new Set([47, 92, 63, 35]);\r\n\r\nURLStateMachine.prototype[\"parse file\"] = function parseFile(c) {\r\n  this.url.scheme = \"file\";\r\n\r\n  if (c === 47 || c === 92) {\r\n    if (c === 92) {\r\n      this.parseError = true;\r\n    }\r\n    this.state = \"file slash\";\r\n  } else if (this.base !== null && this.base.scheme === \"file\") {\r\n    if (isNaN(c)) {\r\n      this.url.host = this.base.host;\r\n      this.url.path = this.base.path.slice();\r\n      this.url.query = this.base.query;\r\n    } else if (c === 63) {\r\n      this.url.host = this.base.host;\r\n      this.url.path = this.base.path.slice();\r\n      this.url.query = \"\";\r\n      this.state = \"query\";\r\n    } else if (c === 35) {\r\n      this.url.host = this.base.host;\r\n      this.url.path = this.base.path.slice();\r\n      this.url.query = this.base.query;\r\n      this.url.fragment = \"\";\r\n      this.state = \"fragment\";\r\n    } else {\r\n      if (this.input.length - this.pointer - 1 === 0 || // remaining consists of 0 code points\r\n          !isWindowsDriveLetterCodePoints(c, this.input[this.pointer + 1]) ||\r\n          (this.input.length - this.pointer - 1 >= 2 && // remaining has at least 2 code points\r\n           !fileOtherwiseCodePoints.has(this.input[this.pointer + 2]))) {\r\n        this.url.host = this.base.host;\r\n        this.url.path = this.base.path.slice();\r\n        shortenPath(this.url);\r\n      } else {\r\n        this.parseError = true;\r\n      }\r\n\r\n      this.state = \"path\";\r\n      --this.pointer;\r\n    }\r\n  } else {\r\n    this.state = \"path\";\r\n    --this.pointer;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse file slash\"] = function parseFileSlash(c) {\r\n  if (c === 47 || c === 92) {\r\n    if (c === 92) {\r\n      this.parseError = true;\r\n    }\r\n    this.state = \"file host\";\r\n  } else {\r\n    if (this.base !== null && this.base.scheme === \"file\") {\r\n      if (isNormalizedWindowsDriveLetterString(this.base.path[0])) {\r\n        this.url.path.push(this.base.path[0]);\r\n      } else {\r\n        this.url.host = this.base.host;\r\n      }\r\n    }\r\n    this.state = \"path\";\r\n    --this.pointer;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse file host\"] = function parseFileHost(c, cStr) {\r\n  if (isNaN(c) || c === 47 || c === 92 || c === 63 || c === 35) {\r\n    --this.pointer;\r\n    if (!this.stateOverride && isWindowsDriveLetterString(this.buffer)) {\r\n      this.parseError = true;\r\n      this.state = \"path\";\r\n    } else if (this.buffer === \"\") {\r\n      this.url.host = \"\";\r\n      if (this.stateOverride) {\r\n        return false;\r\n      }\r\n      this.state = \"path start\";\r\n    } else {\r\n      let host = parseHost(this.buffer, isSpecial(this.url));\r\n      if (host === failure) {\r\n        return failure;\r\n      }\r\n      if (host === \"localhost\") {\r\n        host = \"\";\r\n      }\r\n      this.url.host = host;\r\n\r\n      if (this.stateOverride) {\r\n        return false;\r\n      }\r\n\r\n      this.buffer = \"\";\r\n      this.state = \"path start\";\r\n    }\r\n  } else {\r\n    this.buffer += cStr;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse path start\"] = function parsePathStart(c) {\r\n  if (isSpecial(this.url)) {\r\n    if (c === 92) {\r\n      this.parseError = true;\r\n    }\r\n    this.state = \"path\";\r\n\r\n    if (c !== 47 && c !== 92) {\r\n      --this.pointer;\r\n    }\r\n  } else if (!this.stateOverride && c === 63) {\r\n    this.url.query = \"\";\r\n    this.state = \"query\";\r\n  } else if (!this.stateOverride && c === 35) {\r\n    this.url.fragment = \"\";\r\n    this.state = \"fragment\";\r\n  } else if (c !== undefined) {\r\n    this.state = \"path\";\r\n    if (c !== 47) {\r\n      --this.pointer;\r\n    }\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse path\"] = function parsePath(c) {\r\n  if (isNaN(c) || c === 47 || (isSpecial(this.url) && c === 92) ||\r\n      (!this.stateOverride && (c === 63 || c === 35))) {\r\n    if (isSpecial(this.url) && c === 92) {\r\n      this.parseError = true;\r\n    }\r\n\r\n    if (isDoubleDot(this.buffer)) {\r\n      shortenPath(this.url);\r\n      if (c !== 47 && !(isSpecial(this.url) && c === 92)) {\r\n        this.url.path.push(\"\");\r\n      }\r\n    } else if (isSingleDot(this.buffer) && c !== 47 &&\r\n               !(isSpecial(this.url) && c === 92)) {\r\n      this.url.path.push(\"\");\r\n    } else if (!isSingleDot(this.buffer)) {\r\n      if (this.url.scheme === \"file\" && this.url.path.length === 0 && isWindowsDriveLetterString(this.buffer)) {\r\n        if (this.url.host !== \"\" && this.url.host !== null) {\r\n          this.parseError = true;\r\n          this.url.host = \"\";\r\n        }\r\n        this.buffer = this.buffer[0] + \":\";\r\n      }\r\n      this.url.path.push(this.buffer);\r\n    }\r\n    this.buffer = \"\";\r\n    if (this.url.scheme === \"file\" && (c === undefined || c === 63 || c === 35)) {\r\n      while (this.url.path.length > 1 && this.url.path[0] === \"\") {\r\n        this.parseError = true;\r\n        this.url.path.shift();\r\n      }\r\n    }\r\n    if (c === 63) {\r\n      this.url.query = \"\";\r\n      this.state = \"query\";\r\n    }\r\n    if (c === 35) {\r\n      this.url.fragment = \"\";\r\n      this.state = \"fragment\";\r\n    }\r\n  } else {\r\n    // TODO: If c is not a URL code point and not \"%\", parse error.\r\n\r\n    if (c === 37 &&\r\n      (!isASCIIHex(this.input[this.pointer + 1]) ||\r\n        !isASCIIHex(this.input[this.pointer + 2]))) {\r\n      this.parseError = true;\r\n    }\r\n\r\n    this.buffer += percentEncodeChar(c, isPathPercentEncode);\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse cannot-be-a-base-URL path\"] = function parseCannotBeABaseURLPath(c) {\r\n  if (c === 63) {\r\n    this.url.query = \"\";\r\n    this.state = \"query\";\r\n  } else if (c === 35) {\r\n    this.url.fragment = \"\";\r\n    this.state = \"fragment\";\r\n  } else {\r\n    // TODO: Add: not a URL code point\r\n    if (!isNaN(c) && c !== 37) {\r\n      this.parseError = true;\r\n    }\r\n\r\n    if (c === 37 &&\r\n        (!isASCIIHex(this.input[this.pointer + 1]) ||\r\n         !isASCIIHex(this.input[this.pointer + 2]))) {\r\n      this.parseError = true;\r\n    }\r\n\r\n    if (!isNaN(c)) {\r\n      this.url.path[0] = this.url.path[0] + percentEncodeChar(c, isC0ControlPercentEncode);\r\n    }\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse query\"] = function parseQuery(c, cStr) {\r\n  if (isNaN(c) || (!this.stateOverride && c === 35)) {\r\n    if (!isSpecial(this.url) || this.url.scheme === \"ws\" || this.url.scheme === \"wss\") {\r\n      this.encodingOverride = \"utf-8\";\r\n    }\r\n\r\n    const buffer = new Buffer(this.buffer); // TODO: Use encoding override instead\r\n    for (let i = 0; i < buffer.length; ++i) {\r\n      if (buffer[i] < 0x21 || buffer[i] > 0x7E || buffer[i] === 0x22 || buffer[i] === 0x23 ||\r\n          buffer[i] === 0x3C || buffer[i] === 0x3E) {\r\n        this.url.query += percentEncode(buffer[i]);\r\n      } else {\r\n        this.url.query += String.fromCodePoint(buffer[i]);\r\n      }\r\n    }\r\n\r\n    this.buffer = \"\";\r\n    if (c === 35) {\r\n      this.url.fragment = \"\";\r\n      this.state = \"fragment\";\r\n    }\r\n  } else {\r\n    // TODO: If c is not a URL code point and not \"%\", parse error.\r\n    if (c === 37 &&\r\n      (!isASCIIHex(this.input[this.pointer + 1]) ||\r\n        !isASCIIHex(this.input[this.pointer + 2]))) {\r\n      this.parseError = true;\r\n    }\r\n\r\n    this.buffer += cStr;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse fragment\"] = function parseFragment(c) {\r\n  if (isNaN(c)) { // do nothing\r\n  } else if (c === 0x0) {\r\n    this.parseError = true;\r\n  } else {\r\n    // TODO: If c is not a URL code point and not \"%\", parse error.\r\n    if (c === 37 &&\r\n      (!isASCIIHex(this.input[this.pointer + 1]) ||\r\n        !isASCIIHex(this.input[this.pointer + 2]))) {\r\n      this.parseError = true;\r\n    }\r\n\r\n    this.url.fragment += percentEncodeChar(c, isC0ControlPercentEncode);\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nfunction serializeURL(url, excludeFragment) {\r\n  let output = url.scheme + \":\";\r\n  if (url.host !== null) {\r\n    output += \"//\";\r\n\r\n    if (url.username !== \"\" || url.password !== \"\") {\r\n      output += url.username;\r\n      if (url.password !== \"\") {\r\n        output += \":\" + url.password;\r\n      }\r\n      output += \"@\";\r\n    }\r\n\r\n    output += serializeHost(url.host);\r\n\r\n    if (url.port !== null) {\r\n      output += \":\" + url.port;\r\n    }\r\n  } else if (url.host === null && url.scheme === \"file\") {\r\n    output += \"//\";\r\n  }\r\n\r\n  if (url.cannotBeABaseURL) {\r\n    output += url.path[0];\r\n  } else {\r\n    for (const string of url.path) {\r\n      output += \"/\" + string;\r\n    }\r\n  }\r\n\r\n  if (url.query !== null) {\r\n    output += \"?\" + url.query;\r\n  }\r\n\r\n  if (!excludeFragment && url.fragment !== null) {\r\n    output += \"#\" + url.fragment;\r\n  }\r\n\r\n  return output;\r\n}\r\n\r\nfunction serializeOrigin(tuple) {\r\n  let result = tuple.scheme + \"://\";\r\n  result += serializeHost(tuple.host);\r\n\r\n  if (tuple.port !== null) {\r\n    result += \":\" + tuple.port;\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nmodule.exports.serializeURL = serializeURL;\r\n\r\nmodule.exports.serializeURLOrigin = function (url) {\r\n  // https://url.spec.whatwg.org/#concept-url-origin\r\n  switch (url.scheme) {\r\n    case \"blob\":\r\n      try {\r\n        return module.exports.serializeURLOrigin(module.exports.parseURL(url.path[0]));\r\n      } catch (e) {\r\n        // serializing an opaque origin returns \"null\"\r\n        return \"null\";\r\n      }\r\n    case \"ftp\":\r\n    case \"gopher\":\r\n    case \"http\":\r\n    case \"https\":\r\n    case \"ws\":\r\n    case \"wss\":\r\n      return serializeOrigin({\r\n        scheme: url.scheme,\r\n        host: url.host,\r\n        port: url.port\r\n      });\r\n    case \"file\":\r\n      // spec says \"exercise to the reader\", chrome says \"file://\"\r\n      return \"file://\";\r\n    default:\r\n      // serializing an opaque origin returns \"null\"\r\n      return \"null\";\r\n  }\r\n};\r\n\r\nmodule.exports.basicURLParse = function (input, options) {\r\n  if (options === undefined) {\r\n    options = {};\r\n  }\r\n\r\n  const usm = new URLStateMachine(input, options.baseURL, options.encodingOverride, options.url, options.stateOverride);\r\n  if (usm.failure) {\r\n    return \"failure\";\r\n  }\r\n\r\n  return usm.url;\r\n};\r\n\r\nmodule.exports.setTheUsername = function (url, username) {\r\n  url.username = \"\";\r\n  const decoded = punycode.ucs2.decode(username);\r\n  for (let i = 0; i < decoded.length; ++i) {\r\n    url.username += percentEncodeChar(decoded[i], isUserinfoPercentEncode);\r\n  }\r\n};\r\n\r\nmodule.exports.setThePassword = function (url, password) {\r\n  url.password = \"\";\r\n  const decoded = punycode.ucs2.decode(password);\r\n  for (let i = 0; i < decoded.length; ++i) {\r\n    url.password += percentEncodeChar(decoded[i], isUserinfoPercentEncode);\r\n  }\r\n};\r\n\r\nmodule.exports.serializeHost = serializeHost;\r\n\r\nmodule.exports.cannotHaveAUsernamePasswordPort = cannotHaveAUsernamePasswordPort;\r\n\r\nmodule.exports.serializeInteger = function (integer) {\r\n  return String(integer);\r\n};\r\n\r\nmodule.exports.parseURL = function (input, options) {\r\n  if (options === undefined) {\r\n    options = {};\r\n  }\r\n\r\n  // We don't handle blobs, so this just delegates:\r\n  return module.exports.basicURLParse(input, { baseURL: options.baseURL, encodingOverride: options.encodingOverride });\r\n};\r\n","\"use strict\";\n\nmodule.exports.mixin = function mixin(target, source) {\n  const keys = Object.getOwnPropertyNames(source);\n  for (let i = 0; i < keys.length; ++i) {\n    Object.defineProperty(target, keys[i], Object.getOwnPropertyDescriptor(source, keys[i]));\n  }\n};\n\nmodule.exports.wrapperSymbol = Symbol(\"wrapper\");\nmodule.exports.implSymbol = Symbol(\"impl\");\n\nmodule.exports.wrapperForImpl = function (impl) {\n  return impl[module.exports.wrapperSymbol];\n};\n\nmodule.exports.implForWrapper = function (wrapper) {\n  return wrapper[module.exports.implSymbol];\n};\n\n","// Returns a wrapper function that returns a wrapped callback\n// The wrapper function should do some stuff, and return a\n// presumably different callback function.\n// This makes sure that own properties are retained, so that\n// decorations and such are not lost along the way.\nmodule.exports = wrappy\nfunction wrappy (fn, cb) {\n  if (fn && cb) return wrappy(fn)(cb)\n\n  if (typeof fn !== 'function')\n    throw new TypeError('need wrapper function')\n\n  Object.keys(fn).forEach(function (k) {\n    wrapper[k] = fn[k]\n  })\n\n  return wrapper\n\n  function wrapper() {\n    var args = new Array(arguments.length)\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i]\n    }\n    var ret = fn.apply(this, args)\n    var cb = args[args.length-1]\n    if (typeof ret === 'function' && ret !== cb) {\n      Object.keys(cb).forEach(function (k) {\n        ret[k] = cb[k]\n      })\n    }\n    return ret\n  }\n}\n",null,"module.exports = require(\"assert\");","module.exports = require(\"child_process\");","module.exports = require(\"events\");","module.exports = require(\"fs\");","module.exports = require(\"http\");","module.exports = require(\"https\");","module.exports = require(\"net\");","module.exports = require(\"os\");","module.exports = require(\"path\");","module.exports = require(\"punycode\");","module.exports = require(\"stream\");","module.exports = require(\"tls\");","module.exports = require(\"tty\");","module.exports = require(\"url\");","module.exports = require(\"util\");","module.exports = require(\"zlib\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\tvar threw = true;\n\ttry {\n\t\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\t\tthrew = false;\n\t} finally {\n\t\tif(threw) delete __webpack_module_cache__[moduleId];\n\t}\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","\nif (typeof __webpack_require__ !== 'undefined') __webpack_require__.ab = __dirname + \"/\";","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst tsplus_module_1 = require(\"@effect/io/Config\");\nconst tsplus_module_2 = require(\"@effect/io/Layer\");\nconst tsplus_module_3 = require(\"@effect/io/Config/Provider\");\nconst tsplus_module_4 = require(\"@effect/io/Cause\");\nconst tsplus_module_5 = require(\"@effect/io/Effect\");\nconst Git = require(\"./Git\");\nconst Github = require(\"./Github\");\nconst Dotenv = require(\"dotenv\");\nconst config_1 = require(\"./utils/config\");\nconst Runtime_1 = require(\"@effect/node/Runtime\");\n// Dotenv for testing in development\nDotenv.config();\n// Setup the Git client layer\nconst GitLive = Git.makeLayer({\n    userName: (0, config_1.nonEmptyString)(\"github_actor\"),\n    userEmail: tsplus_module_1.map((0, config_1.nonEmptyString)(\"github_actor\"), _ => `${_}@users.noreply.github.com`),\n    simpleGit: tsplus_module_1.succeed({}),\n});\n// Setup the Github API\nconst GithubLive = Github.makeLayer({\n    token: (0, config_1.inputSecret)(\"github_token\"),\n});\n// Build the environment for your program\nconst EnvLive = tsplus_module_2.merge(GithubLive)(GitLive);\nconst program = tsplus_module_5.withConfigProvider(tsplus_module_5.provideLayer(tsplus_module_5.tapErrorCause(tsplus_module_5.flatMap(tsplus_module_5.config((0, config_1.input)(\"name\")), name => tsplus_module_5.map(tsplus_module_5.logInfo(`Hello there ${name}!`), () => void 0)), _ => tsplus_module_5.sync(() => {\n    console.error(tsplus_module_4.squash(_));\n})), EnvLive), tsplus_module_3.upperCase(tsplus_module_3.fromEnv()));\n(0, Runtime_1.runMain)(program);\n//# sourceMappingURL=main.js.map"],"names":[],"sourceRoot":""}